var wl = { exports: {} };
var uN = wl.exports, Vh;
function gN() {
  return Vh || (Vh = 1, (function(pl, Ss) {
    (function(In, Rs) {
      pl.exports = Rs();
    })(uN, (function() {
      var In = {}, Rs = {};
      function Tl(b, u, mt) {
        if (Rs[b] = mt, b === "index") {
          var Qi = "var sharedModule = {}; (" + Rs.shared + ")(sharedModule); (" + Rs.worker + ")(sharedModule);", Cs = {};
          return Rs.shared(Cs), Rs.index(In, Cs), typeof window < "u" && In.setWorkerUrl(window.URL.createObjectURL(new Blob([Qi], { type: "text/javascript" }))), In;
        }
      }
      Tl("shared", ["exports"], (function(b) {
        function u(i, t, s, n) {
          return new (s || (s = Promise))((function(a, M) {
            function l(y) {
              try {
                N(n.next(y));
              } catch (w) {
                M(w);
              }
            }
            function D(y) {
              try {
                N(n.throw(y));
              } catch (w) {
                M(w);
              }
            }
            function N(y) {
              var w;
              y.done ? a(y.value) : (w = y.value, w instanceof s ? w : new s((function(T) {
                T(w);
              }))).then(l, D);
            }
            N((n = n.apply(i, t || [])).next());
          }));
        }
        function mt(i, t) {
          this.x = i, this.y = t;
        }
        function Qi(i) {
          return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i;
        }
        var Cs, vr;
        typeof SuppressedError == "function" && SuppressedError, mt.prototype = { clone() {
          return new mt(this.x, this.y);
        }, add(i) {
          return this.clone()._add(i);
        }, sub(i) {
          return this.clone()._sub(i);
        }, multByPoint(i) {
          return this.clone()._multByPoint(i);
        }, divByPoint(i) {
          return this.clone()._divByPoint(i);
        }, mult(i) {
          return this.clone()._mult(i);
        }, div(i) {
          return this.clone()._div(i);
        }, rotate(i) {
          return this.clone()._rotate(i);
        }, rotateAround(i, t) {
          return this.clone()._rotateAround(i, t);
        }, matMult(i) {
          return this.clone()._matMult(i);
        }, unit() {
          return this.clone()._unit();
        }, perp() {
          return this.clone()._perp();
        }, round() {
          return this.clone()._round();
        }, mag() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }, equals(i) {
          return this.x === i.x && this.y === i.y;
        }, dist(i) {
          return Math.sqrt(this.distSqr(i));
        }, distSqr(i) {
          const t = i.x - this.x, s = i.y - this.y;
          return t * t + s * s;
        }, angle() {
          return Math.atan2(this.y, this.x);
        }, angleTo(i) {
          return Math.atan2(this.y - i.y, this.x - i.x);
        }, angleWith(i) {
          return this.angleWithSep(i.x, i.y);
        }, angleWithSep(i, t) {
          return Math.atan2(this.x * t - this.y * i, this.x * i + this.y * t);
        }, _matMult(i) {
          const t = i[2] * this.x + i[3] * this.y;
          return this.x = i[0] * this.x + i[1] * this.y, this.y = t, this;
        }, _add(i) {
          return this.x += i.x, this.y += i.y, this;
        }, _sub(i) {
          return this.x -= i.x, this.y -= i.y, this;
        }, _mult(i) {
          return this.x *= i, this.y *= i, this;
        }, _div(i) {
          return this.x /= i, this.y /= i, this;
        }, _multByPoint(i) {
          return this.x *= i.x, this.y *= i.y, this;
        }, _divByPoint(i) {
          return this.x /= i.x, this.y /= i.y, this;
        }, _unit() {
          return this._div(this.mag()), this;
        }, _perp() {
          const i = this.y;
          return this.y = this.x, this.x = -i, this;
        }, _rotate(i) {
          const t = Math.cos(i), s = Math.sin(i), n = s * this.x + t * this.y;
          return this.x = t * this.x - s * this.y, this.y = n, this;
        }, _rotateAround(i, t) {
          const s = Math.cos(i), n = Math.sin(i), a = t.y + n * (this.x - t.x) + s * (this.y - t.y);
          return this.x = t.x + s * (this.x - t.x) - n * (this.y - t.y), this.y = a, this;
        }, _round() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
        }, constructor: mt }, mt.convert = function(i) {
          if (i instanceof mt) return i;
          if (Array.isArray(i)) return new mt(+i[0], +i[1]);
          if (i.x !== void 0 && i.y !== void 0) return new mt(+i.x, +i.y);
          throw new Error("Expected [x, y] or {x, y} point format");
        };
        var wn = (function() {
          if (vr) return Cs;
          function i(t, s, n, a) {
            this.cx = 3 * t, this.bx = 3 * (n - t) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * s, this.by = 3 * (a - s) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t, this.p1y = s, this.p2x = n, this.p2y = a;
          }
          return vr = 1, Cs = i, i.prototype = { sampleCurveX: function(t) {
            return ((this.ax * t + this.bx) * t + this.cx) * t;
          }, sampleCurveY: function(t) {
            return ((this.ay * t + this.by) * t + this.cy) * t;
          }, sampleCurveDerivativeX: function(t) {
            return (3 * this.ax * t + 2 * this.bx) * t + this.cx;
          }, solveCurveX: function(t, s) {
            if (s === void 0 && (s = 1e-6), t < 0) return 0;
            if (t > 1) return 1;
            for (var n = t, a = 0; a < 8; a++) {
              var M = this.sampleCurveX(n) - t;
              if (Math.abs(M) < s) return n;
              var l = this.sampleCurveDerivativeX(n);
              if (Math.abs(l) < 1e-6) break;
              n -= M / l;
            }
            var D = 0, N = 1;
            for (n = t, a = 0; a < 20 && (M = this.sampleCurveX(n), !(Math.abs(M - t) < s)); a++) t > M ? D = n : N = n, n = 0.5 * (N - D) + D;
            return n;
          }, solve: function(t, s) {
            return this.sampleCurveY(this.solveCurveX(t, s));
          } }, Cs;
        })(), Ke = Qi(wn);
        let vi, $t;
        function gt() {
          return vi == null && (vi = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") && typeof createImageBitmap == "function"), vi;
        }
        function rr() {
          if ($t == null && ($t = !1, gt())) {
            const t = new OffscreenCanvas(5, 5).getContext("2d", { willReadFrequently: !0 });
            if (t) {
              for (let n = 0; n < 25; n++) {
                const a = 4 * n;
                t.fillStyle = `rgb(${a},${a + 1},${a + 2})`, t.fillRect(n % 5, Math.floor(n / 5), 1, 1);
              }
              const s = t.getImageData(0, 0, 5, 5).data;
              for (let n = 0; n < 100; n++) if (n % 4 != 3 && s[n] !== n) {
                $t = !0;
                break;
              }
            }
          }
          return $t || !1;
        }
        var je = 1e-6, Ie = typeof Float32Array < "u" ? Float32Array : Array;
        function Br() {
          var i = new Ie(9);
          return Ie != Float32Array && (i[1] = 0, i[2] = 0, i[3] = 0, i[5] = 0, i[6] = 0, i[7] = 0), i[0] = 1, i[4] = 1, i[8] = 1, i;
        }
        function Sr(i) {
          return i[0] = 1, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = 1, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = 1, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, i;
        }
        function pn() {
          var i = new Ie(3);
          return Ie != Float32Array && (i[0] = 0, i[1] = 0, i[2] = 0), i;
        }
        function ps(i) {
          var t = i[0], s = i[1], n = i[2];
          return Math.sqrt(t * t + s * s + n * n);
        }
        function da(i, t, s) {
          var n = new Ie(3);
          return n[0] = i, n[1] = t, n[2] = s, n;
        }
        function Ii(i, t, s) {
          return i[0] = t[0] + s[0], i[1] = t[1] + s[1], i[2] = t[2] + s[2], i;
        }
        function Bi(i, t, s) {
          return i[0] = t[0] * s, i[1] = t[1] * s, i[2] = t[2] * s, i;
        }
        function nr(i, t, s) {
          var n = t[0], a = t[1], M = t[2], l = s[0], D = s[1], N = s[2];
          return i[0] = a * N - M * D, i[1] = M * l - n * N, i[2] = n * D - a * l, i;
        }
        var Si, ar = ps;
        function Tn(i, t, s) {
          var n = t[0], a = t[1], M = t[2], l = t[3];
          return i[0] = s[0] * n + s[4] * a + s[8] * M + s[12] * l, i[1] = s[1] * n + s[5] * a + s[9] * M + s[13] * l, i[2] = s[2] * n + s[6] * a + s[10] * M + s[14] * l, i[3] = s[3] * n + s[7] * a + s[11] * M + s[15] * l, i;
        }
        function fn() {
          var i = new Ie(4);
          return Ie != Float32Array && (i[0] = 0, i[1] = 0, i[2] = 0), i[3] = 1, i;
        }
        function xn(i, t, s, n) {
          var a = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : "zyx", M = Math.PI / 360;
          t *= M, n *= M, s *= M;
          var l = Math.sin(t), D = Math.cos(t), N = Math.sin(s), y = Math.cos(s), w = Math.sin(n), T = Math.cos(n);
          switch (a) {
            case "xyz":
              i[0] = l * y * T + D * N * w, i[1] = D * N * T - l * y * w, i[2] = D * y * w + l * N * T, i[3] = D * y * T - l * N * w;
              break;
            case "xzy":
              i[0] = l * y * T - D * N * w, i[1] = D * N * T - l * y * w, i[2] = D * y * w + l * N * T, i[3] = D * y * T + l * N * w;
              break;
            case "yxz":
              i[0] = l * y * T + D * N * w, i[1] = D * N * T - l * y * w, i[2] = D * y * w - l * N * T, i[3] = D * y * T + l * N * w;
              break;
            case "yzx":
              i[0] = l * y * T + D * N * w, i[1] = D * N * T + l * y * w, i[2] = D * y * w - l * N * T, i[3] = D * y * T - l * N * w;
              break;
            case "zxy":
              i[0] = l * y * T - D * N * w, i[1] = D * N * T + l * y * w, i[2] = D * y * w + l * N * T, i[3] = D * y * T - l * N * w;
              break;
            case "zyx":
              i[0] = l * y * T - D * N * w, i[1] = D * N * T + l * y * w, i[2] = D * y * w - l * N * T, i[3] = D * y * T + l * N * w;
              break;
            default:
              throw new Error("Unknown angle order " + a);
          }
          return i;
        }
        function Zs() {
          var i = new Ie(2);
          return Ie != Float32Array && (i[0] = 0, i[1] = 0), i;
        }
        function ya(i, t) {
          var s = new Ie(2);
          return s[0] = i, s[1] = t, s;
        }
        pn(), Si = new Ie(4), Ie != Float32Array && (Si[0] = 0, Si[1] = 0, Si[2] = 0, Si[3] = 0), pn(), da(1, 0, 0), da(0, 1, 0), fn(), fn(), Br(), Zs();
        const se = 8192;
        function kr(i, t, s) {
          return t * (se / (i.tileSize * Math.pow(2, s - i.tileID.overscaledZ)));
        }
        function ni(i, t) {
          return (i % t + t) % t;
        }
        function or(i, t, s) {
          return i * (1 - s) + t * s;
        }
        function Ia(i) {
          if (i <= 0) return 0;
          if (i >= 1) return 1;
          const t = i * i, s = t * i;
          return 4 * (i < 0.5 ? s : 3 * (i - t) + s - 0.75);
        }
        function ki(i, t, s, n) {
          const a = new Ke(i, t, s, n);
          return (M) => a.solve(M);
        }
        const Fi = ki(0.25, 0.1, 0.25, 1);
        function Ds(i, t, s) {
          return Math.min(s, Math.max(t, i));
        }
        function Vs(i, t, s) {
          const n = s - t, a = ((i - t) % n + n) % n + t;
          return a === t ? s : a;
        }
        function rs(i, ...t) {
          for (const s of t) for (const n in s) i[n] = s[n];
          return i;
        }
        let Fr = 1;
        function Yi(i, t, s) {
          const n = {};
          for (const a in i) n[a] = t.call(this, i[a], a, i);
          return n;
        }
        function Mr(i, t, s) {
          const n = {};
          for (const a in i) t.call(this, i[a], a, i) && (n[a] = i[a]);
          return n;
        }
        function ks(i) {
          return Array.isArray(i) ? i.map(ks) : typeof i == "object" && i ? Yi(i, ks) : i;
        }
        const An = {};
        function we(i) {
          An[i] || (typeof console < "u" && console.warn(i), An[i] = !0);
        }
        function Gs(i, t, s) {
          return (s.y - i.y) * (t.x - i.x) > (t.y - i.y) * (s.x - i.x);
        }
        function ai(i) {
          return typeof WorkerGlobalScope < "u" && i !== void 0 && i instanceof WorkerGlobalScope;
        }
        let pe = null;
        function oi(i) {
          return typeof ImageBitmap < "u" && i instanceof ImageBitmap;
        }
        const Mi = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
        function Yr(i, t, s, n, a) {
          return u(this, void 0, void 0, (function* () {
            if (typeof VideoFrame > "u") throw new Error("VideoFrame not supported");
            const M = new VideoFrame(i, { timestamp: 0 });
            try {
              const l = M?.format;
              if (!l || !l.startsWith("BGR") && !l.startsWith("RGB")) throw new Error(`Unrecognized format ${l}`);
              const D = l.startsWith("BGR"), N = new Uint8ClampedArray(n * a * 4);
              if (yield M.copyTo(N, (function(y, w, T, x, A) {
                const m = 4 * Math.max(-w, 0), L = (Math.max(0, T) - T) * x * 4 + m, O = 4 * x, B = Math.max(0, w), P = Math.max(0, T);
                return { rect: { x: B, y: P, width: Math.min(y.width, w + x) - B, height: Math.min(y.height, T + A) - P }, layout: [{ offset: L, stride: O }] };
              })(i, t, s, n, a)), D) for (let y = 0; y < N.length; y += 4) {
                const w = N[y];
                N[y] = N[y + 2], N[y + 2] = w;
              }
              return N;
            } finally {
              M.close();
            }
          }));
        }
        let Ui, ci;
        function Xi(i, t, s, n) {
          return i.addEventListener(t, s, n), { unsubscribe: () => {
            i.removeEventListener(t, s, n);
          } };
        }
        function cr(i) {
          return i * Math.PI / 180;
        }
        function Ts(i) {
          return i / Math.PI * 180;
        }
        const mn = { touchstart: !0, touchmove: !0, touchmoveWindow: !0, touchend: !0, touchcancel: !0 }, jn = { dblclick: !0, click: !0, mouseover: !0, mouseout: !0, mousedown: !0, mousemove: !0, mousemoveWindow: !0, mouseup: !0, mouseupWindow: !0, contextmenu: !0, wheel: !0 }, lr = "AbortError";
        function Ur() {
          return new Error(lr);
        }
        const Wi = { MAX_PARALLEL_IMAGE_REQUESTS: 16, MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8, MAX_TILE_CACHE_ZOOM_LEVELS: 5, REGISTERED_PROTOCOLS: {}, WORKER_URL: "" };
        function Xr(i) {
          return Wi.REGISTERED_PROTOCOLS[i.substring(0, i.indexOf("://"))];
        }
        const ur = "global-dispatcher";
        class Hs extends Error {
          constructor(t, s, n, a) {
            super(`AJAXError: ${s} (${t}): ${n}`), this.status = t, this.statusText = s, this.url = n, this.body = a;
          }
        }
        const Os = () => ai(self) ? self.worker && self.worker.referrer : (window.location.protocol === "blob:" ? window.parent : window).location.href, tt = function(i, t) {
          if (/:\/\//.test(i.url) && !/^https?:|^file:/.test(i.url)) {
            const n = Xr(i.url);
            if (n) return n(i, t);
            if (ai(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: i, targetMapId: ur }, t);
          }
          if (!(/^file:/.test(s = i.url) || /^file:/.test(Os()) && !/^\w+:/.test(s))) {
            if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal")) return (function(n, a) {
              return u(this, void 0, void 0, (function* () {
                const M = new Request(n.url, { method: n.method || "GET", body: n.body, credentials: n.credentials, headers: n.headers, cache: n.cache, referrer: Os(), signal: a.signal });
                let l, D;
                n.type !== "json" || M.headers.has("Accept") || M.headers.set("Accept", "application/json");
                try {
                  l = yield fetch(M);
                } catch (y) {
                  throw new Hs(0, y.message, n.url, new Blob());
                }
                if (!l.ok) {
                  const y = yield l.blob();
                  throw new Hs(l.status, l.statusText, n.url, y);
                }
                D = n.type === "arrayBuffer" || n.type === "image" ? l.arrayBuffer() : n.type === "json" ? l.json() : l.text();
                const N = yield D;
                if (a.signal.aborted) throw Ur();
                return { data: N, cacheControl: l.headers.get("Cache-Control"), expires: l.headers.get("Expires") };
              }));
            })(i, t);
            if (ai(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: i, mustQueue: !0, targetMapId: ur }, t);
          }
          var s;
          return (function(n, a) {
            return new Promise(((M, l) => {
              var D;
              const N = new XMLHttpRequest();
              N.open(n.method || "GET", n.url, !0), n.type !== "arrayBuffer" && n.type !== "image" || (N.responseType = "arraybuffer");
              for (const y in n.headers) N.setRequestHeader(y, n.headers[y]);
              n.type === "json" && (N.responseType = "text", !((D = n.headers) === null || D === void 0) && D.Accept || N.setRequestHeader("Accept", "application/json")), N.withCredentials = n.credentials === "include", N.onerror = () => {
                l(new Error(N.statusText));
              }, N.onload = () => {
                if (!a.signal.aborted) if ((N.status >= 200 && N.status < 300 || N.status === 0) && N.response !== null) {
                  let y = N.response;
                  if (n.type === "json") try {
                    y = JSON.parse(N.response);
                  } catch (w) {
                    return void l(w);
                  }
                  M({ data: y, cacheControl: N.getResponseHeader("Cache-Control"), expires: N.getResponseHeader("Expires") });
                } else {
                  const y = new Blob([N.response], { type: N.getResponseHeader("Content-Type") });
                  l(new Hs(N.status, N.statusText, n.url, y));
                }
              }, a.signal.addEventListener("abort", (() => {
                N.abort(), l(Ur());
              })), N.send(n.body);
            }));
          })(i, t);
        };
        function E(i) {
          if (!i || i.indexOf("://") <= 0 || i.indexOf("data:image/") === 0 || i.indexOf("blob:") === 0) return !0;
          const t = new URL(i), s = window.location;
          return t.protocol === s.protocol && t.host === s.host;
        }
        function Q(i, t, s) {
          s[i] && s[i].indexOf(t) !== -1 || (s[i] = s[i] || [], s[i].push(t));
        }
        function S(i, t, s) {
          if (s && s[i]) {
            const n = s[i].indexOf(t);
            n !== -1 && s[i].splice(n, 1);
          }
        }
        class V {
          constructor(t, s = {}) {
            rs(this, s), this.type = t;
          }
        }
        class H extends V {
          constructor(t, s = {}) {
            super("error", rs({ error: t }, s));
          }
        }
        class rt {
          on(t, s) {
            return this._listeners = this._listeners || {}, Q(t, s, this._listeners), { unsubscribe: () => {
              this.off(t, s);
            } };
          }
          off(t, s) {
            return S(t, s, this._listeners), S(t, s, this._oneTimeListeners), this;
          }
          once(t, s) {
            return s ? (this._oneTimeListeners = this._oneTimeListeners || {}, Q(t, s, this._oneTimeListeners), this) : new Promise(((n) => this.once(t, n)));
          }
          fire(t, s) {
            typeof t == "string" && (t = new V(t, s || {}));
            const n = t.type;
            if (this.listens(n)) {
              t.target = this;
              const a = this._listeners && this._listeners[n] ? this._listeners[n].slice() : [];
              for (const D of a) D.call(this, t);
              const M = this._oneTimeListeners && this._oneTimeListeners[n] ? this._oneTimeListeners[n].slice() : [];
              for (const D of M) S(n, D, this._oneTimeListeners), D.call(this, t);
              const l = this._eventedParent;
              l && (rs(t, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData), l.fire(t));
            } else t instanceof H && console.error(t.error);
            return this;
          }
          listens(t) {
            return this._listeners && this._listeners[t] && this._listeners[t].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t] && this._oneTimeListeners[t].length > 0 || this._eventedParent && this._eventedParent.listens(t);
          }
          setEventedParent(t, s) {
            return this._eventedParent = t, this._eventedParentData = s, this;
          }
        }
        var X = { $version: 8, $root: { version: { required: !0, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number" }, centerAltitude: { type: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, roll: { type: "number", default: 0, units: "degrees" }, state: { type: "state", default: {} }, light: { type: "light" }, sky: { type: "sky" }, projection: { type: "projection" }, terrain: { type: "terrain" }, sources: { required: !0, type: "sources" }, sprite: { type: "sprite" }, glyphs: { type: "string" }, "font-faces": { type: "array", value: "fontFaces" }, transition: { type: "transition" }, layers: { required: !0, type: "array", value: "layer" } }, sources: { "*": { type: "source" } }, source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"], source_vector: { type: { required: !0, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, promoteId: { type: "promoteId" }, volatile: { type: "boolean", default: !1 }, encoding: { type: "enum", values: { mvt: {}, mlt: {} }, default: "mvt" }, "*": { type: "*" } }, source_raster: { type: { required: !0, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_raster_dem: { type: { required: !0, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {}, custom: {} }, default: "mapbox" }, redFactor: { type: "number", default: 1 }, blueFactor: { type: "number", default: 1 }, greenFactor: { type: "number", default: 1 }, baseShift: { type: "number", default: 0 }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_geojson: { type: { required: !0, type: "enum", values: { geojson: {} } }, data: { required: !0, type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, filter: { type: "*" }, tolerance: { type: "number", default: 0.375 }, cluster: { type: "boolean", default: !1 }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, clusterMinPoints: { type: "number" }, clusterProperties: { type: "*" }, lineMetrics: { type: "boolean", default: !1 }, generateId: { type: "boolean", default: !1 }, promoteId: { type: "promoteId" } }, source_video: { type: { required: !0, type: "enum", values: { video: {} } }, urls: { required: !0, type: "array", value: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, source_image: { type: { required: !0, type: "enum", values: { image: {} } }, url: { required: !0, type: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, layer: { id: { type: "string", required: !0 }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, "color-relief": {}, background: {} }, required: !0 }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } }, layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_color-relief", "layout_background"], layout_background: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_fill: { "fill-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_circle: { "circle-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_heatmap: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_line: { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_symbol: { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "symbol-z-order": { type: "enum", values: { auto: {}, "viewport-y": {}, source: {} }, default: "auto", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: !1, requires: ["icon-image", { "!": "icon-overlap" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: !1, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: !1, requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "resolvedImage", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "padding", default: [2], units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-keep-upright": { type: "boolean", default: !1, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, "viewport-glyph": {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"], requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { auto: {}, left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-radial-offset": { type: "number", units: "ems", default: 0, requires: ["text-field"], "property-type": "data-driven", expression: { interpolated: !0, parameters: ["zoom", "feature"] } }, "text-variable-anchor": { type: "array", value: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-variable-anchor-offset": { type: "variableAnchorOffsetCollection", requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field", { "!": "text-variable-anchor" }], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-writing-mode": { type: "array", value: "enum", values: { horizontal: {}, vertical: {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: !0, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field", { "!": "text-radial-offset" }], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: !1, requires: ["text-field", { "!": "text-overlap" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: !1, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: !1, requires: ["text-field", "icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_raster: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_hillshade: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_color-relief": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, filter: { type: "array", value: "*" }, filter_operator: { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {} } }, geometry_type: { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } }, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: !1 } }, function_stop: { type: "array", minimum: 0, maximum: 24, value: ["number", "color"], length: 2 }, expression: { type: "array", value: "*", minimum: 1 }, light: { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: !1, expression: { interpolated: !1, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, intensity: { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 } }, sky: { "sky-color": { type: "color", "property-type": "data-constant", default: "#88C6FC", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "horizon-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "fog-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "fog-ground-blend": { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "horizon-fog-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "sky-horizon-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "atmosphere-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 } }, terrain: { source: { type: "string", required: !0 }, exaggeration: { type: "number", minimum: 0, default: 1 } }, projection: { type: { type: "projectionDefinition", default: "mercator", "property-type": "data-constant", transition: !1, expression: { interpolated: !0, parameters: ["zoom"] } } }, paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_color-relief", "paint_background"], paint_fill: { "fill-antialias": { type: "boolean", default: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: !0, requires: [{ "!": "fill-pattern" }, { "fill-antialias": !0 }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" } }, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, requires: ["fill-extrusion-height"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-vertical-gradient": { type: "boolean", default: !0, transition: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_line: { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "line-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: !0, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-gradient": { type: "color", transition: !1, requires: [{ "!": "line-dasharray" }, { "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: !0 } }], expression: { interpolated: !0, parameters: ["line-progress"] }, "property-type": "color-ramp" } }, paint_circle: { "circle-radius": { type: "number", default: 5, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } }, paint_heatmap: { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: !1, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"], transition: !1, expression: { interpolated: !0, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_symbol: { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: !0, overridable: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_raster: { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: !0, units: "degrees", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: !1, units: "milliseconds", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_hillshade: { "hillshade-illumination-direction": { type: "numberArray", default: 335, minimum: 0, maximum: 359, transition: !1, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-altitude": { type: "numberArray", default: 45, minimum: 0, maximum: 90, transition: !1, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: 0.5, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "colorArray", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "colorArray", default: "#FFFFFF", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-method": { type: "enum", values: { standard: {}, basic: {}, combined: {}, igor: {}, multidirectional: {} }, default: "standard", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, "paint_color-relief": { "color-relief-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "color-relief-color": { type: "color", transition: !1, expression: { interpolated: !0, parameters: ["elevation"] }, "property-type": "color-ramp" } }, paint_background: { "background-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "background-pattern" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, transition: { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } }, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } }, promoteId: { "*": { type: "string" } } };
        const it = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];
        function lt(i, t) {
          const s = {};
          for (const n in i) n !== "ref" && (s[n] = i[n]);
          return it.forEach(((n) => {
            n in t && (s[n] = t[n]);
          })), s;
        }
        function ut(i, t) {
          if (Array.isArray(i)) {
            if (!Array.isArray(t) || i.length !== t.length) return !1;
            for (let s = 0; s < i.length; s++) if (!ut(i[s], t[s])) return !1;
            return !0;
          }
          if (typeof i == "object" && i !== null && t !== null) {
            if (typeof t != "object" || Object.keys(i).length !== Object.keys(t).length) return !1;
            for (const s in i) if (!ut(i[s], t[s])) return !1;
            return !0;
          }
          return i === t;
        }
        function ht(i, t) {
          i.push(t);
        }
        function _t(i, t, s) {
          ht(s, { command: "addSource", args: [i, t[i]] });
        }
        function vt(i, t, s) {
          ht(t, { command: "removeSource", args: [i] }), s[i] = !0;
        }
        function Xt(i, t, s, n) {
          vt(i, s, n), _t(i, t, s);
        }
        function _e(i, t, s) {
          let n;
          for (n in i[s]) if (Object.prototype.hasOwnProperty.call(i[s], n) && n !== "data" && !ut(i[s][n], t[s][n])) return !1;
          for (n in t[s]) if (Object.prototype.hasOwnProperty.call(t[s], n) && n !== "data" && !ut(i[s][n], t[s][n])) return !1;
          return !0;
        }
        function Zt(i, t, s, n, a, M) {
          i = i || {}, t = t || {};
          for (const l in i) Object.prototype.hasOwnProperty.call(i, l) && (ut(i[l], t[l]) || s.push({ command: M, args: [n, l, t[l], a] }));
          for (const l in t) Object.prototype.hasOwnProperty.call(t, l) && !Object.prototype.hasOwnProperty.call(i, l) && (ut(i[l], t[l]) || s.push({ command: M, args: [n, l, t[l], a] }));
        }
        function te(i) {
          return i.id;
        }
        function oe(i, t) {
          return i[t.id] = t, i;
        }
        class It {
          constructor(t, s, n, a) {
            this.message = (t ? `${t}: ` : "") + n, a && (this.identifier = a), s != null && s.__line__ && (this.line = s.__line__);
          }
        }
        function De(i, ...t) {
          for (const s of t) for (const n in s) i[n] = s[n];
          return i;
        }
        class Me extends Error {
          constructor(t, s) {
            super(s), this.message = s, this.key = t;
          }
        }
        class ke {
          constructor(t, s = []) {
            this.parent = t, this.bindings = {};
            for (const [n, a] of s) this.bindings[n] = a;
          }
          concat(t) {
            return new ke(this, t);
          }
          get(t) {
            if (this.bindings[t]) return this.bindings[t];
            if (this.parent) return this.parent.get(t);
            throw new Error(`${t} not found in scope.`);
          }
          has(t) {
            return !!this.bindings[t] || !!this.parent && this.parent.has(t);
          }
        }
        const ce = { kind: "null" }, pt = { kind: "number" }, Ot = { kind: "string" }, kt = { kind: "boolean" }, fs = { kind: "color" }, gr = { kind: "projectionDefinition" }, Ve = { kind: "object" }, Ft = { kind: "value" }, wi = { kind: "collator" }, Wr = { kind: "formatted" }, Pr = { kind: "padding" }, Js = { kind: "colorArray" }, hr = { kind: "numberArray" }, Rr = { kind: "resolvedImage" }, Zr = { kind: "variableAnchorOffsetCollection" };
        function Es(i, t) {
          return { kind: "array", itemType: i, N: t };
        }
        function le(i) {
          if (i.kind === "array") {
            const t = le(i.itemType);
            return typeof i.N == "number" ? `array<${t}, ${i.N}>` : i.itemType.kind === "value" ? "array" : `array<${t}>`;
          }
          return i.kind;
        }
        const fl = [ce, pt, Ot, kt, fs, gr, Wr, Ve, Es(Ft), Pr, hr, Js, Rr, Zr];
        function li(i, t) {
          if (t.kind === "error") return null;
          if (i.kind === "array") {
            if (t.kind === "array" && (t.N === 0 && t.itemType.kind === "value" || !li(i.itemType, t.itemType)) && (typeof i.N != "number" || i.N === t.N)) return null;
          } else {
            if (i.kind === t.kind) return null;
            if (i.kind === "value") {
              for (const s of fl) if (!li(s, t)) return null;
            }
          }
          return `Expected ${le(i)} but found ${le(t)} instead.`;
        }
        function _n(i, t) {
          return t.some(((s) => s.kind === i.kind));
        }
        function Te(i, t) {
          return t.some(((s) => s === "null" ? i === null : s === "array" ? Array.isArray(i) : s === "object" ? i && !Array.isArray(i) && typeof i == "object" : s === typeof i));
        }
        function Pi(i, t) {
          return i.kind === "array" && t.kind === "array" ? i.itemType.kind === t.itemType.kind && typeof i.N == "number" : i.kind === t.kind;
        }
        const fo = 0.96422, Vr = 0.82521, xo = 4 / 29, Gr = 6 / 29, WM = 3 * Gr * Gr, PM = Gr * Gr * Gr, xl = Math.PI / 180, RM = 180 / Math.PI;
        function ZM(i) {
          return (i %= 360) < 0 && (i += 360), i;
        }
        function VM([i, t, s, n]) {
          let a, M;
          const l = mo((0.2225045 * (i = Ao(i)) + 0.7168786 * (t = Ao(t)) + 0.0606169 * (s = Ao(s))) / 1);
          i === t && t === s ? a = M = l : (a = mo((0.4360747 * i + 0.3850649 * t + 0.1430804 * s) / fo), M = mo((0.0139322 * i + 0.0971045 * t + 0.7141733 * s) / Vr));
          const D = 116 * l - 16;
          return [D < 0 ? 0 : D, 500 * (a - l), 200 * (l - M), n];
        }
        function Ao(i) {
          return i <= 0.04045 ? i / 12.92 : Math.pow((i + 0.055) / 1.055, 2.4);
        }
        function mo(i) {
          return i > PM ? Math.pow(i, 1 / 3) : i / WM + xo;
        }
        function GM([i, t, s, n]) {
          let a = (i + 16) / 116, M = isNaN(t) ? a : a + t / 500, l = isNaN(s) ? a : a - s / 200;
          return a = 1 * _o(a), M = fo * _o(M), l = Vr * _o(l), [jo(3.1338561 * M - 1.6168667 * a - 0.4906146 * l), jo(-0.9787684 * M + 1.9161415 * a + 0.033454 * l), jo(0.0719453 * M - 0.2289914 * a + 1.4052427 * l), n];
        }
        function jo(i) {
          return (i = i <= 304e-5 ? 12.92 * i : 1.055 * Math.pow(i, 1 / 2.4) - 0.055) < 0 ? 0 : i > 1 ? 1 : i;
        }
        function _o(i) {
          return i > Gr ? i * i * i : WM * (i - xo);
        }
        const HM = Object.hasOwn || function(i, t) {
          return Object.prototype.hasOwnProperty.call(i, t);
        };
        function pi(i, t) {
          return HM(i, t) ? i[t] : void 0;
        }
        function wa(i) {
          return parseInt(i.padEnd(2, i), 16) / 255;
        }
        function JM(i, t) {
          return ui(t ? i / 100 : i, 0, 1);
        }
        function ui(i, t, s) {
          return Math.min(Math.max(t, i), s);
        }
        function qM(i) {
          return !i.some(Number.isNaN);
        }
        const Al = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
        function Ri(i, t, s) {
          return i + s * (t - i);
        }
        function Dr(i, t, s) {
          return i.map(((n, a) => Ri(n, t[a], s)));
        }
        class Vt {
          constructor(t, s, n, a = 1, M = !0) {
            this.r = t, this.g = s, this.b = n, this.a = a, M || (this.r *= a, this.g *= a, this.b *= a, a || this.overwriteGetter("rgb", [t, s, n, a]));
          }
          static parse(t) {
            if (t instanceof Vt) return t;
            if (typeof t != "string") return;
            const s = (function(n) {
              if ((n = n.toLowerCase().trim()) === "transparent") return [0, 0, 0, 0];
              const a = pi(Al, n);
              if (a) {
                const [l, D, N] = a;
                return [l / 255, D / 255, N / 255, 1];
              }
              if (n.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(n)) {
                const l = n.length < 6 ? 1 : 2;
                let D = 1;
                return [wa(n.slice(D, D += l)), wa(n.slice(D, D += l)), wa(n.slice(D, D += l)), wa(n.slice(D, D + l) || "ff")];
              }
              if (n.startsWith("rgb")) {
                const l = n.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
                if (l) {
                  const [D, N, y, w, T, x, A, m, L, O, B, P] = l, k = [w || " ", A || " ", O].join("");
                  if (k === "  " || k === "  /" || k === ",," || k === ",,,") {
                    const U = [y, x, L].join(""), K = U === "%%%" ? 100 : U === "" ? 255 : 0;
                    if (K) {
                      const et = [ui(+N / K, 0, 1), ui(+T / K, 0, 1), ui(+m / K, 0, 1), B ? JM(+B, P) : 1];
                      if (qM(et)) return et;
                    }
                  }
                  return;
                }
              }
              const M = n.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
              if (M) {
                const [l, D, N, y, w, T, x, A, m] = M, L = [N || " ", w || " ", x].join("");
                if (L === "  " || L === "  /" || L === ",," || L === ",,,") {
                  const O = [+D, ui(+y, 0, 100), ui(+T, 0, 100), A ? JM(+A, m) : 1];
                  if (qM(O)) return (function([B, P, k, U]) {
                    function K(et) {
                      const ot = (et + B / 30) % 12, dt = P * Math.min(k, 1 - k);
                      return k - dt * Math.max(-1, Math.min(ot - 3, 9 - ot, 1));
                    }
                    return B = ZM(B), P /= 100, k /= 100, [K(0), K(8), K(4), U];
                  })(O);
                }
              }
            })(t);
            return s ? new Vt(...s, !1) : void 0;
          }
          get rgb() {
            const { r: t, g: s, b: n, a } = this, M = a || 1 / 0;
            return this.overwriteGetter("rgb", [t / M, s / M, n / M, a]);
          }
          get hcl() {
            return this.overwriteGetter("hcl", (function(t) {
              const [s, n, a, M] = VM(t), l = Math.sqrt(n * n + a * a);
              return [Math.round(1e4 * l) ? ZM(Math.atan2(a, n) * RM) : NaN, l, s, M];
            })(this.rgb));
          }
          get lab() {
            return this.overwriteGetter("lab", VM(this.rgb));
          }
          overwriteGetter(t, s) {
            return Object.defineProperty(this, t, { value: s }), s;
          }
          toString() {
            const [t, s, n, a] = this.rgb;
            return `rgba(${[t, s, n].map(((M) => Math.round(255 * M))).join(",")},${a})`;
          }
          static interpolate(t, s, n, a = "rgb") {
            switch (a) {
              case "rgb": {
                const [M, l, D, N] = Dr(t.rgb, s.rgb, n);
                return new Vt(M, l, D, N, !1);
              }
              case "hcl": {
                const [M, l, D, N] = t.hcl, [y, w, T, x] = s.hcl;
                let A, m;
                if (isNaN(M) || isNaN(y)) isNaN(M) ? isNaN(y) ? A = NaN : (A = y, D !== 1 && D !== 0 || (m = w)) : (A = M, T !== 1 && T !== 0 || (m = l));
                else {
                  let k = y - M;
                  y > M && k > 180 ? k -= 360 : y < M && M - y > 180 && (k += 360), A = M + n * k;
                }
                const [L, O, B, P] = (function([k, U, K, et]) {
                  return k = isNaN(k) ? 0 : k * xl, GM([K, Math.cos(k) * U, Math.sin(k) * U, et]);
                })([A, m ?? Ri(l, w, n), Ri(D, T, n), Ri(N, x, n)]);
                return new Vt(L, O, B, P, !1);
              }
              case "lab": {
                const [M, l, D, N] = GM(Dr(t.lab, s.lab, n));
                return new Vt(M, l, D, N, !1);
              }
            }
          }
        }
        Vt.black = new Vt(0, 0, 0, 1), Vt.white = new Vt(1, 1, 1, 1), Vt.transparent = new Vt(0, 0, 0, 0), Vt.red = new Vt(1, 0, 0, 1);
        class Fs {
          constructor(t, s, n) {
            this.sensitivity = t ? s ? "variant" : "case" : s ? "accent" : "base", this.locale = n, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
          }
          compare(t, s) {
            return this.collator.compare(t, s);
          }
          resolvedLocale() {
            return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
          }
        }
        const Jt = ["bottom", "center", "top"];
        class Zi {
          constructor(t, s, n, a, M, l) {
            this.text = t, this.image = s, this.scale = n, this.fontStack = a, this.textColor = M, this.verticalAlign = l;
          }
        }
        class Fe {
          constructor(t) {
            this.sections = t;
          }
          static fromString(t) {
            return new Fe([new Zi(t, null, null, null, null, null)]);
          }
          isEmpty() {
            return this.sections.length === 0 || !this.sections.some(((t) => t.text.length !== 0 || t.image && t.image.name.length !== 0));
          }
          static factory(t) {
            return t instanceof Fe ? t : Fe.fromString(t);
          }
          toString() {
            return this.sections.length === 0 ? "" : this.sections.map(((t) => t.text)).join("");
          }
        }
        class ns {
          constructor(t) {
            this.values = t.slice();
          }
          static parse(t) {
            if (t instanceof ns) return t;
            if (typeof t == "number") return new ns([t, t, t, t]);
            if (Array.isArray(t) && !(t.length < 1 || t.length > 4)) {
              for (const s of t) if (typeof s != "number") return;
              switch (t.length) {
                case 1:
                  t = [t[0], t[0], t[0], t[0]];
                  break;
                case 2:
                  t = [t[0], t[1], t[0], t[1]];
                  break;
                case 3:
                  t = [t[0], t[1], t[2], t[1]];
              }
              return new ns(t);
            }
          }
          toString() {
            return JSON.stringify(this.values);
          }
          static interpolate(t, s, n) {
            return new ns(Dr(t.values, s.values, n));
          }
        }
        class as {
          constructor(t) {
            this.values = t.slice();
          }
          static parse(t) {
            if (t instanceof as) return t;
            if (typeof t == "number") return new as([t]);
            if (Array.isArray(t)) {
              for (const s of t) if (typeof s != "number") return;
              return new as(t);
            }
          }
          toString() {
            return JSON.stringify(this.values);
          }
          static interpolate(t, s, n) {
            return new as(Dr(t.values, s.values, n));
          }
        }
        class Re {
          constructor(t) {
            this.values = t.slice();
          }
          static parse(t) {
            if (t instanceof Re) return t;
            if (typeof t == "string") {
              const n = Vt.parse(t);
              return n ? new Re([n]) : void 0;
            }
            if (!Array.isArray(t)) return;
            const s = [];
            for (const n of t) {
              if (typeof n != "string") return;
              const a = Vt.parse(n);
              if (!a) return;
              s.push(a);
            }
            return new Re(s);
          }
          toString() {
            return JSON.stringify(this.values);
          }
          static interpolate(t, s, n, a = "rgb") {
            const M = [];
            if (t.values.length != s.values.length) throw new Error(`colorArray: Arrays have mismatched length (${t.values.length} vs. ${s.values.length}), cannot interpolate.`);
            for (let l = 0; l < t.values.length; l++) M.push(Vt.interpolate(t.values[l], s.values[l], n, a));
            return new Re(M);
          }
        }
        class ue extends Error {
          constructor(t) {
            super(t), this.name = "RuntimeError";
          }
          toJSON() {
            return this.message;
          }
        }
        const pa = /* @__PURE__ */ new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]);
        class zs {
          constructor(t) {
            this.values = t.slice();
          }
          static parse(t) {
            if (t instanceof zs) return t;
            if (Array.isArray(t) && !(t.length < 1) && t.length % 2 == 0) {
              for (let s = 0; s < t.length; s += 2) {
                const n = t[s], a = t[s + 1];
                if (typeof n != "string" || !pa.has(n) || !Array.isArray(a) || a.length !== 2 || typeof a[0] != "number" || typeof a[1] != "number") return;
              }
              return new zs(t);
            }
          }
          toString() {
            return JSON.stringify(this.values);
          }
          static interpolate(t, s, n) {
            const a = t.values, M = s.values;
            if (a.length !== M.length) throw new ue(`Cannot interpolate values of different length. from: ${t.toString()}, to: ${s.toString()}`);
            const l = [];
            for (let D = 0; D < a.length; D += 2) {
              if (a[D] !== M[D]) throw new ue(`Cannot interpolate values containing mismatched anchors. from[${D}]: ${a[D]}, to[${D}]: ${M[D]}`);
              l.push(a[D]);
              const [N, y] = a[D + 1], [w, T] = M[D + 1];
              l.push([Ri(N, w, n), Ri(y, T, n)]);
            }
            return new zs(l);
          }
        }
        class xs {
          constructor(t) {
            this.name = t.name, this.available = t.available;
          }
          toString() {
            return this.name;
          }
          static fromString(t) {
            return t ? new xs({ name: t, available: !1 }) : null;
          }
        }
        class os {
          constructor(t, s, n) {
            this.from = t, this.to = s, this.transition = n;
          }
          static interpolate(t, s, n) {
            return new os(t, s, n);
          }
          static parse(t) {
            return t instanceof os ? t : Array.isArray(t) && t.length === 3 && typeof t[0] == "string" && typeof t[1] == "string" && typeof t[2] == "number" ? new os(t[0], t[1], t[2]) : typeof t == "object" && typeof t.from == "string" && typeof t.to == "string" && typeof t.transition == "number" ? new os(t.from, t.to, t.transition) : typeof t == "string" ? new os(t, t, 1) : void 0;
          }
        }
        function $M(i, t, s, n) {
          return typeof i == "number" && i >= 0 && i <= 255 && typeof t == "number" && t >= 0 && t <= 255 && typeof s == "number" && s >= 0 && s <= 255 ? n === void 0 || typeof n == "number" && n >= 0 && n <= 1 ? null : `Invalid rgba value [${[i, t, s, n].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof n == "number" ? [i, t, s, n] : [i, t, s]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
        }
        function Vi(i) {
          if (i === null || typeof i == "string" || typeof i == "boolean" || typeof i == "number" || i instanceof os || i instanceof Vt || i instanceof Fs || i instanceof Fe || i instanceof ns || i instanceof as || i instanceof Re || i instanceof zs || i instanceof xs) return !0;
          if (Array.isArray(i)) {
            for (const t of i) if (!Vi(t)) return !1;
            return !0;
          }
          if (typeof i == "object") {
            for (const t in i) if (!Vi(i[t])) return !1;
            return !0;
          }
          return !1;
        }
        function ze(i) {
          if (i === null) return ce;
          if (typeof i == "string") return Ot;
          if (typeof i == "boolean") return kt;
          if (typeof i == "number") return pt;
          if (i instanceof Vt) return fs;
          if (i instanceof os) return gr;
          if (i instanceof Fs) return wi;
          if (i instanceof Fe) return Wr;
          if (i instanceof ns) return Pr;
          if (i instanceof as) return hr;
          if (i instanceof Re) return Js;
          if (i instanceof zs) return Zr;
          if (i instanceof xs) return Rr;
          if (Array.isArray(i)) {
            const t = i.length;
            let s;
            for (const n of i) {
              const a = ze(n);
              if (s) {
                if (s === a) continue;
                s = Ft;
                break;
              }
              s = a;
            }
            return Es(s || Ft, t);
          }
          return Ve;
        }
        function Hr(i) {
          const t = typeof i;
          return i === null ? "" : t === "string" || t === "number" || t === "boolean" ? String(i) : i instanceof Vt || i instanceof os || i instanceof Fe || i instanceof ns || i instanceof as || i instanceof Re || i instanceof zs || i instanceof xs ? i.toString() : JSON.stringify(i);
        }
        class Gi {
          constructor(t, s) {
            this.type = t, this.value = s;
          }
          static parse(t, s) {
            if (t.length !== 2) return s.error(`'literal' expression requires exactly one argument, but found ${t.length - 1} instead.`);
            if (!Vi(t[1])) return s.error("invalid value");
            const n = t[1];
            let a = ze(n);
            const M = s.expectedType;
            return a.kind !== "array" || a.N !== 0 || !M || M.kind !== "array" || typeof M.N == "number" && M.N !== 0 || (a = M), new Gi(a, n);
          }
          evaluate() {
            return this.value;
          }
          eachChild() {
          }
          outputDefined() {
            return !0;
          }
        }
        const Ln = { string: Ot, number: pt, boolean: kt, object: Ve };
        class As {
          constructor(t, s) {
            this.type = t, this.args = s;
          }
          static parse(t, s) {
            if (t.length < 2) return s.error("Expected at least one argument.");
            let n, a = 1;
            const M = t[0];
            if (M === "array") {
              let D, N;
              if (t.length > 2) {
                const y = t[1];
                if (typeof y != "string" || !(y in Ln) || y === "object") return s.error('The item type argument of "array" must be one of string, number, boolean', 1);
                D = Ln[y], a++;
              } else D = Ft;
              if (t.length > 3) {
                if (t[2] !== null && (typeof t[2] != "number" || t[2] < 0 || t[2] !== Math.floor(t[2]))) return s.error('The length argument to "array" must be a positive integer literal', 2);
                N = t[2], a++;
              }
              n = Es(D, N);
            } else {
              if (!Ln[M]) throw new Error(`Types doesn't contain name = ${M}`);
              n = Ln[M];
            }
            const l = [];
            for (; a < t.length; a++) {
              const D = s.parse(t[a], a, Ft);
              if (!D) return null;
              l.push(D);
            }
            return new As(n, l);
          }
          evaluate(t) {
            for (let s = 0; s < this.args.length; s++) {
              const n = this.args[s].evaluate(t);
              if (!li(this.type, ze(n))) return n;
              if (s === this.args.length - 1) throw new ue(`Expected value to be of type ${le(this.type)}, but found ${le(ze(n))} instead.`);
            }
            throw new Error();
          }
          eachChild(t) {
            this.args.forEach(t);
          }
          outputDefined() {
            return this.args.every(((t) => t.outputDefined()));
          }
        }
        const Ne = { "to-boolean": kt, "to-color": fs, "to-number": pt, "to-string": Ot };
        class gi {
          constructor(t, s) {
            this.type = t, this.args = s;
          }
          static parse(t, s) {
            if (t.length < 2) return s.error("Expected at least one argument.");
            const n = t[0];
            if (!Ne[n]) throw new Error(`Can't parse ${n} as it is not part of the known types`);
            if ((n === "to-boolean" || n === "to-string") && t.length !== 2) return s.error("Expected one argument.");
            const a = Ne[n], M = [];
            for (let l = 1; l < t.length; l++) {
              const D = s.parse(t[l], l, Ft);
              if (!D) return null;
              M.push(D);
            }
            return new gi(a, M);
          }
          evaluate(t) {
            switch (this.type.kind) {
              case "boolean":
                return !!this.args[0].evaluate(t);
              case "color": {
                let s, n;
                for (const a of this.args) {
                  if (s = a.evaluate(t), n = null, s instanceof Vt) return s;
                  if (typeof s == "string") {
                    const M = t.parseColor(s);
                    if (M) return M;
                  } else if (Array.isArray(s) && (n = s.length < 3 || s.length > 4 ? `Invalid rgba value ${JSON.stringify(s)}: expected an array containing either three or four numeric values.` : $M(s[0], s[1], s[2], s[3]), !n)) return new Vt(s[0] / 255, s[1] / 255, s[2] / 255, s[3]);
                }
                throw new ue(n || `Could not parse color from value '${typeof s == "string" ? s : JSON.stringify(s)}'`);
              }
              case "padding": {
                let s;
                for (const n of this.args) {
                  s = n.evaluate(t);
                  const a = ns.parse(s);
                  if (a) return a;
                }
                throw new ue(`Could not parse padding from value '${typeof s == "string" ? s : JSON.stringify(s)}'`);
              }
              case "numberArray": {
                let s;
                for (const n of this.args) {
                  s = n.evaluate(t);
                  const a = as.parse(s);
                  if (a) return a;
                }
                throw new ue(`Could not parse numberArray from value '${typeof s == "string" ? s : JSON.stringify(s)}'`);
              }
              case "colorArray": {
                let s;
                for (const n of this.args) {
                  s = n.evaluate(t);
                  const a = Re.parse(s);
                  if (a) return a;
                }
                throw new ue(`Could not parse colorArray from value '${typeof s == "string" ? s : JSON.stringify(s)}'`);
              }
              case "variableAnchorOffsetCollection": {
                let s;
                for (const n of this.args) {
                  s = n.evaluate(t);
                  const a = zs.parse(s);
                  if (a) return a;
                }
                throw new ue(`Could not parse variableAnchorOffsetCollection from value '${typeof s == "string" ? s : JSON.stringify(s)}'`);
              }
              case "number": {
                let s = null;
                for (const n of this.args) {
                  if (s = n.evaluate(t), s === null) return 0;
                  const a = Number(s);
                  if (!isNaN(a)) return a;
                }
                throw new ue(`Could not convert ${JSON.stringify(s)} to number.`);
              }
              case "formatted":
                return Fe.fromString(Hr(this.args[0].evaluate(t)));
              case "resolvedImage":
                return xs.fromString(Hr(this.args[0].evaluate(t)));
              case "projectionDefinition":
                return this.args[0].evaluate(t);
              default:
                return Hr(this.args[0].evaluate(t));
            }
          }
          eachChild(t) {
            this.args.forEach(t);
          }
          outputDefined() {
            return this.args.every(((t) => t.outputDefined()));
          }
        }
        const Kt = ["Unknown", "Point", "LineString", "Polygon"];
        class Pt {
          constructor() {
            this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = /* @__PURE__ */ new Map(), this.availableImages = null, this.canonical = null;
          }
          id() {
            return this.feature && "id" in this.feature ? this.feature.id : null;
          }
          geometryType() {
            return this.feature ? typeof this.feature.type == "number" ? Kt[this.feature.type] : this.feature.type : null;
          }
          geometry() {
            return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
          }
          canonicalID() {
            return this.canonical;
          }
          properties() {
            return this.feature && this.feature.properties || {};
          }
          parseColor(t) {
            let s = this._parseColorCache.get(t);
            return s || (s = Vt.parse(t), this._parseColorCache.set(t, s)), s;
          }
        }
        class Jr {
          constructor(t, s, n = [], a, M = new ke(), l = []) {
            this.registry = t, this.path = n, this.key = n.map(((D) => `[${D}]`)).join(""), this.scope = M, this.errors = l, this.expectedType = a, this._isConstant = s;
          }
          parse(t, s, n, a, M = {}) {
            return s ? this.concat(s, n, a)._parse(t, M) : this._parse(t, M);
          }
          _parse(t, s) {
            function n(a, M, l) {
              return l === "assert" ? new As(M, [a]) : l === "coerce" ? new gi(M, [a]) : a;
            }
            if (t !== null && typeof t != "string" && typeof t != "boolean" && typeof t != "number" || (t = ["literal", t]), Array.isArray(t)) {
              if (t.length === 0) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
              const a = t[0];
              if (typeof a != "string") return this.error(`Expression name must be a string, but found ${typeof a} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
              const M = this.registry[a];
              if (M) {
                let l = M.parse(t, this);
                if (!l) return null;
                if (this.expectedType) {
                  const D = this.expectedType, N = l.type;
                  if (D.kind !== "string" && D.kind !== "number" && D.kind !== "boolean" && D.kind !== "object" && D.kind !== "array" || N.kind !== "value") {
                    if (D.kind === "projectionDefinition" && ["string", "array"].includes(N.kind) || ["color", "formatted", "resolvedImage"].includes(D.kind) && ["value", "string"].includes(N.kind) || ["padding", "numberArray"].includes(D.kind) && ["value", "number", "array"].includes(N.kind) || D.kind === "colorArray" && ["value", "string", "array"].includes(N.kind) || D.kind === "variableAnchorOffsetCollection" && ["value", "array"].includes(N.kind)) l = n(l, D, s.typeAnnotation || "coerce");
                    else if (this.checkSubtype(D, N)) return null;
                  } else l = n(l, D, s.typeAnnotation || "assert");
                }
                if (!(l instanceof Gi) && l.type.kind !== "resolvedImage" && this._isConstant(l)) {
                  const D = new Pt();
                  try {
                    l = new Gi(l.type, l.evaluate(D));
                  } catch (N) {
                    return this.error(N.message), null;
                  }
                }
                return l;
              }
              return this.error(`Unknown expression "${a}". If you wanted a literal array, use ["literal", [...]].`, 0);
            }
            return this.error(t === void 0 ? "'undefined' value invalid. Use null instead." : typeof t == "object" ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t} instead.`);
          }
          concat(t, s, n) {
            const a = typeof t == "number" ? this.path.concat(t) : this.path, M = n ? this.scope.concat(n) : this.scope;
            return new Jr(this.registry, this._isConstant, a, s || null, M, this.errors);
          }
          error(t, ...s) {
            const n = `${this.key}${s.map(((a) => `[${a}]`)).join("")}`;
            this.errors.push(new Me(n, t));
          }
          checkSubtype(t, s) {
            const n = li(t, s);
            return n && this.error(n), n;
          }
        }
        class qt {
          constructor(t, s) {
            this.type = s.type, this.bindings = [].concat(t), this.result = s;
          }
          evaluate(t) {
            return this.result.evaluate(t);
          }
          eachChild(t) {
            for (const s of this.bindings) t(s[1]);
            t(this.result);
          }
          static parse(t, s) {
            if (t.length < 4) return s.error(`Expected at least 3 arguments, but found ${t.length - 1} instead.`);
            const n = [];
            for (let M = 1; M < t.length - 1; M += 2) {
              const l = t[M];
              if (typeof l != "string") return s.error(`Expected string, but found ${typeof l} instead.`, M);
              if (/[^a-zA-Z0-9_]/.test(l)) return s.error("Variable names must contain only alphanumeric characters or '_'.", M);
              const D = s.parse(t[M + 1], M + 1);
              if (!D) return null;
              n.push([l, D]);
            }
            const a = s.parse(t[t.length - 1], t.length - 1, s.expectedType, n);
            return a ? new qt(n, a) : null;
          }
          outputDefined() {
            return this.result.outputDefined();
          }
        }
        class qr {
          constructor(t, s) {
            this.type = s.type, this.name = t, this.boundExpression = s;
          }
          static parse(t, s) {
            if (t.length !== 2 || typeof t[1] != "string") return s.error("'var' expression requires exactly one string literal argument.");
            const n = t[1];
            return s.scope.has(n) ? new qr(n, s.scope.get(n)) : s.error(`Unknown variable "${n}". Make sure "${n}" has been bound in an enclosing "let" expression before using it.`, 1);
          }
          evaluate(t) {
            return this.boundExpression.evaluate(t);
          }
          eachChild() {
          }
          outputDefined() {
            return !1;
          }
        }
        class qs {
          constructor(t, s, n) {
            this.type = t, this.index = s, this.input = n;
          }
          static parse(t, s) {
            if (t.length !== 3) return s.error(`Expected 2 arguments, but found ${t.length - 1} instead.`);
            const n = s.parse(t[1], 1, pt), a = s.parse(t[2], 2, Es(s.expectedType || Ft));
            return n && a ? new qs(a.type.itemType, n, a) : null;
          }
          evaluate(t) {
            const s = this.index.evaluate(t), n = this.input.evaluate(t);
            if (s < 0) throw new ue(`Array index out of bounds: ${s} < 0.`);
            if (s >= n.length) throw new ue(`Array index out of bounds: ${s} > ${n.length - 1}.`);
            if (s !== Math.floor(s)) throw new ue(`Array index must be an integer, but found ${s} instead.`);
            return n[s];
          }
          eachChild(t) {
            t(this.index), t(this.input);
          }
          outputDefined() {
            return !1;
          }
        }
        class Cn {
          constructor(t, s) {
            this.type = kt, this.needle = t, this.haystack = s;
          }
          static parse(t, s) {
            if (t.length !== 3) return s.error(`Expected 2 arguments, but found ${t.length - 1} instead.`);
            const n = s.parse(t[1], 1, Ft), a = s.parse(t[2], 2, Ft);
            return n && a ? _n(n.type, [kt, Ot, pt, ce, Ft]) ? new Cn(n, a) : s.error(`Expected first argument to be of type boolean, string, number or null, but found ${le(n.type)} instead`) : null;
          }
          evaluate(t) {
            const s = this.needle.evaluate(t), n = this.haystack.evaluate(t);
            if (!n) return !1;
            if (!Te(s, ["boolean", "string", "number", "null"])) throw new ue(`Expected first argument to be of type boolean, string, number or null, but found ${le(ze(s))} instead.`);
            if (!Te(n, ["string", "array"])) throw new ue(`Expected second argument to be of type array or string, but found ${le(ze(n))} instead.`);
            return n.indexOf(s) >= 0;
          }
          eachChild(t) {
            t(this.needle), t(this.haystack);
          }
          outputDefined() {
            return !0;
          }
        }
        class zr {
          constructor(t, s, n) {
            this.type = pt, this.needle = t, this.haystack = s, this.fromIndex = n;
          }
          static parse(t, s) {
            if (t.length <= 2 || t.length >= 5) return s.error(`Expected 2 or 3 arguments, but found ${t.length - 1} instead.`);
            const n = s.parse(t[1], 1, Ft), a = s.parse(t[2], 2, Ft);
            if (!n || !a) return null;
            if (!_n(n.type, [kt, Ot, pt, ce, Ft])) return s.error(`Expected first argument to be of type boolean, string, number or null, but found ${le(n.type)} instead`);
            if (t.length === 4) {
              const M = s.parse(t[3], 3, pt);
              return M ? new zr(n, a, M) : null;
            }
            return new zr(n, a);
          }
          evaluate(t) {
            const s = this.needle.evaluate(t), n = this.haystack.evaluate(t);
            if (!Te(s, ["boolean", "string", "number", "null"])) throw new ue(`Expected first argument to be of type boolean, string, number or null, but found ${le(ze(s))} instead.`);
            let a;
            if (this.fromIndex && (a = this.fromIndex.evaluate(t)), Te(n, ["string"])) {
              const M = n.indexOf(s, a);
              return M === -1 ? -1 : [...n.slice(0, M)].length;
            }
            if (Te(n, ["array"])) return n.indexOf(s, a);
            throw new ue(`Expected second argument to be of type array or string, but found ${le(ze(n))} instead.`);
          }
          eachChild(t) {
            t(this.needle), t(this.haystack), this.fromIndex && t(this.fromIndex);
          }
          outputDefined() {
            return !1;
          }
        }
        class Ta {
          constructor(t, s, n, a, M, l) {
            this.inputType = t, this.type = s, this.input = n, this.cases = a, this.outputs = M, this.otherwise = l;
          }
          static parse(t, s) {
            if (t.length < 5) return s.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
            if (t.length % 2 != 1) return s.error("Expected an even number of arguments.");
            let n, a;
            s.expectedType && s.expectedType.kind !== "value" && (a = s.expectedType);
            const M = {}, l = [];
            for (let y = 2; y < t.length - 1; y += 2) {
              let w = t[y];
              const T = t[y + 1];
              Array.isArray(w) || (w = [w]);
              const x = s.concat(y);
              if (w.length === 0) return x.error("Expected at least one branch label.");
              for (const m of w) {
                if (typeof m != "number" && typeof m != "string") return x.error("Branch labels must be numbers or strings.");
                if (typeof m == "number" && Math.abs(m) > Number.MAX_SAFE_INTEGER) return x.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                if (typeof m == "number" && Math.floor(m) !== m) return x.error("Numeric branch labels must be integer values.");
                if (n) {
                  if (x.checkSubtype(n, ze(m))) return null;
                } else n = ze(m);
                if (M[String(m)] !== void 0) return x.error("Branch labels must be unique.");
                M[String(m)] = l.length;
              }
              const A = s.parse(T, y, a);
              if (!A) return null;
              a = a || A.type, l.push(A);
            }
            const D = s.parse(t[1], 1, Ft);
            if (!D) return null;
            const N = s.parse(t[t.length - 1], t.length - 1, a);
            return N ? D.type.kind !== "value" && s.concat(1).checkSubtype(n, D.type) ? null : new Ta(n, a, D, M, l, N) : null;
          }
          evaluate(t) {
            const s = this.input.evaluate(t);
            return (ze(s) === this.inputType && this.outputs[this.cases[s]] || this.otherwise).evaluate(t);
          }
          eachChild(t) {
            t(this.input), this.outputs.forEach(t), t(this.otherwise);
          }
          outputDefined() {
            return this.outputs.every(((t) => t.outputDefined())) && this.otherwise.outputDefined();
          }
        }
        class On {
          constructor(t, s, n) {
            this.type = t, this.branches = s, this.otherwise = n;
          }
          static parse(t, s) {
            if (t.length < 4) return s.error(`Expected at least 3 arguments, but found only ${t.length - 1}.`);
            if (t.length % 2 != 0) return s.error("Expected an odd number of arguments.");
            let n;
            s.expectedType && s.expectedType.kind !== "value" && (n = s.expectedType);
            const a = [];
            for (let l = 1; l < t.length - 1; l += 2) {
              const D = s.parse(t[l], l, kt);
              if (!D) return null;
              const N = s.parse(t[l + 1], l + 1, n);
              if (!N) return null;
              a.push([D, N]), n = n || N.type;
            }
            const M = s.parse(t[t.length - 1], t.length - 1, n);
            if (!M) return null;
            if (!n) throw new Error("Can't infer output type");
            return new On(n, a, M);
          }
          evaluate(t) {
            for (const [s, n] of this.branches) if (s.evaluate(t)) return n.evaluate(t);
            return this.otherwise.evaluate(t);
          }
          eachChild(t) {
            for (const [s, n] of this.branches) t(s), t(n);
            t(this.otherwise);
          }
          outputDefined() {
            return this.branches.every((([t, s]) => s.outputDefined())) && this.otherwise.outputDefined();
          }
        }
        class En {
          constructor(t, s, n, a) {
            this.type = t, this.input = s, this.beginIndex = n, this.endIndex = a;
          }
          static parse(t, s) {
            if (t.length <= 2 || t.length >= 5) return s.error(`Expected 2 or 3 arguments, but found ${t.length - 1} instead.`);
            const n = s.parse(t[1], 1, Ft), a = s.parse(t[2], 2, pt);
            if (!n || !a) return null;
            if (!_n(n.type, [Es(Ft), Ot, Ft])) return s.error(`Expected first argument to be of type array or string, but found ${le(n.type)} instead`);
            if (t.length === 4) {
              const M = s.parse(t[3], 3, pt);
              return M ? new En(n.type, n, a, M) : null;
            }
            return new En(n.type, n, a);
          }
          evaluate(t) {
            const s = this.input.evaluate(t), n = this.beginIndex.evaluate(t);
            let a;
            if (this.endIndex && (a = this.endIndex.evaluate(t)), Te(s, ["string"])) return [...s].slice(n, a).join("");
            if (Te(s, ["array"])) return s.slice(n, a);
            throw new ue(`Expected first argument to be of type array or string, but found ${le(ze(s))} instead.`);
          }
          eachChild(t) {
            t(this.input), t(this.beginIndex), this.endIndex && t(this.endIndex);
          }
          outputDefined() {
            return !1;
          }
        }
        function fa(i, t) {
          const s = i.length - 1;
          let n, a, M = 0, l = s, D = 0;
          for (; M <= l; ) if (D = Math.floor((M + l) / 2), n = i[D], a = i[D + 1], n <= t) {
            if (D === s || t < a) return D;
            M = D + 1;
          } else {
            if (!(n > t)) throw new ue("Input is not a number.");
            l = D - 1;
          }
          return 0;
        }
        class $r {
          constructor(t, s, n) {
            this.type = t, this.input = s, this.labels = [], this.outputs = [];
            for (const [a, M] of n) this.labels.push(a), this.outputs.push(M);
          }
          static parse(t, s) {
            if (t.length - 1 < 4) return s.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
            if ((t.length - 1) % 2 != 0) return s.error("Expected an even number of arguments.");
            const n = s.parse(t[1], 1, pt);
            if (!n) return null;
            const a = [];
            let M = null;
            s.expectedType && s.expectedType.kind !== "value" && (M = s.expectedType);
            for (let l = 1; l < t.length; l += 2) {
              const D = l === 1 ? -1 / 0 : t[l], N = t[l + 1], y = l, w = l + 1;
              if (typeof D != "number") return s.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', y);
              if (a.length && a[a.length - 1][0] >= D) return s.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', y);
              const T = s.parse(N, w, M);
              if (!T) return null;
              M = M || T.type, a.push([D, T]);
            }
            return new $r(M, n, a);
          }
          evaluate(t) {
            const s = this.labels, n = this.outputs;
            if (s.length === 1) return n[0].evaluate(t);
            const a = this.input.evaluate(t);
            if (a <= s[0]) return n[0].evaluate(t);
            const M = s.length;
            return a >= s[M - 1] ? n[M - 1].evaluate(t) : n[fa(s, a)].evaluate(t);
          }
          eachChild(t) {
            t(this.input);
            for (const s of this.outputs) t(s);
          }
          outputDefined() {
            return this.outputs.every(((t) => t.outputDefined()));
          }
        }
        function KM(i) {
          return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i;
        }
        var hi, ts, xa = (function() {
          if (ts) return hi;
          function i(t, s, n, a) {
            this.cx = 3 * t, this.bx = 3 * (n - t) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * s, this.by = 3 * (a - s) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t, this.p1y = s, this.p2x = n, this.p2y = a;
          }
          return ts = 1, hi = i, i.prototype = { sampleCurveX: function(t) {
            return ((this.ax * t + this.bx) * t + this.cx) * t;
          }, sampleCurveY: function(t) {
            return ((this.ay * t + this.by) * t + this.cy) * t;
          }, sampleCurveDerivativeX: function(t) {
            return (3 * this.ax * t + 2 * this.bx) * t + this.cx;
          }, solveCurveX: function(t, s) {
            if (s === void 0 && (s = 1e-6), t < 0) return 0;
            if (t > 1) return 1;
            for (var n = t, a = 0; a < 8; a++) {
              var M = this.sampleCurveX(n) - t;
              if (Math.abs(M) < s) return n;
              var l = this.sampleCurveDerivativeX(n);
              if (Math.abs(l) < 1e-6) break;
              n -= M / l;
            }
            var D = 0, N = 1;
            for (n = t, a = 0; a < 20 && (M = this.sampleCurveX(n), !(Math.abs(M - t) < s)); a++) t > M ? D = n : N = n, n = 0.5 * (N - D) + D;
            return n;
          }, solve: function(t, s) {
            return this.sampleCurveY(this.solveCurveX(t, s));
          } }, hi;
        })(), tc = KM(xa);
        class es {
          constructor(t, s, n, a, M) {
            this.type = t, this.operator = s, this.interpolation = n, this.input = a, this.labels = [], this.outputs = [];
            for (const [l, D] of M) this.labels.push(l), this.outputs.push(D);
          }
          static interpolationFactor(t, s, n, a) {
            let M = 0;
            if (t.name === "exponential") M = Ye(s, t.base, n, a);
            else if (t.name === "linear") M = Ye(s, 1, n, a);
            else if (t.name === "cubic-bezier") {
              const l = t.controlPoints;
              M = new tc(l[0], l[1], l[2], l[3]).solve(Ye(s, 1, n, a));
            }
            return M;
          }
          static parse(t, s) {
            let [n, a, M, ...l] = t;
            if (!Array.isArray(a) || a.length === 0) return s.error("Expected an interpolation type expression.", 1);
            if (a[0] === "linear") a = { name: "linear" };
            else if (a[0] === "exponential") {
              const y = a[1];
              if (typeof y != "number") return s.error("Exponential interpolation requires a numeric base.", 1, 1);
              a = { name: "exponential", base: y };
            } else {
              if (a[0] !== "cubic-bezier") return s.error(`Unknown interpolation type ${String(a[0])}`, 1, 0);
              {
                const y = a.slice(1);
                if (y.length !== 4 || y.some(((w) => typeof w != "number" || w < 0 || w > 1))) return s.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                a = { name: "cubic-bezier", controlPoints: y };
              }
            }
            if (t.length - 1 < 4) return s.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
            if ((t.length - 1) % 2 != 0) return s.error("Expected an even number of arguments.");
            if (M = s.parse(M, 2, pt), !M) return null;
            const D = [];
            let N = null;
            n !== "interpolate-hcl" && n !== "interpolate-lab" || s.expectedType == Js ? s.expectedType && s.expectedType.kind !== "value" && (N = s.expectedType) : N = fs;
            for (let y = 0; y < l.length; y += 2) {
              const w = l[y], T = l[y + 1], x = y + 3, A = y + 4;
              if (typeof w != "number") return s.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', x);
              if (D.length && D[D.length - 1][0] >= w) return s.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', x);
              const m = s.parse(T, A, N);
              if (!m) return null;
              N = N || m.type, D.push([w, m]);
            }
            return Pi(N, pt) || Pi(N, gr) || Pi(N, fs) || Pi(N, Pr) || Pi(N, hr) || Pi(N, Js) || Pi(N, Zr) || Pi(N, Es(pt)) ? new es(N, n, a, M, D) : s.error(`Type ${le(N)} is not interpolatable.`);
          }
          evaluate(t) {
            const s = this.labels, n = this.outputs;
            if (s.length === 1) return n[0].evaluate(t);
            const a = this.input.evaluate(t);
            if (a <= s[0]) return n[0].evaluate(t);
            const M = s.length;
            if (a >= s[M - 1]) return n[M - 1].evaluate(t);
            const l = fa(s, a), D = es.interpolationFactor(this.interpolation, a, s[l], s[l + 1]), N = n[l].evaluate(t), y = n[l + 1].evaluate(t);
            switch (this.operator) {
              case "interpolate":
                switch (this.type.kind) {
                  case "number":
                    return Ri(N, y, D);
                  case "color":
                    return Vt.interpolate(N, y, D);
                  case "padding":
                    return ns.interpolate(N, y, D);
                  case "colorArray":
                    return Re.interpolate(N, y, D);
                  case "numberArray":
                    return as.interpolate(N, y, D);
                  case "variableAnchorOffsetCollection":
                    return zs.interpolate(N, y, D);
                  case "array":
                    return Dr(N, y, D);
                  case "projectionDefinition":
                    return os.interpolate(N, y, D);
                }
              case "interpolate-hcl":
                switch (this.type.kind) {
                  case "color":
                    return Vt.interpolate(N, y, D, "hcl");
                  case "colorArray":
                    return Re.interpolate(N, y, D, "hcl");
                }
              case "interpolate-lab":
                switch (this.type.kind) {
                  case "color":
                    return Vt.interpolate(N, y, D, "lab");
                  case "colorArray":
                    return Re.interpolate(N, y, D, "lab");
                }
            }
          }
          eachChild(t) {
            t(this.input);
            for (const s of this.outputs) t(s);
          }
          outputDefined() {
            return this.outputs.every(((t) => t.outputDefined()));
          }
        }
        function Ye(i, t, s, n) {
          const a = n - s, M = i - s;
          return a === 0 ? 0 : t === 1 ? M / a : (Math.pow(t, M) - 1) / (Math.pow(t, a) - 1);
        }
        const $s = { color: Vt.interpolate, number: Ri, padding: ns.interpolate, numberArray: as.interpolate, colorArray: Re.interpolate, variableAnchorOffsetCollection: zs.interpolate, array: Dr };
        class Kr {
          constructor(t, s) {
            this.type = t, this.args = s;
          }
          static parse(t, s) {
            if (t.length < 2) return s.error("Expected at least one argument.");
            let n = null;
            const a = s.expectedType;
            a && a.kind !== "value" && (n = a);
            const M = [];
            for (const D of t.slice(1)) {
              const N = s.parse(D, 1 + M.length, n, void 0, { typeAnnotation: "omit" });
              if (!N) return null;
              n = n || N.type, M.push(N);
            }
            if (!n) throw new Error("No output type");
            const l = a && M.some(((D) => li(a, D.type)));
            return new Kr(l ? Ft : n, M);
          }
          evaluate(t) {
            let s, n = null, a = 0;
            for (const M of this.args) if (a++, n = M.evaluate(t), n && n instanceof xs && !n.available && (s || (s = n.name), n = null, a === this.args.length && (n = s)), n !== null) break;
            return n;
          }
          eachChild(t) {
            this.args.forEach(t);
          }
          outputDefined() {
            return this.args.every(((t) => t.outputDefined()));
          }
        }
        function Lo(i, t) {
          return i === "==" || i === "!=" ? t.kind === "boolean" || t.kind === "string" || t.kind === "number" || t.kind === "null" || t.kind === "value" : t.kind === "string" || t.kind === "number" || t.kind === "value";
        }
        function ec(i, t, s, n) {
          return n.compare(t, s) === 0;
        }
        function Ks(i, t, s) {
          const n = i !== "==" && i !== "!=";
          return class Gh {
            constructor(M, l, D) {
              this.type = kt, this.lhs = M, this.rhs = l, this.collator = D, this.hasUntypedArgument = M.type.kind === "value" || l.type.kind === "value";
            }
            static parse(M, l) {
              if (M.length !== 3 && M.length !== 4) return l.error("Expected two or three arguments.");
              const D = M[0];
              let N = l.parse(M[1], 1, Ft);
              if (!N) return null;
              if (!Lo(D, N.type)) return l.concat(1).error(`"${D}" comparisons are not supported for type '${le(N.type)}'.`);
              let y = l.parse(M[2], 2, Ft);
              if (!y) return null;
              if (!Lo(D, y.type)) return l.concat(2).error(`"${D}" comparisons are not supported for type '${le(y.type)}'.`);
              if (N.type.kind !== y.type.kind && N.type.kind !== "value" && y.type.kind !== "value") return l.error(`Cannot compare types '${le(N.type)}' and '${le(y.type)}'.`);
              n && (N.type.kind === "value" && y.type.kind !== "value" ? N = new As(y.type, [N]) : N.type.kind !== "value" && y.type.kind === "value" && (y = new As(N.type, [y])));
              let w = null;
              if (M.length === 4) {
                if (N.type.kind !== "string" && y.type.kind !== "string" && N.type.kind !== "value" && y.type.kind !== "value") return l.error("Cannot use collator to compare non-string types.");
                if (w = l.parse(M[3], 3, wi), !w) return null;
              }
              return new Gh(N, y, w);
            }
            evaluate(M) {
              const l = this.lhs.evaluate(M), D = this.rhs.evaluate(M);
              if (n && this.hasUntypedArgument) {
                const N = ze(l), y = ze(D);
                if (N.kind !== y.kind || N.kind !== "string" && N.kind !== "number") throw new ue(`Expected arguments for "${i}" to be (string, string) or (number, number), but found (${N.kind}, ${y.kind}) instead.`);
              }
              if (this.collator && !n && this.hasUntypedArgument) {
                const N = ze(l), y = ze(D);
                if (N.kind !== "string" || y.kind !== "string") return t(M, l, D);
              }
              return this.collator ? s(M, l, D, this.collator.evaluate(M)) : t(M, l, D);
            }
            eachChild(M) {
              M(this.lhs), M(this.rhs), this.collator && M(this.collator);
            }
            outputDefined() {
              return !0;
            }
          };
        }
        const Aa = Ks("==", (function(i, t, s) {
          return t === s;
        }), ec), Co = Ks("!=", (function(i, t, s) {
          return t !== s;
        }), (function(i, t, s, n) {
          return !ec(0, t, s, n);
        })), ml = Ks("<", (function(i, t, s) {
          return t < s;
        }), (function(i, t, s, n) {
          return n.compare(t, s) < 0;
        })), sc = Ks(">", (function(i, t, s) {
          return t > s;
        }), (function(i, t, s, n) {
          return n.compare(t, s) > 0;
        })), ma = Ks("<=", (function(i, t, s) {
          return t <= s;
        }), (function(i, t, s, n) {
          return n.compare(t, s) <= 0;
        })), ja = Ks(">=", (function(i, t, s) {
          return t >= s;
        }), (function(i, t, s, n) {
          return n.compare(t, s) >= 0;
        }));
        class ms {
          constructor(t, s, n) {
            this.type = wi, this.locale = n, this.caseSensitive = t, this.diacriticSensitive = s;
          }
          static parse(t, s) {
            if (t.length !== 2) return s.error("Expected one argument.");
            const n = t[1];
            if (typeof n != "object" || Array.isArray(n)) return s.error("Collator options argument must be an object.");
            const a = s.parse(n["case-sensitive"] !== void 0 && n["case-sensitive"], 1, kt);
            if (!a) return null;
            const M = s.parse(n["diacritic-sensitive"] !== void 0 && n["diacritic-sensitive"], 1, kt);
            if (!M) return null;
            let l = null;
            return n.locale && (l = s.parse(n.locale, 1, Ot), !l) ? null : new ms(a, M, l);
          }
          evaluate(t) {
            return new Fs(this.caseSensitive.evaluate(t), this.diacriticSensitive.evaluate(t), this.locale ? this.locale.evaluate(t) : null);
          }
          eachChild(t) {
            t(this.caseSensitive), t(this.diacriticSensitive), this.locale && t(this.locale);
          }
          outputDefined() {
            return !1;
          }
        }
        class _a {
          constructor(t, s, n, a, M) {
            this.type = Ot, this.number = t, this.locale = s, this.currency = n, this.minFractionDigits = a, this.maxFractionDigits = M;
          }
          static parse(t, s) {
            if (t.length !== 3) return s.error("Expected two arguments.");
            const n = s.parse(t[1], 1, pt);
            if (!n) return null;
            const a = t[2];
            if (typeof a != "object" || Array.isArray(a)) return s.error("NumberFormat options argument must be an object.");
            let M = null;
            if (a.locale && (M = s.parse(a.locale, 1, Ot), !M)) return null;
            let l = null;
            if (a.currency && (l = s.parse(a.currency, 1, Ot), !l)) return null;
            let D = null;
            if (a["min-fraction-digits"] && (D = s.parse(a["min-fraction-digits"], 1, pt), !D)) return null;
            let N = null;
            return a["max-fraction-digits"] && (N = s.parse(a["max-fraction-digits"], 1, pt), !N) ? null : new _a(n, M, l, D, N);
          }
          evaluate(t) {
            return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t) : [], { style: this.currency ? "currency" : "decimal", currency: this.currency ? this.currency.evaluate(t) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t) : void 0 }).format(this.number.evaluate(t));
          }
          eachChild(t) {
            t(this.number), this.locale && t(this.locale), this.currency && t(this.currency), this.minFractionDigits && t(this.minFractionDigits), this.maxFractionDigits && t(this.maxFractionDigits);
          }
          outputDefined() {
            return !1;
          }
        }
        class Nr {
          constructor(t) {
            this.type = Wr, this.sections = t;
          }
          static parse(t, s) {
            if (t.length < 2) return s.error("Expected at least one argument.");
            const n = t[1];
            if (!Array.isArray(n) && typeof n == "object") return s.error("First argument must be an image or text section.");
            const a = [];
            let M = !1;
            for (let l = 1; l <= t.length - 1; ++l) {
              const D = t[l];
              if (M && typeof D == "object" && !Array.isArray(D)) {
                M = !1;
                let N = null;
                if (D["font-scale"] && (N = s.parse(D["font-scale"], 1, pt), !N)) return null;
                let y = null;
                if (D["text-font"] && (y = s.parse(D["text-font"], 1, Es(Ot)), !y)) return null;
                let w = null;
                if (D["text-color"] && (w = s.parse(D["text-color"], 1, fs), !w)) return null;
                let T = null;
                if (D["vertical-align"]) {
                  if (typeof D["vertical-align"] == "string" && !Jt.includes(D["vertical-align"])) return s.error(`'vertical-align' must be one of: 'bottom', 'center', 'top' but found '${D["vertical-align"]}' instead.`);
                  if (T = s.parse(D["vertical-align"], 1, Ot), !T) return null;
                }
                const x = a[a.length - 1];
                x.scale = N, x.font = y, x.textColor = w, x.verticalAlign = T;
              } else {
                const N = s.parse(t[l], 1, Ft);
                if (!N) return null;
                const y = N.type.kind;
                if (y !== "string" && y !== "value" && y !== "null" && y !== "resolvedImage") return s.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                M = !0, a.push({ content: N, scale: null, font: null, textColor: null, verticalAlign: null });
              }
            }
            return new Nr(a);
          }
          evaluate(t) {
            return new Fe(this.sections.map(((s) => {
              const n = s.content.evaluate(t);
              return ze(n) === Rr ? new Zi("", n, null, null, null, s.verticalAlign ? s.verticalAlign.evaluate(t) : null) : new Zi(Hr(n), null, s.scale ? s.scale.evaluate(t) : null, s.font ? s.font.evaluate(t).join(",") : null, s.textColor ? s.textColor.evaluate(t) : null, s.verticalAlign ? s.verticalAlign.evaluate(t) : null);
            })));
          }
          eachChild(t) {
            for (const s of this.sections) t(s.content), s.scale && t(s.scale), s.font && t(s.font), s.textColor && t(s.textColor), s.verticalAlign && t(s.verticalAlign);
          }
          outputDefined() {
            return !1;
          }
        }
        class Oo {
          constructor(t) {
            this.type = Rr, this.input = t;
          }
          static parse(t, s) {
            if (t.length !== 2) return s.error("Expected two arguments.");
            const n = s.parse(t[1], 1, Ot);
            return n ? new Oo(n) : s.error("No image name provided.");
          }
          evaluate(t) {
            const s = this.input.evaluate(t), n = xs.fromString(s);
            return n && t.availableImages && (n.available = t.availableImages.indexOf(s) > -1), n;
          }
          eachChild(t) {
            t(this.input);
          }
          outputDefined() {
            return !1;
          }
        }
        class bn {
          constructor(t) {
            this.type = pt, this.input = t;
          }
          static parse(t, s) {
            if (t.length !== 2) return s.error(`Expected 1 argument, but found ${t.length - 1} instead.`);
            const n = s.parse(t[1], 1);
            return n ? n.type.kind !== "array" && n.type.kind !== "string" && n.type.kind !== "value" ? s.error(`Expected argument of type string or array, but found ${le(n.type)} instead.`) : new bn(n) : null;
          }
          evaluate(t) {
            const s = this.input.evaluate(t);
            if (typeof s == "string") return [...s].length;
            if (Array.isArray(s)) return s.length;
            throw new ue(`Expected value to be of type string or array, but found ${le(ze(s))} instead.`);
          }
          eachChild(t) {
            t(this.input);
          }
          outputDefined() {
            return !1;
          }
        }
        const Di = 8192;
        function jl(i, t) {
          const s = (180 + i[0]) / 360, n = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + i[1] * Math.PI / 360))) / 360, a = Math.pow(2, t.z);
          return [Math.round(s * a * Di), Math.round(n * a * Di)];
        }
        function Eo(i, t) {
          const s = Math.pow(2, t.z);
          return [(a = (i[0] / Di + t.x) / s, 360 * a - 180), (n = (i[1] / Di + t.y) / s, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * n) * Math.PI / 180)) - 90)];
          var n, a;
        }
        function Qn(i, t) {
          i[0] = Math.min(i[0], t[0]), i[1] = Math.min(i[1], t[1]), i[2] = Math.max(i[2], t[0]), i[3] = Math.max(i[3], t[1]);
        }
        function Hi(i, t) {
          return !(i[0] <= t[0] || i[2] >= t[2] || i[1] <= t[1] || i[3] >= t[3]);
        }
        function _l(i, t, s) {
          const n = i[0] - t[0], a = i[1] - t[1], M = i[0] - s[0], l = i[1] - s[1];
          return n * l - M * a == 0 && n * M <= 0 && a * l <= 0;
        }
        function vn(i, t, s, n) {
          return (a = [n[0] - s[0], n[1] - s[1]])[0] * (M = [t[0] - i[0], t[1] - i[1]])[1] - a[1] * M[0] != 0 && !(!ac(i, t, s, n) || !ac(s, n, i, t));
          var a, M;
        }
        function ic(i, t, s) {
          for (const n of s) for (let a = 0; a < n.length - 1; ++a) if (vn(i, t, n[a], n[a + 1])) return !0;
          return !1;
        }
        function tn(i, t, s = !1) {
          let n = !1;
          for (const D of t) for (let N = 0; N < D.length - 1; N++) {
            if (_l(i, D[N], D[N + 1])) return s;
            (M = D[N])[1] > (a = i)[1] != (l = D[N + 1])[1] > a[1] && a[0] < (l[0] - M[0]) * (a[1] - M[1]) / (l[1] - M[1]) + M[0] && (n = !n);
          }
          var a, M, l;
          return n;
        }
        function rc(i, t) {
          for (const s of t) if (tn(i, s)) return !0;
          return !1;
        }
        function nc(i, t) {
          for (const s of i) if (!tn(s, t)) return !1;
          for (let s = 0; s < i.length - 1; ++s) if (ic(i[s], i[s + 1], t)) return !1;
          return !0;
        }
        function Ll(i, t) {
          for (const s of t) if (nc(i, s)) return !0;
          return !1;
        }
        function ac(i, t, s, n) {
          const a = n[0] - s[0], M = n[1] - s[1], l = (i[0] - s[0]) * M - a * (i[1] - s[1]), D = (t[0] - s[0]) * M - a * (t[1] - s[1]);
          return l > 0 && D < 0 || l < 0 && D > 0;
        }
        function bo(i, t, s) {
          const n = [];
          for (let a = 0; a < i.length; a++) {
            const M = [];
            for (let l = 0; l < i[a].length; l++) {
              const D = jl(i[a][l], s);
              Qn(t, D), M.push(D);
            }
            n.push(M);
          }
          return n;
        }
        function oc(i, t, s) {
          const n = [];
          for (let a = 0; a < i.length; a++) {
            const M = bo(i[a], t, s);
            n.push(M);
          }
          return n;
        }
        function Qo(i, t, s, n) {
          if (i[0] < s[0] || i[0] > s[2]) {
            const a = 0.5 * n;
            let M = i[0] - s[0] > a ? -n : s[0] - i[0] > a ? n : 0;
            M === 0 && (M = i[0] - s[2] > a ? -n : s[2] - i[0] > a ? n : 0), i[0] += M;
          }
          Qn(t, i);
        }
        function vo(i, t, s, n) {
          const a = Math.pow(2, n.z) * Di, M = [n.x * Di, n.y * Di], l = [];
          for (const D of i) for (const N of D) {
            const y = [N.x + M[0], N.y + M[1]];
            Qo(y, t, s, a), l.push(y);
          }
          return l;
        }
        function Bo(i, t, s, n) {
          const a = Math.pow(2, n.z) * Di, M = [n.x * Di, n.y * Di], l = [];
          for (const N of i) {
            const y = [];
            for (const w of N) {
              const T = [w.x + M[0], w.y + M[1]];
              Qn(t, T), y.push(T);
            }
            l.push(y);
          }
          if (t[2] - t[0] <= a / 2) {
            (D = t)[0] = D[1] = 1 / 0, D[2] = D[3] = -1 / 0;
            for (const N of l) for (const y of N) Qo(y, t, s, a);
          }
          var D;
          return l;
        }
        class dr {
          constructor(t, s) {
            this.type = kt, this.geojson = t, this.geometries = s;
          }
          static parse(t, s) {
            if (t.length !== 2) return s.error(`'within' expression requires exactly one argument, but found ${t.length - 1} instead.`);
            if (Vi(t[1])) {
              const n = t[1];
              if (n.type === "FeatureCollection") {
                const a = [];
                for (const M of n.features) {
                  const { type: l, coordinates: D } = M.geometry;
                  l === "Polygon" && a.push(D), l === "MultiPolygon" && a.push(...D);
                }
                if (a.length) return new dr(n, { type: "MultiPolygon", coordinates: a });
              } else if (n.type === "Feature") {
                const a = n.geometry.type;
                if (a === "Polygon" || a === "MultiPolygon") return new dr(n, n.geometry);
              } else if (n.type === "Polygon" || n.type === "MultiPolygon") return new dr(n, n);
            }
            return s.error("'within' expression requires valid geojson object that contains polygon geometry type.");
          }
          evaluate(t) {
            if (t.geometry() != null && t.canonicalID() != null) {
              if (t.geometryType() === "Point") return (function(s, n) {
                const a = [1 / 0, 1 / 0, -1 / 0, -1 / 0], M = [1 / 0, 1 / 0, -1 / 0, -1 / 0], l = s.canonicalID();
                if (n.type === "Polygon") {
                  const D = bo(n.coordinates, M, l), N = vo(s.geometry(), a, M, l);
                  if (!Hi(a, M)) return !1;
                  for (const y of N) if (!tn(y, D)) return !1;
                }
                if (n.type === "MultiPolygon") {
                  const D = oc(n.coordinates, M, l), N = vo(s.geometry(), a, M, l);
                  if (!Hi(a, M)) return !1;
                  for (const y of N) if (!rc(y, D)) return !1;
                }
                return !0;
              })(t, this.geometries);
              if (t.geometryType() === "LineString") return (function(s, n) {
                const a = [1 / 0, 1 / 0, -1 / 0, -1 / 0], M = [1 / 0, 1 / 0, -1 / 0, -1 / 0], l = s.canonicalID();
                if (n.type === "Polygon") {
                  const D = bo(n.coordinates, M, l), N = Bo(s.geometry(), a, M, l);
                  if (!Hi(a, M)) return !1;
                  for (const y of N) if (!nc(y, D)) return !1;
                }
                if (n.type === "MultiPolygon") {
                  const D = oc(n.coordinates, M, l), N = Bo(s.geometry(), a, M, l);
                  if (!Hi(a, M)) return !1;
                  for (const y of N) if (!Ll(y, D)) return !1;
                }
                return !0;
              })(t, this.geometries);
            }
            return !1;
          }
          eachChild() {
          }
          outputDefined() {
            return !0;
          }
        }
        let Mc = class {
          constructor(i = [], t = (s, n) => s < n ? -1 : s > n ? 1 : 0) {
            if (this.data = i, this.length = this.data.length, this.compare = t, this.length > 0) for (let s = (this.length >> 1) - 1; s >= 0; s--) this._down(s);
          }
          push(i) {
            this.data.push(i), this._up(this.length++);
          }
          pop() {
            if (this.length === 0) return;
            const i = this.data[0], t = this.data.pop();
            return --this.length > 0 && (this.data[0] = t, this._down(0)), i;
          }
          peek() {
            return this.data[0];
          }
          _up(i) {
            const { data: t, compare: s } = this, n = t[i];
            for (; i > 0; ) {
              const a = i - 1 >> 1, M = t[a];
              if (s(n, M) >= 0) break;
              t[i] = M, i = a;
            }
            t[i] = n;
          }
          _down(i) {
            const { data: t, compare: s } = this, n = this.length >> 1, a = t[i];
            for (; i < n; ) {
              let M = 1 + (i << 1);
              const l = M + 1;
              if (l < this.length && s(t[l], t[M]) < 0 && (M = l), s(t[M], a) >= 0) break;
              t[i] = t[M], i = M;
            }
            t[i] = a;
          }
        };
        function cc(i, t, s = 0, n = i.length - 1, a = La) {
          for (; n > s; ) {
            if (n - s > 600) {
              const N = n - s + 1, y = t - s + 1, w = Math.log(N), T = 0.5 * Math.exp(2 * w / 3), x = 0.5 * Math.sqrt(w * T * (N - T) / N) * (y - N / 2 < 0 ? -1 : 1);
              cc(i, t, Math.max(s, Math.floor(t - y * T / N + x)), Math.min(n, Math.floor(t + (N - y) * T / N + x)), a);
            }
            const M = i[t];
            let l = s, D = n;
            for (Bn(i, s, t), a(i[n], M) > 0 && Bn(i, s, n); l < D; ) {
              for (Bn(i, l, D), l++, D--; a(i[l], M) < 0; ) l++;
              for (; a(i[D], M) > 0; ) D--;
            }
            a(i[s], M) === 0 ? Bn(i, s, D) : (D++, Bn(i, D, n)), D <= t && (s = D + 1), t <= D && (n = D - 1);
          }
        }
        function Bn(i, t, s) {
          const n = i[t];
          i[t] = i[s], i[s] = n;
        }
        function La(i, t) {
          return i < t ? -1 : i > t ? 1 : 0;
        }
        function Sn(i, t) {
          if (i.length <= 1) return [i];
          const s = [];
          let n, a;
          for (const M of i) {
            const l = Ol(M);
            l !== 0 && (M.area = Math.abs(l), a === void 0 && (a = l < 0), a === l < 0 ? (n && s.push(n), n = [M]) : n.push(M));
          }
          if (n && s.push(n), t > 1) for (let M = 0; M < s.length; M++) s[M].length <= t || (cc(s[M], t, 1, s[M].length - 1, Cl), s[M] = s[M].slice(0, t));
          return s;
        }
        function Cl(i, t) {
          return t.area - i.area;
        }
        function Ol(i) {
          let t = 0;
          for (let s, n, a = 0, M = i.length, l = M - 1; a < M; l = a++) s = i[a], n = i[l], t += (n.x - s.x) * (s.y + n.y);
          return t;
        }
        const lc = 1 / 298.257223563, Ca = lc * (2 - lc), So = Math.PI / 180;
        class ko {
          constructor(t) {
            const s = 6378.137 * So * 1e3, n = Math.cos(t * So), a = 1 / (1 - Ca * (1 - n * n)), M = Math.sqrt(a);
            this.kx = s * M * n, this.ky = s * M * a * (1 - Ca);
          }
          distance(t, s) {
            const n = this.wrap(t[0] - s[0]) * this.kx, a = (t[1] - s[1]) * this.ky;
            return Math.sqrt(n * n + a * a);
          }
          pointOnLine(t, s) {
            let n, a, M, l, D = 1 / 0;
            for (let N = 0; N < t.length - 1; N++) {
              let y = t[N][0], w = t[N][1], T = this.wrap(t[N + 1][0] - y) * this.kx, x = (t[N + 1][1] - w) * this.ky, A = 0;
              T === 0 && x === 0 || (A = (this.wrap(s[0] - y) * this.kx * T + (s[1] - w) * this.ky * x) / (T * T + x * x), A > 1 ? (y = t[N + 1][0], w = t[N + 1][1]) : A > 0 && (y += T / this.kx * A, w += x / this.ky * A)), T = this.wrap(s[0] - y) * this.kx, x = (s[1] - w) * this.ky;
              const m = T * T + x * x;
              m < D && (D = m, n = y, a = w, M = N, l = A);
            }
            return { point: [n, a], index: M, t: Math.max(0, Math.min(1, l)) };
          }
          wrap(t) {
            for (; t < -180; ) t += 360;
            for (; t > 180; ) t -= 360;
            return t;
          }
        }
        function uc(i, t) {
          return t[0] - i[0];
        }
        function kn(i) {
          return i[1] - i[0] + 1;
        }
        function zi(i, t) {
          return i[1] >= i[0] && i[1] < t;
        }
        function Fo(i, t) {
          if (i[0] > i[1]) return [null, null];
          const s = kn(i);
          if (t) {
            if (s === 2) return [i, null];
            const a = Math.floor(s / 2);
            return [[i[0], i[0] + a], [i[0] + a, i[1]]];
          }
          if (s === 1) return [i, null];
          const n = Math.floor(s / 2) - 1;
          return [[i[0], i[0] + n], [i[0] + n + 1, i[1]]];
        }
        function Yo(i, t) {
          if (!zi(t, i.length)) return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          const s = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (let n = t[0]; n <= t[1]; ++n) Qn(s, i[n]);
          return s;
        }
        function Uo(i) {
          const t = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (const s of i) for (const n of s) Qn(t, n);
          return t;
        }
        function Xo(i) {
          return i[0] !== -1 / 0 && i[1] !== -1 / 0 && i[2] !== 1 / 0 && i[3] !== 1 / 0;
        }
        function Wo(i, t, s) {
          if (!Xo(i) || !Xo(t)) return NaN;
          let n = 0, a = 0;
          return i[2] < t[0] && (n = t[0] - i[2]), i[0] > t[2] && (n = i[0] - t[2]), i[1] > t[3] && (a = i[1] - t[3]), i[3] < t[1] && (a = t[1] - i[3]), s.distance([0, 0], [n, a]);
        }
        function yr(i, t, s) {
          const n = s.pointOnLine(t, i);
          return s.distance(i, n.point);
        }
        function Po(i, t, s, n, a) {
          const M = Math.min(yr(i, [s, n], a), yr(t, [s, n], a)), l = Math.min(yr(s, [i, t], a), yr(n, [i, t], a));
          return Math.min(M, l);
        }
        function El(i, t, s, n, a) {
          if (!zi(t, i.length) || !zi(n, s.length)) return 1 / 0;
          let M = 1 / 0;
          for (let l = t[0]; l < t[1]; ++l) {
            const D = i[l], N = i[l + 1];
            for (let y = n[0]; y < n[1]; ++y) {
              const w = s[y], T = s[y + 1];
              if (vn(D, N, w, T)) return 0;
              M = Math.min(M, Po(D, N, w, T, a));
            }
          }
          return M;
        }
        function ee(i, t, s, n, a) {
          if (!zi(t, i.length) || !zi(n, s.length)) return NaN;
          let M = 1 / 0;
          for (let l = t[0]; l <= t[1]; ++l) for (let D = n[0]; D <= n[1]; ++D) if (M = Math.min(M, a.distance(i[l], s[D])), M === 0) return M;
          return M;
        }
        function bl(i, t, s) {
          if (tn(i, t, !0)) return 0;
          let n = 1 / 0;
          for (const a of t) {
            const M = a[0], l = a[a.length - 1];
            if (M !== l && (n = Math.min(n, yr(i, [l, M], s)), n === 0)) return n;
            const D = s.pointOnLine(a, i);
            if (n = Math.min(n, s.distance(i, D.point)), n === 0) return n;
          }
          return n;
        }
        function Ql(i, t, s, n) {
          if (!zi(t, i.length)) return NaN;
          for (let M = t[0]; M <= t[1]; ++M) if (tn(i[M], s, !0)) return 0;
          let a = 1 / 0;
          for (let M = t[0]; M < t[1]; ++M) {
            const l = i[M], D = i[M + 1];
            for (const N of s) for (let y = 0, w = N.length, T = w - 1; y < w; T = y++) {
              const x = N[T], A = N[y];
              if (vn(l, D, x, A)) return 0;
              a = Math.min(a, Po(l, D, x, A, n));
            }
          }
          return a;
        }
        function gc(i, t) {
          for (const s of i) for (const n of s) if (tn(n, t, !0)) return !0;
          return !1;
        }
        function vl(i, t, s, n = 1 / 0) {
          const a = Uo(i), M = Uo(t);
          if (n !== 1 / 0 && Wo(a, M, s) >= n) return n;
          if (Hi(a, M)) {
            if (gc(i, t)) return 0;
          } else if (gc(t, i)) return 0;
          let l = 1 / 0;
          for (const D of i) for (let N = 0, y = D.length, w = y - 1; N < y; w = N++) {
            const T = D[w], x = D[N];
            for (const A of t) for (let m = 0, L = A.length, O = L - 1; m < L; O = m++) {
              const B = A[O], P = A[m];
              if (vn(T, x, B, P)) return 0;
              l = Math.min(l, Po(T, x, B, P, s));
            }
          }
          return l;
        }
        function hc(i, t, s, n, a, M) {
          if (!M) return;
          const l = Wo(Yo(n, M), a, s);
          l < t && i.push([l, M, [0, 0]]);
        }
        function Oa(i, t, s, n, a, M, l) {
          if (!M || !l) return;
          const D = Wo(Yo(n, M), Yo(a, l), s);
          D < t && i.push([D, M, l]);
        }
        function Ea(i, t, s, n, a = 1 / 0) {
          let M = Math.min(n.distance(i[0], s[0][0]), a);
          if (M === 0) return M;
          const l = new Mc([[0, [0, i.length - 1], [0, 0]]], uc), D = Uo(s);
          for (; l.length > 0; ) {
            const N = l.pop();
            if (N[0] >= M) continue;
            const y = N[1], w = t ? 50 : 100;
            if (kn(y) <= w) {
              if (!zi(y, i.length)) return NaN;
              if (t) {
                const T = Ql(i, y, s, n);
                if (isNaN(T) || T === 0) return T;
                M = Math.min(M, T);
              } else for (let T = y[0]; T <= y[1]; ++T) {
                const x = bl(i[T], s, n);
                if (M = Math.min(M, x), M === 0) return 0;
              }
            } else {
              const T = Fo(y, t);
              hc(l, M, n, i, D, T[0]), hc(l, M, n, i, D, T[1]);
            }
          }
          return M;
        }
        function ba(i, t, s, n, a, M = 1 / 0) {
          let l = Math.min(M, a.distance(i[0], s[0]));
          if (l === 0) return l;
          const D = new Mc([[0, [0, i.length - 1], [0, s.length - 1]]], uc);
          for (; D.length > 0; ) {
            const N = D.pop();
            if (N[0] >= l) continue;
            const y = N[1], w = N[2], T = t ? 50 : 100, x = n ? 50 : 100;
            if (kn(y) <= T && kn(w) <= x) {
              if (!zi(y, i.length) && zi(w, s.length)) return NaN;
              let A;
              if (t && n) A = El(i, y, s, w, a), l = Math.min(l, A);
              else if (t && !n) {
                const m = i.slice(y[0], y[1] + 1);
                for (let L = w[0]; L <= w[1]; ++L) if (A = yr(s[L], m, a), l = Math.min(l, A), l === 0) return l;
              } else if (!t && n) {
                const m = s.slice(w[0], w[1] + 1);
                for (let L = y[0]; L <= y[1]; ++L) if (A = yr(i[L], m, a), l = Math.min(l, A), l === 0) return l;
              } else A = ee(i, y, s, w, a), l = Math.min(l, A);
            } else {
              const A = Fo(y, t), m = Fo(w, n);
              Oa(D, l, a, i, s, A[0], m[0]), Oa(D, l, a, i, s, A[0], m[1]), Oa(D, l, a, i, s, A[1], m[0]), Oa(D, l, a, i, s, A[1], m[1]);
            }
          }
          return l;
        }
        function Ro(i) {
          return i.type === "MultiPolygon" ? i.coordinates.map(((t) => ({ type: "Polygon", coordinates: t }))) : i.type === "MultiLineString" ? i.coordinates.map(((t) => ({ type: "LineString", coordinates: t }))) : i.type === "MultiPoint" ? i.coordinates.map(((t) => ({ type: "Point", coordinates: t }))) : [i];
        }
        class Ir {
          constructor(t, s) {
            this.type = pt, this.geojson = t, this.geometries = s;
          }
          static parse(t, s) {
            if (t.length !== 2) return s.error(`'distance' expression requires exactly one argument, but found ${t.length - 1} instead.`);
            if (Vi(t[1])) {
              const n = t[1];
              if (n.type === "FeatureCollection") return new Ir(n, n.features.map(((a) => Ro(a.geometry))).flat());
              if (n.type === "Feature") return new Ir(n, Ro(n.geometry));
              if ("type" in n && "coordinates" in n) return new Ir(n, Ro(n));
            }
            return s.error("'distance' expression requires valid geojson object that contains polygon geometry type.");
          }
          evaluate(t) {
            if (t.geometry() != null && t.canonicalID() != null) {
              if (t.geometryType() === "Point") return (function(s, n) {
                const a = s.geometry(), M = a.flat().map(((N) => Eo([N.x, N.y], s.canonical)));
                if (a.length === 0) return NaN;
                const l = new ko(M[0][1]);
                let D = 1 / 0;
                for (const N of n) {
                  switch (N.type) {
                    case "Point":
                      D = Math.min(D, ba(M, !1, [N.coordinates], !1, l, D));
                      break;
                    case "LineString":
                      D = Math.min(D, ba(M, !1, N.coordinates, !0, l, D));
                      break;
                    case "Polygon":
                      D = Math.min(D, Ea(M, !1, N.coordinates, l, D));
                  }
                  if (D === 0) return D;
                }
                return D;
              })(t, this.geometries);
              if (t.geometryType() === "LineString") return (function(s, n) {
                const a = s.geometry(), M = a.flat().map(((N) => Eo([N.x, N.y], s.canonical)));
                if (a.length === 0) return NaN;
                const l = new ko(M[0][1]);
                let D = 1 / 0;
                for (const N of n) {
                  switch (N.type) {
                    case "Point":
                      D = Math.min(D, ba(M, !0, [N.coordinates], !1, l, D));
                      break;
                    case "LineString":
                      D = Math.min(D, ba(M, !0, N.coordinates, !0, l, D));
                      break;
                    case "Polygon":
                      D = Math.min(D, Ea(M, !0, N.coordinates, l, D));
                  }
                  if (D === 0) return D;
                }
                return D;
              })(t, this.geometries);
              if (t.geometryType() === "Polygon") return (function(s, n) {
                const a = s.geometry();
                if (a.length === 0 || a[0].length === 0) return NaN;
                const M = Sn(a, 0).map(((N) => N.map(((y) => y.map(((w) => Eo([w.x, w.y], s.canonical))))))), l = new ko(M[0][0][0][1]);
                let D = 1 / 0;
                for (const N of n) for (const y of M) {
                  switch (N.type) {
                    case "Point":
                      D = Math.min(D, Ea([N.coordinates], !1, y, l, D));
                      break;
                    case "LineString":
                      D = Math.min(D, Ea(N.coordinates, !0, y, l, D));
                      break;
                    case "Polygon":
                      D = Math.min(D, vl(y, N.coordinates, l, D));
                  }
                  if (D === 0) return D;
                }
                return D;
              })(t, this.geometries);
            }
            return NaN;
          }
          eachChild() {
          }
          outputDefined() {
            return !0;
          }
        }
        class Fn {
          constructor(t) {
            this.type = Ft, this.key = t;
          }
          static parse(t, s) {
            if (t.length !== 2) return s.error(`Expected 1 argument, but found ${t.length - 1} instead.`);
            const n = t[1];
            return n == null ? s.error("Global state property must be defined.") : typeof n != "string" ? s.error(`Global state property must be string, but found ${typeof t[1]} instead.`) : new Fn(n);
          }
          evaluate(t) {
            var s;
            const n = (s = t.globals) === null || s === void 0 ? void 0 : s.globalState;
            return n && Object.keys(n).length !== 0 ? pi(n, this.key) : null;
          }
          eachChild() {
          }
          outputDefined() {
            return !1;
          }
        }
        const en = { "==": Aa, "!=": Co, ">": sc, "<": ml, ">=": ja, "<=": ma, array: As, at: qs, boolean: As, case: On, coalesce: Kr, collator: ms, format: Nr, image: Oo, in: Cn, "index-of": zr, interpolate: es, "interpolate-hcl": es, "interpolate-lab": es, length: bn, let: qt, literal: Gi, match: Ta, number: As, "number-format": _a, object: As, slice: En, step: $r, string: As, "to-boolean": gi, "to-color": gi, "to-number": gi, "to-string": gi, var: qr, within: dr, distance: Ir, "global-state": Fn };
        class Ys {
          constructor(t, s, n, a) {
            this.name = t, this.type = s, this._evaluate = n, this.args = a;
          }
          evaluate(t) {
            return this._evaluate(t, this.args);
          }
          eachChild(t) {
            this.args.forEach(t);
          }
          outputDefined() {
            return !1;
          }
          static parse(t, s) {
            const n = t[0], a = Ys.definitions[n];
            if (!a) return s.error(`Unknown expression "${n}". If you wanted a literal array, use ["literal", [...]].`, 0);
            const M = Array.isArray(a) ? a[0] : a.type, l = Array.isArray(a) ? [[a[1], a[2]]] : a.overloads, D = l.filter((([y]) => !Array.isArray(y) || y.length === t.length - 1));
            let N = null;
            for (const [y, w] of D) {
              N = new Jr(s.registry, Qa, s.path, null, s.scope);
              const T = [];
              let x = !1;
              for (let A = 1; A < t.length; A++) {
                const m = t[A], L = Array.isArray(y) ? y[A - 1] : y.type, O = N.parse(m, 1 + T.length, L);
                if (!O) {
                  x = !0;
                  break;
                }
                T.push(O);
              }
              if (!x) if (Array.isArray(y) && y.length !== T.length) N.error(`Expected ${y.length} arguments, but found ${T.length} instead.`);
              else {
                for (let A = 0; A < T.length; A++) {
                  const m = Array.isArray(y) ? y[A] : y.type, L = T[A];
                  N.concat(A + 1).checkSubtype(m, L.type);
                }
                if (N.errors.length === 0) return new Ys(n, M, w, T);
              }
            }
            if (D.length === 1) s.errors.push(...N.errors);
            else {
              const y = (D.length ? D : l).map((([T]) => {
                return x = T, Array.isArray(x) ? `(${x.map(le).join(", ")})` : `(${le(x.type)}...)`;
                var x;
              })).join(" | "), w = [];
              for (let T = 1; T < t.length; T++) {
                const x = s.parse(t[T], 1 + w.length);
                if (!x) return null;
                w.push(le(x.type));
              }
              s.error(`Expected arguments of type ${y}, but found (${w.join(", ")}) instead.`);
            }
            return null;
          }
          static register(t, s) {
            Ys.definitions = s;
            for (const n in s) t[n] = Ys;
          }
        }
        function Dc(i, [t, s, n, a]) {
          t = t.evaluate(i), s = s.evaluate(i), n = n.evaluate(i);
          const M = a ? a.evaluate(i) : 1, l = $M(t, s, n, M);
          if (l) throw new ue(l);
          return new Vt(t / 255, s / 255, n / 255, M, !1);
        }
        function zc(i, t) {
          return i in t;
        }
        function Zo(i, t) {
          const s = t[i];
          return s === void 0 ? null : s;
        }
        function wr(i) {
          return { type: i };
        }
        function Qa(i) {
          if (i instanceof qr) return Qa(i.boundExpression);
          if (i instanceof Ys && i.name === "error" || i instanceof ms || i instanceof dr || i instanceof Ir || i instanceof Fn) return !1;
          const t = i instanceof gi || i instanceof As;
          let s = !0;
          return i.eachChild(((n) => {
            s = t ? s && Qa(n) : s && n instanceof Gi;
          })), !!s && va(i) && Ba(i, ["zoom", "heatmap-density", "elevation", "line-progress", "accumulated", "is-supported-script"]);
        }
        function va(i) {
          if (i instanceof Ys && (i.name === "get" && i.args.length === 1 || i.name === "feature-state" || i.name === "has" && i.args.length === 1 || i.name === "properties" || i.name === "geometry-type" || i.name === "id" || /^filter-/.test(i.name)) || i instanceof dr || i instanceof Ir) return !1;
          let t = !0;
          return i.eachChild(((s) => {
            t && !va(s) && (t = !1);
          })), t;
        }
        function Yn(i) {
          if (i instanceof Ys && i.name === "feature-state") return !1;
          let t = !0;
          return i.eachChild(((s) => {
            t && !Yn(s) && (t = !1);
          })), t;
        }
        function Ba(i, t) {
          if (i instanceof Ys && t.indexOf(i.name) >= 0) return !1;
          let s = !0;
          return i.eachChild(((n) => {
            s && !Ba(n, t) && (s = !1);
          })), s;
        }
        function Nc(i) {
          return { result: "success", value: i };
        }
        function sn(i) {
          return { result: "error", value: i };
        }
        function rn(i) {
          return i["property-type"] === "data-driven" || i["property-type"] === "cross-faded-data-driven";
        }
        function dc(i) {
          return !!i.expression && i.expression.parameters.indexOf("zoom") > -1;
        }
        function Vo(i) {
          return !!i.expression && i.expression.interpolated;
        }
        function Gt(i) {
          return i instanceof Number ? "number" : i instanceof String ? "string" : i instanceof Boolean ? "boolean" : Array.isArray(i) ? "array" : i === null ? "null" : typeof i;
        }
        function Sa(i) {
          return typeof i == "object" && i !== null && !Array.isArray(i) && ze(i) === Ve;
        }
        function Bl(i) {
          return i;
        }
        function yc(i, t) {
          const s = i.stops && typeof i.stops[0][0] == "object", n = s || !(s || i.property !== void 0), a = i.type || (Vo(t) ? "exponential" : "interval"), M = (function(w) {
            switch (w.type) {
              case "color":
                return Vt.parse;
              case "padding":
                return ns.parse;
              case "numberArray":
                return as.parse;
              case "colorArray":
                return Re.parse;
              default:
                return null;
            }
          })(t);
          if (M && ((i = De({}, i)).stops && (i.stops = i.stops.map(((w) => [w[0], M(w[1])]))), i.default = M(i.default ? i.default : t.default)), i.colorSpace && (l = i.colorSpace) !== "rgb" && l !== "hcl" && l !== "lab") throw new Error(`Unknown color space: "${i.colorSpace}"`);
          var l;
          const D = (function(w) {
            switch (w) {
              case "exponential":
                return Ic;
              case "interval":
                return Sl;
              case "categorical":
                return Go;
              case "identity":
                return kl;
              default:
                throw new Error(`Unknown function type "${w}"`);
            }
          })(a);
          let N, y;
          if (a === "categorical") {
            N = /* @__PURE__ */ Object.create(null);
            for (const w of i.stops) N[w[0]] = w[1];
            y = typeof i.stops[0][0];
          }
          if (s) {
            const w = {}, T = [];
            for (let m = 0; m < i.stops.length; m++) {
              const L = i.stops[m], O = L[0].zoom;
              w[O] === void 0 && (w[O] = { zoom: O, type: i.type, property: i.property, default: i.default, stops: [] }, T.push(O)), w[O].stops.push([L[0].value, L[1]]);
            }
            const x = [];
            for (const m of T) x.push([w[m].zoom, yc(w[m], t)]);
            const A = { name: "linear" };
            return { kind: "composite", interpolationType: A, interpolationFactor: es.interpolationFactor.bind(void 0, A), zoomStops: x.map(((m) => m[0])), evaluate: ({ zoom: m }, L) => Ic({ stops: x, base: i.base }, t, m).evaluate(m, L) };
          }
          if (n) {
            const w = a === "exponential" ? { name: "exponential", base: i.base !== void 0 ? i.base : 1 } : null;
            return { kind: "camera", interpolationType: w, interpolationFactor: es.interpolationFactor.bind(void 0, w), zoomStops: i.stops.map(((T) => T[0])), evaluate: ({ zoom: T }) => D(i, t, T, N, y) };
          }
          return { kind: "source", evaluate(w, T) {
            const x = T && T.properties ? T.properties[i.property] : void 0;
            return x === void 0 ? Un(i.default, t.default) : D(i, t, x, N, y);
          } };
        }
        function Un(i, t, s) {
          return i !== void 0 ? i : t !== void 0 ? t : s !== void 0 ? s : void 0;
        }
        function Go(i, t, s, n, a) {
          return Un(typeof s === a ? n[s] : void 0, i.default, t.default);
        }
        function Sl(i, t, s) {
          if (Gt(s) !== "number") return Un(i.default, t.default);
          const n = i.stops.length;
          if (n === 1 || s <= i.stops[0][0]) return i.stops[0][1];
          if (s >= i.stops[n - 1][0]) return i.stops[n - 1][1];
          const a = fa(i.stops.map(((M) => M[0])), s);
          return i.stops[a][1];
        }
        function Ic(i, t, s) {
          const n = i.base !== void 0 ? i.base : 1;
          if (Gt(s) !== "number") return Un(i.default, t.default);
          const a = i.stops.length;
          if (a === 1 || s <= i.stops[0][0]) return i.stops[0][1];
          if (s >= i.stops[a - 1][0]) return i.stops[a - 1][1];
          const M = fa(i.stops.map(((w) => w[0])), s), l = (function(w, T, x, A) {
            const m = A - x, L = w - x;
            return m === 0 ? 0 : T === 1 ? L / m : (Math.pow(T, L) - 1) / (Math.pow(T, m) - 1);
          })(s, n, i.stops[M][0], i.stops[M + 1][0]), D = i.stops[M][1], N = i.stops[M + 1][1], y = $s[t.type] || Bl;
          return typeof D.evaluate == "function" ? { evaluate(...w) {
            const T = D.evaluate.apply(void 0, w), x = N.evaluate.apply(void 0, w);
            if (T !== void 0 && x !== void 0) return y(T, x, l, i.colorSpace);
          } } : y(D, N, l, i.colorSpace);
        }
        function kl(i, t, s) {
          switch (t.type) {
            case "color":
              s = Vt.parse(s);
              break;
            case "formatted":
              s = Fe.fromString(s.toString());
              break;
            case "resolvedImage":
              s = xs.fromString(s.toString());
              break;
            case "padding":
              s = ns.parse(s);
              break;
            case "colorArray":
              s = Re.parse(s);
              break;
            case "numberArray":
              s = as.parse(s);
              break;
            default:
              Gt(s) === t.type || t.type === "enum" && t.values[s] || (s = void 0);
          }
          return Un(s, i.default, t.default);
        }
        Ys.register(en, { error: [{ kind: "error" }, [Ot], (i, [t]) => {
          throw new ue(t.evaluate(i));
        }], typeof: [Ot, [Ft], (i, [t]) => le(ze(t.evaluate(i)))], "to-rgba": [Es(pt, 4), [fs], (i, [t]) => {
          const [s, n, a, M] = t.evaluate(i).rgb;
          return [255 * s, 255 * n, 255 * a, M];
        }], rgb: [fs, [pt, pt, pt], Dc], rgba: [fs, [pt, pt, pt, pt], Dc], has: { type: kt, overloads: [[[Ot], (i, [t]) => zc(t.evaluate(i), i.properties())], [[Ot, Ve], (i, [t, s]) => zc(t.evaluate(i), s.evaluate(i))]] }, get: { type: Ft, overloads: [[[Ot], (i, [t]) => Zo(t.evaluate(i), i.properties())], [[Ot, Ve], (i, [t, s]) => Zo(t.evaluate(i), s.evaluate(i))]] }, "feature-state": [Ft, [Ot], (i, [t]) => Zo(t.evaluate(i), i.featureState || {})], properties: [Ve, [], (i) => i.properties()], "geometry-type": [Ot, [], (i) => i.geometryType()], id: [Ft, [], (i) => i.id()], zoom: [pt, [], (i) => i.globals.zoom], "heatmap-density": [pt, [], (i) => i.globals.heatmapDensity || 0], elevation: [pt, [], (i) => i.globals.elevation || 0], "line-progress": [pt, [], (i) => i.globals.lineProgress || 0], accumulated: [Ft, [], (i) => i.globals.accumulated === void 0 ? null : i.globals.accumulated], "+": [pt, wr(pt), (i, t) => {
          let s = 0;
          for (const n of t) s += n.evaluate(i);
          return s;
        }], "*": [pt, wr(pt), (i, t) => {
          let s = 1;
          for (const n of t) s *= n.evaluate(i);
          return s;
        }], "-": { type: pt, overloads: [[[pt, pt], (i, [t, s]) => t.evaluate(i) - s.evaluate(i)], [[pt], (i, [t]) => -t.evaluate(i)]] }, "/": [pt, [pt, pt], (i, [t, s]) => t.evaluate(i) / s.evaluate(i)], "%": [pt, [pt, pt], (i, [t, s]) => t.evaluate(i) % s.evaluate(i)], ln2: [pt, [], () => Math.LN2], pi: [pt, [], () => Math.PI], e: [pt, [], () => Math.E], "^": [pt, [pt, pt], (i, [t, s]) => Math.pow(t.evaluate(i), s.evaluate(i))], sqrt: [pt, [pt], (i, [t]) => Math.sqrt(t.evaluate(i))], log10: [pt, [pt], (i, [t]) => Math.log(t.evaluate(i)) / Math.LN10], ln: [pt, [pt], (i, [t]) => Math.log(t.evaluate(i))], log2: [pt, [pt], (i, [t]) => Math.log(t.evaluate(i)) / Math.LN2], sin: [pt, [pt], (i, [t]) => Math.sin(t.evaluate(i))], cos: [pt, [pt], (i, [t]) => Math.cos(t.evaluate(i))], tan: [pt, [pt], (i, [t]) => Math.tan(t.evaluate(i))], asin: [pt, [pt], (i, [t]) => Math.asin(t.evaluate(i))], acos: [pt, [pt], (i, [t]) => Math.acos(t.evaluate(i))], atan: [pt, [pt], (i, [t]) => Math.atan(t.evaluate(i))], min: [pt, wr(pt), (i, t) => Math.min(...t.map(((s) => s.evaluate(i))))], max: [pt, wr(pt), (i, t) => Math.max(...t.map(((s) => s.evaluate(i))))], abs: [pt, [pt], (i, [t]) => Math.abs(t.evaluate(i))], round: [pt, [pt], (i, [t]) => {
          const s = t.evaluate(i);
          return s < 0 ? -Math.round(-s) : Math.round(s);
        }], floor: [pt, [pt], (i, [t]) => Math.floor(t.evaluate(i))], ceil: [pt, [pt], (i, [t]) => Math.ceil(t.evaluate(i))], "filter-==": [kt, [Ot, Ft], (i, [t, s]) => i.properties()[t.value] === s.value], "filter-id-==": [kt, [Ft], (i, [t]) => i.id() === t.value], "filter-type-==": [kt, [Ot], (i, [t]) => i.geometryType() === t.value], "filter-<": [kt, [Ot, Ft], (i, [t, s]) => {
          const n = i.properties()[t.value], a = s.value;
          return typeof n == typeof a && n < a;
        }], "filter-id-<": [kt, [Ft], (i, [t]) => {
          const s = i.id(), n = t.value;
          return typeof s == typeof n && s < n;
        }], "filter->": [kt, [Ot, Ft], (i, [t, s]) => {
          const n = i.properties()[t.value], a = s.value;
          return typeof n == typeof a && n > a;
        }], "filter-id->": [kt, [Ft], (i, [t]) => {
          const s = i.id(), n = t.value;
          return typeof s == typeof n && s > n;
        }], "filter-<=": [kt, [Ot, Ft], (i, [t, s]) => {
          const n = i.properties()[t.value], a = s.value;
          return typeof n == typeof a && n <= a;
        }], "filter-id-<=": [kt, [Ft], (i, [t]) => {
          const s = i.id(), n = t.value;
          return typeof s == typeof n && s <= n;
        }], "filter->=": [kt, [Ot, Ft], (i, [t, s]) => {
          const n = i.properties()[t.value], a = s.value;
          return typeof n == typeof a && n >= a;
        }], "filter-id->=": [kt, [Ft], (i, [t]) => {
          const s = i.id(), n = t.value;
          return typeof s == typeof n && s >= n;
        }], "filter-has": [kt, [Ft], (i, [t]) => t.value in i.properties()], "filter-has-id": [kt, [], (i) => i.id() !== null && i.id() !== void 0], "filter-type-in": [kt, [Es(Ot)], (i, [t]) => t.value.indexOf(i.geometryType()) >= 0], "filter-id-in": [kt, [Es(Ft)], (i, [t]) => t.value.indexOf(i.id()) >= 0], "filter-in-small": [kt, [Ot, Es(Ft)], (i, [t, s]) => s.value.indexOf(i.properties()[t.value]) >= 0], "filter-in-large": [kt, [Ot, Es(Ft)], (i, [t, s]) => (function(n, a, M, l) {
          for (; M <= l; ) {
            const D = M + l >> 1;
            if (a[D] === n) return !0;
            a[D] > n ? l = D - 1 : M = D + 1;
          }
          return !1;
        })(i.properties()[t.value], s.value, 0, s.value.length - 1)], all: { type: kt, overloads: [[[kt, kt], (i, [t, s]) => t.evaluate(i) && s.evaluate(i)], [wr(kt), (i, t) => {
          for (const s of t) if (!s.evaluate(i)) return !1;
          return !0;
        }]] }, any: { type: kt, overloads: [[[kt, kt], (i, [t, s]) => t.evaluate(i) || s.evaluate(i)], [wr(kt), (i, t) => {
          for (const s of t) if (s.evaluate(i)) return !0;
          return !1;
        }]] }, "!": [kt, [kt], (i, [t]) => !t.evaluate(i)], "is-supported-script": [kt, [Ot], (i, [t]) => {
          const s = i.globals && i.globals.isSupportedScript;
          return !s || s(t.evaluate(i));
        }], upcase: [Ot, [Ot], (i, [t]) => t.evaluate(i).toUpperCase()], downcase: [Ot, [Ot], (i, [t]) => t.evaluate(i).toLowerCase()], concat: [Ot, wr(Ft), (i, t) => t.map(((s) => Hr(s.evaluate(i)))).join("")], "resolved-locale": [Ot, [wi], (i, [t]) => t.evaluate(i).resolvedLocale()] });
        class ka {
          constructor(t, s, n) {
            this.expression = t, this._warningHistory = {}, this._evaluator = new Pt(), this._defaultValue = s ? (function(a) {
              if (a.type === "color" && Sa(a.default)) return new Vt(0, 0, 0, 0);
              switch (a.type) {
                case "color":
                  return Vt.parse(a.default) || null;
                case "padding":
                  return ns.parse(a.default) || null;
                case "numberArray":
                  return as.parse(a.default) || null;
                case "colorArray":
                  return Re.parse(a.default) || null;
                case "variableAnchorOffsetCollection":
                  return zs.parse(a.default) || null;
                case "projectionDefinition":
                  return os.parse(a.default) || null;
                default:
                  return a.default === void 0 ? null : a.default;
              }
            })(s) : null, this._enumValues = s && s.type === "enum" ? s.values : null, this._globalState = n;
          }
          evaluateWithoutErrorHandling(t, s, n, a, M, l) {
            return this._globalState && (t = nn(t, this._globalState)), this._evaluator.globals = t, this._evaluator.feature = s, this._evaluator.featureState = n, this._evaluator.canonical = a, this._evaluator.availableImages = M || null, this._evaluator.formattedSection = l, this.expression.evaluate(this._evaluator);
          }
          evaluate(t, s, n, a, M, l) {
            this._globalState && (t = nn(t, this._globalState)), this._evaluator.globals = t, this._evaluator.feature = s || null, this._evaluator.featureState = n || null, this._evaluator.canonical = a, this._evaluator.availableImages = M || null, this._evaluator.formattedSection = l || null;
            try {
              const D = this.expression.evaluate(this._evaluator);
              if (D == null || typeof D == "number" && D != D) return this._defaultValue;
              if (this._enumValues && !(D in this._enumValues)) throw new ue(`Expected value to be one of ${Object.keys(this._enumValues).map(((N) => JSON.stringify(N))).join(", ")}, but found ${JSON.stringify(D)} instead.`);
              return D;
            } catch (D) {
              return this._warningHistory[D.message] || (this._warningHistory[D.message] = !0, typeof console < "u" && console.warn(D.message)), this._defaultValue;
            }
          }
        }
        function Fa(i) {
          return Array.isArray(i) && i.length > 0 && typeof i[0] == "string" && i[0] in en;
        }
        function Ya(i, t, s) {
          const n = new Jr(en, Qa, [], t ? (function(M) {
            const l = { color: fs, string: Ot, number: pt, enum: Ot, boolean: kt, formatted: Wr, padding: Pr, numberArray: hr, colorArray: Js, projectionDefinition: gr, resolvedImage: Rr, variableAnchorOffsetCollection: Zr };
            return M.type === "array" ? Es(l[M.value] || Ft, M.length) : l[M.type];
          })(t) : void 0), a = n.parse(i, void 0, void 0, void 0, t && t.type === "string" ? { typeAnnotation: "coerce" } : void 0);
          return a ? Nc(new ka(a, t, s)) : sn(n.errors);
        }
        class pr {
          constructor(t, s, n) {
            this.kind = t, this._styleExpression = s, this.isStateDependent = t !== "constant" && !Yn(s.expression), this.globalStateRefs = Pa(s.expression), this._globalState = n;
          }
          evaluateWithoutErrorHandling(t, s, n, a, M, l) {
            return this._globalState && (t = nn(t, this._globalState)), this._styleExpression.evaluateWithoutErrorHandling(t, s, n, a, M, l);
          }
          evaluate(t, s, n, a, M, l) {
            return this._globalState && (t = nn(t, this._globalState)), this._styleExpression.evaluate(t, s, n, a, M, l);
          }
        }
        class Ua {
          constructor(t, s, n, a, M) {
            this.kind = t, this.zoomStops = n, this._styleExpression = s, this.isStateDependent = t !== "camera" && !Yn(s.expression), this.globalStateRefs = Pa(s.expression), this.interpolationType = a, this._globalState = M;
          }
          evaluateWithoutErrorHandling(t, s, n, a, M, l) {
            return this._globalState && (t = nn(t, this._globalState)), this._styleExpression.evaluateWithoutErrorHandling(t, s, n, a, M, l);
          }
          evaluate(t, s, n, a, M, l) {
            return this._globalState && (t = nn(t, this._globalState)), this._styleExpression.evaluate(t, s, n, a, M, l);
          }
          interpolationFactor(t, s, n) {
            return this.interpolationType ? es.interpolationFactor(this.interpolationType, t, s, n) : 0;
          }
        }
        function wc(i, t, s) {
          const n = Ya(i, t, s);
          if (n.result === "error") return n;
          const a = n.value.expression, M = va(a);
          if (!M && !rn(t)) return sn([new Me("", "data expressions not supported")]);
          const l = Ba(a, ["zoom"]);
          if (!l && !dc(t)) return sn([new Me("", "zoom expressions not supported")]);
          const D = Wa(a);
          return D || l ? D instanceof Me ? sn([D]) : D instanceof es && !Vo(t) ? sn([new Me("", '"interpolate" expressions cannot be used with this property')]) : Nc(D ? new Ua(M ? "camera" : "composite", n.value, D.labels, D instanceof es ? D.interpolation : void 0, s) : new pr(M ? "constant" : "source", n.value, s)) : sn([new Me("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
        }
        class Xa {
          constructor(t, s) {
            this._parameters = t, this._specification = s, De(this, yc(this._parameters, this._specification));
          }
          static deserialize(t) {
            return new Xa(t._parameters, t._specification);
          }
          static serialize(t) {
            return { _parameters: t._parameters, _specification: t._specification };
          }
        }
        function Wa(i) {
          let t = null;
          if (i instanceof qt) t = Wa(i.result);
          else if (i instanceof Kr) {
            for (const s of i.args) if (t = Wa(s), t) break;
          } else (i instanceof $r || i instanceof es) && i.input instanceof Ys && i.input.name === "zoom" && (t = i);
          return t instanceof Me || i.eachChild(((s) => {
            const n = Wa(s);
            n instanceof Me ? t = n : !t && n ? t = new Me("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : t && n && t !== n && (t = new Me("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
          })), t;
        }
        function Pa(i, t = /* @__PURE__ */ new Set()) {
          return i instanceof Fn && t.add(i.key), i.eachChild(((s) => {
            Pa(s, t);
          })), t;
        }
        function nn(i, t) {
          const { zoom: s, heatmapDensity: n, elevation: a, lineProgress: M, isSupportedScript: l, accumulated: D } = i ?? {};
          return { zoom: s, heatmapDensity: n, elevation: a, lineProgress: M, isSupportedScript: l, accumulated: D, globalState: t };
        }
        function Ra(i) {
          if (i === !0 || i === !1) return !0;
          if (!Array.isArray(i) || i.length === 0) return !1;
          switch (i[0]) {
            case "has":
              return i.length >= 2 && i[1] !== "$id" && i[1] !== "$type";
            case "in":
              return i.length >= 3 && (typeof i[1] != "string" || Array.isArray(i[2]));
            case "!in":
            case "!has":
            case "none":
              return !1;
            case "==":
            case "!=":
            case ">":
            case ">=":
            case "<":
            case "<=":
              return i.length !== 3 || Array.isArray(i[1]) || Array.isArray(i[2]);
            case "any":
            case "all":
              for (const t of i.slice(1)) if (!Ra(t) && typeof t != "boolean") return !1;
              return !0;
            default:
              return !0;
          }
        }
        const pc = { type: "boolean", default: !1, transition: !1, "property-type": "data-driven", expression: { interpolated: !1, parameters: ["zoom", "feature"] } };
        function Xn(i, t) {
          if (i == null) return { filter: () => !0, needGeometry: !1, getGlobalStateRefs: () => /* @__PURE__ */ new Set() };
          Ra(i) || (i = Wn(i));
          const s = Ya(i, pc, t);
          if (s.result === "error") throw new Error(s.value.map(((n) => `${n.key}: ${n.message}`)).join(", "));
          return { filter: (n, a, M) => s.value.evaluate(n, a, {}, M), needGeometry: Ho(i), getGlobalStateRefs: () => Pa(s.value.expression) };
        }
        function Fl(i, t) {
          return i < t ? -1 : i > t ? 1 : 0;
        }
        function Ho(i) {
          if (!Array.isArray(i)) return !1;
          if (i[0] === "within" || i[0] === "distance") return !0;
          for (let t = 1; t < i.length; t++) if (Ho(i[t])) return !0;
          return !1;
        }
        function Wn(i) {
          if (!i) return !0;
          const t = i[0];
          return i.length <= 1 ? t !== "any" : t === "==" ? Za(i[1], i[2], "==") : t === "!=" ? Va(Za(i[1], i[2], "==")) : t === "<" || t === ">" || t === "<=" || t === ">=" ? Za(i[1], i[2], t) : t === "any" ? (s = i.slice(1), ["any"].concat(s.map(Wn))) : t === "all" ? ["all"].concat(i.slice(1).map(Wn)) : t === "none" ? ["all"].concat(i.slice(1).map(Wn).map(Va)) : t === "in" ? Tc(i[1], i.slice(2)) : t === "!in" ? Va(Tc(i[1], i.slice(2))) : t === "has" ? fc(i[1]) : t !== "!has" || Va(fc(i[1]));
          var s;
        }
        function Za(i, t, s) {
          switch (i) {
            case "$type":
              return [`filter-type-${s}`, t];
            case "$id":
              return [`filter-id-${s}`, t];
            default:
              return [`filter-${s}`, i, t];
          }
        }
        function Tc(i, t) {
          if (t.length === 0) return !1;
          switch (i) {
            case "$type":
              return ["filter-type-in", ["literal", t]];
            case "$id":
              return ["filter-id-in", ["literal", t]];
            default:
              return t.length > 200 && !t.some(((s) => typeof s != typeof t[0])) ? ["filter-in-large", i, ["literal", t.sort(Fl)]] : ["filter-in-small", i, ["literal", t]];
          }
        }
        function fc(i) {
          switch (i) {
            case "$type":
              return !0;
            case "$id":
              return ["filter-has-id"];
            default:
              return ["filter-has", i];
          }
        }
        function Va(i) {
          return ["!", i];
        }
        function Jo(i) {
          const t = typeof i;
          if (t === "number" || t === "boolean" || t === "string" || i == null) return JSON.stringify(i);
          if (Array.isArray(i)) {
            let a = "[";
            for (const M of i) a += `${Jo(M)},`;
            return `${a}]`;
          }
          const s = Object.keys(i).sort();
          let n = "{";
          for (let a = 0; a < s.length; a++) n += `${JSON.stringify(s[a])}:${Jo(i[s[a]])},`;
          return `${n}}`;
        }
        function xc(i) {
          let t = "";
          for (const s of it) t += `/${Jo(i[s])}`;
          return t;
        }
        function qo(i) {
          const t = i.value;
          return t ? [new It(i.key, t, "constants have been deprecated as of v8")] : [];
        }
        function fe(i) {
          return i instanceof Number || i instanceof String || i instanceof Boolean ? i.valueOf() : i;
        }
        function Ti(i) {
          if (Array.isArray(i)) return i.map(Ti);
          if (i instanceof Object && !(i instanceof Number || i instanceof String || i instanceof Boolean)) {
            const t = {};
            for (const s in i) t[s] = Ti(i[s]);
            return t;
          }
          return fe(i);
        }
        function js(i) {
          const t = i.key, s = i.value, n = i.valueSpec || {}, a = i.objectElementValidators || {}, M = i.style, l = i.styleSpec, D = i.validateSpec;
          let N = [];
          const y = Gt(s);
          if (y !== "object") return [new It(t, s, `object expected, ${y} found`)];
          for (const w in s) {
            const T = w.split(".")[0], x = pi(n, T) || n["*"];
            let A;
            if (pi(a, T)) A = a[T];
            else if (pi(n, T)) A = D;
            else if (a["*"]) A = a["*"];
            else {
              if (!n["*"]) {
                N.push(new It(t, s[w], `unknown property "${w}"`));
                continue;
              }
              A = D;
            }
            N = N.concat(A({ key: (t && `${t}.`) + w, value: s[w], valueSpec: x, style: M, styleSpec: l, object: s, objectKey: w, validateSpec: D }, s));
          }
          for (const w in n) a[w] || n[w].required && n[w].default === void 0 && s[w] === void 0 && N.push(new It(t, s, `missing required property "${w}"`));
          return N;
        }
        function Pn(i) {
          const t = i.value, s = i.valueSpec, n = i.style, a = i.styleSpec, M = i.key, l = i.arrayElementValidator || i.validateSpec;
          if (Gt(t) !== "array") return [new It(M, t, `array expected, ${Gt(t)} found`)];
          if (s.length && t.length !== s.length) return [new It(M, t, `array length ${s.length} expected, length ${t.length} found`)];
          if (s["min-length"] && t.length < s["min-length"]) return [new It(M, t, `array length at least ${s["min-length"]} expected, length ${t.length} found`)];
          let D = { type: s.value, values: s.values };
          a.$version < 7 && (D.function = s.function), Gt(s.value) === "object" && (D = s.value);
          let N = [];
          for (let y = 0; y < t.length; y++) N = N.concat(l({ array: t, arrayIndex: y, value: t[y], valueSpec: D, validateSpec: i.validateSpec, style: n, styleSpec: a, key: `${M}[${y}]` }));
          return N;
        }
        function Tr(i) {
          const t = i.key, s = i.value, n = i.valueSpec;
          let a = Gt(s);
          return a === "number" && s != s && (a = "NaN"), a !== "number" ? [new It(t, s, `number expected, ${a} found`)] : "minimum" in n && s < n.minimum ? [new It(t, s, `${s} is less than the minimum value ${n.minimum}`)] : "maximum" in n && s > n.maximum ? [new It(t, s, `${s} is greater than the maximum value ${n.maximum}`)] : [];
        }
        function Ac(i) {
          const t = i.valueSpec, s = fe(i.value.type);
          let n, a, M, l = {};
          const D = s !== "categorical" && i.value.property === void 0, N = !D, y = Gt(i.value.stops) === "array" && Gt(i.value.stops[0]) === "array" && Gt(i.value.stops[0][0]) === "object", w = js({ key: i.key, value: i.value, valueSpec: i.styleSpec.function, validateSpec: i.validateSpec, style: i.style, styleSpec: i.styleSpec, objectElementValidators: { stops: function(A) {
            if (s === "identity") return [new It(A.key, A.value, 'identity function may not have a "stops" property')];
            let m = [];
            const L = A.value;
            return m = m.concat(Pn({ key: A.key, value: L, valueSpec: A.valueSpec, validateSpec: A.validateSpec, style: A.style, styleSpec: A.styleSpec, arrayElementValidator: T })), Gt(L) === "array" && L.length === 0 && m.push(new It(A.key, L, "array must have at least one stop")), m;
          }, default: function(A) {
            return A.validateSpec({ key: A.key, value: A.value, valueSpec: t, validateSpec: A.validateSpec, style: A.style, styleSpec: A.styleSpec });
          } } });
          return s === "identity" && D && w.push(new It(i.key, i.value, 'missing required property "property"')), s === "identity" || i.value.stops || w.push(new It(i.key, i.value, 'missing required property "stops"')), s === "exponential" && i.valueSpec.expression && !Vo(i.valueSpec) && w.push(new It(i.key, i.value, "exponential functions not supported")), i.styleSpec.$version >= 8 && (N && !rn(i.valueSpec) ? w.push(new It(i.key, i.value, "property functions not supported")) : D && !dc(i.valueSpec) && w.push(new It(i.key, i.value, "zoom functions not supported"))), s !== "categorical" && !y || i.value.property !== void 0 || w.push(new It(i.key, i.value, '"property" property is required')), w;
          function T(A) {
            let m = [];
            const L = A.value, O = A.key;
            if (Gt(L) !== "array") return [new It(O, L, `array expected, ${Gt(L)} found`)];
            if (L.length !== 2) return [new It(O, L, `array length 2 expected, length ${L.length} found`)];
            if (y) {
              if (Gt(L[0]) !== "object") return [new It(O, L, `object expected, ${Gt(L[0])} found`)];
              if (L[0].zoom === void 0) return [new It(O, L, "object stop key must have zoom")];
              if (L[0].value === void 0) return [new It(O, L, "object stop key must have value")];
              if (M && M > fe(L[0].zoom)) return [new It(O, L[0].zoom, "stop zoom values must appear in ascending order")];
              fe(L[0].zoom) !== M && (M = fe(L[0].zoom), a = void 0, l = {}), m = m.concat(js({ key: `${O}[0]`, value: L[0], valueSpec: { zoom: {} }, validateSpec: A.validateSpec, style: A.style, styleSpec: A.styleSpec, objectElementValidators: { zoom: Tr, value: x } }));
            } else m = m.concat(x({ key: `${O}[0]`, value: L[0], validateSpec: A.validateSpec, style: A.style, styleSpec: A.styleSpec }, L));
            return Fa(Ti(L[1])) ? m.concat([new It(`${O}[1]`, L[1], "expressions are not allowed in function stops.")]) : m.concat(A.validateSpec({ key: `${O}[1]`, value: L[1], valueSpec: t, validateSpec: A.validateSpec, style: A.style, styleSpec: A.styleSpec }));
          }
          function x(A, m) {
            const L = Gt(A.value), O = fe(A.value), B = A.value !== null ? A.value : m;
            if (n) {
              if (L !== n) return [new It(A.key, B, `${L} stop domain type must match previous stop domain type ${n}`)];
            } else n = L;
            if (L !== "number" && L !== "string" && L !== "boolean") return [new It(A.key, B, "stop domain value must be a number, string, or boolean")];
            if (L !== "number" && s !== "categorical") {
              let P = `number expected, ${L} found`;
              return rn(t) && s === void 0 && (P += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new It(A.key, B, P)];
            }
            return s !== "categorical" || L !== "number" || isFinite(O) && Math.floor(O) === O ? s !== "categorical" && L === "number" && a !== void 0 && O < a ? [new It(A.key, B, "stop domain values must appear in ascending order")] : (a = O, s === "categorical" && O in l ? [new It(A.key, B, "stop domain values must be unique")] : (l[O] = !0, [])) : [new It(A.key, B, `integer expected, found ${O}`)];
          }
        }
        function an(i) {
          const t = (i.expressionContext === "property" ? wc : Ya)(Ti(i.value), i.valueSpec);
          if (t.result === "error") return t.value.map(((n) => new It(`${i.key}${n.key}`, i.value, n.message)));
          const s = t.value.expression || t.value._styleExpression.expression;
          if (i.expressionContext === "property" && i.propertyKey === "text-font" && !s.outputDefined()) return [new It(i.key, i.value, `Invalid data expression for "${i.propertyKey}". Output values must be contained as literals within the expression.`)];
          if (i.expressionContext === "property" && i.propertyType === "layout" && !Yn(s)) return [new It(i.key, i.value, '"feature-state" data expressions are not supported with layout properties.')];
          if (i.expressionContext === "filter" && !Yn(s)) return [new It(i.key, i.value, '"feature-state" data expressions are not supported with filters.')];
          if (i.expressionContext && i.expressionContext.indexOf("cluster") === 0) {
            if (!Ba(s, ["zoom", "feature-state"])) return [new It(i.key, i.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
            if (i.expressionContext === "cluster-initial" && !va(s)) return [new It(i.key, i.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
          }
          return [];
        }
        function $o(i) {
          const t = i.key, s = i.value, n = Gt(s);
          return n !== "string" ? [new It(t, s, `color expected, ${n} found`)] : Vt.parse(String(s)) ? [] : [new It(t, s, `color expected, "${s}" found`)];
        }
        function Rn(i) {
          const t = i.key, s = i.value, n = i.valueSpec, a = [];
          return Array.isArray(n.values) ? n.values.indexOf(fe(s)) === -1 && a.push(new It(t, s, `expected one of [${n.values.join(", ")}], ${JSON.stringify(s)} found`)) : Object.keys(n.values).indexOf(fe(s)) === -1 && a.push(new It(t, s, `expected one of [${Object.keys(n.values).join(", ")}], ${JSON.stringify(s)} found`)), a;
        }
        function Ko(i) {
          return Ra(Ti(i.value)) ? an(De({}, i, { expressionContext: "filter", valueSpec: { value: "boolean" } })) : mc(i);
        }
        function mc(i) {
          const t = i.value, s = i.key;
          if (Gt(t) !== "array") return [new It(s, t, `array expected, ${Gt(t)} found`)];
          const n = i.styleSpec;
          let a, M = [];
          if (t.length < 1) return [new It(s, t, "filter array must have at least 1 element")];
          switch (M = M.concat(Rn({ key: `${s}[0]`, value: t[0], valueSpec: n.filter_operator, style: i.style, styleSpec: i.styleSpec })), fe(t[0])) {
            case "<":
            case "<=":
            case ">":
            case ">=":
              t.length >= 2 && fe(t[1]) === "$type" && M.push(new It(s, t, `"$type" cannot be use with operator "${t[0]}"`));
            case "==":
            case "!=":
              t.length !== 3 && M.push(new It(s, t, `filter array for operator "${t[0]}" must have 3 elements`));
            case "in":
            case "!in":
              t.length >= 2 && (a = Gt(t[1]), a !== "string" && M.push(new It(`${s}[1]`, t[1], `string expected, ${a} found`)));
              for (let l = 2; l < t.length; l++) a = Gt(t[l]), fe(t[1]) === "$type" ? M = M.concat(Rn({ key: `${s}[${l}]`, value: t[l], valueSpec: n.geometry_type, style: i.style, styleSpec: i.styleSpec })) : a !== "string" && a !== "number" && a !== "boolean" && M.push(new It(`${s}[${l}]`, t[l], `string, number, or boolean expected, ${a} found`));
              break;
            case "any":
            case "all":
            case "none":
              for (let l = 1; l < t.length; l++) M = M.concat(mc({ key: `${s}[${l}]`, value: t[l], style: i.style, styleSpec: i.styleSpec }));
              break;
            case "has":
            case "!has":
              a = Gt(t[1]), t.length !== 2 ? M.push(new It(s, t, `filter array for "${t[0]}" operator must have 2 elements`)) : a !== "string" && M.push(new It(`${s}[1]`, t[1], `string expected, ${a} found`));
          }
          return M;
        }
        function tM(i, t) {
          const s = i.key, n = i.validateSpec, a = i.style, M = i.styleSpec, l = i.value, D = i.objectKey, N = M[`${t}_${i.layerType}`];
          if (!N) return [];
          const y = D.match(/^(.*)-transition$/);
          if (t === "paint" && y && N[y[1]] && N[y[1]].transition) return n({ key: s, value: l, valueSpec: M.transition, style: a, styleSpec: M });
          const w = i.valueSpec || N[D];
          if (!w) return [new It(s, l, `unknown property "${D}"`)];
          let T;
          if (Gt(l) === "string" && rn(w) && !w.tokens && (T = /^{([^}]+)}$/.exec(l))) return [new It(s, l, `"${D}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(T[1])} }\`.`)];
          const x = [];
          return i.layerType === "symbol" && D === "text-font" && Sa(Ti(l)) && fe(l.type) === "identity" && x.push(new It(s, l, '"text-font" does not support identity functions')), x.concat(n({ key: i.key, value: l, valueSpec: w, style: a, styleSpec: M, expressionContext: "property", propertyType: t, propertyKey: D }));
        }
        function eM(i) {
          return tM(i, "paint");
        }
        function Zn(i) {
          return tM(i, "layout");
        }
        function jc(i) {
          let t = [];
          const s = i.value, n = i.key, a = i.style, M = i.styleSpec;
          if (Gt(s) !== "object") return [new It(n, s, `object expected, ${Gt(s)} found`)];
          s.type || s.ref || t.push(new It(n, s, 'either "type" or "ref" is required'));
          let l = fe(s.type);
          const D = fe(s.ref);
          if (s.id) {
            const N = fe(s.id);
            for (let y = 0; y < i.arrayIndex; y++) {
              const w = a.layers[y];
              fe(w.id) === N && t.push(new It(n, s.id, `duplicate layer id "${s.id}", previously used at line ${w.id.__line__}`));
            }
          }
          if ("ref" in s) {
            let N;
            ["type", "source", "source-layer", "filter", "layout"].forEach(((y) => {
              y in s && t.push(new It(n, s[y], `"${y}" is prohibited for ref layers`));
            })), a.layers.forEach(((y) => {
              fe(y.id) === D && (N = y);
            })), N ? N.ref ? t.push(new It(n, s.ref, "ref cannot reference another ref layer")) : l = fe(N.type) : t.push(new It(n, s.ref, `ref layer "${D}" not found`));
          } else if (l !== "background") if (s.source) {
            const N = a.sources && a.sources[s.source], y = N && fe(N.type);
            N ? y === "vector" && l === "raster" ? t.push(new It(n, s.source, `layer "${s.id}" requires a raster source`)) : y !== "raster-dem" && l === "hillshade" || y !== "raster-dem" && l === "color-relief" ? t.push(new It(n, s.source, `layer "${s.id}" requires a raster-dem source`)) : y === "raster" && l !== "raster" ? t.push(new It(n, s.source, `layer "${s.id}" requires a vector source`)) : y !== "vector" || s["source-layer"] ? y === "raster-dem" && l !== "hillshade" && l !== "color-relief" ? t.push(new It(n, s.source, "raster-dem source can only be used with layer type 'hillshade' or 'color-relief'.")) : l !== "line" || !s.paint || !s.paint["line-gradient"] || y === "geojson" && N.lineMetrics || t.push(new It(n, s, `layer "${s.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : t.push(new It(n, s, `layer "${s.id}" must specify a "source-layer"`)) : t.push(new It(n, s.source, `source "${s.source}" not found`));
          } else t.push(new It(n, s, 'missing required property "source"'));
          return t = t.concat(js({ key: n, value: s, valueSpec: M.layer, style: i.style, styleSpec: i.styleSpec, validateSpec: i.validateSpec, objectElementValidators: { "*": () => [], type: () => i.validateSpec({ key: `${n}.type`, value: s.type, valueSpec: M.layer.type, style: i.style, styleSpec: i.styleSpec, validateSpec: i.validateSpec, object: s, objectKey: "type" }), filter: Ko, layout: (N) => js({ layer: s, key: N.key, value: N.value, style: N.style, styleSpec: N.styleSpec, validateSpec: N.validateSpec, objectElementValidators: { "*": (y) => Zn(De({ layerType: l }, y)) } }), paint: (N) => js({ layer: s, key: N.key, value: N.value, style: N.style, styleSpec: N.styleSpec, validateSpec: N.validateSpec, objectElementValidators: { "*": (y) => eM(De({ layerType: l }, y)) } }) } })), t;
        }
        function Ji(i) {
          const t = i.value, s = i.key, n = Gt(t);
          return n !== "string" ? [new It(s, t, `string expected, ${n} found`)] : [];
        }
        const sM = { promoteId: function({ key: i, value: t }) {
          if (Gt(t) === "string") return Ji({ key: i, value: t });
          {
            const s = [];
            for (const n in t) s.push(...Ji({ key: `${i}.${n}`, value: t[n] }));
            return s;
          }
        } };
        function _c(i) {
          const t = i.value, s = i.key, n = i.styleSpec, a = i.style, M = i.validateSpec;
          if (!t.type) return [new It(s, t, '"type" is required')];
          const l = fe(t.type);
          let D;
          switch (l) {
            case "vector":
            case "raster":
              return D = js({ key: s, value: t, valueSpec: n[`source_${l.replace("-", "_")}`], style: i.style, styleSpec: n, objectElementValidators: sM, validateSpec: M }), D;
            case "raster-dem":
              return D = (function(N) {
                var y;
                const w = (y = N.sourceName) !== null && y !== void 0 ? y : "", T = N.value, x = N.styleSpec, A = x.source_raster_dem, m = N.style;
                let L = [];
                const O = Gt(T);
                if (T === void 0) return L;
                if (O !== "object") return L.push(new It("source_raster_dem", T, `object expected, ${O} found`)), L;
                const B = fe(T.encoding) === "custom", P = ["redFactor", "greenFactor", "blueFactor", "baseShift"], k = N.value.encoding ? `"${N.value.encoding}"` : "Default";
                for (const U in T) !B && P.includes(U) ? L.push(new It(U, T[U], `In "${w}": "${U}" is only valid when "encoding" is set to "custom". ${k} encoding found`)) : A[U] ? L = L.concat(N.validateSpec({ key: U, value: T[U], valueSpec: A[U], validateSpec: N.validateSpec, style: m, styleSpec: x })) : L.push(new It(U, T[U], `unknown property "${U}"`));
                return L;
              })({ sourceName: s, value: t, style: i.style, styleSpec: n, validateSpec: M }), D;
            case "geojson":
              if (D = js({ key: s, value: t, valueSpec: n.source_geojson, style: a, styleSpec: n, validateSpec: M, objectElementValidators: sM }), t.cluster) for (const N in t.clusterProperties) {
                const [y, w] = t.clusterProperties[N], T = typeof y == "string" ? [y, ["accumulated"], ["get", N]] : y;
                D.push(...an({ key: `${s}.${N}.map`, value: w, expressionContext: "cluster-map" })), D.push(...an({ key: `${s}.${N}.reduce`, value: T, expressionContext: "cluster-reduce" }));
              }
              return D;
            case "video":
              return js({ key: s, value: t, valueSpec: n.source_video, style: a, validateSpec: M, styleSpec: n });
            case "image":
              return js({ key: s, value: t, valueSpec: n.source_image, style: a, validateSpec: M, styleSpec: n });
            case "canvas":
              return [new It(s, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
            default:
              return Rn({ key: `${s}.type`, value: t.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] } });
          }
        }
        function iM(i) {
          const t = i.value, s = i.styleSpec, n = s.light, a = i.style;
          let M = [];
          const l = Gt(t);
          if (t === void 0) return M;
          if (l !== "object") return M = M.concat([new It("light", t, `object expected, ${l} found`)]), M;
          for (const D in t) {
            const N = D.match(/^(.*)-transition$/);
            M = M.concat(N && n[N[1]] && n[N[1]].transition ? i.validateSpec({ key: D, value: t[D], valueSpec: s.transition, validateSpec: i.validateSpec, style: a, styleSpec: s }) : n[D] ? i.validateSpec({ key: D, value: t[D], valueSpec: n[D], validateSpec: i.validateSpec, style: a, styleSpec: s }) : [new It(D, t[D], `unknown property "${D}"`)]);
          }
          return M;
        }
        function rM(i) {
          const t = i.value, s = i.styleSpec, n = s.sky, a = i.style, M = Gt(t);
          if (t === void 0) return [];
          if (M !== "object") return [new It("sky", t, `object expected, ${M} found`)];
          let l = [];
          for (const D in t) l = l.concat(n[D] ? i.validateSpec({ key: D, value: t[D], valueSpec: n[D], style: a, styleSpec: s }) : [new It(D, t[D], `unknown property "${D}"`)]);
          return l;
        }
        function on(i) {
          const t = i.value, s = i.styleSpec, n = s.terrain, a = i.style;
          let M = [];
          const l = Gt(t);
          if (t === void 0) return M;
          if (l !== "object") return M = M.concat([new It("terrain", t, `object expected, ${l} found`)]), M;
          for (const D in t) M = M.concat(n[D] ? i.validateSpec({ key: D, value: t[D], valueSpec: n[D], validateSpec: i.validateSpec, style: a, styleSpec: s }) : [new It(D, t[D], `unknown property "${D}"`)]);
          return M;
        }
        function Lc(i) {
          let t = [];
          const s = i.value, n = i.key;
          if (Array.isArray(s)) {
            const a = [], M = [];
            for (const l in s) s[l].id && a.includes(s[l].id) && t.push(new It(n, s, `all the sprites' ids must be unique, but ${s[l].id} is duplicated`)), a.push(s[l].id), s[l].url && M.includes(s[l].url) && t.push(new It(n, s, `all the sprites' URLs must be unique, but ${s[l].url} is duplicated`)), M.push(s[l].url), t = t.concat(js({ key: `${n}[${l}]`, value: s[l], valueSpec: { id: { type: "string", required: !0 }, url: { type: "string", required: !0 } }, validateSpec: i.validateSpec }));
            return t;
          }
          return Ji({ key: n, value: s });
        }
        function Cc(i) {
          return t = i.value, t && t.constructor === Object ? [] : [new It(i.key, i.value, `object expected, ${Gt(i.value)} found`)];
          var t;
        }
        const Oc = { "*": () => [], array: Pn, boolean: function(i) {
          const t = i.value, s = i.key, n = Gt(t);
          return n !== "boolean" ? [new It(s, t, `boolean expected, ${n} found`)] : [];
        }, number: Tr, color: $o, constants: qo, enum: Rn, filter: Ko, function: Ac, layer: jc, object: js, source: _c, light: iM, sky: rM, terrain: on, projection: function(i) {
          const t = i.value, s = i.styleSpec, n = s.projection, a = i.style, M = Gt(t);
          if (t === void 0) return [];
          if (M !== "object") return [new It("projection", t, `object expected, ${M} found`)];
          let l = [];
          for (const D in t) l = l.concat(n[D] ? i.validateSpec({ key: D, value: t[D], valueSpec: n[D], style: a, styleSpec: s }) : [new It(D, t[D], `unknown property "${D}"`)]);
          return l;
        }, projectionDefinition: function(i) {
          const t = i.key;
          let s = i.value;
          s = s instanceof String ? s.valueOf() : s;
          const n = Gt(s);
          return n !== "array" || (function(a) {
            return Array.isArray(a) && a.length === 3 && typeof a[0] == "string" && typeof a[1] == "string" && typeof a[2] == "number";
          })(s) || (function(a) {
            return !!["interpolate", "step", "literal"].includes(a[0]);
          })(s) ? ["array", "string"].includes(n) ? [] : [new It(t, s, `projection expected, invalid type "${n}" found`)] : [new It(t, s, `projection expected, invalid array ${JSON.stringify(s)} found`)];
        }, string: Ji, formatted: function(i) {
          return Ji(i).length === 0 ? [] : an(i);
        }, resolvedImage: function(i) {
          return Ji(i).length === 0 ? [] : an(i);
        }, padding: function(i) {
          const t = i.key, s = i.value;
          if (Gt(s) === "array") {
            if (s.length < 1 || s.length > 4) return [new It(t, s, `padding requires 1 to 4 values; ${s.length} values found`)];
            const n = { type: "number" };
            let a = [];
            for (let M = 0; M < s.length; M++) a = a.concat(i.validateSpec({ key: `${t}[${M}]`, value: s[M], validateSpec: i.validateSpec, valueSpec: n }));
            return a;
          }
          return Tr({ key: t, value: s, valueSpec: {} });
        }, numberArray: function(i) {
          const t = i.key, s = i.value;
          if (Gt(s) === "array") {
            const n = { type: "number" };
            if (s.length < 1) return [new It(t, s, "array length at least 1 expected, length 0 found")];
            let a = [];
            for (let M = 0; M < s.length; M++) a = a.concat(i.validateSpec({ key: `${t}[${M}]`, value: s[M], validateSpec: i.validateSpec, valueSpec: n }));
            return a;
          }
          return Tr({ key: t, value: s, valueSpec: {} });
        }, colorArray: function(i) {
          const t = i.key, s = i.value;
          if (Gt(s) === "array") {
            if (s.length < 1) return [new It(t, s, "array length at least 1 expected, length 0 found")];
            let n = [];
            for (let a = 0; a < s.length; a++) n = n.concat($o({ key: `${t}[${a}]`, value: s[a] }));
            return n;
          }
          return $o({ key: t, value: s });
        }, variableAnchorOffsetCollection: function(i) {
          const t = i.key, s = i.value, n = Gt(s), a = i.styleSpec;
          if (n !== "array" || s.length < 1 || s.length % 2 != 0) return [new It(t, s, "variableAnchorOffsetCollection requires a non-empty array of even length")];
          let M = [];
          for (let l = 0; l < s.length; l += 2) M = M.concat(Rn({ key: `${t}[${l}]`, value: s[l], valueSpec: a.layout_symbol["text-anchor"] })), M = M.concat(Pn({ key: `${t}[${l + 1}]`, value: s[l + 1], valueSpec: { length: 2, value: "number" }, validateSpec: i.validateSpec, style: i.style, styleSpec: a }));
          return M;
        }, sprite: Lc, state: Cc };
        function Ga(i) {
          const t = i.value, s = i.valueSpec, n = i.styleSpec;
          return i.validateSpec = Ga, s.expression && Sa(fe(t)) ? Ac(i) : s.expression && Fa(Ti(t)) ? an(i) : s.type && Oc[s.type] ? Oc[s.type](i) : js(De({}, i, { valueSpec: s.type ? n[s.type] : s }));
        }
        function Ec(i) {
          const t = i.value, s = i.key, n = Ji(i);
          return n.length || (t.indexOf("{fontstack}") === -1 && n.push(new It(s, t, '"glyphs" url must include a "{fontstack}" token')), t.indexOf("{range}") === -1 && n.push(new It(s, t, '"glyphs" url must include a "{range}" token'))), n;
        }
        function Us(i, t = X) {
          let s = [];
          return s = s.concat(Ga({ key: "", value: i, valueSpec: t.$root, styleSpec: t, style: i, validateSpec: Ga, objectElementValidators: { glyphs: Ec, "*": () => [] } })), i.constants && (s = s.concat(qo({ key: "constants", value: i.constants }))), Mn(s);
        }
        function Ns(i) {
          return function(t) {
            return i(Object.assign({}, t, { validateSpec: Ga }));
          };
        }
        function Mn(i) {
          return [].concat(i).sort(((t, s) => t.line - s.line));
        }
        function Le(i) {
          return function(...t) {
            return Mn(i.apply(this, t));
          };
        }
        Us.source = Le(Ns(_c)), Us.sprite = Le(Ns(Lc)), Us.glyphs = Le(Ns(Ec)), Us.light = Le(Ns(iM)), Us.sky = Le(Ns(rM)), Us.terrain = Le(Ns(on)), Us.state = Le(Ns(Cc)), Us.layer = Le(Ns(jc)), Us.filter = Le(Ns(Ko)), Us.paintProperty = Le(Ns(eM)), Us.layoutProperty = Le(Ns(Zn));
        const Vn = X, fr = Us, Yl = fr.light, Ul = fr.sky, Gn = fr.paintProperty, bc = fr.layoutProperty;
        function Ha(i, t) {
          let s = !1;
          if (t && t.length) for (const n of t) i.fire(new H(new Error(n.message))), s = !0;
          return s;
        }
        class Hn {
          constructor(t, s, n) {
            const a = this.cells = [];
            if (t instanceof ArrayBuffer) {
              this.arrayBuffer = t;
              const l = new Int32Array(this.arrayBuffer);
              t = l[0], this.d = (s = l[1]) + 2 * (n = l[2]);
              for (let N = 0; N < this.d * this.d; N++) {
                const y = l[3 + N], w = l[3 + N + 1];
                a.push(y === w ? null : l.subarray(y, w));
              }
              const D = l[3 + a.length + 1];
              this.keys = l.subarray(l[3 + a.length], D), this.bboxes = l.subarray(D), this.insert = this._insertReadonly;
            } else {
              this.d = s + 2 * n;
              for (let l = 0; l < this.d * this.d; l++) a.push([]);
              this.keys = [], this.bboxes = [];
            }
            this.n = s, this.extent = t, this.padding = n, this.scale = s / t, this.uid = 0;
            const M = n / s * t;
            this.min = -M, this.max = t + M;
          }
          insert(t, s, n, a, M) {
            this._forEachCell(s, n, a, M, this._insertCell, this.uid++, void 0, void 0), this.keys.push(t), this.bboxes.push(s), this.bboxes.push(n), this.bboxes.push(a), this.bboxes.push(M);
          }
          _insertReadonly() {
            throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.");
          }
          _insertCell(t, s, n, a, M, l) {
            this.cells[M].push(l);
          }
          query(t, s, n, a, M) {
            const l = this.min, D = this.max;
            if (t <= l && s <= l && D <= n && D <= a && !M) return Array.prototype.slice.call(this.keys);
            {
              const N = [];
              return this._forEachCell(t, s, n, a, this._queryCell, N, {}, M), N;
            }
          }
          _queryCell(t, s, n, a, M, l, D, N) {
            const y = this.cells[M];
            if (y !== null) {
              const w = this.keys, T = this.bboxes;
              for (let x = 0; x < y.length; x++) {
                const A = y[x];
                if (D[A] === void 0) {
                  const m = 4 * A;
                  (N ? N(T[m + 0], T[m + 1], T[m + 2], T[m + 3]) : t <= T[m + 2] && s <= T[m + 3] && n >= T[m + 0] && a >= T[m + 1]) ? (D[A] = !0, l.push(w[A])) : D[A] = !1;
                }
              }
            }
          }
          _forEachCell(t, s, n, a, M, l, D, N) {
            const y = this._convertToCellCoord(t), w = this._convertToCellCoord(s), T = this._convertToCellCoord(n), x = this._convertToCellCoord(a);
            for (let A = y; A <= T; A++) for (let m = w; m <= x; m++) {
              const L = this.d * m + A;
              if ((!N || N(this._convertFromCellCoord(A), this._convertFromCellCoord(m), this._convertFromCellCoord(A + 1), this._convertFromCellCoord(m + 1))) && M.call(this, t, s, n, a, L, l, D, N)) return;
            }
          }
          _convertFromCellCoord(t) {
            return (t - this.padding) / this.scale;
          }
          _convertToCellCoord(t) {
            return Math.max(0, Math.min(this.d - 1, Math.floor(t * this.scale) + this.padding));
          }
          toArrayBuffer() {
            if (this.arrayBuffer) return this.arrayBuffer;
            const t = this.cells, s = 3 + this.cells.length + 1 + 1;
            let n = 0;
            for (let l = 0; l < this.cells.length; l++) n += this.cells[l].length;
            const a = new Int32Array(s + n + this.keys.length + this.bboxes.length);
            a[0] = this.extent, a[1] = this.n, a[2] = this.padding;
            let M = s;
            for (let l = 0; l < t.length; l++) {
              const D = t[l];
              a[3 + l] = M, a.set(D, M), M += D.length;
            }
            return a[3 + t.length] = M, a.set(this.keys, M), M += this.keys.length, a[3 + t.length + 1] = M, a.set(this.bboxes, M), M += this.bboxes.length, a.buffer;
          }
          static serialize(t, s) {
            const n = t.toArrayBuffer();
            return s && s.push(n), { buffer: n };
          }
          static deserialize(t) {
            return new Hn(t.buffer);
          }
        }
        const ti = {};
        function jt(i, t, s = {}) {
          if (ti[i]) throw new Error(`${i} is already registered.`);
          Object.defineProperty(t, "_classRegistryKey", { value: i, writeable: !1 }), ti[i] = { klass: t, omit: s.omit || [], shallow: s.shallow || [] };
        }
        jt("Object", Object), jt("Set", Set), jt("TransferableGridIndex", Hn), jt("Color", Vt), jt("Error", Error), jt("AJAXError", Hs), jt("ResolvedImage", xs), jt("StylePropertyFunction", Xa), jt("StyleExpression", ka, { omit: ["_evaluator"] }), jt("ZoomDependentExpression", Ua), jt("ZoomConstantExpression", pr), jt("CompoundExpression", Ys, { omit: ["_evaluate"] });
        for (const i in en) en[i]._classRegistryKey || jt(`Expression_${i}`, en[i]);
        function cn(i) {
          return i && typeof ArrayBuffer < "u" && (i instanceof ArrayBuffer || i.constructor && i.constructor.name === "ArrayBuffer");
        }
        function nM(i) {
          return i.$name || i.constructor._classRegistryKey;
        }
        function Qc(i) {
          return !(function(t) {
            if (t === null || typeof t != "object") return !1;
            const s = nM(t);
            return !(!s || s === "Object");
          })(i) && (i == null || typeof i == "boolean" || typeof i == "number" || typeof i == "string" || i instanceof Boolean || i instanceof Number || i instanceof String || i instanceof Date || i instanceof RegExp || i instanceof Blob || i instanceof Error || cn(i) || oi(i) || ArrayBuffer.isView(i) || i instanceof ImageData);
        }
        function Jn(i, t) {
          if (Qc(i)) return (cn(i) || oi(i)) && t && t.push(i), ArrayBuffer.isView(i) && t && t.push(i.buffer), i instanceof ImageData && t && t.push(i.data.buffer), i;
          if (Array.isArray(i)) {
            const M = [];
            for (const l of i) M.push(Jn(l, t));
            return M;
          }
          if (typeof i != "object") throw new Error("can't serialize object of type " + typeof i);
          const s = nM(i);
          if (!s) throw new Error(`can't serialize object of unregistered class ${i.constructor.name}`);
          if (!ti[s]) throw new Error(`${s} is not registered.`);
          const { klass: n } = ti[s], a = n.serialize ? n.serialize(i, t) : {};
          if (n.serialize) {
            if (t && a === t[t.length - 1]) throw new Error("statically serialized object won't survive transfer of $name property");
          } else {
            for (const M in i) {
              if (!i.hasOwnProperty(M) || ti[s].omit.indexOf(M) >= 0) continue;
              const l = i[M];
              a[M] = ti[s].shallow.indexOf(M) >= 0 ? l : Jn(l, t);
            }
            i instanceof Error && (a.message = i.message);
          }
          if (a.$name) throw new Error("$name property is reserved for worker serialization logic.");
          return s !== "Object" && (a.$name = s), a;
        }
        function fi(i) {
          if (Qc(i)) return i;
          if (Array.isArray(i)) return i.map(fi);
          if (typeof i != "object") throw new Error("can't deserialize object of type " + typeof i);
          const t = nM(i) || "Object";
          if (!ti[t]) throw new Error(`can't deserialize unregistered class ${t}`);
          const { klass: s } = ti[t];
          if (!s) throw new Error(`can't deserialize unregistered class ${t}`);
          if (s.deserialize) return s.deserialize(i);
          const n = Object.create(s.prototype);
          for (const a of Object.keys(i)) {
            if (a === "$name") continue;
            const M = i[a];
            n[a] = ti[t].shallow.indexOf(a) >= 0 ? M : fi(M);
          }
          return n;
        }
        class aM {
          constructor() {
            this.first = !0;
          }
          update(t, s) {
            const n = Math.floor(t);
            return this.first ? (this.first = !1, this.lastIntegerZoom = n, this.lastIntegerZoomTime = 0, this.lastZoom = t, this.lastFloorZoom = n, !0) : (this.lastFloorZoom > n ? (this.lastIntegerZoom = n + 1, this.lastIntegerZoomTime = s) : this.lastFloorZoom < n && (this.lastIntegerZoom = n, this.lastIntegerZoomTime = s), t !== this.lastZoom && (this.lastZoom = t, this.lastFloorZoom = n, !0));
          }
        }
        function Xl(i) {
          return /[\u02EA\u02EB\u2E80-\u2FDF\u2FF0-\u303F\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FD-\u30FF\u3105-\u312F\u31A0-\u4DBF\u4E00-\uA48C\uA490-\uA4C6\uF900-\uFA6D\uFA70-\uFAD9\uFE10-\uFE1F\uFE30-\uFE4F\uFF00-\uFFEF]|\uD81B[\uDFE0-\uDFFF]|[\uD81C-\uD822\uD840-\uD868\uD86A-\uD86D\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD88C][\uDC00-\uDFFF]|\uD823[\uDC00-\uDCD5\uDCFF-\uDD1E\uDD80-\uDDF2]|\uD82B[\uDFF0-\uDFFF]|\uD82C[\uDC00-\uDEFB]|\uD83C[\uDE00-\uDEFF]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEAD\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0\uDFF0-\uDFFF]|\uD87B[\uDC00-\uDE5D]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD88D[\uDC00-\uDC79]/gim.test(String.fromCodePoint(i));
        }
        function ln(i) {
          return /[\u02EA\u02EB\u1100-\u11FF\u1400-\u167F\u18B0-\u18F5\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u3007\u3012\u3013\u3020-\u302F\u3031-\u303F\u3041-\u3096\u309D-\u30FB\u30FD-\u30FF\u3105-\u312F\u3131-\u318E\u3190-\uA48C\uA490-\uA4C6\uA960-\uA97C\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFE10-\uFE1F\uFE30-\uFE48\uFE50-\uFE57\uFE5F-\uFE62\uFE67-\uFE6F\uFF00-\uFF07\uFF0A-\uFF0C\uFF0E-\uFF19\uFF1F-\uFF3A\uFF3C\uFF3E\uFF40-\uFF5A\uFFE0-\uFFE2\uFFE4-\uFFE7]|\uD802[\uDD80-\uDD9F]|\uD805[\uDD80-\uDDFF]|\uD806[\uDE00-\uDEBF]|\uD811[\uDC00-\uDE7F]|\uD81B[\uDFE0-\uDFE4\uDFF0-\uDFF6]|[\uD81C-\uD822\uD83D\uD840-\uD868\uD86A-\uD86D\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD88C][\uDC00-\uDFFF]|\uD823[\uDC00-\uDCD5\uDCFF-\uDD1E\uDD80-\uDDF2]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD30-\uDEFB]|\uD833[\uDEC0-\uDFCF]|\uD834[\uDC00-\uDDFF\uDEE0-\uDF7F]|\uD836[\uDC00-\uDEAF]|\uD83C[\uDC00-\uDE00\uDF00-\uDFFF]|\uD83E[\uDD00-\uDEFF]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEAD\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0\uDFF0-\uDFFF]|\uD87B[\uDC00-\uDE5D]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD88D[\uDC00-\uDC79]/gim.test(String.fromCodePoint(i));
        }
        function vc(i) {
          return /\s/u.test(String.fromCodePoint(i));
        }
        function qn(i) {
          for (const t of i) if (ln(t.codePointAt(0))) return !0;
          return !1;
        }
        function Ja(i) {
          for (const t of i) if (!Sc(t.codePointAt(0))) return !1;
          return !0;
        }
        function oM(i) {
          const t = i.map(((s) => {
            try {
              return new RegExp(`\\p{sc=${s}}`, "u").source;
            } catch {
              return null;
            }
          })).filter(((s) => s));
          return new RegExp(t.join("|"), "u");
        }
        const Bc = oM(["Arab", "Dupl", "Mong", "Ougr", "Syrc"]);
        function Sc(i) {
          return !Bc.test(String.fromCodePoint(i));
        }
        function MM(i) {
          return !(ln(i) || (t = i, /[\xA7\xA9\xAE\xB1\xBC-\xBE\xD7\xF7\u2016\u2020\u2021\u2030\u2031\u203B\u203C\u2042\u2047-\u2049\u2051\u2100-\u218F\u221E\u2234\u2235\u2300-\u2307\u230C-\u231F\u2324-\u2328\u232B\u237D-\u239A\u23BE-\u23CD\u23CF\u23D1-\u23DB\u23E2-\u2422\u2424-\u24FF\u25A0-\u2619\u2620-\u2767\u2776-\u2793\u2B12-\u2B2F\u2B50-\u2B59\u2BB8-\u2BEB\u3000-\u303F\u30A0-\u30FF\uE000-\uF8FF\uFE30-\uFE6F\uFF00-\uFFEF\uFFFC\uFFFD]|[\uDB80-\uDBFF][\uDC00-\uDFFF]/gim.test(String.fromCodePoint(t))));
          var t;
        }
        const cM = oM(["Adlm", "Arab", "Armi", "Avst", "Chrs", "Cprt", "Egyp", "Elym", "Gara", "Hatr", "Hebr", "Hung", "Khar", "Lydi", "Mand", "Mani", "Mend", "Merc", "Mero", "Narb", "Nbat", "Nkoo", "Orkh", "Palm", "Phli", "Phlp", "Phnx", "Prti", "Rohg", "Samr", "Sarb", "Sogo", "Syrc", "Thaa", "Todr", "Yezi"]);
        function lM(i) {
          return cM.test(String.fromCodePoint(i));
        }
        function Wl(i, t) {
          return !(!t && lM(i) || /[\u0900-\u0DFF\u0F00-\u109F\u1780-\u17FF]/gim.test(String.fromCodePoint(i)));
        }
        function kc(i) {
          for (const t of i) if (lM(t.codePointAt(0))) return !0;
          return !1;
        }
        const qi = new class {
          constructor() {
            this.TIMEOUT = 5e3, this.applyArabicShaping = null, this.processBidirectionalText = null, this.processStyledBidirectionalText = null, this.pluginStatus = "unavailable", this.pluginURL = null, this.loadScriptResolve = () => {
            };
          }
          setState(i) {
            this.pluginStatus = i.pluginStatus, this.pluginURL = i.pluginURL;
          }
          getState() {
            return { pluginStatus: this.pluginStatus, pluginURL: this.pluginURL };
          }
          setMethods(i) {
            if (qi.isParsed()) throw new Error("RTL text plugin already registered.");
            this.applyArabicShaping = i.applyArabicShaping, this.processBidirectionalText = i.processBidirectionalText, this.processStyledBidirectionalText = i.processStyledBidirectionalText, this.loadScriptResolve();
          }
          isParsed() {
            return this.applyArabicShaping != null && this.processBidirectionalText != null && this.processStyledBidirectionalText != null;
          }
          getRTLTextPluginStatus() {
            return this.pluginStatus;
          }
          syncState(i, t) {
            return u(this, void 0, void 0, (function* () {
              if (this.isParsed()) return this.getState();
              if (i.pluginStatus !== "loading") return this.setState(i), i;
              const s = i.pluginURL, n = new Promise(((M) => {
                this.loadScriptResolve = M;
              }));
              t(s);
              const a = new Promise(((M) => setTimeout((() => M()), this.TIMEOUT)));
              if (yield Promise.race([n, a]), this.isParsed()) {
                const M = { pluginStatus: "loaded", pluginURL: s };
                return this.setState(M), M;
              }
              throw this.setState({ pluginStatus: "error", pluginURL: "" }), new Error(`RTL Text Plugin failed to import scripts from ${s}`);
            }));
          }
        }();
        class ie {
          constructor(t, s) {
            this.isSupportedScript = Pl, this.zoom = t, s ? (this.now = s.now || 0, this.fadeDuration = s.fadeDuration || 0, this.zoomHistory = s.zoomHistory || new aM(), this.transition = s.transition || {}) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new aM(), this.transition = {});
          }
          crossFadingFactor() {
            return this.fadeDuration === 0 ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
          }
          getCrossfadeParameters() {
            const t = this.zoom, s = t - Math.floor(t), n = this.crossFadingFactor();
            return t > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: s + (1 - s) * n } : { fromScale: 0.5, toScale: 1, t: 1 - (1 - n) * s };
          }
        }
        function Pl(i) {
          return (function(t, s) {
            for (const n of t) if (!Wl(n.codePointAt(0), s)) return !1;
            return !0;
          })(i, qi.getRTLTextPluginStatus() === "loaded");
        }
        const $n = "-transition";
        class Kn {
          constructor(t, s, n) {
            this.property = t, this.value = s, this.expression = (function(a, M, l) {
              if (Sa(a)) return new Xa(a, M);
              if (Fa(a)) {
                const D = wc(a, M, l);
                if (D.result === "error") throw new Error(D.value.map(((N) => `${N.key}: ${N.message}`)).join(", "));
                return D.value;
              }
              {
                let D = a;
                return M.type === "color" && typeof a == "string" ? D = Vt.parse(a) : M.type !== "padding" || typeof a != "number" && !Array.isArray(a) ? M.type !== "numberArray" || typeof a != "number" && !Array.isArray(a) ? M.type !== "colorArray" || typeof a != "string" && !Array.isArray(a) ? M.type === "variableAnchorOffsetCollection" && Array.isArray(a) ? D = zs.parse(a) : M.type === "projectionDefinition" && typeof a == "string" && (D = os.parse(a)) : D = Re.parse(a) : D = as.parse(a) : D = ns.parse(a), { globalStateRefs: /* @__PURE__ */ new Set(), _globalState: null, kind: "constant", evaluate: () => D };
              }
            })(s === void 0 ? t.specification.default : s, t.specification, n);
          }
          isDataDriven() {
            return this.expression.kind === "source" || this.expression.kind === "composite";
          }
          getGlobalStateRefs() {
            return this.expression.globalStateRefs || /* @__PURE__ */ new Set();
          }
          possiblyEvaluate(t, s, n) {
            return this.property.possiblyEvaluate(this, t, s, n);
          }
        }
        class uM {
          constructor(t, s) {
            this.property = t, this.value = new Kn(t, void 0, s);
          }
          transitioned(t, s) {
            return new gM(this.property, this.value, s, rs({}, t.transition, this.transition), t.now);
          }
          untransitioned() {
            return new gM(this.property, this.value, null, {}, 0);
          }
        }
        class Fc {
          constructor(t, s) {
            this._properties = t, this._values = Object.create(t.defaultTransitionablePropertyValues), this._globalState = s;
          }
          getValue(t) {
            return ks(this._values[t].value.value);
          }
          setValue(t, s) {
            Object.prototype.hasOwnProperty.call(this._values, t) || (this._values[t] = new uM(this._values[t].property, this._globalState)), this._values[t].value = new Kn(this._values[t].property, s === null ? void 0 : ks(s), this._globalState);
          }
          getTransition(t) {
            return ks(this._values[t].transition);
          }
          setTransition(t, s) {
            Object.prototype.hasOwnProperty.call(this._values, t) || (this._values[t] = new uM(this._values[t].property, this._globalState)), this._values[t].transition = ks(s) || void 0;
          }
          serialize() {
            const t = {};
            for (const s of Object.keys(this._values)) {
              const n = this.getValue(s);
              n !== void 0 && (t[s] = n);
              const a = this.getTransition(s);
              a !== void 0 && (t[`${s}${$n}`] = a);
            }
            return t;
          }
          transitioned(t, s) {
            const n = new hM(this._properties);
            for (const a of Object.keys(this._values)) n._values[a] = this._values[a].transitioned(t, s._values[a]);
            return n;
          }
          untransitioned() {
            const t = new hM(this._properties);
            for (const s of Object.keys(this._values)) t._values[s] = this._values[s].untransitioned();
            return t;
          }
        }
        class gM {
          constructor(t, s, n, a, M) {
            this.property = t, this.value = s, this.begin = M + a.delay || 0, this.end = this.begin + a.duration || 0, t.specification.transition && (a.delay || a.duration) && (this.prior = n);
          }
          possiblyEvaluate(t, s, n) {
            const a = t.now || 0, M = this.value.possiblyEvaluate(t, s, n), l = this.prior;
            if (l) {
              if (a > this.end) return this.prior = null, M;
              if (this.value.isDataDriven()) return this.prior = null, M;
              if (a < this.begin) return l.possiblyEvaluate(t, s, n);
              {
                const D = (a - this.begin) / (this.end - this.begin);
                return this.property.interpolate(l.possiblyEvaluate(t, s, n), M, Ia(D));
              }
            }
            return M;
          }
        }
        class hM {
          constructor(t) {
            this._properties = t, this._values = Object.create(t.defaultTransitioningPropertyValues);
          }
          possiblyEvaluate(t, s, n) {
            const a = new xr(this._properties);
            for (const M of Object.keys(this._values)) a._values[M] = this._values[M].possiblyEvaluate(t, s, n);
            return a;
          }
          hasTransition() {
            for (const t of Object.keys(this._values)) if (this._values[t].prior) return !0;
            return !1;
          }
        }
        class Yc {
          constructor(t, s) {
            this._properties = t, this._values = Object.create(t.defaultPropertyValues), this._globalState = s;
          }
          hasValue(t) {
            return this._values[t].value !== void 0;
          }
          getValue(t) {
            return ks(this._values[t].value);
          }
          setValue(t, s) {
            this._values[t] = new Kn(this._values[t].property, s === null ? void 0 : ks(s), this._globalState);
          }
          serialize() {
            const t = {};
            for (const s of Object.keys(this._values)) {
              const n = this.getValue(s);
              n !== void 0 && (t[s] = n);
            }
            return t;
          }
          possiblyEvaluate(t, s, n) {
            const a = new xr(this._properties);
            for (const M of Object.keys(this._values)) a._values[M] = this._values[M].possiblyEvaluate(t, s, n);
            return a;
          }
        }
        class ei {
          constructor(t, s, n) {
            this.property = t, this.value = s, this.parameters = n;
          }
          isConstant() {
            return this.value.kind === "constant";
          }
          constantOr(t) {
            return this.value.kind === "constant" ? this.value.value : t;
          }
          evaluate(t, s, n, a) {
            return this.property.evaluate(this.value, this.parameters, t, s, n, a);
          }
        }
        class xr {
          constructor(t) {
            this._properties = t, this._values = Object.create(t.defaultPossiblyEvaluatedValues);
          }
          get(t) {
            return this._values[t];
          }
        }
        class Et {
          constructor(t) {
            this.specification = t;
          }
          possiblyEvaluate(t, s) {
            if (t.isDataDriven()) throw new Error("Value should not be data driven");
            return t.expression.evaluate(s);
          }
          interpolate(t, s, n) {
            const a = $s[this.specification.type];
            return a ? a(t, s, n) : t;
          }
        }
        class Bt {
          constructor(t, s) {
            this.specification = t, this.overrides = s;
          }
          possiblyEvaluate(t, s, n, a) {
            return new ei(this, t.expression.kind === "constant" || t.expression.kind === "camera" ? { kind: "constant", value: t.expression.evaluate(s, null, {}, n, a) } : t.expression, s);
          }
          interpolate(t, s, n) {
            if (t.value.kind !== "constant" || s.value.kind !== "constant") return t;
            if (t.value.value === void 0 || s.value.value === void 0) return new ei(this, { kind: "constant", value: void 0 }, t.parameters);
            const a = $s[this.specification.type];
            if (a) {
              const M = a(t.value.value, s.value.value, n);
              return new ei(this, { kind: "constant", value: M }, t.parameters);
            }
            return t;
          }
          evaluate(t, s, n, a, M, l) {
            return t.kind === "constant" ? t.value : t.evaluate(s, n, a, M, l);
          }
        }
        class ta extends Bt {
          possiblyEvaluate(t, s, n, a) {
            if (t.value === void 0) return new ei(this, { kind: "constant", value: void 0 }, s);
            if (t.expression.kind === "constant") {
              const M = t.expression.evaluate(s, null, {}, n, a), l = t.property.specification.type === "resolvedImage" && typeof M != "string" ? M.name : M, D = this._calculate(l, l, l, s);
              return new ei(this, { kind: "constant", value: D }, s);
            }
            if (t.expression.kind === "camera") {
              const M = this._calculate(t.expression.evaluate({ zoom: s.zoom - 1 }), t.expression.evaluate({ zoom: s.zoom }), t.expression.evaluate({ zoom: s.zoom + 1 }), s);
              return new ei(this, { kind: "constant", value: M }, s);
            }
            return new ei(this, t.expression, s);
          }
          evaluate(t, s, n, a, M, l) {
            if (t.kind === "source") {
              const D = t.evaluate(s, n, a, M, l);
              return this._calculate(D, D, D, s);
            }
            return t.kind === "composite" ? this._calculate(t.evaluate({ zoom: Math.floor(s.zoom) - 1 }, n, a), t.evaluate({ zoom: Math.floor(s.zoom) }, n, a), t.evaluate({ zoom: Math.floor(s.zoom) + 1 }, n, a), s) : t.value;
          }
          _calculate(t, s, n, a) {
            return a.zoom > a.zoomHistory.lastIntegerZoom ? { from: t, to: s } : { from: n, to: s };
          }
          interpolate(t) {
            return t;
          }
        }
        class Uc {
          constructor(t) {
            this.specification = t;
          }
          possiblyEvaluate(t, s, n, a) {
            if (t.value !== void 0) {
              if (t.expression.kind === "constant") {
                const M = t.expression.evaluate(s, null, {}, n, a);
                return this._calculate(M, M, M, s);
              }
              return this._calculate(t.expression.evaluate(new ie(Math.floor(s.zoom - 1), s)), t.expression.evaluate(new ie(Math.floor(s.zoom), s)), t.expression.evaluate(new ie(Math.floor(s.zoom + 1), s)), s);
            }
          }
          _calculate(t, s, n, a) {
            return a.zoom > a.zoomHistory.lastIntegerZoom ? { from: t, to: s } : { from: n, to: s };
          }
          interpolate(t) {
            return t;
          }
        }
        class ea {
          constructor(t) {
            this.specification = t;
          }
          possiblyEvaluate(t, s, n, a) {
            return !!t.expression.evaluate(s, null, {}, n, a);
          }
          interpolate() {
            return !1;
          }
        }
        class Ms {
          constructor(t) {
            this.properties = t, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
            for (const s in t) {
              const n = t[s];
              n.specification.overridable && this.overridableProperties.push(s);
              const a = this.defaultPropertyValues[s] = new Kn(n, void 0, void 0), M = this.defaultTransitionablePropertyValues[s] = new uM(n, void 0);
              this.defaultTransitioningPropertyValues[s] = M.untransitioned(), this.defaultPossiblyEvaluatedValues[s] = a.possiblyEvaluate({});
            }
          }
        }
        jt("DataDrivenProperty", Bt), jt("DataConstantProperty", Et), jt("CrossFadedDataDrivenProperty", ta), jt("CrossFadedProperty", Uc), jt("ColorRampProperty", ea);
        class Xs extends rt {
          constructor(t, s, n) {
            if (super(), this.id = t.id, this.type = t.type, this._globalState = n, this._featureFilter = { filter: () => !0, needGeometry: !1, getGlobalStateRefs: () => /* @__PURE__ */ new Set() }, t.type !== "custom" && (this.metadata = t.metadata, this.minzoom = t.minzoom, this.maxzoom = t.maxzoom, t.type !== "background" && (this.source = t.source, this.sourceLayer = t["source-layer"], this.filter = t.filter, this._featureFilter = Xn(t.filter, n)), s.layout && (this._unevaluatedLayout = new Yc(s.layout, n)), s.paint)) {
              this._transitionablePaint = new Fc(s.paint, n);
              for (const a in t.paint) this.setPaintProperty(a, t.paint[a], { validate: !1 });
              for (const a in t.layout) this.setLayoutProperty(a, t.layout[a], { validate: !1 });
              this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new xr(s.paint);
            }
          }
          setFilter(t) {
            this.filter = t, this._featureFilter = Xn(t, this._globalState);
          }
          getCrossfadeParameters() {
            return this._crossfadeParameters;
          }
          getLayoutProperty(t) {
            return t === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(t);
          }
          getLayoutAffectingGlobalStateRefs() {
            const t = /* @__PURE__ */ new Set();
            if (this._unevaluatedLayout) for (const s in this._unevaluatedLayout._values) {
              const n = this._unevaluatedLayout._values[s];
              for (const a of n.getGlobalStateRefs()) t.add(a);
            }
            for (const s of this._featureFilter.getGlobalStateRefs()) t.add(s);
            return t;
          }
          getPaintAffectingGlobalStateRefs() {
            var t;
            const s = new globalThis.Map();
            if (this._transitionablePaint) for (const n in this._transitionablePaint._values) {
              const a = this._transitionablePaint._values[n].value;
              for (const M of a.getGlobalStateRefs()) {
                const l = (t = s.get(M)) !== null && t !== void 0 ? t : [];
                l.push({ name: n, value: a.value }), s.set(M, l);
              }
            }
            return s;
          }
          setLayoutProperty(t, s, n = {}) {
            s != null && this._validate(bc, `layers.${this.id}.layout.${t}`, t, s, n) || (t !== "visibility" ? this._unevaluatedLayout.setValue(t, s) : this.visibility = s);
          }
          getPaintProperty(t) {
            return t.endsWith($n) ? this._transitionablePaint.getTransition(t.slice(0, -11)) : this._transitionablePaint.getValue(t);
          }
          setPaintProperty(t, s, n = {}) {
            if (s != null && this._validate(Gn, `layers.${this.id}.paint.${t}`, t, s, n)) return !1;
            if (t.endsWith($n)) return this._transitionablePaint.setTransition(t.slice(0, -11), s || void 0), !1;
            {
              const a = this._transitionablePaint._values[t], M = a.property.specification["property-type"] === "cross-faded-data-driven", l = a.value.isDataDriven(), D = a.value;
              this._transitionablePaint.setValue(t, s), this._handleSpecialPaintPropertyUpdate(t);
              const N = this._transitionablePaint._values[t].value;
              return N.isDataDriven() || l || M || this._handleOverridablePaintPropertyUpdate(t, D, N);
            }
          }
          _handleSpecialPaintPropertyUpdate(t) {
          }
          _handleOverridablePaintPropertyUpdate(t, s, n) {
            return !1;
          }
          isHidden(t, s = !1) {
            return !!(this.minzoom && t < (s ? Math.floor(this.minzoom) : this.minzoom)) || !!(this.maxzoom && t >= this.maxzoom) || this.visibility === "none";
          }
          updateTransitions(t) {
            this._transitioningPaint = this._transitionablePaint.transitioned(t, this._transitioningPaint);
          }
          hasTransition() {
            return this._transitioningPaint.hasTransition();
          }
          recalculate(t, s) {
            t.getCrossfadeParameters && (this._crossfadeParameters = t.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t, void 0, s)), this.paint = this._transitioningPaint.possiblyEvaluate(t, void 0, s);
          }
          serialize() {
            const t = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
            return this.visibility && (t.layout = t.layout || {}, t.layout.visibility = this.visibility), Mr(t, ((s, n) => !(s === void 0 || n === "layout" && !Object.keys(s).length || n === "paint" && !Object.keys(s).length)));
          }
          _validate(t, s, n, a, M = {}) {
            return (!M || M.validate !== !1) && Ha(this, t.call(fr, { key: s, layerType: this.type, objectKey: n, value: a, styleSpec: X, style: { glyphs: !0, sprite: !0 } }));
          }
          is3D() {
            return !1;
          }
          isTileClipped() {
            return !1;
          }
          hasOffscreenPass() {
            return !1;
          }
          resize() {
          }
          isStateDependent() {
            for (const t in this.paint._values) {
              const s = this.paint.get(t);
              if (s instanceof ei && rn(s.property.specification) && (s.value.kind === "source" || s.value.kind === "composite") && s.value.isStateDependent) return !0;
            }
            return !1;
          }
        }
        let Xc;
        var Rl = { get paint() {
          return Xc = Xc || new Ms({ "raster-opacity": new Et(X.paint_raster["raster-opacity"]), "raster-hue-rotate": new Et(X.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new Et(X.paint_raster["raster-brightness-min"]), "raster-brightness-max": new Et(X.paint_raster["raster-brightness-max"]), "raster-saturation": new Et(X.paint_raster["raster-saturation"]), "raster-contrast": new Et(X.paint_raster["raster-contrast"]), "raster-resampling": new Et(X.paint_raster["raster-resampling"]), "raster-fade-duration": new Et(X.paint_raster["raster-fade-duration"]) });
        } };
        class Zl extends Xs {
          constructor(t, s) {
            super(t, Rl, s);
          }
        }
        const Vl = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
        class sa {
          constructor(t, s) {
            this._structArray = t, this._pos1 = s * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
          }
        }
        class re {
          constructor() {
            this.isTransferred = !1, this.capacity = -1, this.resize(0);
          }
          static serialize(t, s) {
            return t._trim(), s && (t.isTransferred = !0, s.push(t.arrayBuffer)), { length: t.length, arrayBuffer: t.arrayBuffer };
          }
          static deserialize(t) {
            const s = Object.create(this.prototype);
            return s.arrayBuffer = t.arrayBuffer, s.length = t.length, s.capacity = t.arrayBuffer.byteLength / s.bytesPerElement, s._refreshViews(), s;
          }
          _trim() {
            this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
          }
          clear() {
            this.length = 0;
          }
          resize(t) {
            this.reserve(t), this.length = t;
          }
          reserve(t) {
            if (t > this.capacity) {
              this.capacity = Math.max(t, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
              const s = this.uint8;
              this._refreshViews(), s && this.uint8.set(s);
            }
          }
          _refreshViews() {
            throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
          }
        }
        function Ee(i, t = 1) {
          let s = 0, n = 0;
          return { members: i.map(((a) => {
            const M = Vl[a.type].BYTES_PER_ELEMENT, l = s = Wc(s, Math.max(t, M)), D = a.components || 1;
            return n = Math.max(n, M), s += M * D, { name: a.name, type: a.type, components: D, offset: l };
          })), size: Wc(s, Math.max(n, t)), alignment: t };
        }
        function Wc(i, t) {
          return Math.ceil(i / t) * t;
        }
        class ia extends re {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, s) {
            const n = this.length;
            return this.resize(n + 1), this.emplace(n, t, s);
          }
          emplace(t, s, n) {
            const a = 2 * t;
            return this.int16[a + 0] = s, this.int16[a + 1] = n, t;
          }
        }
        ia.prototype.bytesPerElement = 4, jt("StructArrayLayout2i4", ia);
        class ra extends re {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, s, n) {
            const a = this.length;
            return this.resize(a + 1), this.emplace(a, t, s, n);
          }
          emplace(t, s, n, a) {
            const M = 3 * t;
            return this.int16[M + 0] = s, this.int16[M + 1] = n, this.int16[M + 2] = a, t;
          }
        }
        ra.prototype.bytesPerElement = 6, jt("StructArrayLayout3i6", ra);
        class DM extends re {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, s, n, a) {
            const M = this.length;
            return this.resize(M + 1), this.emplace(M, t, s, n, a);
          }
          emplace(t, s, n, a, M) {
            const l = 4 * t;
            return this.int16[l + 0] = s, this.int16[l + 1] = n, this.int16[l + 2] = a, this.int16[l + 3] = M, t;
          }
        }
        DM.prototype.bytesPerElement = 8, jt("StructArrayLayout4i8", DM);
        class zM extends re {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, s, n, a, M, l) {
            const D = this.length;
            return this.resize(D + 1), this.emplace(D, t, s, n, a, M, l);
          }
          emplace(t, s, n, a, M, l, D) {
            const N = 6 * t;
            return this.int16[N + 0] = s, this.int16[N + 1] = n, this.int16[N + 2] = a, this.int16[N + 3] = M, this.int16[N + 4] = l, this.int16[N + 5] = D, t;
          }
        }
        zM.prototype.bytesPerElement = 12, jt("StructArrayLayout2i4i12", zM);
        class xi extends re {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, s, n, a, M, l) {
            const D = this.length;
            return this.resize(D + 1), this.emplace(D, t, s, n, a, M, l);
          }
          emplace(t, s, n, a, M, l, D) {
            const N = 4 * t, y = 8 * t;
            return this.int16[N + 0] = s, this.int16[N + 1] = n, this.uint8[y + 4] = a, this.uint8[y + 5] = M, this.uint8[y + 6] = l, this.uint8[y + 7] = D, t;
          }
        }
        xi.prototype.bytesPerElement = 8, jt("StructArrayLayout2i4ub8", xi);
        class un extends re {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t, s) {
            const n = this.length;
            return this.resize(n + 1), this.emplace(n, t, s);
          }
          emplace(t, s, n) {
            const a = 2 * t;
            return this.float32[a + 0] = s, this.float32[a + 1] = n, t;
          }
        }
        un.prototype.bytesPerElement = 8, jt("StructArrayLayout2f8", un);
        class na extends re {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t, s, n, a, M, l, D, N, y, w) {
            const T = this.length;
            return this.resize(T + 1), this.emplace(T, t, s, n, a, M, l, D, N, y, w);
          }
          emplace(t, s, n, a, M, l, D, N, y, w, T) {
            const x = 10 * t;
            return this.uint16[x + 0] = s, this.uint16[x + 1] = n, this.uint16[x + 2] = a, this.uint16[x + 3] = M, this.uint16[x + 4] = l, this.uint16[x + 5] = D, this.uint16[x + 6] = N, this.uint16[x + 7] = y, this.uint16[x + 8] = w, this.uint16[x + 9] = T, t;
          }
        }
        na.prototype.bytesPerElement = 20, jt("StructArrayLayout10ui20", na);
        class qa extends re {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t, s, n, a, M, l, D, N) {
            const y = this.length;
            return this.resize(y + 1), this.emplace(y, t, s, n, a, M, l, D, N);
          }
          emplace(t, s, n, a, M, l, D, N, y) {
            const w = 8 * t;
            return this.uint16[w + 0] = s, this.uint16[w + 1] = n, this.uint16[w + 2] = a, this.uint16[w + 3] = M, this.uint16[w + 4] = l, this.uint16[w + 5] = D, this.uint16[w + 6] = N, this.uint16[w + 7] = y, t;
          }
        }
        qa.prototype.bytesPerElement = 16, jt("StructArrayLayout8ui16", qa);
        class aa extends re {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t, s, n, a, M, l, D, N, y, w, T, x) {
            const A = this.length;
            return this.resize(A + 1), this.emplace(A, t, s, n, a, M, l, D, N, y, w, T, x);
          }
          emplace(t, s, n, a, M, l, D, N, y, w, T, x, A) {
            const m = 12 * t;
            return this.int16[m + 0] = s, this.int16[m + 1] = n, this.int16[m + 2] = a, this.int16[m + 3] = M, this.uint16[m + 4] = l, this.uint16[m + 5] = D, this.uint16[m + 6] = N, this.uint16[m + 7] = y, this.int16[m + 8] = w, this.int16[m + 9] = T, this.int16[m + 10] = x, this.int16[m + 11] = A, t;
          }
        }
        aa.prototype.bytesPerElement = 24, jt("StructArrayLayout4i4ui4i24", aa);
        class NM extends re {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t, s, n) {
            const a = this.length;
            return this.resize(a + 1), this.emplace(a, t, s, n);
          }
          emplace(t, s, n, a) {
            const M = 3 * t;
            return this.float32[M + 0] = s, this.float32[M + 1] = n, this.float32[M + 2] = a, t;
          }
        }
        NM.prototype.bytesPerElement = 12, jt("StructArrayLayout3f12", NM);
        class gn extends re {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
          }
          emplaceBack(t) {
            const s = this.length;
            return this.resize(s + 1), this.emplace(s, t);
          }
          emplace(t, s) {
            return this.uint32[1 * t + 0] = s, t;
          }
        }
        gn.prototype.bytesPerElement = 4, jt("StructArrayLayout1ul4", gn);
        class Ar extends re {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t, s, n, a, M, l, D, N, y) {
            const w = this.length;
            return this.resize(w + 1), this.emplace(w, t, s, n, a, M, l, D, N, y);
          }
          emplace(t, s, n, a, M, l, D, N, y, w) {
            const T = 10 * t, x = 5 * t;
            return this.int16[T + 0] = s, this.int16[T + 1] = n, this.int16[T + 2] = a, this.int16[T + 3] = M, this.int16[T + 4] = l, this.int16[T + 5] = D, this.uint32[x + 3] = N, this.uint16[T + 8] = y, this.uint16[T + 9] = w, t;
          }
        }
        Ar.prototype.bytesPerElement = 20, jt("StructArrayLayout6i1ul2ui20", Ar);
        class dM extends re {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, s, n, a, M, l) {
            const D = this.length;
            return this.resize(D + 1), this.emplace(D, t, s, n, a, M, l);
          }
          emplace(t, s, n, a, M, l, D) {
            const N = 6 * t;
            return this.int16[N + 0] = s, this.int16[N + 1] = n, this.int16[N + 2] = a, this.int16[N + 3] = M, this.int16[N + 4] = l, this.int16[N + 5] = D, t;
          }
        }
        dM.prototype.bytesPerElement = 12, jt("StructArrayLayout2i2i2i12", dM);
        class $a extends re {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, s, n, a, M) {
            const l = this.length;
            return this.resize(l + 1), this.emplace(l, t, s, n, a, M);
          }
          emplace(t, s, n, a, M, l) {
            const D = 4 * t, N = 8 * t;
            return this.float32[D + 0] = s, this.float32[D + 1] = n, this.float32[D + 2] = a, this.int16[N + 6] = M, this.int16[N + 7] = l, t;
          }
        }
        $a.prototype.bytesPerElement = 16, jt("StructArrayLayout2f1f2i16", $a);
        class mr extends re {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, s, n, a, M, l) {
            const D = this.length;
            return this.resize(D + 1), this.emplace(D, t, s, n, a, M, l);
          }
          emplace(t, s, n, a, M, l, D) {
            const N = 16 * t, y = 4 * t, w = 8 * t;
            return this.uint8[N + 0] = s, this.uint8[N + 1] = n, this.float32[y + 1] = a, this.float32[y + 2] = M, this.int16[w + 6] = l, this.int16[w + 7] = D, t;
          }
        }
        mr.prototype.bytesPerElement = 16, jt("StructArrayLayout2ub2f2i16", mr);
        class Ka extends re {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t, s, n) {
            const a = this.length;
            return this.resize(a + 1), this.emplace(a, t, s, n);
          }
          emplace(t, s, n, a) {
            const M = 3 * t;
            return this.uint16[M + 0] = s, this.uint16[M + 1] = n, this.uint16[M + 2] = a, t;
          }
        }
        Ka.prototype.bytesPerElement = 6, jt("StructArrayLayout3ui6", Ka);
        class yM extends re {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t, s, n, a, M, l, D, N, y, w, T, x, A, m, L, O, B) {
            const P = this.length;
            return this.resize(P + 1), this.emplace(P, t, s, n, a, M, l, D, N, y, w, T, x, A, m, L, O, B);
          }
          emplace(t, s, n, a, M, l, D, N, y, w, T, x, A, m, L, O, B, P) {
            const k = 24 * t, U = 12 * t, K = 48 * t;
            return this.int16[k + 0] = s, this.int16[k + 1] = n, this.uint16[k + 2] = a, this.uint16[k + 3] = M, this.uint32[U + 2] = l, this.uint32[U + 3] = D, this.uint32[U + 4] = N, this.uint16[k + 10] = y, this.uint16[k + 11] = w, this.uint16[k + 12] = T, this.float32[U + 7] = x, this.float32[U + 8] = A, this.uint8[K + 36] = m, this.uint8[K + 37] = L, this.uint8[K + 38] = O, this.uint32[U + 10] = B, this.int16[k + 22] = P, t;
          }
        }
        yM.prototype.bytesPerElement = 48, jt("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", yM);
        class to extends re {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t, s, n, a, M, l, D, N, y, w, T, x, A, m, L, O, B, P, k, U, K, et, ot, dt, Dt, yt, At, Tt) {
            const ft = this.length;
            return this.resize(ft + 1), this.emplace(ft, t, s, n, a, M, l, D, N, y, w, T, x, A, m, L, O, B, P, k, U, K, et, ot, dt, Dt, yt, At, Tt);
          }
          emplace(t, s, n, a, M, l, D, N, y, w, T, x, A, m, L, O, B, P, k, U, K, et, ot, dt, Dt, yt, At, Tt, ft) {
            const zt = 32 * t, bt = 16 * t;
            return this.int16[zt + 0] = s, this.int16[zt + 1] = n, this.int16[zt + 2] = a, this.int16[zt + 3] = M, this.int16[zt + 4] = l, this.int16[zt + 5] = D, this.int16[zt + 6] = N, this.int16[zt + 7] = y, this.uint16[zt + 8] = w, this.uint16[zt + 9] = T, this.uint16[zt + 10] = x, this.uint16[zt + 11] = A, this.uint16[zt + 12] = m, this.uint16[zt + 13] = L, this.uint16[zt + 14] = O, this.uint16[zt + 15] = B, this.uint16[zt + 16] = P, this.uint16[zt + 17] = k, this.uint16[zt + 18] = U, this.uint16[zt + 19] = K, this.uint16[zt + 20] = et, this.uint16[zt + 21] = ot, this.uint16[zt + 22] = dt, this.uint32[bt + 12] = Dt, this.float32[bt + 13] = yt, this.float32[bt + 14] = At, this.uint16[zt + 30] = Tt, this.uint16[zt + 31] = ft, t;
          }
        }
        to.prototype.bytesPerElement = 64, jt("StructArrayLayout8i15ui1ul2f2ui64", to);
        class eo extends re {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t) {
            const s = this.length;
            return this.resize(s + 1), this.emplace(s, t);
          }
          emplace(t, s) {
            return this.float32[1 * t + 0] = s, t;
          }
        }
        eo.prototype.bytesPerElement = 4, jt("StructArrayLayout1f4", eo);
        class g extends re {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t, s, n) {
            const a = this.length;
            return this.resize(a + 1), this.emplace(a, t, s, n);
          }
          emplace(t, s, n, a) {
            const M = 3 * t;
            return this.uint16[6 * t + 0] = s, this.float32[M + 1] = n, this.float32[M + 2] = a, t;
          }
        }
        g.prototype.bytesPerElement = 12, jt("StructArrayLayout1ui2f12", g);
        class e extends re {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t, s, n) {
            const a = this.length;
            return this.resize(a + 1), this.emplace(a, t, s, n);
          }
          emplace(t, s, n, a) {
            const M = 4 * t;
            return this.uint32[2 * t + 0] = s, this.uint16[M + 2] = n, this.uint16[M + 3] = a, t;
          }
        }
        e.prototype.bytesPerElement = 8, jt("StructArrayLayout1ul2ui8", e);
        class r extends re {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t, s) {
            const n = this.length;
            return this.resize(n + 1), this.emplace(n, t, s);
          }
          emplace(t, s, n) {
            const a = 2 * t;
            return this.uint16[a + 0] = s, this.uint16[a + 1] = n, t;
          }
        }
        r.prototype.bytesPerElement = 4, jt("StructArrayLayout2ui4", r);
        class o extends re {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t) {
            const s = this.length;
            return this.resize(s + 1), this.emplace(s, t);
          }
          emplace(t, s) {
            return this.uint16[1 * t + 0] = s, t;
          }
        }
        o.prototype.bytesPerElement = 2, jt("StructArrayLayout1ui2", o);
        class c extends re {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t, s, n, a) {
            const M = this.length;
            return this.resize(M + 1), this.emplace(M, t, s, n, a);
          }
          emplace(t, s, n, a, M) {
            const l = 4 * t;
            return this.float32[l + 0] = s, this.float32[l + 1] = n, this.float32[l + 2] = a, this.float32[l + 3] = M, t;
          }
        }
        c.prototype.bytesPerElement = 16, jt("StructArrayLayout4f16", c);
        class h extends sa {
          get anchorPointX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorPointY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get x1() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get y1() {
            return this._structArray.int16[this._pos2 + 3];
          }
          get x2() {
            return this._structArray.int16[this._pos2 + 4];
          }
          get y2() {
            return this._structArray.int16[this._pos2 + 5];
          }
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 3];
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 8];
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 9];
          }
          get anchorPoint() {
            return new mt(this.anchorPointX, this.anchorPointY);
          }
        }
        h.prototype.size = 20;
        class z extends Ar {
          get(t) {
            return new h(this, t);
          }
        }
        jt("CollisionBoxArray", z);
        class d extends sa {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get glyphStartIndex() {
            return this._structArray.uint16[this._pos2 + 2];
          }
          get numGlyphs() {
            return this._structArray.uint16[this._pos2 + 3];
          }
          get vertexStartIndex() {
            return this._structArray.uint32[this._pos4 + 2];
          }
          get lineStartIndex() {
            return this._structArray.uint32[this._pos4 + 3];
          }
          get lineLength() {
            return this._structArray.uint32[this._pos4 + 4];
          }
          get segment() {
            return this._structArray.uint16[this._pos2 + 10];
          }
          get lowerSize() {
            return this._structArray.uint16[this._pos2 + 11];
          }
          get upperSize() {
            return this._structArray.uint16[this._pos2 + 12];
          }
          get lineOffsetX() {
            return this._structArray.float32[this._pos4 + 7];
          }
          get lineOffsetY() {
            return this._structArray.float32[this._pos4 + 8];
          }
          get writingMode() {
            return this._structArray.uint8[this._pos1 + 36];
          }
          get placedOrientation() {
            return this._structArray.uint8[this._pos1 + 37];
          }
          set placedOrientation(t) {
            this._structArray.uint8[this._pos1 + 37] = t;
          }
          get hidden() {
            return this._structArray.uint8[this._pos1 + 38];
          }
          set hidden(t) {
            this._structArray.uint8[this._pos1 + 38] = t;
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 10];
          }
          set crossTileID(t) {
            this._structArray.uint32[this._pos4 + 10] = t;
          }
          get associatedIconIndex() {
            return this._structArray.int16[this._pos2 + 22];
          }
        }
        d.prototype.size = 48;
        class I extends yM {
          get(t) {
            return new d(this, t);
          }
        }
        jt("PlacedSymbolArray", I);
        class p extends sa {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get rightJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get centerJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 3];
          }
          get leftJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 4];
          }
          get verticalPlacedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 5];
          }
          get placedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 6];
          }
          get verticalPlacedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 7];
          }
          get key() {
            return this._structArray.uint16[this._pos2 + 8];
          }
          get textBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 9];
          }
          get textBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 10];
          }
          get verticalTextBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 11];
          }
          get verticalTextBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 12];
          }
          get iconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 13];
          }
          get iconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 14];
          }
          get verticalIconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 15];
          }
          get verticalIconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 16];
          }
          get featureIndex() {
            return this._structArray.uint16[this._pos2 + 17];
          }
          get numHorizontalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 18];
          }
          get numVerticalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 19];
          }
          get numIconVertices() {
            return this._structArray.uint16[this._pos2 + 20];
          }
          get numVerticalIconVertices() {
            return this._structArray.uint16[this._pos2 + 21];
          }
          get useRuntimeCollisionCircles() {
            return this._structArray.uint16[this._pos2 + 22];
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 12];
          }
          set crossTileID(t) {
            this._structArray.uint32[this._pos4 + 12] = t;
          }
          get textBoxScale() {
            return this._structArray.float32[this._pos4 + 13];
          }
          get collisionCircleDiameter() {
            return this._structArray.float32[this._pos4 + 14];
          }
          get textAnchorOffsetStartIndex() {
            return this._structArray.uint16[this._pos2 + 30];
          }
          get textAnchorOffsetEndIndex() {
            return this._structArray.uint16[this._pos2 + 31];
          }
        }
        p.prototype.size = 64;
        class f extends to {
          get(t) {
            return new p(this, t);
          }
        }
        jt("SymbolInstanceArray", f);
        class _ extends eo {
          getoffsetX(t) {
            return this.float32[1 * t + 0];
          }
        }
        jt("GlyphOffsetArray", _);
        class j extends ra {
          getx(t) {
            return this.int16[3 * t + 0];
          }
          gety(t) {
            return this.int16[3 * t + 1];
          }
          gettileUnitDistanceFromAnchor(t) {
            return this.int16[3 * t + 2];
          }
        }
        jt("SymbolLineVertexArray", j);
        class C extends sa {
          get textAnchor() {
            return this._structArray.uint16[this._pos2 + 0];
          }
          get textOffset0() {
            return this._structArray.float32[this._pos4 + 1];
          }
          get textOffset1() {
            return this._structArray.float32[this._pos4 + 2];
          }
        }
        C.prototype.size = 12;
        class v extends g {
          get(t) {
            return new C(this, t);
          }
        }
        jt("TextAnchorOffsetArray", v);
        class F extends sa {
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 0];
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 2];
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 3];
          }
        }
        F.prototype.size = 8;
        class Y extends e {
          get(t) {
            return new F(this, t);
          }
        }
        jt("FeatureIndexArray", Y);
        class W extends ia {
        }
        class Z extends ia {
        }
        class J extends ia {
        }
        class R extends zM {
        }
        class q extends xi {
        }
        class $ extends un {
        }
        class G extends na {
        }
        class st extends qa {
        }
        class ct extends aa {
        }
        class nt extends NM {
        }
        class at extends gn {
        }
        class Mt extends dM {
        }
        class xt extends mr {
        }
        class wt extends Ka {
        }
        class Nt extends r {
        }
        const Ct = Ee([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: Ut } = Ct;
        class Yt {
          constructor(t = []) {
            this._forceNewSegmentOnNextPrepare = !1, this.segments = t;
          }
          prepareSegment(t, s, n, a) {
            const M = this.segments[this.segments.length - 1];
            return t > Yt.MAX_VERTEX_ARRAY_LENGTH && we(`Max vertices per segment is ${Yt.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t}. Consider using the \`fillLargeMeshArrays\` function if you require meshes with more than ${Yt.MAX_VERTEX_ARRAY_LENGTH} vertices.`), this._forceNewSegmentOnNextPrepare || !M || M.vertexLength + t > Yt.MAX_VERTEX_ARRAY_LENGTH || M.sortKey !== a ? this.createNewSegment(s, n, a) : M;
          }
          createNewSegment(t, s, n) {
            const a = { vertexOffset: t.length, primitiveOffset: s.length, vertexLength: 0, primitiveLength: 0, vaos: {} };
            return n !== void 0 && (a.sortKey = n), this._forceNewSegmentOnNextPrepare = !1, this.segments.push(a), a;
          }
          getOrCreateLatestSegment(t, s, n) {
            return this.prepareSegment(0, t, s, n);
          }
          forceNewSegmentOnNextPrepare() {
            this._forceNewSegmentOnNextPrepare = !0;
          }
          get() {
            return this.segments;
          }
          destroy() {
            for (const t of this.segments) for (const s in t.vaos) t.vaos[s].destroy();
          }
          static simpleSegment(t, s, n, a) {
            return new Yt([{ vertexOffset: t, primitiveOffset: s, vertexLength: n, primitiveLength: a, vaos: {}, sortKey: 0 }]);
          }
        }
        function ge(i, t) {
          return 256 * (i = Ds(Math.floor(i), 0, 255)) + Ds(Math.floor(t), 0, 255);
        }
        Yt.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, jt("SegmentVector", Yt);
        const he = Ee([{ name: "a_pattern_from", components: 4, type: "Uint16" }, { name: "a_pattern_to", components: 4, type: "Uint16" }, { name: "a_pixel_ratio_from", components: 1, type: "Uint16" }, { name: "a_pixel_ratio_to", components: 1, type: "Uint16" }]), xe = Ee([{ name: "a_dasharray_from", components: 4, type: "Uint16" }, { name: "a_dasharray_to", components: 4, type: "Uint16" }]);
        var ne, Ue, de, ve = { exports: {} }, be = { exports: {} }, Be = { exports: {} }, _s = (function() {
          if (de) return ve.exports;
          de = 1;
          var i = (ne || (ne = 1, be.exports = function(s, n) {
            var a, M, l, D, N, y, w, T;
            for (M = s.length - (a = 3 & s.length), l = n, N = 3432918353, y = 461845907, T = 0; T < M; ) w = 255 & s.charCodeAt(T) | (255 & s.charCodeAt(++T)) << 8 | (255 & s.charCodeAt(++T)) << 16 | (255 & s.charCodeAt(++T)) << 24, ++T, l = 27492 + (65535 & (D = 5 * (65535 & (l = (l ^= w = (65535 & (w = (w = (65535 & w) * N + (((w >>> 16) * N & 65535) << 16) & 4294967295) << 15 | w >>> 17)) * y + (((w >>> 16) * y & 65535) << 16) & 4294967295) << 13 | l >>> 19)) + ((5 * (l >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (D >>> 16) & 65535) << 16);
            switch (w = 0, a) {
              case 3:
                w ^= (255 & s.charCodeAt(T + 2)) << 16;
              case 2:
                w ^= (255 & s.charCodeAt(T + 1)) << 8;
              case 1:
                l ^= w = (65535 & (w = (w = (65535 & (w ^= 255 & s.charCodeAt(T))) * N + (((w >>> 16) * N & 65535) << 16) & 4294967295) << 15 | w >>> 17)) * y + (((w >>> 16) * y & 65535) << 16) & 4294967295;
            }
            return l ^= s.length, l = 2246822507 * (65535 & (l ^= l >>> 16)) + ((2246822507 * (l >>> 16) & 65535) << 16) & 4294967295, l = 3266489909 * (65535 & (l ^= l >>> 13)) + ((3266489909 * (l >>> 16) & 65535) << 16) & 4294967295, (l ^= l >>> 16) >>> 0;
          }), be.exports), t = (Ue || (Ue = 1, Be.exports = function(s, n) {
            for (var a, M = s.length, l = n ^ M, D = 0; M >= 4; ) a = 1540483477 * (65535 & (a = 255 & s.charCodeAt(D) | (255 & s.charCodeAt(++D)) << 8 | (255 & s.charCodeAt(++D)) << 16 | (255 & s.charCodeAt(++D)) << 24)) + ((1540483477 * (a >>> 16) & 65535) << 16), l = 1540483477 * (65535 & l) + ((1540483477 * (l >>> 16) & 65535) << 16) ^ (a = 1540483477 * (65535 & (a ^= a >>> 24)) + ((1540483477 * (a >>> 16) & 65535) << 16)), M -= 4, ++D;
            switch (M) {
              case 3:
                l ^= (255 & s.charCodeAt(D + 2)) << 16;
              case 2:
                l ^= (255 & s.charCodeAt(D + 1)) << 8;
              case 1:
                l = 1540483477 * (65535 & (l ^= 255 & s.charCodeAt(D))) + ((1540483477 * (l >>> 16) & 65535) << 16);
            }
            return l = 1540483477 * (65535 & (l ^= l >>> 13)) + ((1540483477 * (l >>> 16) & 65535) << 16), (l ^= l >>> 15) >>> 0;
          }), Be.exports);
          return ve.exports = i, ve.exports.murmur3 = i, ve.exports.murmur2 = t, ve.exports;
        })(), Ai = Qi(_s);
        class Ni {
          constructor() {
            this.ids = [], this.positions = [], this.indexed = !1;
          }
          add(t, s, n, a) {
            this.ids.push($i(t)), this.positions.push(s, n, a);
          }
          getPositions(t) {
            if (!this.indexed) throw new Error("Trying to get index, but feature positions are not indexed");
            const s = $i(t);
            let n = 0, a = this.ids.length - 1;
            for (; n < a; ) {
              const l = n + a >> 1;
              this.ids[l] >= s ? a = l : n = l + 1;
            }
            const M = [];
            for (; this.ids[n] === s; ) M.push({ index: this.positions[3 * n], start: this.positions[3 * n + 1], end: this.positions[3 * n + 2] }), n++;
            return M;
          }
          static serialize(t, s) {
            const n = new Float64Array(t.ids), a = new Uint32Array(t.positions);
            return Ki(n, a, 0, n.length - 1), s && s.push(n.buffer, a.buffer), { ids: n, positions: a };
          }
          static deserialize(t) {
            const s = new Ni();
            return s.ids = t.ids, s.positions = t.positions, s.indexed = !0, s;
          }
        }
        function $i(i) {
          const t = +i;
          return !isNaN(t) && t <= Number.MAX_SAFE_INTEGER ? t : Ai(String(i));
        }
        function Ki(i, t, s, n) {
          for (; s < n; ) {
            const a = i[s + n >> 1];
            let M = s - 1, l = n + 1;
            for (; ; ) {
              do
                M++;
              while (i[M] < a);
              do
                l--;
              while (i[l] > a);
              if (M >= l) break;
              jr(i, M, l), jr(t, 3 * M, 3 * l), jr(t, 3 * M + 1, 3 * l + 1), jr(t, 3 * M + 2, 3 * l + 2);
            }
            l - s < n - l ? (Ki(i, t, s, l), s = l + 1) : (Ki(i, t, l + 1, n), n = l);
          }
        }
        function jr(i, t, s) {
          const n = i[t];
          i[t] = i[s], i[s] = n;
        }
        jt("FeaturePositionMap", Ni);
        class Ws {
          constructor(t, s) {
            this.gl = t.gl, this.location = s;
          }
        }
        class mi extends Ws {
          constructor(t, s) {
            super(t, s), this.current = 0;
          }
          set(t) {
            this.current !== t && (this.current = t, this.gl.uniform1f(this.location, t));
          }
        }
        class bs extends Ws {
          constructor(t, s) {
            super(t, s), this.current = [0, 0, 0, 0];
          }
          set(t) {
            t[0] === this.current[0] && t[1] === this.current[1] && t[2] === this.current[2] && t[3] === this.current[3] || (this.current = t, this.gl.uniform4f(this.location, t[0], t[1], t[2], t[3]));
          }
        }
        class ji extends Ws {
          constructor(t, s) {
            super(t, s), this.current = Vt.transparent;
          }
          set(t) {
            t.r === this.current.r && t.g === this.current.g && t.b === this.current.b && t.a === this.current.a || (this.current = t, this.gl.uniform4f(this.location, t.r, t.g, t.b, t.a));
          }
        }
        const _r = new Float32Array(16);
        function Lr(i) {
          return [ge(255 * i.r, 255 * i.g), ge(255 * i.b, 255 * i.a)];
        }
        class Ce {
          constructor(t, s, n) {
            this.value = t, this.uniformNames = s.map(((a) => `u_${a}`)), this.type = n;
          }
          setUniform(t, s, n) {
            t.set(n.constantOr(this.value));
          }
          getBinding(t, s, n) {
            return this.type === "color" ? new ji(t, s) : new mi(t, s);
          }
        }
        class Ae {
          constructor(t, s) {
            this.uniformNames = s.map(((n) => `u_${n}`)), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
          }
          setConstantPatternPositions(t, s) {
            this.pixelRatioFrom = s.pixelRatio, this.pixelRatioTo = t.pixelRatio, this.patternFrom = s.tlbr, this.patternTo = t.tlbr;
          }
          setConstantDashPositions(t, s) {
            this.dashTo = [0, t.y, t.height, t.width], this.dashFrom = [0, s.y, s.height, s.width];
          }
          setUniform(t, s, n, a) {
            let M = null;
            a === "u_pattern_to" ? M = this.patternTo : a === "u_pattern_from" ? M = this.patternFrom : a === "u_dasharray_to" ? M = this.dashTo : a === "u_dasharray_from" ? M = this.dashFrom : a === "u_pixel_ratio_to" ? M = this.pixelRatioTo : a === "u_pixel_ratio_from" && (M = this.pixelRatioFrom), M !== null && t.set(M);
          }
          getBinding(t, s, n) {
            return n.substr(0, 9) === "u_pattern" || n.substr(0, 12) === "u_dasharray_" ? new bs(t, s) : new mi(t, s);
          }
        }
        class Xe {
          constructor(t, s, n, a) {
            this.expression = t, this.type = n, this.maxValue = 0, this.paintVertexAttributes = s.map(((M) => ({ name: `a_${M}`, type: "Float32", components: n === "color" ? 2 : 1, offset: 0 }))), this.paintVertexArray = new a();
          }
          populatePaintArray(t, s, n) {
            const a = this.paintVertexArray.length, M = this.expression.evaluate(new ie(0, n), s, {}, n.canonical, [], n.formattedSection);
            this.paintVertexArray.resize(t), this._setPaintValue(a, t, M);
          }
          updatePaintArray(t, s, n, a, M) {
            const l = this.expression.evaluate(new ie(0, M), n, a);
            this._setPaintValue(t, s, l);
          }
          _setPaintValue(t, s, n) {
            if (this.type === "color") {
              const a = Lr(n);
              for (let M = t; M < s; M++) this.paintVertexArray.emplace(M, a[0], a[1]);
            } else {
              for (let a = t; a < s; a++) this.paintVertexArray.emplace(a, n);
              this.maxValue = Math.max(this.maxValue, Math.abs(n));
            }
          }
          upload(t) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
        }
        class ae {
          constructor(t, s, n, a, M, l) {
            this.expression = t, this.uniformNames = s.map(((D) => `u_${D}_t`)), this.type = n, this.useIntegerZoom = a, this.zoom = M, this.maxValue = 0, this.paintVertexAttributes = s.map(((D) => ({ name: `a_${D}`, type: "Float32", components: n === "color" ? 4 : 2, offset: 0 }))), this.paintVertexArray = new l();
          }
          populatePaintArray(t, s, n) {
            const a = this.expression.evaluate(new ie(this.zoom, n), s, {}, n.canonical, [], n.formattedSection), M = this.expression.evaluate(new ie(this.zoom + 1, n), s, {}, n.canonical, [], n.formattedSection), l = this.paintVertexArray.length;
            this.paintVertexArray.resize(t), this._setPaintValue(l, t, a, M);
          }
          updatePaintArray(t, s, n, a, M) {
            const l = this.expression.evaluate(new ie(this.zoom, M), n, a), D = this.expression.evaluate(new ie(this.zoom + 1, M), n, a);
            this._setPaintValue(t, s, l, D);
          }
          _setPaintValue(t, s, n, a) {
            if (this.type === "color") {
              const M = Lr(n), l = Lr(a);
              for (let D = t; D < s; D++) this.paintVertexArray.emplace(D, M[0], M[1], l[0], l[1]);
            } else {
              for (let M = t; M < s; M++) this.paintVertexArray.emplace(M, n, a);
              this.maxValue = Math.max(this.maxValue, Math.abs(n), Math.abs(a));
            }
          }
          upload(t) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
          setUniform(t, s) {
            const n = this.useIntegerZoom ? Math.floor(s.zoom) : s.zoom, a = Ds(this.expression.interpolationFactor(n, this.zoom, this.zoom + 1), 0, 1);
            t.set(a);
          }
          getBinding(t, s, n) {
            return new mi(t, s);
          }
        }
        class tr {
          constructor(t, s, n, a, M, l) {
            this.expression = t, this.type = s, this.useIntegerZoom = n, this.zoom = a, this.layerId = l, this.zoomInPaintVertexArray = new M(), this.zoomOutPaintVertexArray = new M();
          }
          populatePaintArray(t, s, n) {
            const a = this.zoomInPaintVertexArray.length;
            this.zoomInPaintVertexArray.resize(t), this.zoomOutPaintVertexArray.resize(t), this._setPaintValues(a, t, this.getPositionIds(s), n);
          }
          updatePaintArray(t, s, n, a, M) {
            this._setPaintValues(t, s, this.getPositionIds(n), M);
          }
          _setPaintValues(t, s, n, a) {
            const M = this.getPositions(a);
            if (!M || !n) return;
            const l = M[n.min], D = M[n.mid], N = M[n.max];
            if (l && D && N) for (let y = t; y < s; y++) this.emplace(this.zoomInPaintVertexArray, y, D, l), this.emplace(this.zoomOutPaintVertexArray, y, D, N);
          }
          upload(t) {
            if (this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer) {
              const s = this.getVertexAttributes();
              this.zoomInPaintVertexBuffer = t.createVertexBuffer(this.zoomInPaintVertexArray, s, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = t.createVertexBuffer(this.zoomOutPaintVertexArray, s, this.expression.isStateDependent);
            }
          }
          destroy() {
            this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
          }
        }
        class Pc extends tr {
          getPositions(t) {
            return t.imagePositions;
          }
          getPositionIds(t) {
            return t.patterns && t.patterns[this.layerId];
          }
          getVertexAttributes() {
            return he.members;
          }
          emplace(t, s, n, a) {
            t.emplace(s, n.tlbr[0], n.tlbr[1], n.tlbr[2], n.tlbr[3], a.tlbr[0], a.tlbr[1], a.tlbr[2], a.tlbr[3], n.pixelRatio, a.pixelRatio);
          }
        }
        class Rc extends tr {
          getPositions(t) {
            return t.dashPositions;
          }
          getPositionIds(t) {
            return t.dashes && t.dashes[this.layerId];
          }
          getVertexAttributes() {
            return xe.members;
          }
          emplace(t, s, n, a) {
            t.emplace(s, 0, n.y, n.height, n.width, 0, a.y, a.height, a.width);
          }
        }
        class Zc {
          constructor(t, s, n) {
            this.binders = {}, this._buffers = [];
            const a = [];
            for (const M in t.paint._values) {
              if (!n(M)) continue;
              const l = t.paint.get(M);
              if (!(l instanceof ei && rn(l.property.specification))) continue;
              const D = Gl(M, t.type), N = l.value, y = l.property.specification.type, w = l.property.useIntegerZoom, T = l.property.specification["property-type"], x = T === "cross-faded" || T === "cross-faded-data-driven";
              if (N.kind === "constant") this.binders[M] = x ? new Ae(N.value, D) : new Ce(N.value, D, y), a.push(`/u_${M}`);
              else if (N.kind === "source" || x) {
                const A = er(M, y, "source");
                this.binders[M] = x ? M === "line-dasharray" ? new Rc(N, y, w, s, A, t.id) : new Pc(N, y, w, s, A, t.id) : new Xe(N, D, y, A), a.push(`/a_${M}`);
              } else {
                const A = er(M, y, "composite");
                this.binders[M] = new ae(N, D, y, w, s, A), a.push(`/z_${M}`);
              }
            }
            this.cacheKey = a.sort().join("");
          }
          getMaxValue(t) {
            const s = this.binders[t];
            return s instanceof Xe || s instanceof ae ? s.maxValue : 0;
          }
          populatePaintArrays(t, s, n) {
            for (const a in this.binders) {
              const M = this.binders[a];
              (M instanceof Xe || M instanceof ae || M instanceof tr) && M.populatePaintArray(t, s, n);
            }
          }
          setConstantPatternPositions(t, s) {
            for (const n in this.binders) {
              const a = this.binders[n];
              a instanceof Ae && a.setConstantPatternPositions(t, s);
            }
          }
          setConstantDashPositions(t, s) {
            for (const n in this.binders) {
              const a = this.binders[n];
              a instanceof Ae && a.setConstantDashPositions(t, s);
            }
          }
          updatePaintArrays(t, s, n, a, M) {
            let l = !1;
            for (const D in t) {
              const N = s.getPositions(D);
              for (const y of N) {
                const w = n.feature(y.index);
                for (const T in this.binders) {
                  const x = this.binders[T];
                  if ((x instanceof Xe || x instanceof ae || x instanceof tr) && x.expression.isStateDependent === !0) {
                    const A = a.paint.get(T);
                    x.expression = A.value, x.updatePaintArray(y.start, y.end, w, t[D], M), l = !0;
                  }
                }
              }
            }
            return l;
          }
          defines() {
            const t = [];
            for (const s in this.binders) {
              const n = this.binders[s];
              (n instanceof Ce || n instanceof Ae) && t.push(...n.uniformNames.map(((a) => `#define HAS_UNIFORM_${a}`)));
            }
            return t;
          }
          getBinderAttributes() {
            const t = [];
            for (const s in this.binders) {
              const n = this.binders[s];
              if (n instanceof Xe || n instanceof ae) for (let a = 0; a < n.paintVertexAttributes.length; a++) t.push(n.paintVertexAttributes[a].name);
              else if (n instanceof tr) {
                const a = n.getVertexAttributes();
                for (const M of a) t.push(M.name);
              }
            }
            return t;
          }
          getBinderUniforms() {
            const t = [];
            for (const s in this.binders) {
              const n = this.binders[s];
              if (n instanceof Ce || n instanceof Ae || n instanceof ae) for (const a of n.uniformNames) t.push(a);
            }
            return t;
          }
          getPaintVertexBuffers() {
            return this._buffers;
          }
          getUniforms(t, s) {
            const n = [];
            for (const a in this.binders) {
              const M = this.binders[a];
              if (M instanceof Ce || M instanceof Ae || M instanceof ae) {
                for (const l of M.uniformNames) if (s[l]) {
                  const D = M.getBinding(t, s[l], l);
                  n.push({ name: l, property: a, binding: D });
                }
              }
            }
            return n;
          }
          setUniforms(t, s, n, a) {
            for (const { name: M, property: l, binding: D } of s) this.binders[l].setUniform(D, a, n.get(l), M);
          }
          updatePaintBuffers(t) {
            this._buffers = [];
            for (const s in this.binders) {
              const n = this.binders[s];
              if (t && n instanceof tr) {
                const a = t.fromScale === 2 ? n.zoomInPaintVertexBuffer : n.zoomOutPaintVertexBuffer;
                a && this._buffers.push(a);
              } else (n instanceof Xe || n instanceof ae) && n.paintVertexBuffer && this._buffers.push(n.paintVertexBuffer);
            }
          }
          upload(t) {
            for (const s in this.binders) {
              const n = this.binders[s];
              (n instanceof Xe || n instanceof ae || n instanceof tr) && n.upload(t);
            }
            this.updatePaintBuffers();
          }
          destroy() {
            for (const t in this.binders) {
              const s = this.binders[t];
              (s instanceof Xe || s instanceof ae || s instanceof tr) && s.destroy();
            }
          }
        }
        class Cr {
          constructor(t, s, n = () => !0) {
            this.programConfigurations = {};
            for (const a of t) this.programConfigurations[a.id] = new Zc(a, s, n);
            this.needsUpload = !1, this._featureMap = new Ni(), this._bufferOffset = 0;
          }
          populatePaintArrays(t, s, n, a) {
            for (const M in this.programConfigurations) this.programConfigurations[M].populatePaintArrays(t, s, a);
            s.id !== void 0 && this._featureMap.add(s.id, n, this._bufferOffset, t), this._bufferOffset = t, this.needsUpload = !0;
          }
          updatePaintArrays(t, s, n, a) {
            for (const M of n) this.needsUpload = this.programConfigurations[M.id].updatePaintArrays(t, this._featureMap, s, M, a) || this.needsUpload;
          }
          get(t) {
            return this.programConfigurations[t];
          }
          upload(t) {
            if (this.needsUpload) {
              for (const s in this.programConfigurations) this.programConfigurations[s].upload(t);
              this.needsUpload = !1;
            }
          }
          destroy() {
            for (const t in this.programConfigurations) this.programConfigurations[t].destroy();
          }
        }
        function Gl(i, t) {
          return { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-dasharray": ["dasharray_to", "dasharray_from"], "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"] }[i] || [i.replace(`${t}-`, "").replace(/-/g, "_")];
        }
        function er(i, t, s) {
          const n = { color: { source: un, composite: c }, number: { source: eo, composite: un } }, a = (function(M) {
            return { "line-pattern": { source: G, composite: G }, "fill-pattern": { source: G, composite: G }, "fill-extrusion-pattern": { source: G, composite: G }, "line-dasharray": { source: st, composite: st } }[M];
          })(i);
          return a && a[s] || n[t][s];
        }
        jt("ConstantBinder", Ce), jt("CrossFadedConstantBinder", Ae), jt("SourceExpressionBinder", Xe), jt("CrossFadedPatternBinder", Pc), jt("CrossFadedDasharrayBinder", Rc), jt("CompositeExpressionBinder", ae), jt("ProgramConfiguration", Zc, { omit: ["_buffers"] }), jt("ProgramConfigurationSet", Cr);
        const so = Math.pow(2, 14) - 1, IM = -so - 1;
        function sr(i) {
          const t = se / i.extent, s = i.loadGeometry();
          for (let n = 0; n < s.length; n++) {
            const a = s[n];
            for (let M = 0; M < a.length; M++) {
              const l = a[M], D = Math.round(l.x * t), N = Math.round(l.y * t);
              l.x = Ds(D, IM, so), l.y = Ds(N, IM, so), (D < l.x || D > l.x + 1 || N < l.y || N > l.y + 1) && we("Geometry exceeds allowed extent, reduce your vector tile buffer size");
            }
          }
          return s;
        }
        function _i(i, t) {
          return { type: i.type, id: i.id, properties: i.properties, geometry: t ? sr(i) : [] };
        }
        const wM = -32768;
        function pM(i, t, s, n, a) {
          i.emplaceBack(wM + 8 * t + n, wM + 8 * s + a);
        }
        class Hl {
          constructor(t) {
            this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(((s) => s.id)), this.index = t.index, this.hasDependencies = !1, this.layoutVertexArray = new Z(), this.indexArray = new wt(), this.segments = new Yt(), this.programConfigurations = new Cr(t.layers, t.zoom), this.stateDependentLayerIds = this.layers.filter(((s) => s.isStateDependent())).map(((s) => s.id));
          }
          populate(t, s, n) {
            const a = this.layers[0], M = [];
            let l = null, D = !1, N = a.type === "heatmap";
            if (a.type === "circle") {
              const w = a;
              l = w.layout.get("circle-sort-key"), D = !l.isConstant(), N = N || w.paint.get("circle-pitch-alignment") === "map";
            }
            const y = N ? s.subdivisionGranularity.circle : 1;
            for (const { feature: w, id: T, index: x, sourceLayerIndex: A } of t) {
              const m = this.layers[0]._featureFilter.needGeometry, L = _i(w, m);
              if (!this.layers[0]._featureFilter.filter(new ie(this.zoom), L, n)) continue;
              const O = D ? l.evaluate(L, {}, n) : void 0, B = { id: T, properties: w.properties, type: w.type, sourceLayerIndex: A, index: x, geometry: m ? L.geometry : sr(w), patterns: {}, sortKey: O };
              M.push(B);
            }
            D && M.sort(((w, T) => w.sortKey - T.sortKey));
            for (const w of M) {
              const { geometry: T, index: x, sourceLayerIndex: A } = w, m = t[x].feature;
              this.addFeature(w, T, x, n, y), s.featureIndex.insert(m, T, x, A, this.index);
            }
          }
          update(t, s, n) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, s, this.stateDependentLayers, { imagePositions: n });
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t) {
            this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Ut), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          addFeature(t, s, n, a, M = 1) {
            let l;
            switch (M) {
              case 1:
                l = [0, 7];
                break;
              case 3:
                l = [0, 2, 5, 7];
                break;
              case 5:
                l = [0, 1, 3, 4, 6, 7];
                break;
              case 7:
                l = [0, 1, 2, 3, 4, 5, 6, 7];
                break;
              default:
                throw new Error(`Invalid circle bucket granularity: ${M}; valid values are 1, 3, 5, 7.`);
            }
            const D = l.length;
            for (const N of s) for (const y of N) {
              const w = y.x, T = y.y;
              if (w < 0 || w >= se || T < 0 || T >= se) continue;
              const x = this.segments.prepareSegment(D * D, this.layoutVertexArray, this.indexArray, t.sortKey), A = x.vertexLength;
              for (let m = 0; m < D; m++) for (let L = 0; L < D; L++) pM(this.layoutVertexArray, w, T, l[L], l[m]);
              for (let m = 0; m < D - 1; m++) for (let L = 0; L < D - 1; L++) {
                const O = A + m * D + L, B = A + (m + 1) * D + L;
                this.indexArray.emplaceBack(O, B + 1, O + 1), this.indexArray.emplaceBack(O, B, B + 1);
              }
              x.vertexLength += D * D, x.primitiveLength += (D - 1) * (D - 1) * 2;
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, n, { imagePositions: {}, canonical: a });
          }
        }
        function Ru(i, t) {
          for (let s = 0; s < i.length; s++) if (io(t, i[s])) return !0;
          for (let s = 0; s < t.length; s++) if (io(i, t[s])) return !0;
          return !!Jl(i, t);
        }
        function Vc(i, t, s) {
          return !!io(i, t) || !!ql(t, i, s);
        }
        function Zu(i, t) {
          if (i.length === 1) return Gu(t, i[0]);
          for (let s = 0; s < t.length; s++) {
            const n = t[s];
            for (let a = 0; a < n.length; a++) if (io(i, n[a])) return !0;
          }
          for (let s = 0; s < i.length; s++) if (Gu(t, i[s])) return !0;
          for (let s = 0; s < t.length; s++) if (Jl(i, t[s])) return !0;
          return !1;
        }
        function Jh(i, t, s) {
          if (i.length > 1) {
            if (Jl(i, t)) return !0;
            for (let n = 0; n < t.length; n++) if (ql(t[n], i, s)) return !0;
          }
          for (let n = 0; n < i.length; n++) if (ql(i[n], t, s)) return !0;
          return !1;
        }
        function Jl(i, t) {
          if (i.length === 0 || t.length === 0) return !1;
          for (let s = 0; s < i.length - 1; s++) {
            const n = i[s], a = i[s + 1];
            for (let M = 0; M < t.length - 1; M++) if (qh(n, a, t[M], t[M + 1])) return !0;
          }
          return !1;
        }
        function qh(i, t, s, n) {
          return Gs(i, s, n) !== Gs(t, s, n) && Gs(i, t, s) !== Gs(i, t, n);
        }
        function ql(i, t, s) {
          const n = s * s;
          if (t.length === 1) return i.distSqr(t[0]) < n;
          for (let a = 1; a < t.length; a++) if (Vu(i, t[a - 1], t[a]) < n) return !0;
          return !1;
        }
        function Vu(i, t, s) {
          const n = t.distSqr(s);
          if (n === 0) return i.distSqr(t);
          const a = ((i.x - t.x) * (s.x - t.x) + (i.y - t.y) * (s.y - t.y)) / n;
          return i.distSqr(a < 0 ? t : a > 1 ? s : s.sub(t)._mult(a)._add(t));
        }
        function Gu(i, t) {
          let s, n, a, M = !1;
          for (let l = 0; l < i.length; l++) {
            s = i[l];
            for (let D = 0, N = s.length - 1; D < s.length; N = D++) n = s[D], a = s[N], n.y > t.y != a.y > t.y && t.x < (a.x - n.x) * (t.y - n.y) / (a.y - n.y) + n.x && (M = !M);
          }
          return M;
        }
        function io(i, t) {
          let s = !1;
          for (let n = 0, a = i.length - 1; n < i.length; a = n++) {
            const M = i[n], l = i[a];
            M.y > t.y != l.y > t.y && t.x < (l.x - M.x) * (t.y - M.y) / (l.y - M.y) + M.x && (s = !s);
          }
          return s;
        }
        function $h(i, t, s) {
          const n = s[0], a = s[2];
          if (i.x < n.x && t.x < n.x || i.x > a.x && t.x > a.x || i.y < n.y && t.y < n.y || i.y > a.y && t.y > a.y) return !1;
          const M = Gs(i, t, s[0]);
          return M !== Gs(i, t, s[1]) || M !== Gs(i, t, s[2]) || M !== Gs(i, t, s[3]);
        }
        function ro(i, t, s) {
          const n = t.paint.get(i).value;
          return n.kind === "constant" ? n.value : s.programConfigurations.get(t.id).getMaxValue(i);
        }
        function Gc(i) {
          return Math.sqrt(i[0] * i[0] + i[1] * i[1]);
        }
        function Hc(i, t, s, n, a) {
          if (!t[0] && !t[1]) return i;
          const M = mt.convert(t)._mult(a);
          s === "viewport" && M._rotate(-n);
          const l = [];
          for (let D = 0; D < i.length; D++) l.push(i[D].sub(M));
          return l;
        }
        function Kh({ queryGeometry: i, size: t }, s) {
          return Vc(i, s, t);
        }
        function tD({ queryGeometry: i, size: t, transform: s, unwrappedTileID: n, getElevation: a }, M) {
          return Vc(i, M, t * (s.projectTileCoordinates(M.x, M.y, n, a).signedDistanceFromCamera / s.cameraToCenterDistance));
        }
        function eD({ queryGeometry: i, size: t, transform: s, unwrappedTileID: n, getElevation: a }, M) {
          const l = s.projectTileCoordinates(M.x, M.y, n, a).signedDistanceFromCamera, D = t * (s.cameraToCenterDistance / l);
          return Vc(i, $l(M, s, n, a), D);
        }
        function sD({ queryGeometry: i, size: t, transform: s, unwrappedTileID: n, getElevation: a }, M) {
          return Vc(i, $l(M, s, n, a), t);
        }
        function Hu({ queryGeometry: i, size: t, transform: s, unwrappedTileID: n, getElevation: a, pitchAlignment: M = "map", pitchScale: l = "map" }, D) {
          const N = M === "map" ? l === "map" ? Kh : tD : l === "map" ? eD : sD, y = { queryGeometry: i, size: t, transform: s, unwrappedTileID: n, getElevation: a };
          for (const w of D) for (const T of w) if (N(y, T)) return !0;
          return !1;
        }
        function $l(i, t, s, n) {
          const a = t.projectTileCoordinates(i.x, i.y, s, n).point;
          return new mt((0.5 * a.x + 0.5) * t.width, (0.5 * -a.y + 0.5) * t.height);
        }
        let Ju, qu;
        jt("CircleBucket", Hl, { omit: ["layers"] });
        var iD = { get paint() {
          return qu = qu || new Ms({ "circle-radius": new Bt(X.paint_circle["circle-radius"]), "circle-color": new Bt(X.paint_circle["circle-color"]), "circle-blur": new Bt(X.paint_circle["circle-blur"]), "circle-opacity": new Bt(X.paint_circle["circle-opacity"]), "circle-translate": new Et(X.paint_circle["circle-translate"]), "circle-translate-anchor": new Et(X.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new Et(X.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new Et(X.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new Bt(X.paint_circle["circle-stroke-width"]), "circle-stroke-color": new Bt(X.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new Bt(X.paint_circle["circle-stroke-opacity"]) });
        }, get layout() {
          return Ju = Ju || new Ms({ "circle-sort-key": new Bt(X.layout_circle["circle-sort-key"]) });
        } };
        class rD extends Xs {
          constructor(t, s) {
            super(t, iD, s);
          }
          createBucket(t) {
            return new Hl(t);
          }
          queryRadius(t) {
            const s = t;
            return ro("circle-radius", this, s) + ro("circle-stroke-width", this, s) + Gc(this.paint.get("circle-translate"));
          }
          queryIntersectsFeature({ queryGeometry: t, feature: s, featureState: n, geometry: a, transform: M, pixelsToTileUnits: l, unwrappedTileID: D, getElevation: N }) {
            const y = Hc(t, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), -M.bearingInRadians, l), w = this.paint.get("circle-radius").evaluate(s, n) + this.paint.get("circle-stroke-width").evaluate(s, n), T = this.paint.get("circle-pitch-scale"), x = this.paint.get("circle-pitch-alignment");
            let A, m;
            return x === "map" ? (A = y, m = w * l) : (A = (function(L, O, B, P) {
              return L.map(((k) => $l(k, O, B, P)));
            })(y, M, D, N), m = w), Hu({ queryGeometry: A, size: m, transform: M, unwrappedTileID: D, getElevation: N, pitchAlignment: x, pitchScale: T }, a);
          }
        }
        class $u extends Hl {
        }
        let Ku;
        jt("HeatmapBucket", $u, { omit: ["layers"] });
        var nD = { get paint() {
          return Ku = Ku || new Ms({ "heatmap-radius": new Bt(X.paint_heatmap["heatmap-radius"]), "heatmap-weight": new Bt(X.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new Et(X.paint_heatmap["heatmap-intensity"]), "heatmap-color": new ea(X.paint_heatmap["heatmap-color"]), "heatmap-opacity": new Et(X.paint_heatmap["heatmap-opacity"]) });
        } };
        function Kl(i, { width: t, height: s }, n, a) {
          if (a) {
            if (a instanceof Uint8ClampedArray) a = new Uint8Array(a.buffer);
            else if (a.length !== t * s * n) throw new RangeError(`mismatched image size. expected: ${a.length} but got: ${t * s * n}`);
          } else a = new Uint8Array(t * s * n);
          return i.width = t, i.height = s, i.data = a, i;
        }
        function tg(i, { width: t, height: s }, n) {
          if (t === i.width && s === i.height) return;
          const a = Kl({}, { width: t, height: s }, n);
          tu(i, a, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(i.width, t), height: Math.min(i.height, s) }, n), i.width = t, i.height = s, i.data = a.data;
        }
        function tu(i, t, s, n, a, M) {
          if (a.width === 0 || a.height === 0) return t;
          if (a.width > i.width || a.height > i.height || s.x > i.width - a.width || s.y > i.height - a.height) throw new RangeError("out of range source coordinates for image copy");
          if (a.width > t.width || a.height > t.height || n.x > t.width - a.width || n.y > t.height - a.height) throw new RangeError("out of range destination coordinates for image copy");
          const l = i.data, D = t.data;
          if (l === D) throw new Error("srcData equals dstData, so image is already copied");
          for (let N = 0; N < a.height; N++) {
            const y = ((s.y + N) * i.width + s.x) * M, w = ((n.y + N) * t.width + n.x) * M;
            for (let T = 0; T < a.width * M; T++) D[w + T] = l[y + T];
          }
          return t;
        }
        class TM {
          constructor(t, s) {
            Kl(this, t, 1, s);
          }
          resize(t) {
            tg(this, t, 1);
          }
          clone() {
            return new TM({ width: this.width, height: this.height }, new Uint8Array(this.data));
          }
          static copy(t, s, n, a, M) {
            tu(t, s, n, a, M, 1);
          }
        }
        class Qs {
          constructor(t, s) {
            Kl(this, t, 4, s);
          }
          resize(t) {
            tg(this, t, 4);
          }
          replace(t, s) {
            s ? this.data.set(t) : this.data = t instanceof Uint8ClampedArray ? new Uint8Array(t.buffer) : t;
          }
          clone() {
            return new Qs({ width: this.width, height: this.height }, new Uint8Array(this.data));
          }
          static copy(t, s, n, a, M) {
            tu(t, s, n, a, M, 4);
          }
          setPixel(t, s, n) {
            const a = 4 * (t * this.width + s);
            this.data[a + 0] = Math.round(255 * n.r / n.a), this.data[a + 1] = Math.round(255 * n.g / n.a), this.data[a + 2] = Math.round(255 * n.b / n.a), this.data[a + 3] = Math.round(255 * n.a);
          }
        }
        function eg(i) {
          const t = {}, s = i.resolution || 256, n = i.clips ? i.clips.length : 1, a = i.image || new Qs({ width: s, height: n });
          if (Math.log(s) / Math.LN2 % 1 != 0) throw new Error(`width is not a power of 2 - ${s}`);
          const M = (l, D, N) => {
            t[i.evaluationKey] = N;
            const y = i.expression.evaluate(t);
            a.setPixel(l / 4 / s, D / 4, y);
          };
          if (i.clips) for (let l = 0, D = 0; l < n; ++l, D += 4 * s) for (let N = 0, y = 0; N < s; N++, y += 4) {
            const w = N / (s - 1), { start: T, end: x } = i.clips[l];
            M(D, y, T * (1 - w) + x * w);
          }
          else for (let l = 0, D = 0; l < s; l++, D += 4) M(0, D, l / (s - 1));
          return a;
        }
        jt("AlphaImage", TM), jt("RGBAImage", Qs);
        const eu = "big-fb";
        class aD extends Xs {
          createBucket(t) {
            return new $u(t);
          }
          constructor(t, s) {
            super(t, nD, s), this.heatmapFbos = /* @__PURE__ */ new Map(), this._updateColorRamp();
          }
          _handleSpecialPaintPropertyUpdate(t) {
            t === "heatmap-color" && this._updateColorRamp();
          }
          _updateColorRamp() {
            this.colorRamp = eg({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
          }
          resize() {
            this.heatmapFbos.has(eu) && this.heatmapFbos.delete(eu);
          }
          queryRadius(t) {
            return ro("heatmap-radius", this, t);
          }
          queryIntersectsFeature({ queryGeometry: t, feature: s, featureState: n, geometry: a, transform: M, pixelsToTileUnits: l, unwrappedTileID: D, getElevation: N }) {
            return Hu({ queryGeometry: t, size: this.paint.get("heatmap-radius").evaluate(s, n) * l, transform: M, unwrappedTileID: D, getElevation: N }, a);
          }
          hasOffscreenPass() {
            return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none";
          }
        }
        let sg;
        var oD = { get paint() {
          return sg = sg || new Ms({ "hillshade-illumination-direction": new Et(X.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-altitude": new Et(X.paint_hillshade["hillshade-illumination-altitude"]), "hillshade-illumination-anchor": new Et(X.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new Et(X.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new Et(X.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new Et(X.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new Et(X.paint_hillshade["hillshade-accent-color"]), "hillshade-method": new Et(X.paint_hillshade["hillshade-method"]) });
        } };
        class MD extends Xs {
          constructor(t, s) {
            super(t, oD, s), this.recalculate({ zoom: 0, zoomHistory: {} }, void 0);
          }
          getIlluminationProperties() {
            let t = this.paint.get("hillshade-illumination-direction").values, s = this.paint.get("hillshade-illumination-altitude").values, n = this.paint.get("hillshade-highlight-color").values, a = this.paint.get("hillshade-shadow-color").values;
            const M = Math.max(t.length, s.length, n.length, a.length);
            t = t.concat(Array(M - t.length).fill(t.at(-1))), s = s.concat(Array(M - s.length).fill(s.at(-1))), n = n.concat(Array(M - n.length).fill(n.at(-1))), a = a.concat(Array(M - a.length).fill(a.at(-1)));
            const l = s.map(cr);
            return { directionRadians: t.map(cr), altitudeRadians: l, shadowColor: a, highlightColor: n };
          }
          hasOffscreenPass() {
            return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none";
          }
        }
        let ig;
        var cD = { get paint() {
          return ig = ig || new Ms({ "color-relief-opacity": new Et(X["paint_color-relief"]["color-relief-opacity"]), "color-relief-color": new ea(X["paint_color-relief"]["color-relief-color"]) });
        } };
        class su {
          constructor(t, s, n, a) {
            this.context = t, this.format = n, this.texture = t.gl.createTexture(), this.update(s, a);
          }
          update(t, s, n) {
            const { width: a, height: M } = t, l = !(this.size && this.size[0] === a && this.size[1] === M || n), { context: D } = this, { gl: N } = D;
            if (this.useMipmap = !!(s && s.useMipmap), N.bindTexture(N.TEXTURE_2D, this.texture), D.pixelStoreUnpackFlipY.set(!1), D.pixelStoreUnpack.set(1), D.pixelStoreUnpackPremultiplyAlpha.set(this.format === N.RGBA && (!s || s.premultiply !== !1)), l) this.size = [a, M], t instanceof HTMLImageElement || t instanceof HTMLCanvasElement || t instanceof HTMLVideoElement || t instanceof ImageData || oi(t) ? N.texImage2D(N.TEXTURE_2D, 0, this.format, this.format, N.UNSIGNED_BYTE, t) : N.texImage2D(N.TEXTURE_2D, 0, this.format, a, M, 0, this.format, N.UNSIGNED_BYTE, t.data);
            else {
              const { x: y, y: w } = n || { x: 0, y: 0 };
              t instanceof HTMLImageElement || t instanceof HTMLCanvasElement || t instanceof HTMLVideoElement || t instanceof ImageData || oi(t) ? N.texSubImage2D(N.TEXTURE_2D, 0, y, w, N.RGBA, N.UNSIGNED_BYTE, t) : N.texSubImage2D(N.TEXTURE_2D, 0, y, w, a, M, N.RGBA, N.UNSIGNED_BYTE, t.data);
            }
            this.useMipmap && this.isSizePowerOfTwo() && N.generateMipmap(N.TEXTURE_2D), D.pixelStoreUnpackFlipY.setDefault(), D.pixelStoreUnpack.setDefault(), D.pixelStoreUnpackPremultiplyAlpha.setDefault();
          }
          bind(t, s, n) {
            const { context: a } = this, { gl: M } = a;
            M.bindTexture(M.TEXTURE_2D, this.texture), n !== M.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (n = M.LINEAR), t !== this.filter && (M.texParameteri(M.TEXTURE_2D, M.TEXTURE_MAG_FILTER, t), M.texParameteri(M.TEXTURE_2D, M.TEXTURE_MIN_FILTER, n || t), this.filter = t), s !== this.wrap && (M.texParameteri(M.TEXTURE_2D, M.TEXTURE_WRAP_S, s), M.texParameteri(M.TEXTURE_2D, M.TEXTURE_WRAP_T, s), this.wrap = s);
          }
          isSizePowerOfTwo() {
            return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
          }
          destroy() {
            const { gl: t } = this.context;
            t.deleteTexture(this.texture), this.texture = null;
          }
        }
        class rg {
          constructor(t, s, n, a = 1, M = 1, l = 1, D = 0) {
            if (this.uid = t, s.height !== s.width) throw new RangeError("DEM tiles must be square");
            if (n && !["mapbox", "terrarium", "custom"].includes(n)) return void we(`"${n}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`);
            this.stride = s.height;
            const N = this.dim = s.height - 2;
            switch (this.data = new Uint32Array(s.data.buffer), n) {
              case "terrarium":
                this.redFactor = 256, this.greenFactor = 1, this.blueFactor = 1 / 256, this.baseShift = 32768;
                break;
              case "custom":
                this.redFactor = a, this.greenFactor = M, this.blueFactor = l, this.baseShift = D;
                break;
              default:
                this.redFactor = 6553.6, this.greenFactor = 25.6, this.blueFactor = 0.1, this.baseShift = 1e4;
            }
            for (let y = 0; y < N; y++) this.data[this._idx(-1, y)] = this.data[this._idx(0, y)], this.data[this._idx(N, y)] = this.data[this._idx(N - 1, y)], this.data[this._idx(y, -1)] = this.data[this._idx(y, 0)], this.data[this._idx(y, N)] = this.data[this._idx(y, N - 1)];
            this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(N, -1)] = this.data[this._idx(N - 1, 0)], this.data[this._idx(-1, N)] = this.data[this._idx(0, N - 1)], this.data[this._idx(N, N)] = this.data[this._idx(N - 1, N - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER;
            for (let y = 0; y < N; y++) for (let w = 0; w < N; w++) {
              const T = this.get(y, w);
              T > this.max && (this.max = T), T < this.min && (this.min = T);
            }
          }
          get(t, s) {
            const n = new Uint8Array(this.data.buffer), a = 4 * this._idx(t, s);
            return this.unpack(n[a], n[a + 1], n[a + 2]);
          }
          getUnpackVector() {
            return [this.redFactor, this.greenFactor, this.blueFactor, this.baseShift];
          }
          _idx(t, s) {
            if (t < -1 || t >= this.dim + 1 || s < -1 || s >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
            return (s + 1) * this.stride + (t + 1);
          }
          unpack(t, s, n) {
            return t * this.redFactor + s * this.greenFactor + n * this.blueFactor - this.baseShift;
          }
          pack(t) {
            return ng(t, this.getUnpackVector());
          }
          getPixels() {
            return new Qs({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer));
          }
          backfillBorder(t, s, n) {
            if (this.dim !== t.dim) throw new Error("dem dimension mismatch");
            let a = s * this.dim, M = s * this.dim + this.dim, l = n * this.dim, D = n * this.dim + this.dim;
            switch (s) {
              case -1:
                a = M - 1;
                break;
              case 1:
                M = a + 1;
            }
            switch (n) {
              case -1:
                l = D - 1;
                break;
              case 1:
                D = l + 1;
            }
            const N = -s * this.dim, y = -n * this.dim;
            for (let w = l; w < D; w++) for (let T = a; T < M; T++) this.data[this._idx(T, w)] = t.data[this._idx(T + N, w + y)];
          }
        }
        function ng(i, t) {
          const s = t[0], n = t[1], a = t[2], M = t[3], l = Math.min(s, n, a), D = Math.round((i + M) / l);
          return { r: Math.floor(D * l / s) % 256, g: Math.floor(D * l / n) % 256, b: Math.floor(D * l / a) % 256 };
        }
        jt("DEMData", rg);
        class lD extends Xs {
          constructor(t, s) {
            super(t, cD, s);
          }
          _createColorRamp(t) {
            const s = { elevationStops: [], colorStops: [] }, n = this._transitionablePaint._values["color-relief-color"].value.expression;
            if (n instanceof pr && n._styleExpression.expression instanceof es) {
              this.colorRampExpression = n;
              const l = n._styleExpression.expression;
              s.elevationStops = l.labels, s.colorStops = [];
              for (const D of s.elevationStops) s.colorStops.push(l.evaluate({ globals: { elevation: D } }));
            }
            if (s.elevationStops.length < 1 && (s.elevationStops = [0], s.colorStops = [Vt.transparent]), s.elevationStops.length < 2 && (s.elevationStops.push(s.elevationStops[0] + 1), s.colorStops.push(s.colorStops[0])), s.elevationStops.length <= t) return s;
            const a = { elevationStops: [], colorStops: [] }, M = (s.elevationStops.length - 1) / (t - 1);
            for (let l = 0; l < s.elevationStops.length - 0.5; l += M) a.elevationStops.push(s.elevationStops[Math.round(l)]), a.colorStops.push(s.colorStops[Math.round(l)]);
            return we(`Too many colors in specification of ${this.id} color-relief layer, may not render properly. Max possible colors: ${t}, provided: ${s.elevationStops.length}`), a;
          }
          _colorRampChanged() {
            return this.colorRampExpression != this._transitionablePaint._values["color-relief-color"].value.expression;
          }
          getColorRampTextures(t, s, n) {
            if (this.colorRampTextures && !this._colorRampChanged()) return this.colorRampTextures;
            const a = this._createColorRamp(s), M = new Qs({ width: a.colorStops.length, height: 1 }), l = new Qs({ width: a.colorStops.length, height: 1 });
            for (let D = 0; D < a.elevationStops.length; D++) {
              const N = ng(a.elevationStops[D], n);
              l.setPixel(0, D, new Vt(N.r / 255, N.g / 255, N.b / 255, 1)), M.setPixel(0, D, a.colorStops[D]);
            }
            return this.colorRampTextures = { elevationTexture: new su(t, l, t.gl.RGBA), colorTexture: new su(t, M, t.gl.RGBA) }, this.colorRampTextures;
          }
          hasOffscreenPass() {
            return this.visibility !== "none" && !!this.colorRampTextures;
          }
        }
        const uD = Ee([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: gD } = uD;
        function Jc(i, t, s) {
          const n = s.patternDependencies;
          let a = !1;
          for (const M of t) {
            const l = M.paint.get(`${i}-pattern`);
            l.isConstant() || (a = !0);
            const D = l.constantOr(null);
            D && (a = !0, n[D.to] = !0, n[D.from] = !0);
          }
          return a;
        }
        function iu(i, t, s, n, a) {
          const { zoom: M } = n, l = a.patternDependencies;
          for (const D of t) {
            const N = D.paint.get(`${i}-pattern`).value;
            if (N.kind !== "constant") {
              let y = N.evaluate({ zoom: M - 1 }, s, {}, a.availableImages), w = N.evaluate({ zoom: M }, s, {}, a.availableImages), T = N.evaluate({ zoom: M + 1 }, s, {}, a.availableImages);
              y = y && y.name ? y.name : y, w = w && w.name ? w.name : w, T = T && T.name ? T.name : T, l[y] = !0, l[w] = !0, l[T] = !0, s.patterns[D.id] = { min: y, mid: w, max: T };
            }
          }
          return s;
        }
        function ag(i, t, s, n, a) {
          let M;
          if (a === (function(l, D, N, y) {
            let w = 0;
            for (let T = D, x = N - y; T < N; T += y) w += (l[x] - l[T]) * (l[T + 1] + l[x + 1]), x = T;
            return w;
          })(i, t, s, n) > 0) for (let l = t; l < s; l += n) M = lg(l / n | 0, i[l], i[l + 1], M);
          else for (let l = s - n; l >= t; l -= n) M = lg(l / n | 0, i[l], i[l + 1], M);
          return M && no(M, M.next) && (mM(M), M = M.next), M;
        }
        function oa(i, t) {
          if (!i) return i;
          t || (t = i);
          let s, n = i;
          do
            if (s = !1, n.steiner || !no(n, n.next) && Se(n.prev, n, n.next) !== 0) n = n.next;
            else {
              if (mM(n), n = t = n.prev, n === n.next) break;
              s = !0;
            }
          while (s || n !== t);
          return t;
        }
        function fM(i, t, s, n, a, M, l) {
          if (!i) return;
          !l && M && (function(N, y, w, T) {
            let x = N;
            do
              x.z === 0 && (x.z = ru(x.x, x.y, y, w, T)), x.prevZ = x.prev, x.nextZ = x.next, x = x.next;
            while (x !== N);
            x.prevZ.nextZ = null, x.prevZ = null, (function(A) {
              let m, L = 1;
              do {
                let O, B = A;
                A = null;
                let P = null;
                for (m = 0; B; ) {
                  m++;
                  let k = B, U = 0;
                  for (let et = 0; et < L && (U++, k = k.nextZ, k); et++) ;
                  let K = L;
                  for (; U > 0 || K > 0 && k; ) U !== 0 && (K === 0 || !k || B.z <= k.z) ? (O = B, B = B.nextZ, U--) : (O = k, k = k.nextZ, K--), P ? P.nextZ = O : A = O, O.prevZ = P, P = O;
                  B = k;
                }
                P.nextZ = null, L *= 2;
              } while (m > 1);
            })(x);
          })(i, n, a, M);
          let D = i;
          for (; i.prev !== i.next; ) {
            const N = i.prev, y = i.next;
            if (M ? DD(i, n, a, M) : hD(i)) t.push(N.i, i.i, y.i), mM(i), i = y.next, D = y.next;
            else if ((i = y) === D) {
              l ? l === 1 ? fM(i = zD(oa(i), t), t, s, n, a, M, 2) : l === 2 && ND(i, t, s, n, a, M) : fM(oa(i), t, s, n, a, M, 1);
              break;
            }
          }
        }
        function hD(i) {
          const t = i.prev, s = i, n = i.next;
          if (Se(t, s, n) >= 0) return !1;
          const a = t.x, M = s.x, l = n.x, D = t.y, N = s.y, y = n.y, w = Math.min(a, M, l), T = Math.min(D, N, y), x = Math.max(a, M, l), A = Math.max(D, N, y);
          let m = n.next;
          for (; m !== t; ) {
            if (m.x >= w && m.x <= x && m.y >= T && m.y <= A && xM(a, D, M, N, l, y, m.x, m.y) && Se(m.prev, m, m.next) >= 0) return !1;
            m = m.next;
          }
          return !0;
        }
        function DD(i, t, s, n) {
          const a = i.prev, M = i, l = i.next;
          if (Se(a, M, l) >= 0) return !1;
          const D = a.x, N = M.x, y = l.x, w = a.y, T = M.y, x = l.y, A = Math.min(D, N, y), m = Math.min(w, T, x), L = Math.max(D, N, y), O = Math.max(w, T, x), B = ru(A, m, t, s, n), P = ru(L, O, t, s, n);
          let k = i.prevZ, U = i.nextZ;
          for (; k && k.z >= B && U && U.z <= P; ) {
            if (k.x >= A && k.x <= L && k.y >= m && k.y <= O && k !== a && k !== l && xM(D, w, N, T, y, x, k.x, k.y) && Se(k.prev, k, k.next) >= 0 || (k = k.prevZ, U.x >= A && U.x <= L && U.y >= m && U.y <= O && U !== a && U !== l && xM(D, w, N, T, y, x, U.x, U.y) && Se(U.prev, U, U.next) >= 0)) return !1;
            U = U.nextZ;
          }
          for (; k && k.z >= B; ) {
            if (k.x >= A && k.x <= L && k.y >= m && k.y <= O && k !== a && k !== l && xM(D, w, N, T, y, x, k.x, k.y) && Se(k.prev, k, k.next) >= 0) return !1;
            k = k.prevZ;
          }
          for (; U && U.z <= P; ) {
            if (U.x >= A && U.x <= L && U.y >= m && U.y <= O && U !== a && U !== l && xM(D, w, N, T, y, x, U.x, U.y) && Se(U.prev, U, U.next) >= 0) return !1;
            U = U.nextZ;
          }
          return !0;
        }
        function zD(i, t) {
          let s = i;
          do {
            const n = s.prev, a = s.next.next;
            !no(n, a) && Mg(n, s, s.next, a) && AM(n, a) && AM(a, n) && (t.push(n.i, s.i, a.i), mM(s), mM(s.next), s = i = a), s = s.next;
          } while (s !== i);
          return oa(s);
        }
        function ND(i, t, s, n, a, M) {
          let l = i;
          do {
            let D = l.next.next;
            for (; D !== l.prev; ) {
              if (l.i !== D.i && pD(l, D)) {
                let N = cg(l, D);
                return l = oa(l, l.next), N = oa(N, N.next), fM(l, t, s, n, a, M, 0), void fM(N, t, s, n, a, M, 0);
              }
              D = D.next;
            }
            l = l.next;
          } while (l !== i);
        }
        function dD(i, t) {
          let s = i.x - t.x;
          return s === 0 && (s = i.y - t.y, s === 0) && (s = (i.next.y - i.y) / (i.next.x - i.x) - (t.next.y - t.y) / (t.next.x - t.x)), s;
        }
        function yD(i, t) {
          const s = (function(a, M) {
            let l = M;
            const D = a.x, N = a.y;
            let y, w = -1 / 0;
            if (no(a, l)) return l;
            do {
              if (no(a, l.next)) return l.next;
              if (N <= l.y && N >= l.next.y && l.next.y !== l.y) {
                const L = l.x + (N - l.y) * (l.next.x - l.x) / (l.next.y - l.y);
                if (L <= D && L > w && (w = L, y = l.x < l.next.x ? l : l.next, L === D)) return y;
              }
              l = l.next;
            } while (l !== M);
            if (!y) return null;
            const T = y, x = y.x, A = y.y;
            let m = 1 / 0;
            l = y;
            do {
              if (D >= l.x && l.x >= x && D !== l.x && og(N < A ? D : w, N, x, A, N < A ? w : D, N, l.x, l.y)) {
                const L = Math.abs(N - l.y) / (D - l.x);
                AM(l, a) && (L < m || L === m && (l.x > y.x || l.x === y.x && ID(y, l))) && (y = l, m = L);
              }
              l = l.next;
            } while (l !== T);
            return y;
          })(i, t);
          if (!s) return t;
          const n = cg(s, i);
          return oa(n, n.next), oa(s, s.next);
        }
        function ID(i, t) {
          return Se(i.prev, i, t.prev) < 0 && Se(t.next, i, i.next) < 0;
        }
        function ru(i, t, s, n, a) {
          return (i = 1431655765 & ((i = 858993459 & ((i = 252645135 & ((i = 16711935 & ((i = (i - s) * a | 0) | i << 8)) | i << 4)) | i << 2)) | i << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - n) * a | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1;
        }
        function wD(i) {
          let t = i, s = i;
          do
            (t.x < s.x || t.x === s.x && t.y < s.y) && (s = t), t = t.next;
          while (t !== i);
          return s;
        }
        function og(i, t, s, n, a, M, l, D) {
          return (a - l) * (t - D) >= (i - l) * (M - D) && (i - l) * (n - D) >= (s - l) * (t - D) && (s - l) * (M - D) >= (a - l) * (n - D);
        }
        function xM(i, t, s, n, a, M, l, D) {
          return !(i === l && t === D) && og(i, t, s, n, a, M, l, D);
        }
        function pD(i, t) {
          return i.next.i !== t.i && i.prev.i !== t.i && !(function(s, n) {
            let a = s;
            do {
              if (a.i !== s.i && a.next.i !== s.i && a.i !== n.i && a.next.i !== n.i && Mg(a, a.next, s, n)) return !0;
              a = a.next;
            } while (a !== s);
            return !1;
          })(i, t) && (AM(i, t) && AM(t, i) && (function(s, n) {
            let a = s, M = !1;
            const l = (s.x + n.x) / 2, D = (s.y + n.y) / 2;
            do
              a.y > D != a.next.y > D && a.next.y !== a.y && l < (a.next.x - a.x) * (D - a.y) / (a.next.y - a.y) + a.x && (M = !M), a = a.next;
            while (a !== s);
            return M;
          })(i, t) && (Se(i.prev, i, t.prev) || Se(i, t.prev, t)) || no(i, t) && Se(i.prev, i, i.next) > 0 && Se(t.prev, t, t.next) > 0);
        }
        function Se(i, t, s) {
          return (t.y - i.y) * (s.x - t.x) - (t.x - i.x) * (s.y - t.y);
        }
        function no(i, t) {
          return i.x === t.x && i.y === t.y;
        }
        function Mg(i, t, s, n) {
          const a = $c(Se(i, t, s)), M = $c(Se(i, t, n)), l = $c(Se(s, n, i)), D = $c(Se(s, n, t));
          return a !== M && l !== D || !(a !== 0 || !qc(i, s, t)) || !(M !== 0 || !qc(i, n, t)) || !(l !== 0 || !qc(s, i, n)) || !(D !== 0 || !qc(s, t, n));
        }
        function qc(i, t, s) {
          return t.x <= Math.max(i.x, s.x) && t.x >= Math.min(i.x, s.x) && t.y <= Math.max(i.y, s.y) && t.y >= Math.min(i.y, s.y);
        }
        function $c(i) {
          return i > 0 ? 1 : i < 0 ? -1 : 0;
        }
        function AM(i, t) {
          return Se(i.prev, i, i.next) < 0 ? Se(i, t, i.next) >= 0 && Se(i, i.prev, t) >= 0 : Se(i, t, i.prev) < 0 || Se(i, i.next, t) < 0;
        }
        function cg(i, t) {
          const s = nu(i.i, i.x, i.y), n = nu(t.i, t.x, t.y), a = i.next, M = t.prev;
          return i.next = t, t.prev = i, s.next = a, a.prev = s, n.next = s, s.prev = n, M.next = n, n.prev = M, n;
        }
        function lg(i, t, s, n) {
          const a = nu(i, t, s);
          return n ? (a.next = n.next, a.prev = n, n.next.prev = a, n.next = a) : (a.prev = a, a.next = a), a;
        }
        function mM(i) {
          i.next.prev = i.prev, i.prev.next = i.next, i.prevZ && (i.prevZ.nextZ = i.nextZ), i.nextZ && (i.nextZ.prevZ = i.prevZ);
        }
        function nu(i, t, s) {
          return { i, x: t, y: s, prev: null, next: null, z: 0, prevZ: null, nextZ: null, steiner: !1 };
        }
        class ao {
          constructor(t, s) {
            if (s > t) throw new Error("Min granularity must not be greater than base granularity.");
            this._baseZoomGranularity = t, this._minGranularity = s;
          }
          getGranularityForZoomLevel(t) {
            return Math.max(Math.floor(this._baseZoomGranularity / (1 << t)), this._minGranularity, 1);
          }
        }
        class Kc {
          constructor(t) {
            this.fill = t.fill, this.line = t.line, this.tile = t.tile, this.stencil = t.stencil, this.circle = t.circle;
          }
        }
        Kc.noSubdivision = new Kc({ fill: new ao(0, 0), line: new ao(0, 0), tile: new ao(0, 0), stencil: new ao(0, 0), circle: 1 }), jt("SubdivisionGranularityExpression", ao), jt("SubdivisionGranularitySetting", Kc);
        const oo = -32768, jM = 32767;
        class TD {
          constructor(t, s) {
            this._vertexBuffer = [], this._vertexDictionary = /* @__PURE__ */ new Map(), this._used = !1, this._granularity = t, this._granularityCellSize = se / t, this._canonical = s;
          }
          _getKey(t, s) {
            return (t += 32768) << 16 | s + 32768;
          }
          _vertexToIndex(t, s) {
            if (t < -32768 || s < -32768 || t > 32767 || s > 32767) throw new Error("Vertex coordinates are out of signed 16 bit integer range.");
            const n = 0 | Math.round(t), a = 0 | Math.round(s), M = this._getKey(n, a);
            if (this._vertexDictionary.has(M)) return this._vertexDictionary.get(M);
            const l = this._vertexBuffer.length / 2;
            return this._vertexDictionary.set(M, l), this._vertexBuffer.push(n, a), l;
          }
          _subdivideTrianglesScanline(t) {
            if (this._granularity < 2) return (function(a, M) {
              const l = [];
              for (let D = 0; D < M.length; D += 3) {
                const N = M[D], y = M[D + 1], w = M[D + 2], T = a[2 * N], x = a[2 * N + 1];
                (a[2 * y] - T) * (a[2 * w + 1] - x) - (a[2 * y + 1] - x) * (a[2 * w] - T) > 0 ? (l.push(N), l.push(w), l.push(y)) : (l.push(N), l.push(y), l.push(w));
              }
              return l;
            })(this._vertexBuffer, t);
            const s = [], n = t.length;
            for (let a = 0; a < n; a += 3) {
              const M = [t[a + 0], t[a + 1], t[a + 2]], l = [this._vertexBuffer[2 * t[a + 0] + 0], this._vertexBuffer[2 * t[a + 0] + 1], this._vertexBuffer[2 * t[a + 1] + 0], this._vertexBuffer[2 * t[a + 1] + 1], this._vertexBuffer[2 * t[a + 2] + 0], this._vertexBuffer[2 * t[a + 2] + 1]];
              let D = 1 / 0, N = 1 / 0, y = -1 / 0, w = -1 / 0;
              for (let L = 0; L < 3; L++) {
                const O = l[2 * L], B = l[2 * L + 1];
                D = Math.min(D, O), y = Math.max(y, O), N = Math.min(N, B), w = Math.max(w, B);
              }
              if (D === y || N === w) continue;
              const T = Math.floor(D / this._granularityCellSize), x = Math.ceil(y / this._granularityCellSize), A = Math.floor(N / this._granularityCellSize), m = Math.ceil(w / this._granularityCellSize);
              if (T !== x || A !== m) for (let L = A; L < m; L++) {
                const O = this._scanlineGenerateVertexRingForCellRow(L, l, M);
                fD(this._vertexBuffer, O, s);
              }
              else s.push(...M);
            }
            return s;
          }
          _scanlineGenerateVertexRingForCellRow(t, s, n) {
            const a = t * this._granularityCellSize, M = a + this._granularityCellSize, l = [];
            for (let D = 0; D < 3; D++) {
              const N = s[2 * D], y = s[2 * D + 1], w = s[2 * (D + 1) % 6], T = s[(2 * (D + 1) + 1) % 6], x = s[2 * (D + 2) % 6], A = s[(2 * (D + 2) + 1) % 6], m = w - N, L = T - y, O = m === 0, B = L === 0, P = (a - y) / L, k = (M - y) / L, U = Math.min(P, k), K = Math.max(P, k);
              if (!B && (U >= 1 || K <= 0) || B && (y < a || y > M)) {
                T >= a && T <= M && l.push(n[(D + 1) % 3]);
                continue;
              }
              !B && U > 0 && l.push(this._vertexToIndex(N + m * U, y + L * U));
              const et = N + m * Math.max(U, 0), ot = N + m * Math.min(K, 1);
              O || this._generateIntraEdgeVertices(l, N, y, w, T, et, ot), !B && K < 1 && l.push(this._vertexToIndex(N + m * K, y + L * K)), (B || T >= a && T <= M) && l.push(n[(D + 1) % 3]), !B && (T <= a || T >= M) && this._generateInterEdgeVertices(l, N, y, w, T, x, A, ot, a, M);
            }
            return l;
          }
          _generateIntraEdgeVertices(t, s, n, a, M, l, D) {
            const N = a - s, y = M - n, w = y === 0, T = w ? Math.min(s, a) : Math.min(l, D), x = w ? Math.max(s, a) : Math.max(l, D), A = Math.floor(T / this._granularityCellSize) + 1, m = Math.ceil(x / this._granularityCellSize) - 1;
            if (w ? s < a : l < D) for (let L = A; L <= m; L++) {
              const O = L * this._granularityCellSize;
              t.push(this._vertexToIndex(O, n + y * (O - s) / N));
            }
            else for (let L = m; L >= A; L--) {
              const O = L * this._granularityCellSize;
              t.push(this._vertexToIndex(O, n + y * (O - s) / N));
            }
          }
          _generateInterEdgeVertices(t, s, n, a, M, l, D, N, y, w) {
            const T = M - n, x = l - a, A = D - M, m = (y - M) / A, L = (w - M) / A, O = Math.min(m, L), B = Math.max(m, L), P = a + x * O;
            let k = Math.floor(Math.min(P, N) / this._granularityCellSize) + 1, U = Math.ceil(Math.max(P, N) / this._granularityCellSize) - 1, K = N < P;
            const et = A === 0;
            if (et && (D === y || D === w)) return;
            if (et || O >= 1 || B <= 0) {
              const dt = n - D, Dt = l + (s - l) * Math.min((y - D) / dt, (w - D) / dt);
              k = Math.floor(Math.min(Dt, N) / this._granularityCellSize) + 1, U = Math.ceil(Math.max(Dt, N) / this._granularityCellSize) - 1, K = N < Dt;
            }
            const ot = T > 0 ? w : y;
            if (K) for (let dt = k; dt <= U; dt++) t.push(this._vertexToIndex(dt * this._granularityCellSize, ot));
            else for (let dt = U; dt >= k; dt--) t.push(this._vertexToIndex(dt * this._granularityCellSize, ot));
          }
          _generateOutline(t) {
            const s = [];
            for (const n of t) {
              const a = Ma(n, this._granularity, !0), M = this._pointArrayToIndices(a), l = [];
              for (let D = 1; D < M.length; D++) l.push(M[D - 1]), l.push(M[D]);
              s.push(l);
            }
            return s;
          }
          _handlePoles(t) {
            let s = !1, n = !1;
            this._canonical && (this._canonical.y === 0 && (s = !0), this._canonical.y === (1 << this._canonical.z) - 1 && (n = !0)), (s || n) && this._fillPoles(t, s, n);
          }
          _ensureNoPoleVertices() {
            const t = this._vertexBuffer;
            for (let s = 0; s < t.length; s += 2) {
              const n = t[s + 1];
              n === oo && (t[s + 1] = -32767), n === jM && (t[s + 1] = 32766);
            }
          }
          _generatePoleQuad(t, s, n, a, M, l) {
            a > M != (l === oo) ? (t.push(s), t.push(n), t.push(this._vertexToIndex(a, l)), t.push(n), t.push(this._vertexToIndex(M, l)), t.push(this._vertexToIndex(a, l))) : (t.push(n), t.push(s), t.push(this._vertexToIndex(a, l)), t.push(this._vertexToIndex(M, l)), t.push(n), t.push(this._vertexToIndex(a, l)));
          }
          _fillPoles(t, s, n) {
            const a = this._vertexBuffer, M = se, l = t.length;
            for (let D = 2; D < l; D += 3) {
              const N = t[D - 2], y = t[D - 1], w = t[D], T = a[2 * N], x = a[2 * N + 1], A = a[2 * y], m = a[2 * y + 1], L = a[2 * w], O = a[2 * w + 1];
              s && (x === 0 && m === 0 && this._generatePoleQuad(t, N, y, T, A, oo), m === 0 && O === 0 && this._generatePoleQuad(t, y, w, A, L, oo), O === 0 && x === 0 && this._generatePoleQuad(t, w, N, L, T, oo)), n && (x === M && m === M && this._generatePoleQuad(t, N, y, T, A, jM), m === M && O === M && this._generatePoleQuad(t, y, w, A, L, jM), O === M && x === M && this._generatePoleQuad(t, w, N, L, T, jM));
            }
          }
          _initializeVertices(t) {
            for (let s = 0; s < t.length; s += 2) this._vertexToIndex(t[s], t[s + 1]);
          }
          subdividePolygonInternal(t, s) {
            if (this._used) throw new Error("Subdivision: multiple use not allowed.");
            this._used = !0;
            const { flattened: n, holeIndices: a } = (function(D) {
              const N = [], y = [];
              for (const w of D) if (w.length !== 0) {
                w !== D[0] && N.push(y.length / 2);
                for (let T = 0; T < w.length; T++) y.push(w[T].x), y.push(w[T].y);
              }
              return { flattened: y, holeIndices: N };
            })(t);
            let M;
            this._initializeVertices(n);
            try {
              const D = (function(y, w, T = 2) {
                const x = w && w.length, A = x ? w[0] * T : y.length;
                let m = ag(y, 0, A, T, !0);
                const L = [];
                if (!m || m.next === m.prev) return L;
                let O, B, P;
                if (x && (m = (function(k, U, K, et) {
                  const ot = [];
                  for (let dt = 0, Dt = U.length; dt < Dt; dt++) {
                    const yt = ag(k, U[dt] * et, dt < Dt - 1 ? U[dt + 1] * et : k.length, et, !1);
                    yt === yt.next && (yt.steiner = !0), ot.push(wD(yt));
                  }
                  ot.sort(dD);
                  for (let dt = 0; dt < ot.length; dt++) K = yD(ot[dt], K);
                  return K;
                })(y, w, m, T)), y.length > 80 * T) {
                  O = y[0], B = y[1];
                  let k = O, U = B;
                  for (let K = T; K < A; K += T) {
                    const et = y[K], ot = y[K + 1];
                    et < O && (O = et), ot < B && (B = ot), et > k && (k = et), ot > U && (U = ot);
                  }
                  P = Math.max(k - O, U - B), P = P !== 0 ? 32767 / P : 0;
                }
                return fM(m, L, T, O, B, P, 0), L;
              })(n, a), N = this._convertIndices(n, D);
              M = this._subdivideTrianglesScanline(N);
            } catch (D) {
              console.error(D);
            }
            let l = [];
            return s && (l = this._generateOutline(t)), this._ensureNoPoleVertices(), this._handlePoles(M), { verticesFlattened: this._vertexBuffer, indicesTriangles: M, indicesLineList: l };
          }
          _convertIndices(t, s) {
            const n = [];
            for (let a = 0; a < s.length; a++) n.push(this._vertexToIndex(t[2 * s[a]], t[2 * s[a] + 1]));
            return n;
          }
          _pointArrayToIndices(t) {
            const s = [];
            for (let n = 0; n < t.length; n++) {
              const a = t[n];
              s.push(this._vertexToIndex(a.x, a.y));
            }
            return s;
          }
        }
        function ug(i, t, s, n = !0) {
          return new TD(s, t).subdividePolygonInternal(i, n);
        }
        function Ma(i, t, s = !1) {
          if (!i || i.length < 1) return [];
          if (i.length < 2) return [];
          const n = i[0], a = i[i.length - 1], M = s && (n.x !== a.x || n.y !== a.y);
          if (t < 2) return M ? [...i, i[0]] : [...i];
          const l = Math.floor(se / t), D = [];
          D.push(new mt(i[0].x, i[0].y));
          const N = i.length, y = M ? N : N - 1;
          for (let w = 0; w < y; w++) {
            const T = i[w], x = w < N - 1 ? i[w + 1] : i[0], A = T.x, m = T.y, L = x.x, O = x.y, B = A !== L, P = m !== O;
            if (!B && !P) continue;
            const k = L - A, U = O - m, K = Math.abs(k), et = Math.abs(U);
            let ot = A, dt = m;
            for (; ; ) {
              const yt = k > 0 ? (Math.floor(ot / l) + 1) * l : (Math.ceil(ot / l) - 1) * l, At = U > 0 ? (Math.floor(dt / l) + 1) * l : (Math.ceil(dt / l) - 1) * l, Tt = Math.abs(ot - yt), ft = Math.abs(dt - At), zt = Math.abs(ot - L), bt = Math.abs(dt - O), Qt = B ? Tt / K : Number.POSITIVE_INFINITY, St = P ? ft / et : Number.POSITIVE_INFINITY;
              if ((zt <= Tt || !B) && (bt <= ft || !P)) break;
              if (Qt < St && B || !P) {
                ot = yt, dt += U * Qt;
                const Lt = new mt(ot, Math.round(dt));
                D[D.length - 1].x === Lt.x && D[D.length - 1].y === Lt.y || D.push(Lt);
              } else {
                ot += k * St, dt = At;
                const Lt = new mt(Math.round(ot), dt);
                D[D.length - 1].x === Lt.x && D[D.length - 1].y === Lt.y || D.push(Lt);
              }
            }
            const Dt = new mt(L, O);
            D[D.length - 1].x === Dt.x && D[D.length - 1].y === Dt.y || D.push(Dt);
          }
          return D;
        }
        function fD(i, t, s) {
          if (t.length === 0) throw new Error("Subdivision vertex ring is empty.");
          let n = 0, a = i[2 * t[0]];
          for (let N = 1; N < t.length; N++) {
            const y = i[2 * t[N]];
            y < a && (a = y, n = N);
          }
          const M = t.length;
          let l = n, D = (l + 1) % M;
          for (; ; ) {
            const N = l - 1 >= 0 ? l - 1 : M - 1, y = (D + 1) % M, w = i[2 * t[N]], T = i[2 * t[y]], x = i[2 * t[l]], A = i[2 * t[l] + 1], m = i[2 * t[D] + 1];
            let L = !1;
            if (w < T) L = !0;
            else if (w > T) L = !1;
            else {
              const O = m - A, B = -(i[2 * t[D]] - x), P = A < m ? 1 : -1;
              ((w - x) * O + (i[2 * t[N] + 1] - A) * B) * P > ((T - x) * O + (i[2 * t[y] + 1] - A) * B) * P && (L = !0);
            }
            if (L) {
              const O = t[N], B = t[l], P = t[D];
              O !== B && O !== P && B !== P && s.push(P, B, O), l--, l < 0 && (l = M - 1);
            } else {
              const O = t[y], B = t[l], P = t[D];
              O !== B && O !== P && B !== P && s.push(P, B, O), D++, D >= M && (D = 0);
            }
            if (N === y) break;
          }
        }
        function gg(i, t, s, n, a, M, l, D, N) {
          const y = a.length / 2, w = l && D && N;
          if (y < Yt.MAX_VERTEX_ARRAY_LENGTH) {
            const T = t.prepareSegment(y, s, n), x = T.vertexLength;
            for (let L = 0; L < M.length; L += 3) n.emplaceBack(x + M[L], x + M[L + 1], x + M[L + 2]);
            let A, m;
            T.vertexLength += y, T.primitiveLength += M.length / 3, w && (m = l.prepareSegment(y, s, D), A = m.vertexLength, m.vertexLength += y);
            for (let L = 0; L < a.length; L += 2) i(a[L], a[L + 1]);
            if (w) for (let L = 0; L < N.length; L++) {
              const O = N[L];
              for (let B = 1; B < O.length; B += 2) D.emplaceBack(A + O[B - 1], A + O[B]);
              m.primitiveLength += O.length / 2;
            }
          } else (function(T, x, A, m, L, O) {
            const B = [];
            for (let et = 0; et < m.length / 2; et++) B.push(-1);
            const P = { count: 0 };
            let k = 0, U = T.getOrCreateLatestSegment(x, A), K = U.vertexLength;
            for (let et = 2; et < L.length; et += 3) {
              const ot = L[et - 2], dt = L[et - 1], Dt = L[et];
              let yt = B[ot] < k, At = B[dt] < k, Tt = B[Dt] < k;
              U.vertexLength + ((yt ? 1 : 0) + (At ? 1 : 0) + (Tt ? 1 : 0)) > Yt.MAX_VERTEX_ARRAY_LENGTH && (U = T.createNewSegment(x, A), k = P.count, yt = !0, At = !0, Tt = !0, K = 0);
              const ft = _M(B, m, O, P, ot, yt, U), zt = _M(B, m, O, P, dt, At, U), bt = _M(B, m, O, P, Dt, Tt, U);
              A.emplaceBack(K + ft - k, K + zt - k, K + bt - k), U.primitiveLength++;
            }
          })(t, s, n, a, M, i), w && (function(T, x, A, m, L, O) {
            const B = [];
            for (let et = 0; et < m.length / 2; et++) B.push(-1);
            const P = { count: 0 };
            let k = 0, U = T.getOrCreateLatestSegment(x, A), K = U.vertexLength;
            for (let et = 0; et < L.length; et++) {
              const ot = L[et];
              for (let dt = 1; dt < L[et].length; dt += 2) {
                const Dt = ot[dt - 1], yt = ot[dt];
                let At = B[Dt] < k, Tt = B[yt] < k;
                U.vertexLength + ((At ? 1 : 0) + (Tt ? 1 : 0)) > Yt.MAX_VERTEX_ARRAY_LENGTH && (U = T.createNewSegment(x, A), k = P.count, At = !0, Tt = !0, K = 0);
                const ft = _M(B, m, O, P, Dt, At, U), zt = _M(B, m, O, P, yt, Tt, U);
                A.emplaceBack(K + ft - k, K + zt - k), U.primitiveLength++;
              }
            }
          })(l, s, D, a, N, i), t.forceNewSegmentOnNextPrepare(), l?.forceNewSegmentOnNextPrepare();
        }
        function _M(i, t, s, n, a, M, l) {
          if (M) {
            const D = n.count;
            return s(t[2 * a], t[2 * a + 1]), i[a] = n.count, n.count++, l.vertexLength++, D;
          }
          return i[a];
        }
        class au {
          constructor(t) {
            this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(((s) => s.id)), this.index = t.index, this.hasDependencies = !1, this.patternFeatures = [], this.layoutVertexArray = new J(), this.indexArray = new wt(), this.indexArray2 = new Nt(), this.programConfigurations = new Cr(t.layers, t.zoom), this.segments = new Yt(), this.segments2 = new Yt(), this.stateDependentLayerIds = this.layers.filter(((s) => s.isStateDependent())).map(((s) => s.id));
          }
          populate(t, s, n) {
            this.hasDependencies = Jc("fill", this.layers, s);
            const a = this.layers[0].layout.get("fill-sort-key"), M = !a.isConstant(), l = [];
            for (const { feature: D, id: N, index: y, sourceLayerIndex: w } of t) {
              const T = this.layers[0]._featureFilter.needGeometry, x = _i(D, T);
              if (!this.layers[0]._featureFilter.filter(new ie(this.zoom), x, n)) continue;
              const A = M ? a.evaluate(x, {}, n, s.availableImages) : void 0, m = { id: N, properties: D.properties, type: D.type, sourceLayerIndex: w, index: y, geometry: T ? x.geometry : sr(D), patterns: {}, sortKey: A };
              l.push(m);
            }
            M && l.sort(((D, N) => D.sortKey - N.sortKey));
            for (const D of l) {
              const { geometry: N, index: y, sourceLayerIndex: w } = D;
              if (this.hasDependencies) {
                const T = iu("fill", this.layers, D, { zoom: this.zoom }, s);
                this.patternFeatures.push(T);
              } else this.addFeature(D, N, y, n, {}, s.subdivisionGranularity);
              s.featureIndex.insert(t[y].feature, N, y, w, this.index);
            }
          }
          update(t, s, n) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, s, this.stateDependentLayers, { imagePositions: n });
          }
          addFeatures(t, s, n) {
            for (const a of this.patternFeatures) this.addFeature(a, a.geometry, a.index, s, n, t.subdivisionGranularity);
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t) {
            this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, gD), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.indexBuffer2 = t.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t), this.uploaded = !0;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
          }
          addFeature(t, s, n, a, M, l) {
            for (const D of Sn(s, 500)) {
              const N = ug(D, a, l.fill.getGranularityForZoomLevel(a.z)), y = this.layoutVertexArray;
              gg(((w, T) => {
                y.emplaceBack(w, T);
              }), this.segments, this.layoutVertexArray, this.indexArray, N.verticesFlattened, N.indicesTriangles, this.segments2, this.indexArray2, N.indicesLineList);
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, n, { imagePositions: M, canonical: a });
          }
        }
        let hg, Dg;
        jt("FillBucket", au, { omit: ["layers", "patternFeatures"] });
        var xD = { get paint() {
          return Dg = Dg || new Ms({ "fill-antialias": new Et(X.paint_fill["fill-antialias"]), "fill-opacity": new Bt(X.paint_fill["fill-opacity"]), "fill-color": new Bt(X.paint_fill["fill-color"]), "fill-outline-color": new Bt(X.paint_fill["fill-outline-color"]), "fill-translate": new Et(X.paint_fill["fill-translate"]), "fill-translate-anchor": new Et(X.paint_fill["fill-translate-anchor"]), "fill-pattern": new ta(X.paint_fill["fill-pattern"]) });
        }, get layout() {
          return hg = hg || new Ms({ "fill-sort-key": new Bt(X.layout_fill["fill-sort-key"]) });
        } };
        class AD extends Xs {
          constructor(t, s) {
            super(t, xD, s);
          }
          recalculate(t, s) {
            super.recalculate(t, s);
            const n = this.paint._values["fill-outline-color"];
            n.value.kind === "constant" && n.value.value === void 0 && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
          }
          createBucket(t) {
            return new au(t);
          }
          queryRadius() {
            return Gc(this.paint.get("fill-translate"));
          }
          queryIntersectsFeature({ queryGeometry: t, geometry: s, transform: n, pixelsToTileUnits: a }) {
            return Zu(Hc(t, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), -n.bearingInRadians, a), s);
          }
          isTileClipped() {
            return !0;
          }
        }
        const mD = Ee([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_normal_ed", components: 4, type: "Int16" }], 4), jD = Ee([{ name: "a_centroid", components: 2, type: "Int16" }], 4), { members: _D } = mD;
        class Mo {
          constructor(t, s, n, a, M) {
            this.properties = {}, this.extent = n, this.type = 0, this.id = void 0, this._pbf = t, this._geometry = -1, this._keys = a, this._values = M, t.readFields(LD, this, s);
          }
          loadGeometry() {
            const t = this._pbf;
            t.pos = this._geometry;
            const s = t.readVarint() + t.pos, n = [];
            let a, M = 1, l = 0, D = 0, N = 0;
            for (; t.pos < s; ) {
              if (l <= 0) {
                const y = t.readVarint();
                M = 7 & y, l = y >> 3;
              }
              if (l--, M === 1 || M === 2) D += t.readSVarint(), N += t.readSVarint(), M === 1 && (a && n.push(a), a = []), a && a.push(new mt(D, N));
              else {
                if (M !== 7) throw new Error(`unknown command ${M}`);
                a && a.push(a[0].clone());
              }
            }
            return a && n.push(a), n;
          }
          bbox() {
            const t = this._pbf;
            t.pos = this._geometry;
            const s = t.readVarint() + t.pos;
            let n = 1, a = 0, M = 0, l = 0, D = 1 / 0, N = -1 / 0, y = 1 / 0, w = -1 / 0;
            for (; t.pos < s; ) {
              if (a <= 0) {
                const T = t.readVarint();
                n = 7 & T, a = T >> 3;
              }
              if (a--, n === 1 || n === 2) M += t.readSVarint(), l += t.readSVarint(), M < D && (D = M), M > N && (N = M), l < y && (y = l), l > w && (w = l);
              else if (n !== 7) throw new Error(`unknown command ${n}`);
            }
            return [D, y, N, w];
          }
          toGeoJSON(t, s, n) {
            const a = this.extent * Math.pow(2, n), M = this.extent * t, l = this.extent * s, D = this.loadGeometry();
            function N(x) {
              return [360 * (x.x + M) / a - 180, 360 / Math.PI * Math.atan(Math.exp((1 - 2 * (x.y + l) / a) * Math.PI)) - 90];
            }
            function y(x) {
              return x.map(N);
            }
            let w;
            if (this.type === 1) {
              const x = [];
              for (const m of D) x.push(m[0]);
              const A = y(x);
              w = x.length === 1 ? { type: "Point", coordinates: A[0] } : { type: "MultiPoint", coordinates: A };
            } else if (this.type === 2) {
              const x = D.map(y);
              w = x.length === 1 ? { type: "LineString", coordinates: x[0] } : { type: "MultiLineString", coordinates: x };
            } else {
              if (this.type !== 3) throw new Error("unknown feature type");
              {
                const x = (function(m) {
                  const L = m.length;
                  if (L <= 1) return [m];
                  const O = [];
                  let B, P;
                  for (let k = 0; k < L; k++) {
                    const U = CD(m[k]);
                    U !== 0 && (P === void 0 && (P = U < 0), P === U < 0 ? (B && O.push(B), B = [m[k]]) : B && B.push(m[k]));
                  }
                  return B && O.push(B), O;
                })(D), A = [];
                for (const m of x) A.push(m.map(y));
                w = A.length === 1 ? { type: "Polygon", coordinates: A[0] } : { type: "MultiPolygon", coordinates: A };
              }
            }
            const T = { type: "Feature", geometry: w, properties: this.properties };
            return this.id != null && (T.id = this.id), T;
          }
        }
        function LD(i, t, s) {
          i === 1 ? t.id = s.readVarint() : i === 2 ? (function(n, a) {
            const M = n.readVarint() + n.pos;
            for (; n.pos < M; ) {
              const l = a._keys[n.readVarint()], D = a._values[n.readVarint()];
              a.properties[l] = D;
            }
          })(s, t) : i === 3 ? t.type = s.readVarint() : i === 4 && (t._geometry = s.pos);
        }
        function CD(i) {
          let t = 0;
          for (let s, n, a = 0, M = i.length, l = M - 1; a < M; l = a++) s = i[a], n = i[l], t += (n.x - s.x) * (s.y + n.y);
          return t;
        }
        Mo.types = ["Unknown", "Point", "LineString", "Polygon"];
        class zg {
          constructor(t, s) {
            this.version = 1, this.name = "", this.extent = 4096, this.length = 0, this._pbf = t, this._keys = [], this._values = [], this._features = [], t.readFields(OD, this, s), this.length = this._features.length;
          }
          feature(t) {
            if (t < 0 || t >= this._features.length) throw new Error("feature index out of bounds");
            this._pbf.pos = this._features[t];
            const s = this._pbf.readVarint() + this._pbf.pos;
            return new Mo(this._pbf, s, this.extent, this._keys, this._values);
          }
        }
        function OD(i, t, s) {
          i === 15 ? t.version = s.readVarint() : i === 1 ? t.name = s.readString() : i === 5 ? t.extent = s.readVarint() : i === 2 ? t._features.push(s.pos) : i === 3 ? t._keys.push(s.readString()) : i === 4 && t._values.push((function(n) {
            let a = null;
            const M = n.readVarint() + n.pos;
            for (; n.pos < M; ) {
              const l = n.readVarint() >> 3;
              a = l === 1 ? n.readString() : l === 2 ? n.readFloat() : l === 3 ? n.readDouble() : l === 4 ? n.readVarint64() : l === 5 ? n.readVarint() : l === 6 ? n.readSVarint() : l === 7 ? n.readBoolean() : null;
            }
            if (a == null) throw new Error("unknown feature value");
            return a;
          })(s));
        }
        class Ng {
          constructor(t, s) {
            this.layers = t.readFields(ED, {}, s);
          }
        }
        function ED(i, t, s) {
          if (i === 3) {
            const n = new zg(s, s.readVarint() + s.pos);
            n.length && (t[n.name] = n);
          }
        }
        const ou = Math.pow(2, 13);
        function LM(i, t, s, n, a, M, l, D) {
          i.emplaceBack(t, s, 2 * Math.floor(n * ou) + l, a * ou * 2, M * ou * 2, Math.round(D));
        }
        class Mu {
          constructor(t) {
            this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(((s) => s.id)), this.index = t.index, this.hasDependencies = !1, this.layoutVertexArray = new R(), this.centroidVertexArray = new W(), this.indexArray = new wt(), this.programConfigurations = new Cr(t.layers, t.zoom), this.segments = new Yt(), this.stateDependentLayerIds = this.layers.filter(((s) => s.isStateDependent())).map(((s) => s.id));
          }
          populate(t, s, n) {
            this.features = [], this.hasDependencies = Jc("fill-extrusion", this.layers, s);
            for (const { feature: a, id: M, index: l, sourceLayerIndex: D } of t) {
              const N = this.layers[0]._featureFilter.needGeometry, y = _i(a, N);
              if (!this.layers[0]._featureFilter.filter(new ie(this.zoom), y, n)) continue;
              const w = { id: M, sourceLayerIndex: D, index: l, geometry: N ? y.geometry : sr(a), properties: a.properties, type: a.type, patterns: {} };
              this.hasDependencies ? this.features.push(iu("fill-extrusion", this.layers, w, { zoom: this.zoom }, s)) : this.addFeature(w, w.geometry, l, n, {}, s.subdivisionGranularity), s.featureIndex.insert(a, w.geometry, l, D, this.index, !0);
            }
          }
          addFeatures(t, s, n) {
            for (const a of this.features) {
              const { geometry: M } = a;
              this.addFeature(a, M, a.index, s, n, t.subdivisionGranularity);
            }
          }
          update(t, s, n) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, s, this.stateDependentLayers, { imagePositions: n });
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0 && this.centroidVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t) {
            this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, _D), this.centroidVertexBuffer = t.createVertexBuffer(this.centroidVertexArray, jD.members, !0), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy());
          }
          addFeature(t, s, n, a, M, l) {
            for (const D of Sn(s, 500)) {
              const N = { x: 0, y: 0, sampleCount: 0 }, y = this.layoutVertexArray.length;
              this.processPolygon(N, a, t, D, l);
              const w = this.layoutVertexArray.length - y, T = Math.floor(N.x / N.sampleCount), x = Math.floor(N.y / N.sampleCount);
              for (let A = 0; A < w; A++) this.centroidVertexArray.emplaceBack(T, x);
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, n, { imagePositions: M, canonical: a });
          }
          processPolygon(t, s, n, a, M) {
            if (a.length < 1 || dg(a[0])) return;
            for (const T of a) T.length !== 0 && bD(t, T);
            const l = { segment: this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray) }, D = M.fill.getGranularityForZoomLevel(s.z), N = Mo.types[n.type] === "Polygon";
            for (const T of a) {
              if (T.length === 0 || dg(T)) continue;
              const x = Ma(T, D, N);
              this._generateSideFaces(x, l);
            }
            if (!N) return;
            const y = ug(a, s, D, !1), w = this.layoutVertexArray;
            gg(((T, x) => {
              LM(w, T, x, 0, 0, 1, 1, 0);
            }), this.segments, this.layoutVertexArray, this.indexArray, y.verticesFlattened, y.indicesTriangles);
          }
          _generateSideFaces(t, s) {
            let n = 0;
            for (let a = 1; a < t.length; a++) {
              const M = t[a], l = t[a - 1];
              if (QD(M, l)) continue;
              s.segment.vertexLength + 4 > Yt.MAX_VERTEX_ARRAY_LENGTH && (s.segment = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
              const D = M.sub(l)._perp()._unit(), N = l.dist(M);
              n + N > 32768 && (n = 0), LM(this.layoutVertexArray, M.x, M.y, D.x, D.y, 0, 0, n), LM(this.layoutVertexArray, M.x, M.y, D.x, D.y, 0, 1, n), n += N, LM(this.layoutVertexArray, l.x, l.y, D.x, D.y, 0, 0, n), LM(this.layoutVertexArray, l.x, l.y, D.x, D.y, 0, 1, n);
              const y = s.segment.vertexLength;
              this.indexArray.emplaceBack(y, y + 2, y + 1), this.indexArray.emplaceBack(y + 1, y + 2, y + 3), s.segment.vertexLength += 4, s.segment.primitiveLength += 2;
            }
          }
        }
        function bD(i, t) {
          for (let s = 0; s < t.length; s++) {
            const n = t[s];
            s === t.length - 1 && t[0].x === n.x && t[0].y === n.y || (i.x += n.x, i.y += n.y, i.sampleCount++);
          }
        }
        function QD(i, t) {
          return i.x === t.x && (i.x < 0 || i.x > se) || i.y === t.y && (i.y < 0 || i.y > se);
        }
        function dg(i) {
          return i.every(((t) => t.x < 0)) || i.every(((t) => t.x > se)) || i.every(((t) => t.y < 0)) || i.every(((t) => t.y > se));
        }
        let yg;
        jt("FillExtrusionBucket", Mu, { omit: ["layers", "features"] });
        var vD = { get paint() {
          return yg = yg || new Ms({ "fill-extrusion-opacity": new Et(X["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new Bt(X["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new Et(X["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new Et(X["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new ta(X["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new Bt(X["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new Bt(X["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new Et(X["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]) });
        } };
        class BD extends Xs {
          constructor(t, s) {
            super(t, vD, s);
          }
          createBucket(t) {
            return new Mu(t);
          }
          queryRadius() {
            return Gc(this.paint.get("fill-extrusion-translate"));
          }
          is3D() {
            return !0;
          }
          queryIntersectsFeature({ queryGeometry: t, feature: s, featureState: n, geometry: a, transform: M, pixelsToTileUnits: l, pixelPosMatrix: D }) {
            const N = Hc(t, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), -M.bearingInRadians, l), y = this.paint.get("fill-extrusion-height").evaluate(s, n), w = this.paint.get("fill-extrusion-base").evaluate(s, n), T = (function(A, m) {
              const L = [];
              for (const O of A) {
                const B = [O.x, O.y, 0, 1];
                Tn(B, B, m), L.push(new mt(B[0] / B[3], B[1] / B[3]));
              }
              return L;
            })(N, D), x = (function(A, m, L, O) {
              const B = [], P = [], k = O[8] * m, U = O[9] * m, K = O[10] * m, et = O[11] * m, ot = O[8] * L, dt = O[9] * L, Dt = O[10] * L, yt = O[11] * L;
              for (const At of A) {
                const Tt = [], ft = [];
                for (const zt of At) {
                  const bt = zt.x, Qt = zt.y, St = O[0] * bt + O[4] * Qt + O[12], Lt = O[1] * bt + O[5] * Qt + O[13], Rt = O[2] * bt + O[6] * Qt + O[14], ye = O[3] * bt + O[7] * Qt + O[15], We = Rt + K, us = ye + et, di = St + ot, Ls = Lt + dt, ss = Rt + Dt, gs = ye + yt, Qe = new mt((St + k) / us, (Lt + U) / us);
                  Qe.z = We / us, Tt.push(Qe);
                  const is = new mt(di / gs, Ls / gs);
                  is.z = ss / gs, ft.push(is);
                }
                B.push(Tt), P.push(ft);
              }
              return [B, P];
            })(a, w, y, D);
            return (function(A, m, L) {
              let O = 1 / 0;
              Zu(L, m) && (O = Ig(L, m[0]));
              for (let B = 0; B < m.length; B++) {
                const P = m[B], k = A[B];
                for (let U = 0; U < P.length - 1; U++) {
                  const K = P[U], et = [K, P[U + 1], k[U + 1], k[U], K];
                  Ru(L, et) && (O = Math.min(O, Ig(L, et)));
                }
              }
              return O !== 1 / 0 && O;
            })(x[0], x[1], T);
          }
        }
        function CM(i, t) {
          return i.x * t.x + i.y * t.y;
        }
        function Ig(i, t) {
          if (i.length === 1) {
            let s = 0;
            const n = t[s++];
            let a;
            for (; !a || n.equals(a); ) if (a = t[s++], !a) return 1 / 0;
            for (; s < t.length; s++) {
              const M = t[s], l = i[0], D = a.sub(n), N = M.sub(n), y = l.sub(n), w = CM(D, D), T = CM(D, N), x = CM(N, N), A = CM(y, D), m = CM(y, N), L = w * x - T * T, O = (x * A - T * m) / L, B = (w * m - T * A) / L, P = n.z * (1 - O - B) + a.z * O + M.z * B;
              if (isFinite(P)) return P;
            }
            return 1 / 0;
          }
          {
            let s = 1 / 0;
            for (const n of t) s = Math.min(s, n.z);
            return s;
          }
        }
        const SD = Ee([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }], 4), { members: kD } = SD, FD = Ee([{ name: "a_uv_x", components: 1, type: "Float32" }, { name: "a_split_index", components: 1, type: "Float32" }]), { members: YD } = FD, UD = Math.cos(Math.PI / 180 * 37.5), wg = Math.pow(2, 14) / 0.5;
        class cu {
          constructor(t) {
            this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(((s) => s.id)), this.index = t.index, this.hasDependencies = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach(((s) => {
              this.gradients[s.id] = {};
            })), this.layoutVertexArray = new q(), this.layoutVertexArray2 = new $(), this.indexArray = new wt(), this.programConfigurations = new Cr(t.layers, t.zoom), this.segments = new Yt(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter(((s) => s.isStateDependent())).map(((s) => s.id));
          }
          populate(t, s, n) {
            this.hasDependencies = Jc("line", this.layers, s) || this.hasLineDasharray(this.layers);
            const a = this.layers[0].layout.get("line-sort-key"), M = !a.isConstant(), l = [];
            for (const { feature: D, id: N, index: y, sourceLayerIndex: w } of t) {
              const T = this.layers[0]._featureFilter.needGeometry, x = _i(D, T);
              if (!this.layers[0]._featureFilter.filter(new ie(this.zoom), x, n)) continue;
              const A = M ? a.evaluate(x, {}, n) : void 0, m = { id: N, properties: D.properties, type: D.type, sourceLayerIndex: w, index: y, geometry: T ? x.geometry : sr(D), patterns: {}, dashes: {}, sortKey: A };
              l.push(m);
            }
            M && l.sort(((D, N) => D.sortKey - N.sortKey));
            for (const D of l) {
              const { geometry: N, index: y, sourceLayerIndex: w } = D;
              this.hasDependencies ? (Jc("line", this.layers, s) ? iu("line", this.layers, D, { zoom: this.zoom }, s) : this.hasLineDasharray(this.layers) && this.addLineDashDependencies(this.layers, D, this.zoom, s), this.patternFeatures.push(D)) : this.addFeature(D, N, y, n, {}, {}, s.subdivisionGranularity), s.featureIndex.insert(t[y].feature, N, y, w, this.index);
            }
          }
          update(t, s, n, a) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, s, this.stateDependentLayers, { imagePositions: n, dashPositions: a });
          }
          addFeatures(t, s, n, a) {
            for (const M of this.patternFeatures) this.addFeature(M, M.geometry, M.index, s, n, a, t.subdivisionGranularity);
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t) {
            this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = t.createVertexBuffer(this.layoutVertexArray2, YD)), this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, kD), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          lineFeatureClips(t) {
            if (t.properties && Object.prototype.hasOwnProperty.call(t.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(t.properties, "mapbox_clip_end")) return { start: +t.properties.mapbox_clip_start, end: +t.properties.mapbox_clip_end };
          }
          addFeature(t, s, n, a, M, l, D) {
            const N = this.layers[0].layout, y = N.get("line-join").evaluate(t, {}), w = N.get("line-cap"), T = N.get("line-miter-limit"), x = N.get("line-round-limit");
            this.lineClips = this.lineFeatureClips(t);
            for (const A of s) this.addLine(A, t, y, w, T, x, a, D);
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, n, { imagePositions: M, dashPositions: l, canonical: a });
          }
          addLine(t, s, n, a, M, l, D, N) {
            if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, t = Ma(t, D ? N.line.getGranularityForZoomLevel(D.z) : 1), this.lineClips) {
              this.lineClipsArray.push(this.lineClips);
              for (let k = 0; k < t.length - 1; k++) this.totalDistance += t[k].dist(t[k + 1]);
              this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
            }
            const y = Mo.types[s.type] === "Polygon";
            let w = t.length;
            for (; w >= 2 && t[w - 1].equals(t[w - 2]); ) w--;
            let T = 0;
            for (; T < w - 1 && t[T].equals(t[T + 1]); ) T++;
            if (w < (y ? 3 : 2)) return;
            n === "bevel" && (M = 1.05);
            const x = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0, A = this.segments.prepareSegment(10 * w, this.layoutVertexArray, this.indexArray);
            let m, L, O, B, P;
            this.e1 = this.e2 = -1, y && (m = t[w - 2], P = t[T].sub(m)._unit()._perp());
            for (let k = T; k < w; k++) {
              if (O = k === w - 1 ? y ? t[T + 1] : void 0 : t[k + 1], O && t[k].equals(O)) continue;
              P && (B = P), m && (L = m), m = t[k], P = O ? O.sub(m)._unit()._perp() : B, B = B || P;
              let U = B.add(P);
              U.x === 0 && U.y === 0 || U._unit();
              const K = B.x * P.x + B.y * P.y, et = U.x * P.x + U.y * P.y, ot = et !== 0 ? 1 / et : 1 / 0, dt = 2 * Math.sqrt(2 - 2 * et), Dt = et < UD && L && O, yt = B.x * P.y - B.y * P.x > 0;
              if (Dt && k > T) {
                const ft = m.dist(L);
                if (ft > 2 * x) {
                  const zt = m.sub(m.sub(L)._mult(x / ft)._round());
                  this.updateDistance(L, zt), this.addCurrentVertex(zt, B, 0, 0, A), L = zt;
                }
              }
              const At = L && O;
              let Tt = At ? n : y ? "butt" : a;
              if (At && Tt === "round" && (ot < l ? Tt = "miter" : ot <= 2 && (Tt = "fakeround")), Tt === "miter" && ot > M && (Tt = "bevel"), Tt === "bevel" && (ot > 2 && (Tt = "flipbevel"), ot < M && (Tt = "miter")), L && this.updateDistance(L, m), Tt === "miter") U._mult(ot), this.addCurrentVertex(m, U, 0, 0, A);
              else if (Tt === "flipbevel") {
                if (ot > 100) U = P.mult(-1);
                else {
                  const ft = ot * B.add(P).mag() / B.sub(P).mag();
                  U._perp()._mult(ft * (yt ? -1 : 1));
                }
                this.addCurrentVertex(m, U, 0, 0, A), this.addCurrentVertex(m, U.mult(-1), 0, 0, A);
              } else if (Tt === "bevel" || Tt === "fakeround") {
                const ft = -Math.sqrt(ot * ot - 1), zt = yt ? ft : 0, bt = yt ? 0 : ft;
                if (L && this.addCurrentVertex(m, B, zt, bt, A), Tt === "fakeround") {
                  const Qt = Math.round(180 * dt / Math.PI / 20);
                  for (let St = 1; St < Qt; St++) {
                    let Lt = St / Qt;
                    if (Lt !== 0.5) {
                      const ye = Lt - 0.5;
                      Lt += Lt * ye * (Lt - 1) * ((1.0904 + K * (K * (3.55645 - 1.43519 * K) - 3.2452)) * ye * ye + (0.848013 + K * (0.215638 * K - 1.06021)));
                    }
                    const Rt = P.sub(B)._mult(Lt)._add(B)._unit()._mult(yt ? -1 : 1);
                    this.addHalfVertex(m, Rt.x, Rt.y, !1, yt, 0, A);
                  }
                }
                O && this.addCurrentVertex(m, P, -zt, -bt, A);
              } else if (Tt === "butt") this.addCurrentVertex(m, U, 0, 0, A);
              else if (Tt === "square") {
                const ft = L ? 1 : -1;
                this.addCurrentVertex(m, U, ft, ft, A);
              } else Tt === "round" && (L && (this.addCurrentVertex(m, B, 0, 0, A), this.addCurrentVertex(m, B, 1, 1, A, !0)), O && (this.addCurrentVertex(m, P, -1, -1, A, !0), this.addCurrentVertex(m, P, 0, 0, A)));
              if (Dt && k < w - 1) {
                const ft = m.dist(O);
                if (ft > 2 * x) {
                  const zt = m.add(O.sub(m)._mult(x / ft)._round());
                  this.updateDistance(m, zt), this.addCurrentVertex(zt, P, 0, 0, A), m = zt;
                }
              }
            }
          }
          addCurrentVertex(t, s, n, a, M, l = !1) {
            const D = s.y * a - s.x, N = -s.y - s.x * a;
            this.addHalfVertex(t, s.x + s.y * n, s.y - s.x * n, l, !1, n, M), this.addHalfVertex(t, D, N, l, !0, -a, M), this.distance > wg / 2 && this.totalDistance === 0 && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(t, s, n, a, M, l));
          }
          addHalfVertex({ x: t, y: s }, n, a, M, l, D, N) {
            const y = 0.5 * (this.lineClips ? this.scaledDistance * (wg - 1) : this.scaledDistance);
            this.layoutVertexArray.emplaceBack((t << 1) + (M ? 1 : 0), (s << 1) + (l ? 1 : 0), Math.round(63 * n) + 128, Math.round(63 * a) + 128, 1 + (D === 0 ? 0 : D < 0 ? -1 : 1) | (63 & y) << 2, y >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
            const w = N.vertexLength++;
            this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, w, this.e2), N.primitiveLength++), l ? this.e2 = w : this.e1 = w;
          }
          updateScaledDistance() {
            this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;
          }
          updateDistance(t, s) {
            this.distance += t.dist(s), this.updateScaledDistance();
          }
          hasLineDasharray(t) {
            for (const s of t) {
              const n = s.paint.get("line-dasharray");
              if (n && !n.isConstant()) return !0;
            }
            return !1;
          }
          addLineDashDependencies(t, s, n, a) {
            for (const M of t) {
              const l = M.paint.get("line-dasharray");
              if (!l || l.value.kind === "constant") continue;
              const D = M.layout.get("line-cap") === "round", N = { dasharray: l.value.evaluate({ zoom: n - 1 }, s, {}), round: D }, y = { dasharray: l.value.evaluate({ zoom: n }, s, {}), round: D }, w = { dasharray: l.value.evaluate({ zoom: n + 1 }, s, {}), round: D }, T = `${N.dasharray.join(",")},${N.round}`, x = `${y.dasharray.join(",")},${y.round}`, A = `${w.dasharray.join(",")},${w.round}`;
              a.dashDependencies[T] = N, a.dashDependencies[x] = y, a.dashDependencies[A] = w, s.dashes[M.id] = { min: T, mid: x, max: A };
            }
          }
        }
        let pg, Tg;
        jt("LineBucket", cu, { omit: ["layers", "patternFeatures"] });
        var fg = { get paint() {
          return Tg = Tg || new Ms({ "line-opacity": new Bt(X.paint_line["line-opacity"]), "line-color": new Bt(X.paint_line["line-color"]), "line-translate": new Et(X.paint_line["line-translate"]), "line-translate-anchor": new Et(X.paint_line["line-translate-anchor"]), "line-width": new Bt(X.paint_line["line-width"]), "line-gap-width": new Bt(X.paint_line["line-gap-width"]), "line-offset": new Bt(X.paint_line["line-offset"]), "line-blur": new Bt(X.paint_line["line-blur"]), "line-dasharray": new ta(X.paint_line["line-dasharray"]), "line-pattern": new ta(X.paint_line["line-pattern"]), "line-gradient": new ea(X.paint_line["line-gradient"]) });
        }, get layout() {
          return pg = pg || new Ms({ "line-cap": new Et(X.layout_line["line-cap"]), "line-join": new Bt(X.layout_line["line-join"]), "line-miter-limit": new Et(X.layout_line["line-miter-limit"]), "line-round-limit": new Et(X.layout_line["line-round-limit"]), "line-sort-key": new Bt(X.layout_line["line-sort-key"]) });
        } };
        class XD extends Bt {
          possiblyEvaluate(t, s) {
            return s = new ie(Math.floor(s.zoom), { now: s.now, fadeDuration: s.fadeDuration, zoomHistory: s.zoomHistory, transition: s.transition }), super.possiblyEvaluate(t, s);
          }
          evaluate(t, s, n, a) {
            return s = rs({}, s, { zoom: Math.floor(s.zoom) }), super.evaluate(t, s, n, a);
          }
        }
        let tl;
        class WD extends Xs {
          constructor(t, s) {
            super(t, fg, s), this.gradientVersion = 0, tl || (tl = new XD(fg.paint.properties["line-width"].specification), tl.useIntegerZoom = !0);
          }
          _handleSpecialPaintPropertyUpdate(t) {
            if (t === "line-gradient") {
              const s = this.gradientExpression();
              this.stepInterpolant = !!(function(n) {
                return n._styleExpression !== void 0;
              })(s) && s._styleExpression.expression instanceof $r, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
            }
          }
          gradientExpression() {
            return this._transitionablePaint._values["line-gradient"].value.expression;
          }
          recalculate(t, s) {
            super.recalculate(t, s), this.paint._values["line-floorwidth"] = tl.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t);
          }
          createBucket(t) {
            return new cu(t);
          }
          queryRadius(t) {
            const s = t, n = xg(ro("line-width", this, s), ro("line-gap-width", this, s)), a = ro("line-offset", this, s);
            return n / 2 + Math.abs(a) + Gc(this.paint.get("line-translate"));
          }
          queryIntersectsFeature({ queryGeometry: t, feature: s, featureState: n, geometry: a, transform: M, pixelsToTileUnits: l }) {
            const D = Hc(t, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), -M.bearingInRadians, l), N = l / 2 * xg(this.paint.get("line-width").evaluate(s, n), this.paint.get("line-gap-width").evaluate(s, n)), y = this.paint.get("line-offset").evaluate(s, n);
            return y && (a = (function(w, T) {
              const x = [];
              for (let A = 0; A < w.length; A++) {
                const m = w[A], L = [];
                for (let O = 0; O < m.length; O++) {
                  const B = m[O - 1], P = m[O], k = m[O + 1], U = O === 0 ? new mt(0, 0) : P.sub(B)._unit()._perp(), K = O === m.length - 1 ? new mt(0, 0) : k.sub(P)._unit()._perp(), et = U._add(K)._unit(), ot = et.x * K.x + et.y * K.y;
                  ot !== 0 && et._mult(1 / ot), L.push(et._mult(T)._add(P));
                }
                x.push(L);
              }
              return x;
            })(a, y * l)), (function(w, T, x) {
              for (let A = 0; A < T.length; A++) {
                const m = T[A];
                if (w.length >= 3) {
                  for (let L = 0; L < m.length; L++) if (io(w, m[L])) return !0;
                }
                if (Jh(w, m, x)) return !0;
              }
              return !1;
            })(D, a, N);
          }
          isTileClipped() {
            return !0;
          }
        }
        function xg(i, t) {
          return t > 0 ? t + 2 * i : i;
        }
        const PD = Ee([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_data", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), RD = Ee([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4);
        Ee([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
        const ZD = Ee([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }, { name: "a_box_real", components: 2, type: "Int16" }]);
        Ee([{ type: "Int16", name: "anchorPointX" }, { type: "Int16", name: "anchorPointY" }, { type: "Int16", name: "x1" }, { type: "Int16", name: "y1" }, { type: "Int16", name: "x2" }, { type: "Int16", name: "y2" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
        const Ag = Ee([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), VD = Ee([{ name: "a_pos", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
        function GD(i, t, s) {
          return i.sections.forEach(((n) => {
            n.text = (function(a, M, l) {
              const D = M.layout.get("text-transform").evaluate(l, {});
              return D === "uppercase" ? a = a.toLocaleUpperCase() : D === "lowercase" && (a = a.toLocaleLowerCase()), qi.applyArabicShaping && (a = qi.applyArabicShaping(a)), a;
            })(n.text, t, s);
          })), i;
        }
        Ee([{ name: "triangle", components: 3, type: "Uint16" }]), Ee([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }]), Ee([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", name: "textBoxScale" }, { type: "Float32", name: "collisionCircleDiameter" }, { type: "Uint16", name: "textAnchorOffsetStartIndex" }, { type: "Uint16", name: "textAnchorOffsetEndIndex" }]), Ee([{ type: "Float32", name: "offsetX" }]), Ee([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]), Ee([{ type: "Uint16", name: "textAnchor" }, { type: "Float32", components: 2, name: "textOffset" }]);
        var Ge = 24;
        const OM = { "!": "", "#": "", $: "", "%": "", "&": "", "(": "", ")": "", "*": "", "+": "", ",": "", "-": "", ".": "", "/": "", ":": "", ";": "", "<": "", "=": "", ">": "", "?": "", "@": "", "[": "", "\\": "", "]": "", "^": "", _: "", "`": "", "{": "", "|": "", "}": "", "~": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "" }, HD = { 10: !0, 32: !0, 38: !0, 41: !0, 43: !0, 45: !0, 47: !0, 173: !0, 183: !0, 8203: !0, 8208: !0, 8211: !0, 8231: !0 }, JD = { 40: !0 };
        function mg(i, t, s, n, a, M) {
          if ("fontStack" in t) {
            const l = s[t.fontStack], D = l && l[i];
            return D ? D.metrics.advance * t.scale + a : 0;
          }
          {
            const l = n[t.imageName];
            return l ? l.displaySize[0] * t.scale * Ge / M + a : 0;
          }
        }
        function jg(i, t, s, n) {
          const a = Math.pow(i - t, 2);
          return n ? i < t ? a / 2 : 2 * a : a + Math.abs(s) * s;
        }
        function qD(i, t, s) {
          let n = 0;
          return i === 10 && (n -= 1e4), s && (n += 150), i !== 40 && i !== 65288 || (n += 50), t !== 41 && t !== 65289 || (n += 50), n;
        }
        function _g(i, t, s, n, a, M) {
          let l = null, D = jg(t, s, a, M);
          for (const N of n) {
            const y = jg(t - N.x, s, a, M) + N.badness;
            y <= D && (l = N, D = y);
          }
          return { index: i, x: t, priorBreak: l, badness: D };
        }
        function Lg(i) {
          return i ? Lg(i.priorBreak).concat(i.index) : [];
        }
        class co {
          constructor(t = "", s = [], n = []) {
            this.text = t, this.sections = s, this.sectionIndex = n, this.imageSectionID = null;
          }
          static fromFeature(t, s) {
            const n = new co();
            for (let a = 0; a < t.sections.length; a++) {
              const M = t.sections[a];
              M.image ? n.addImageSection(M) : n.addTextSection(M, s);
            }
            return n;
          }
          length() {
            return [...this.text].length;
          }
          getSection(t) {
            return this.sections[this.sectionIndex[t]];
          }
          getSectionIndex(t) {
            return this.sectionIndex[t];
          }
          verticalizePunctuation() {
            this.text = (function(t) {
              let s = "", n = { premature: !0, value: void 0 };
              const a = t[Symbol.iterator]();
              let M = a.next();
              const l = t[Symbol.iterator]();
              l.next();
              let D = l.next();
              for (; !M.done; ) s += !D.done && MM(D.value.codePointAt(0)) && !OM[D.value] || !n.premature && MM(n.value.codePointAt(0)) && !OM[n.value] || !OM[M.value] ? M.value : OM[M.value], n = { value: M.value, premature: !1 }, M = a.next(), D = l.next();
              return s;
            })(this.text);
          }
          hasZeroWidthSpaces() {
            return this.text.includes("");
          }
          trim() {
            const t = this.text.match(/^\s*/), s = t ? t[0].length : 0, n = this.text.match(/\S\s*$/), a = n ? n[0].length - 1 : 0;
            this.text = this.text.substring(s, this.text.length - a), this.sectionIndex = this.sectionIndex.slice(s, this.sectionIndex.length - a);
          }
          substring(t, s) {
            const n = [...this.text].slice(t, s).join(""), a = this.sectionIndex.slice(t, s);
            return new co(n, this.sections, a);
          }
          toCodeUnitIndex(t) {
            return [...this.text].slice(0, t).join("").length;
          }
          toString() {
            return this.text;
          }
          getMaxScale() {
            return this.sectionIndex.reduce(((t, s) => Math.max(t, this.sections[s].scale)), 0);
          }
          getMaxImageSize(t) {
            let s = 0, n = 0;
            for (let a = 0; a < this.length(); a++) {
              const M = this.getSection(a);
              if ("imageName" in M) {
                const l = t[M.imageName];
                if (!l) continue;
                const D = l.displaySize;
                s = Math.max(s, D[0]), n = Math.max(n, D[1]);
              }
            }
            return { maxImageWidth: s, maxImageHeight: n };
          }
          addTextSection(t, s) {
            this.text += t.text, this.sections.push({ scale: t.scale || 1, verticalAlign: t.verticalAlign || "bottom", fontStack: t.fontStack || s });
            const n = this.sections.length - 1;
            this.sectionIndex.push(...[...t.text].map((() => n)));
          }
          addImageSection(t) {
            const s = t.image ? t.image.name : "";
            if (s.length === 0) return void we("Can't add FormattedSection with an empty image.");
            const n = this.getNextImageSectionCharCode();
            n ? (this.text += String.fromCharCode(n), this.sections.push({ scale: 1, verticalAlign: t.verticalAlign || "bottom", imageName: s }), this.sectionIndex.push(this.sections.length - 1)) : we("Reached maximum number of images 6401");
          }
          getNextImageSectionCharCode() {
            return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
          }
          determineLineBreaks(t, s, n, a, M) {
            const l = [], D = this.determineAverageLineWidth(t, s, n, a, M), N = this.hasZeroWidthSpaces();
            let y = 0, w = 0;
            const T = this.text[Symbol.iterator]();
            let x = T.next();
            const A = this.text[Symbol.iterator]();
            A.next();
            let m = A.next();
            const L = this.text[Symbol.iterator]();
            L.next(), L.next();
            let O = L.next();
            for (; !x.done; ) {
              const B = this.getSection(w), P = x.value.codePointAt(0);
              if (vc(P) || (y += mg(P, B, n, a, t, M)), !m.done) {
                const k = Xl(P), U = m.value.codePointAt(0);
                (HD[P] || k || "imageName" in B || !O.done && JD[U]) && l.push(_g(w + 1, y, D, l, qD(P, U, k && N), !1));
              }
              w++, x = T.next(), m = A.next(), O = L.next();
            }
            return Lg(_g(this.length(), y, D, l, 0, !0));
          }
          determineAverageLineWidth(t, s, n, a, M) {
            let l = 0, D = 0;
            for (const N of this.text) {
              const y = this.getSection(D);
              l += mg(N.codePointAt(0), y, n, a, t, M), D++;
            }
            return l / Math.max(1, Math.ceil(l / s));
          }
        }
        const lu = 4294967296, Cg = 1 / lu, Og = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8");
        class uu {
          constructor(t = new Uint8Array(16)) {
            this.buf = ArrayBuffer.isView(t) ? t : new Uint8Array(t), this.dataView = new DataView(this.buf.buffer), this.pos = 0, this.type = 0, this.length = this.buf.length;
          }
          readFields(t, s, n = this.length) {
            for (; this.pos < n; ) {
              const a = this.readVarint(), M = a >> 3, l = this.pos;
              this.type = 7 & a, t(M, s, this), this.pos === l && this.skip(a);
            }
            return s;
          }
          readMessage(t, s) {
            return this.readFields(t, s, this.readVarint() + this.pos);
          }
          readFixed32() {
            const t = this.dataView.getUint32(this.pos, !0);
            return this.pos += 4, t;
          }
          readSFixed32() {
            const t = this.dataView.getInt32(this.pos, !0);
            return this.pos += 4, t;
          }
          readFixed64() {
            const t = this.dataView.getUint32(this.pos, !0) + this.dataView.getUint32(this.pos + 4, !0) * lu;
            return this.pos += 8, t;
          }
          readSFixed64() {
            const t = this.dataView.getUint32(this.pos, !0) + this.dataView.getInt32(this.pos + 4, !0) * lu;
            return this.pos += 8, t;
          }
          readFloat() {
            const t = this.dataView.getFloat32(this.pos, !0);
            return this.pos += 4, t;
          }
          readDouble() {
            const t = this.dataView.getFloat64(this.pos, !0);
            return this.pos += 8, t;
          }
          readVarint(t) {
            const s = this.buf;
            let n, a;
            return a = s[this.pos++], n = 127 & a, a < 128 ? n : (a = s[this.pos++], n |= (127 & a) << 7, a < 128 ? n : (a = s[this.pos++], n |= (127 & a) << 14, a < 128 ? n : (a = s[this.pos++], n |= (127 & a) << 21, a < 128 ? n : (a = s[this.pos], n |= (15 & a) << 28, (function(M, l, D) {
              const N = D.buf;
              let y, w;
              if (w = N[D.pos++], y = (112 & w) >> 4, w < 128 || (w = N[D.pos++], y |= (127 & w) << 3, w < 128) || (w = N[D.pos++], y |= (127 & w) << 10, w < 128) || (w = N[D.pos++], y |= (127 & w) << 17, w < 128) || (w = N[D.pos++], y |= (127 & w) << 24, w < 128) || (w = N[D.pos++], y |= (1 & w) << 31, w < 128)) return lo(M, y, l);
              throw new Error("Expected varint not more than 10 bytes");
            })(n, t, this)))));
          }
          readVarint64() {
            return this.readVarint(!0);
          }
          readSVarint() {
            const t = this.readVarint();
            return t % 2 == 1 ? (t + 1) / -2 : t / 2;
          }
          readBoolean() {
            return !!this.readVarint();
          }
          readString() {
            const t = this.readVarint() + this.pos, s = this.pos;
            return this.pos = t, t - s >= 12 && Og ? Og.decode(this.buf.subarray(s, t)) : (function(n, a, M) {
              let l = "", D = a;
              for (; D < M; ) {
                const N = n[D];
                let y, w, T, x = null, A = N > 239 ? 4 : N > 223 ? 3 : N > 191 ? 2 : 1;
                if (D + A > M) break;
                A === 1 ? N < 128 && (x = N) : A === 2 ? (y = n[D + 1], (192 & y) == 128 && (x = (31 & N) << 6 | 63 & y, x <= 127 && (x = null))) : A === 3 ? (y = n[D + 1], w = n[D + 2], (192 & y) == 128 && (192 & w) == 128 && (x = (15 & N) << 12 | (63 & y) << 6 | 63 & w, (x <= 2047 || x >= 55296 && x <= 57343) && (x = null))) : A === 4 && (y = n[D + 1], w = n[D + 2], T = n[D + 3], (192 & y) == 128 && (192 & w) == 128 && (192 & T) == 128 && (x = (15 & N) << 18 | (63 & y) << 12 | (63 & w) << 6 | 63 & T, (x <= 65535 || x >= 1114112) && (x = null))), x === null ? (x = 65533, A = 1) : x > 65535 && (x -= 65536, l += String.fromCharCode(x >>> 10 & 1023 | 55296), x = 56320 | 1023 & x), l += String.fromCharCode(x), D += A;
              }
              return l;
            })(this.buf, s, t);
          }
          readBytes() {
            const t = this.readVarint() + this.pos, s = this.buf.subarray(this.pos, t);
            return this.pos = t, s;
          }
          readPackedVarint(t = [], s) {
            const n = this.readPackedEnd();
            for (; this.pos < n; ) t.push(this.readVarint(s));
            return t;
          }
          readPackedSVarint(t = []) {
            const s = this.readPackedEnd();
            for (; this.pos < s; ) t.push(this.readSVarint());
            return t;
          }
          readPackedBoolean(t = []) {
            const s = this.readPackedEnd();
            for (; this.pos < s; ) t.push(this.readBoolean());
            return t;
          }
          readPackedFloat(t = []) {
            const s = this.readPackedEnd();
            for (; this.pos < s; ) t.push(this.readFloat());
            return t;
          }
          readPackedDouble(t = []) {
            const s = this.readPackedEnd();
            for (; this.pos < s; ) t.push(this.readDouble());
            return t;
          }
          readPackedFixed32(t = []) {
            const s = this.readPackedEnd();
            for (; this.pos < s; ) t.push(this.readFixed32());
            return t;
          }
          readPackedSFixed32(t = []) {
            const s = this.readPackedEnd();
            for (; this.pos < s; ) t.push(this.readSFixed32());
            return t;
          }
          readPackedFixed64(t = []) {
            const s = this.readPackedEnd();
            for (; this.pos < s; ) t.push(this.readFixed64());
            return t;
          }
          readPackedSFixed64(t = []) {
            const s = this.readPackedEnd();
            for (; this.pos < s; ) t.push(this.readSFixed64());
            return t;
          }
          readPackedEnd() {
            return this.type === 2 ? this.readVarint() + this.pos : this.pos + 1;
          }
          skip(t) {
            const s = 7 & t;
            if (s === 0) for (; this.buf[this.pos++] > 127; ) ;
            else if (s === 2) this.pos = this.readVarint() + this.pos;
            else if (s === 5) this.pos += 4;
            else {
              if (s !== 1) throw new Error(`Unimplemented type: ${s}`);
              this.pos += 8;
            }
          }
          writeTag(t, s) {
            this.writeVarint(t << 3 | s);
          }
          realloc(t) {
            let s = this.length || 16;
            for (; s < this.pos + t; ) s *= 2;
            if (s !== this.length) {
              const n = new Uint8Array(s);
              n.set(this.buf), this.buf = n, this.dataView = new DataView(n.buffer), this.length = s;
            }
          }
          finish() {
            return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
          }
          writeFixed32(t) {
            this.realloc(4), this.dataView.setInt32(this.pos, t, !0), this.pos += 4;
          }
          writeSFixed32(t) {
            this.realloc(4), this.dataView.setInt32(this.pos, t, !0), this.pos += 4;
          }
          writeFixed64(t) {
            this.realloc(8), this.dataView.setInt32(this.pos, -1 & t, !0), this.dataView.setInt32(this.pos + 4, Math.floor(t * Cg), !0), this.pos += 8;
          }
          writeSFixed64(t) {
            this.realloc(8), this.dataView.setInt32(this.pos, -1 & t, !0), this.dataView.setInt32(this.pos + 4, Math.floor(t * Cg), !0), this.pos += 8;
          }
          writeVarint(t) {
            (t = +t || 0) > 268435455 || t < 0 ? (function(s, n) {
              let a, M;
              if (s >= 0 ? (a = s % 4294967296 | 0, M = s / 4294967296 | 0) : (a = ~(-s % 4294967296), M = ~(-s / 4294967296), 4294967295 ^ a ? a = a + 1 | 0 : (a = 0, M = M + 1 | 0)), s >= 18446744073709552e3 || s < -18446744073709552e3) throw new Error("Given varint doesn't fit into 10 bytes");
              n.realloc(10), (function(l, D, N) {
                N.buf[N.pos++] = 127 & l | 128, l >>>= 7, N.buf[N.pos++] = 127 & l | 128, l >>>= 7, N.buf[N.pos++] = 127 & l | 128, l >>>= 7, N.buf[N.pos++] = 127 & l | 128, N.buf[N.pos] = 127 & (l >>>= 7);
              })(a, 0, n), (function(l, D) {
                const N = (7 & l) << 4;
                D.buf[D.pos++] |= N | ((l >>>= 3) ? 128 : 0), l && (D.buf[D.pos++] = 127 & l | ((l >>>= 7) ? 128 : 0), l && (D.buf[D.pos++] = 127 & l | ((l >>>= 7) ? 128 : 0), l && (D.buf[D.pos++] = 127 & l | ((l >>>= 7) ? 128 : 0), l && (D.buf[D.pos++] = 127 & l | ((l >>>= 7) ? 128 : 0), l && (D.buf[D.pos++] = 127 & l)))));
              })(M, n);
            })(t, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = t >>> 7 & 127))));
          }
          writeSVarint(t) {
            this.writeVarint(t < 0 ? 2 * -t - 1 : 2 * t);
          }
          writeBoolean(t) {
            this.writeVarint(+t);
          }
          writeString(t) {
            t = String(t), this.realloc(4 * t.length), this.pos++;
            const s = this.pos;
            this.pos = (function(a, M, l) {
              for (let D, N, y = 0; y < M.length; y++) {
                if (D = M.charCodeAt(y), D > 55295 && D < 57344) {
                  if (!N) {
                    D > 56319 || y + 1 === M.length ? (a[l++] = 239, a[l++] = 191, a[l++] = 189) : N = D;
                    continue;
                  }
                  if (D < 56320) {
                    a[l++] = 239, a[l++] = 191, a[l++] = 189, N = D;
                    continue;
                  }
                  D = N - 55296 << 10 | D - 56320 | 65536, N = null;
                } else N && (a[l++] = 239, a[l++] = 191, a[l++] = 189, N = null);
                D < 128 ? a[l++] = D : (D < 2048 ? a[l++] = D >> 6 | 192 : (D < 65536 ? a[l++] = D >> 12 | 224 : (a[l++] = D >> 18 | 240, a[l++] = D >> 12 & 63 | 128), a[l++] = D >> 6 & 63 | 128), a[l++] = 63 & D | 128);
              }
              return l;
            })(this.buf, t, this.pos);
            const n = this.pos - s;
            n >= 128 && Eg(s, n, this), this.pos = s - 1, this.writeVarint(n), this.pos += n;
          }
          writeFloat(t) {
            this.realloc(4), this.dataView.setFloat32(this.pos, t, !0), this.pos += 4;
          }
          writeDouble(t) {
            this.realloc(8), this.dataView.setFloat64(this.pos, t, !0), this.pos += 8;
          }
          writeBytes(t) {
            const s = t.length;
            this.writeVarint(s), this.realloc(s);
            for (let n = 0; n < s; n++) this.buf[this.pos++] = t[n];
          }
          writeRawMessage(t, s) {
            this.pos++;
            const n = this.pos;
            t(s, this);
            const a = this.pos - n;
            a >= 128 && Eg(n, a, this), this.pos = n - 1, this.writeVarint(a), this.pos += a;
          }
          writeMessage(t, s, n) {
            this.writeTag(t, 2), this.writeRawMessage(s, n);
          }
          writePackedVarint(t, s) {
            s.length && this.writeMessage(t, $D, s);
          }
          writePackedSVarint(t, s) {
            s.length && this.writeMessage(t, KD, s);
          }
          writePackedBoolean(t, s) {
            s.length && this.writeMessage(t, sz, s);
          }
          writePackedFloat(t, s) {
            s.length && this.writeMessage(t, tz, s);
          }
          writePackedDouble(t, s) {
            s.length && this.writeMessage(t, ez, s);
          }
          writePackedFixed32(t, s) {
            s.length && this.writeMessage(t, iz, s);
          }
          writePackedSFixed32(t, s) {
            s.length && this.writeMessage(t, rz, s);
          }
          writePackedFixed64(t, s) {
            s.length && this.writeMessage(t, nz, s);
          }
          writePackedSFixed64(t, s) {
            s.length && this.writeMessage(t, az, s);
          }
          writeBytesField(t, s) {
            this.writeTag(t, 2), this.writeBytes(s);
          }
          writeFixed32Field(t, s) {
            this.writeTag(t, 5), this.writeFixed32(s);
          }
          writeSFixed32Field(t, s) {
            this.writeTag(t, 5), this.writeSFixed32(s);
          }
          writeFixed64Field(t, s) {
            this.writeTag(t, 1), this.writeFixed64(s);
          }
          writeSFixed64Field(t, s) {
            this.writeTag(t, 1), this.writeSFixed64(s);
          }
          writeVarintField(t, s) {
            this.writeTag(t, 0), this.writeVarint(s);
          }
          writeSVarintField(t, s) {
            this.writeTag(t, 0), this.writeSVarint(s);
          }
          writeStringField(t, s) {
            this.writeTag(t, 2), this.writeString(s);
          }
          writeFloatField(t, s) {
            this.writeTag(t, 5), this.writeFloat(s);
          }
          writeDoubleField(t, s) {
            this.writeTag(t, 1), this.writeDouble(s);
          }
          writeBooleanField(t, s) {
            this.writeVarintField(t, +s);
          }
        }
        function lo(i, t, s) {
          return s ? 4294967296 * t + (i >>> 0) : 4294967296 * (t >>> 0) + (i >>> 0);
        }
        function Eg(i, t, s) {
          const n = t <= 16383 ? 1 : t <= 2097151 ? 2 : t <= 268435455 ? 3 : Math.floor(Math.log(t) / (7 * Math.LN2));
          s.realloc(n);
          for (let a = s.pos - 1; a >= i; a--) s.buf[a + n] = s.buf[a];
        }
        function $D(i, t) {
          for (let s = 0; s < i.length; s++) t.writeVarint(i[s]);
        }
        function KD(i, t) {
          for (let s = 0; s < i.length; s++) t.writeSVarint(i[s]);
        }
        function tz(i, t) {
          for (let s = 0; s < i.length; s++) t.writeFloat(i[s]);
        }
        function ez(i, t) {
          for (let s = 0; s < i.length; s++) t.writeDouble(i[s]);
        }
        function sz(i, t) {
          for (let s = 0; s < i.length; s++) t.writeBoolean(i[s]);
        }
        function iz(i, t) {
          for (let s = 0; s < i.length; s++) t.writeFixed32(i[s]);
        }
        function rz(i, t) {
          for (let s = 0; s < i.length; s++) t.writeSFixed32(i[s]);
        }
        function nz(i, t) {
          for (let s = 0; s < i.length; s++) t.writeFixed64(i[s]);
        }
        function az(i, t) {
          for (let s = 0; s < i.length; s++) t.writeSFixed64(i[s]);
        }
        function oz(i, t, s) {
          i === 1 && s.readMessage(Mz, t);
        }
        function Mz(i, t, s) {
          if (i === 3) {
            const { id: n, bitmap: a, width: M, height: l, left: D, top: N, advance: y } = s.readMessage(cz, {});
            t.push({ id: n, bitmap: new TM({ width: M + 6, height: l + 6 }, a), metrics: { width: M, height: l, left: D, top: N, advance: y } });
          }
        }
        function cz(i, t, s) {
          i === 1 ? t.id = s.readVarint() : i === 2 ? t.bitmap = s.readBytes() : i === 3 ? t.width = s.readVarint() : i === 4 ? t.height = s.readVarint() : i === 5 ? t.left = s.readSVarint() : i === 6 ? t.top = s.readSVarint() : i === 7 && (t.advance = s.readVarint());
        }
        function bg(i) {
          let t = 0, s = 0;
          for (const l of i) t += l.w * l.h, s = Math.max(s, l.w);
          i.sort(((l, D) => D.h - l.h));
          const n = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(t / 0.95)), s), h: 1 / 0 }];
          let a = 0, M = 0;
          for (const l of i) for (let D = n.length - 1; D >= 0; D--) {
            const N = n[D];
            if (!(l.w > N.w || l.h > N.h)) {
              if (l.x = N.x, l.y = N.y, M = Math.max(M, l.y + l.h), a = Math.max(a, l.x + l.w), l.w === N.w && l.h === N.h) {
                const y = n.pop();
                y && D < n.length && (n[D] = y);
              } else l.h === N.h ? (N.x += l.w, N.w -= l.w) : l.w === N.w ? (N.y += l.h, N.h -= l.h) : (n.push({ x: N.x + l.w, y: N.y, w: N.w - l.w, h: l.h }), N.y += l.h, N.h -= l.h);
              break;
            }
          }
          return { w: a, h: M, fill: t / (a * M) || 0 };
        }
        class gu {
          constructor(t, { pixelRatio: s, version: n, stretchX: a, stretchY: M, content: l, textFitWidth: D, textFitHeight: N }) {
            this.paddedRect = t, this.pixelRatio = s, this.stretchX = a, this.stretchY = M, this.content = l, this.version = n, this.textFitWidth = D, this.textFitHeight = N;
          }
          get tl() {
            return [this.paddedRect.x + 1, this.paddedRect.y + 1];
          }
          get br() {
            return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1];
          }
          get tlbr() {
            return this.tl.concat(this.br);
          }
          get displaySize() {
            return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio];
          }
        }
        class Qg {
          constructor(t, s) {
            const n = {}, a = {};
            this.haveRenderCallbacks = [];
            const M = [];
            this.addImages(t, n, M), this.addImages(s, a, M);
            const { w: l, h: D } = bg(M), N = new Qs({ width: l || 1, height: D || 1 });
            for (const y in t) {
              const w = t[y], T = n[y].paddedRect;
              Qs.copy(w.data, N, { x: 0, y: 0 }, { x: T.x + 1, y: T.y + 1 }, w.data);
            }
            for (const y in s) {
              const w = s[y], T = a[y].paddedRect, x = T.x + 1, A = T.y + 1, m = w.data.width, L = w.data.height;
              Qs.copy(w.data, N, { x: 0, y: 0 }, { x, y: A }, w.data), Qs.copy(w.data, N, { x: 0, y: L - 1 }, { x, y: A - 1 }, { width: m, height: 1 }), Qs.copy(w.data, N, { x: 0, y: 0 }, { x, y: A + L }, { width: m, height: 1 }), Qs.copy(w.data, N, { x: m - 1, y: 0 }, { x: x - 1, y: A }, { width: 1, height: L }), Qs.copy(w.data, N, { x: 0, y: 0 }, { x: x + m, y: A }, { width: 1, height: L });
            }
            this.image = N, this.iconPositions = n, this.patternPositions = a;
          }
          addImages(t, s, n) {
            for (const a in t) {
              const M = t[a], l = { x: 0, y: 0, w: M.data.width + 2, h: M.data.height + 2 };
              n.push(l), s[a] = new gu(l, M), M.hasRenderCallback && this.haveRenderCallbacks.push(a);
            }
          }
          patchUpdatedImages(t, s) {
            t.dispatchRenderCallbacks(this.haveRenderCallbacks);
            for (const n in t.updatedImages) this.patchUpdatedImage(this.iconPositions[n], t.getImage(n), s), this.patchUpdatedImage(this.patternPositions[n], t.getImage(n), s);
          }
          patchUpdatedImage(t, s, n) {
            if (!t || !s || t.version === s.version) return;
            t.version = s.version;
            const [a, M] = t.tl;
            n.update(s.data, void 0, { x: a, y: M });
          }
        }
        var hn;
        function el(i, t, s, n, a, M, l, D, N, y, w, T, x, A, m) {
          const L = co.fromFeature(i, a);
          let O;
          T === b.ay.vertical && L.verticalizePunctuation();
          let B = L.determineLineBreaks(y, M, t, n, A);
          const { processBidirectionalText: P, processStyledBidirectionalText: k } = qi;
          if (P && L.sections.length === 1) {
            O = [], B = B.map(((ot) => L.toCodeUnitIndex(ot)));
            const et = P(L.toString(), B);
            for (const ot of et) {
              const dt = [...ot].map((() => 0));
              O.push(new co(ot, L.sections, dt));
            }
          } else if (k) {
            O = [], B = B.map(((Dt) => L.toCodeUnitIndex(Dt)));
            let et = 0;
            const ot = [];
            for (const Dt of L.text) ot.push(...Array(Dt.length).fill(L.sectionIndex[et])), et++;
            const dt = k(L.text, ot, B);
            for (const Dt of dt) {
              const yt = [];
              let At = "";
              for (const Tt of Dt[0]) yt.push(Dt[1][At.length]), At += Tt;
              O.push(new co(Dt[0], L.sections, yt));
            }
          } else O = (function(et, ot) {
            const dt = [];
            let Dt = 0;
            for (const yt of ot) dt.push(et.substring(Dt, yt)), Dt = yt;
            return Dt < et.length() && dt.push(et.substring(Dt, et.length())), dt;
          })(L, B);
          const U = [], K = { positionedLines: U, text: L.toString(), top: w[1], bottom: w[1], left: w[0], right: w[0], writingMode: T, iconsInText: !1, verticalizable: !1 };
          return (function(et, ot, dt, Dt, yt, At, Tt, ft, zt, bt, Qt, St) {
            let Lt = 0, Rt = 0, ye = 0, We = 0;
            const us = ft === "right" ? 1 : ft === "left" ? 0 : 0.5, di = Ge / St;
            let Ls = 0;
            for (const Qe of yt) {
              Qe.trim();
              const is = Qe.getMaxScale(), ys = { positionedGlyphs: [], lineOffset: 0 };
              et.positionedLines[Ls] = ys;
              const Is = ys.positionedGlyphs;
              let vs = 0;
              if (!Qe.length()) {
                Rt += At, ++Ls;
                continue;
              }
              const hs = lz(Dt, Qe, di);
              let Bs = 0;
              for (const qe of Qe.text) {
                const me = Qe.getSection(Bs), Pe = qe.codePointAt(0), Oe = uz(zt, Qt, Pe), $e = { glyph: Pe, imageName: null, x: Lt, y: Rt + -17, vertical: Oe, scale: 1, fontStack: "", sectionIndex: Qe.getSectionIndex(Bs), metrics: null, rect: null };
                let br;
                if ("fontStack" in me) {
                  if (br = gz(me, Pe, Oe, hs, ot, dt), !br) continue;
                  $e.fontStack = me.fontStack;
                } else {
                  if (et.iconsInText = !0, me.scale *= di, br = hz(me, Oe, is, hs, Dt), !br) continue;
                  vs = Math.max(vs, br.imageOffset), $e.imageName = me.imageName;
                }
                const { rect: Oi, metrics: XM, baselineOffset: yn } = br;
                $e.y += yn, $e.scale = me.scale, $e.metrics = XM, $e.rect = Oi, Is.push($e), Oe ? (et.verticalizable = !0, Lt += ("imageName" in me ? XM.advance : Ge) * me.scale + bt) : Lt += XM.advance * me.scale + bt, Bs++;
              }
              Is.length !== 0 && (ye = Math.max(Lt - bt, ye), Dz(Is, 0, Is.length - 1, us)), Lt = 0, ys.lineOffset = Math.max(vs, (is - 1) * Ge);
              const yi = At * is + vs;
              Rt += yi, We = Math.max(yi, We), ++Ls;
            }
            const { horizontalAlign: ss, verticalAlign: gs } = hu(Tt);
            (function(Qe, is, ys, Is, vs, hs, Bs, yi, qe) {
              const me = (is - ys) * vs;
              let Pe = 0;
              Pe = hs !== Bs ? -yi * Is - -17 : -Is * qe * Bs + 0.5 * Bs;
              for (const Oe of Qe) for (const $e of Oe.positionedGlyphs) $e.x += me, $e.y += Pe;
            })(et.positionedLines, us, ss, gs, ye, We, At, Rt, yt.length), et.top += -gs * Rt, et.bottom = et.top + Rt, et.left += -ss * ye, et.right = et.left + ye;
          })(K, t, s, n, O, l, D, N, T, y, x, m), !(function(et) {
            for (const ot of et) if (ot.positionedGlyphs.length !== 0) return !1;
            return !0;
          })(U) && K;
        }
        function hu(i) {
          let t = 0.5, s = 0.5;
          switch (i) {
            case "right":
            case "top-right":
            case "bottom-right":
              t = 1;
              break;
            case "left":
            case "top-left":
            case "bottom-left":
              t = 0;
          }
          switch (i) {
            case "bottom":
            case "bottom-right":
            case "bottom-left":
              s = 1;
              break;
            case "top":
            case "top-right":
            case "top-left":
              s = 0;
          }
          return { horizontalAlign: t, verticalAlign: s };
        }
        function lz(i, t, s) {
          const n = t.getMaxScale() * Ge, { maxImageWidth: a, maxImageHeight: M } = t.getMaxImageSize(i), l = Math.max(n, M * s);
          return { verticalLineContentWidth: Math.max(n, a * s), horizontalLineContentHeight: l };
        }
        function vg(i) {
          switch (i) {
            case "top":
              return 0;
            case "center":
              return 0.5;
            default:
              return 1;
          }
        }
        function uz(i, t, s) {
          return !(i === b.ay.horizontal || !t && !ln(s) || t && (vc(s) || (n = s, new RegExp("\\p{sc=Arab}", "u").test(String.fromCodePoint(n)))));
          var n;
        }
        function gz(i, t, s, n, a, M) {
          const l = M[i.fontStack], D = (function(y, w, T, x) {
            if (y && y.rect) return y;
            const A = w[T.fontStack], m = A && A[x];
            return m ? { rect: null, metrics: m.metrics } : null;
          })(l && l[t], a, i, t);
          if (D === null) return null;
          let N;
          if (s) N = n.verticalLineContentWidth - i.scale * Ge;
          else {
            const y = vg(i.verticalAlign);
            N = (n.horizontalLineContentHeight - i.scale * Ge) * y;
          }
          return { rect: D.rect, metrics: D.metrics, baselineOffset: N };
        }
        function hz(i, t, s, n, a) {
          const M = a[i.imageName];
          if (!M) return null;
          const l = M.paddedRect, D = M.displaySize, N = { width: D[0], height: D[1], left: 1, top: -3, advance: t ? D[1] : D[0] };
          let y;
          if (t) y = n.verticalLineContentWidth - D[1] * i.scale;
          else {
            const w = vg(i.verticalAlign);
            y = (n.horizontalLineContentHeight - D[1] * i.scale) * w;
          }
          return { rect: l, metrics: N, baselineOffset: y, imageOffset: (t ? D[0] : D[1]) * i.scale - Ge * s };
        }
        function Dz(i, t, s, n) {
          if (n === 0) return;
          const a = i[s], M = (i[s].x + a.metrics.advance * a.scale) * n;
          for (let l = t; l <= s; l++) i[l].x -= M;
        }
        function zz(i, t, s) {
          const { horizontalAlign: n, verticalAlign: a } = hu(s), M = t[0] - i.displaySize[0] * n, l = t[1] - i.displaySize[1] * a;
          return { image: i, top: l, bottom: l + i.displaySize[1], left: M, right: M + i.displaySize[0] };
        }
        function Bg(i) {
          var t, s;
          let n = i.left, a = i.top, M = i.right - n, l = i.bottom - a;
          const D = (t = i.image.textFitWidth) !== null && t !== void 0 ? t : "stretchOrShrink", N = (s = i.image.textFitHeight) !== null && s !== void 0 ? s : "stretchOrShrink", y = (i.image.content[2] - i.image.content[0]) / (i.image.content[3] - i.image.content[1]);
          if (N === "proportional") {
            if (D === "stretchOnly" && M / l < y || D === "proportional") {
              const w = Math.ceil(l * y);
              n *= w / M, M = w;
            }
          } else if (D === "proportional" && N === "stretchOnly" && y !== 0 && M / l > y) {
            const w = Math.ceil(M / y);
            a *= w / l, l = w;
          }
          return { x1: n, y1: a, x2: n + M, y2: a + l };
        }
        function Sg(i, t, s, n, a, M) {
          const l = i.image;
          let D;
          if (l.content) {
            const O = l.content, B = l.pixelRatio || 1;
            D = [O[0] / B, O[1] / B, l.displaySize[0] - O[2] / B, l.displaySize[1] - O[3] / B];
          }
          const N = t.left * M, y = t.right * M;
          let w, T, x, A;
          s === "width" || s === "both" ? (A = a[0] + N - n[3], T = a[0] + y + n[1]) : (A = a[0] + (N + y - l.displaySize[0]) / 2, T = A + l.displaySize[0]);
          const m = t.top * M, L = t.bottom * M;
          return s === "height" || s === "both" ? (w = a[1] + m - n[0], x = a[1] + L + n[2]) : (w = a[1] + (m + L - l.displaySize[1]) / 2, x = w + l.displaySize[1]), { image: l, top: w, right: T, bottom: x, left: A, collisionPadding: D };
        }
        jt("ImagePosition", gu), jt("ImageAtlas", Qg), b.ay = void 0, (hn = b.ay || (b.ay = {}))[hn.none = 0] = "none", hn[hn.horizontal = 1] = "horizontal", hn[hn.vertical = 2] = "vertical", hn[hn.horizontalOnly = 3] = "horizontalOnly";
        const Or = 128, Dn = 32640;
        function kg(i, t) {
          const { expression: s } = t;
          if (s.kind === "constant") return { kind: "constant", layoutSize: s.evaluate(new ie(i + 1)) };
          if (s.kind === "source") return { kind: "source" };
          {
            const { zoomStops: n, interpolationType: a } = s;
            let M = 0;
            for (; M < n.length && n[M] <= i; ) M++;
            M = Math.max(0, M - 1);
            let l = M;
            for (; l < n.length && n[l] < i + 1; ) l++;
            l = Math.min(n.length - 1, l);
            const D = n[M], N = n[l];
            return s.kind === "composite" ? { kind: "composite", minZoom: D, maxZoom: N, interpolationType: a } : { kind: "camera", minZoom: D, maxZoom: N, minSize: s.evaluate(new ie(D)), maxSize: s.evaluate(new ie(N)), interpolationType: a };
          }
        }
        function Du(i, t, s) {
          let n = "never";
          const a = i.get(t);
          return a ? n = a : i.get(s) && (n = "always"), n;
        }
        const Nz = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
        function sl(i, t, s, n, a, M, l, D, N, y, w, T, x) {
          const A = D ? Math.min(Dn, Math.round(D[0])) : 0, m = D ? Math.min(Dn, Math.round(D[1])) : 0;
          i.emplaceBack(t, s, Math.round(32 * n), Math.round(32 * a), M, l, (A << 1) + (N ? 1 : 0), m, 16 * y, 16 * w, 256 * T, 256 * x);
        }
        function zu(i, t, s) {
          i.emplaceBack(t.x, t.y, s), i.emplaceBack(t.x, t.y, s), i.emplaceBack(t.x, t.y, s), i.emplaceBack(t.x, t.y, s);
        }
        function dz(i) {
          for (const t of i.sections) if (kc(t.text)) return !0;
          return !1;
        }
        class Nu {
          constructor(t) {
            this.layoutVertexArray = new ct(), this.indexArray = new wt(), this.programConfigurations = t, this.segments = new Yt(), this.dynamicLayoutVertexArray = new nt(), this.opacityVertexArray = new at(), this.hasVisibleVertices = !1, this.placedSymbolArray = new I();
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0;
          }
          upload(t, s, n, a) {
            this.isEmpty() || (n && (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, PD.members), this.indexBuffer = t.createIndexBuffer(this.indexArray, s), this.dynamicLayoutVertexBuffer = t.createVertexBuffer(this.dynamicLayoutVertexArray, RD.members, !0), this.opacityVertexBuffer = t.createVertexBuffer(this.opacityVertexArray, Nz, !0), this.opacityVertexBuffer.itemSize = 1), (n || a) && this.programConfigurations.upload(t));
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
          }
        }
        jt("SymbolBuffers", Nu);
        class du {
          constructor(t, s, n) {
            this.layoutVertexArray = new t(), this.layoutAttributes = s, this.indexArray = new n(), this.segments = new Yt(), this.collisionVertexArray = new xt();
          }
          upload(t) {
            this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t.createVertexBuffer(this.collisionVertexArray, ZD.members, !0);
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());
          }
        }
        jt("CollisionBuffers", du);
        class uo {
          constructor(t) {
            this.collisionBoxArray = t.collisionBoxArray, this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(((l) => l.id)), this.index = t.index, this.pixelRatio = t.pixelRatio, this.sourceLayerIndex = t.sourceLayerIndex, this.hasDependencies = !1, this.hasRTLText = !1, this.sortKeyRanges = [], this.collisionCircleArray = [];
            const s = this.layers[0]._unevaluatedLayout._values;
            this.textSizeData = kg(this.zoom, s["text-size"]), this.iconSizeData = kg(this.zoom, s["icon-size"]);
            const n = this.layers[0].layout, a = n.get("symbol-sort-key"), M = n.get("symbol-z-order");
            this.canOverlap = Du(n, "text-overlap", "text-allow-overlap") !== "never" || Du(n, "icon-overlap", "icon-allow-overlap") !== "never" || n.get("text-ignore-placement") || n.get("icon-ignore-placement"), this.sortFeaturesByKey = M !== "viewport-y" && !a.isConstant(), this.sortFeaturesByY = (M === "viewport-y" || M === "auto" && !this.sortFeaturesByKey) && this.canOverlap, n.get("symbol-placement") === "point" && (this.writingModes = n.get("text-writing-mode").map(((l) => b.ay[l]))), this.stateDependentLayerIds = this.layers.filter(((l) => l.isStateDependent())).map(((l) => l.id)), this.sourceID = t.sourceID;
          }
          createArrays() {
            this.text = new Nu(new Cr(this.layers, this.zoom, ((t) => /^text/.test(t)))), this.icon = new Nu(new Cr(this.layers, this.zoom, ((t) => /^icon/.test(t)))), this.glyphOffsetArray = new _(), this.lineVertexArray = new j(), this.symbolInstances = new f(), this.textAnchorOffsets = new v();
          }
          calculateGlyphDependencies(t, s, n, a, M) {
            for (const l of t) if (s[l.codePointAt(0)] = !0, (n || a) && M) {
              const D = OM[l];
              D && (s[D.codePointAt(0)] = !0);
            }
          }
          populate(t, s, n) {
            const a = this.layers[0], M = a.layout, l = M.get("text-font"), D = M.get("text-field"), N = M.get("icon-image"), y = (D.value.kind !== "constant" || D.value.value instanceof Fe && !D.value.value.isEmpty() || D.value.value.toString().length > 0) && (l.value.kind !== "constant" || l.value.value.length > 0), w = N.value.kind !== "constant" || !!N.value.value || Object.keys(N.parameters).length > 0, T = M.get("symbol-sort-key");
            if (this.features = [], !y && !w) return;
            const x = s.iconDependencies, A = s.glyphDependencies, m = s.availableImages, L = new ie(this.zoom);
            for (const { feature: O, id: B, index: P, sourceLayerIndex: k } of t) {
              const U = a._featureFilter.needGeometry, K = _i(O, U);
              if (!a._featureFilter.filter(L, K, n)) continue;
              let et, ot;
              if (U || (K.geometry = sr(O)), y) {
                const Dt = a.getValueAndResolveTokens("text-field", K, n, m), yt = Fe.factory(Dt), At = this.hasRTLText = this.hasRTLText || dz(yt);
                (!At || qi.getRTLTextPluginStatus() === "unavailable" || At && qi.isParsed()) && (et = GD(yt, a, K));
              }
              if (w) {
                const Dt = a.getValueAndResolveTokens("icon-image", K, n, m);
                ot = Dt instanceof xs ? Dt : xs.fromString(Dt);
              }
              if (!et && !ot) continue;
              const dt = this.sortFeaturesByKey ? T.evaluate(K, {}, n) : void 0;
              if (this.features.push({ id: B, text: et, icon: ot, index: P, sourceLayerIndex: k, geometry: K.geometry, properties: O.properties, type: Mo.types[O.type], sortKey: dt }), ot && (x[ot.name] = !0), et) {
                const Dt = l.evaluate(K, {}, n).join(","), yt = M.get("text-rotation-alignment") !== "viewport" && M.get("symbol-placement") !== "point";
                this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(b.ay.vertical) >= 0;
                for (const At of et.sections) if (At.image) x[At.image.name] = !0;
                else {
                  const Tt = qn(et.toString()), ft = At.fontStack || Dt, zt = A[ft] = A[ft] || {};
                  this.calculateGlyphDependencies(At.text, zt, yt, this.allowVerticalPlacement, Tt);
                }
              }
            }
            M.get("symbol-placement") === "line" && (this.features = (function(O) {
              const B = {}, P = {}, k = [];
              let U = 0;
              function K(Dt) {
                k.push(O[Dt]), U++;
              }
              function et(Dt, yt, At) {
                const Tt = P[Dt];
                return delete P[Dt], P[yt] = Tt, k[Tt].geometry[0].pop(), k[Tt].geometry[0] = k[Tt].geometry[0].concat(At[0]), Tt;
              }
              function ot(Dt, yt, At) {
                const Tt = B[yt];
                return delete B[yt], B[Dt] = Tt, k[Tt].geometry[0].shift(), k[Tt].geometry[0] = At[0].concat(k[Tt].geometry[0]), Tt;
              }
              function dt(Dt, yt, At) {
                const Tt = At ? yt[0][yt[0].length - 1] : yt[0][0];
                return `${Dt}:${Tt.x}:${Tt.y}`;
              }
              for (let Dt = 0; Dt < O.length; Dt++) {
                const yt = O[Dt], At = yt.geometry, Tt = yt.text ? yt.text.toString() : null;
                if (!Tt) {
                  K(Dt);
                  continue;
                }
                const ft = dt(Tt, At), zt = dt(Tt, At, !0);
                if (ft in P && zt in B && P[ft] !== B[zt]) {
                  const bt = ot(ft, zt, At), Qt = et(ft, zt, k[bt].geometry);
                  delete B[ft], delete P[zt], P[dt(Tt, k[Qt].geometry, !0)] = Qt, k[bt].geometry = null;
                } else ft in P ? et(ft, zt, At) : zt in B ? ot(ft, zt, At) : (K(Dt), B[ft] = U - 1, P[zt] = U - 1);
              }
              return k.filter(((Dt) => Dt.geometry));
            })(this.features)), this.sortFeaturesByKey && this.features.sort(((O, B) => O.sortKey - B.sortKey));
          }
          update(t, s, n) {
            this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t, s, this.layers, { imagePositions: n }), this.icon.programConfigurations.updatePaintArrays(t, s, this.layers, { imagePositions: n }));
          }
          isEmpty() {
            return this.symbolInstances.length === 0 && !this.hasRTLText;
          }
          uploadPending() {
            return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
          }
          upload(t) {
            !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t), this.iconCollisionBox.upload(t)), this.text.upload(t, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = !0;
          }
          destroyDebugData() {
            this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
          }
          destroy() {
            this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
          }
          addToLineVertexArray(t, s) {
            const n = this.lineVertexArray.length;
            if (t.segment !== void 0) {
              let a = t.dist(s[t.segment + 1]), M = t.dist(s[t.segment]);
              const l = {};
              for (let D = t.segment + 1; D < s.length; D++) l[D] = { x: s[D].x, y: s[D].y, tileUnitDistanceFromAnchor: a }, D < s.length - 1 && (a += s[D + 1].dist(s[D]));
              for (let D = t.segment || 0; D >= 0; D--) l[D] = { x: s[D].x, y: s[D].y, tileUnitDistanceFromAnchor: M }, D > 0 && (M += s[D - 1].dist(s[D]));
              for (let D = 0; D < s.length; D++) {
                const N = l[D];
                this.lineVertexArray.emplaceBack(N.x, N.y, N.tileUnitDistanceFromAnchor);
              }
            }
            return { lineStartIndex: n, lineLength: this.lineVertexArray.length - n };
          }
          addSymbols(t, s, n, a, M, l, D, N, y, w, T, x) {
            const A = t.indexArray, m = t.layoutVertexArray, L = t.segments.prepareSegment(4 * s.length, m, A, this.canOverlap ? l.sortKey : void 0), O = this.glyphOffsetArray.length, B = L.vertexLength, P = this.allowVerticalPlacement && D === b.ay.vertical ? Math.PI / 2 : 0, k = l.text && l.text.sections;
            for (let U = 0; U < s.length; U++) {
              const { tl: K, tr: et, bl: ot, br: dt, tex: Dt, pixelOffsetTL: yt, pixelOffsetBR: At, minFontScaleX: Tt, minFontScaleY: ft, glyphOffset: zt, isSDF: bt, sectionIndex: Qt } = s[U], St = L.vertexLength, Lt = zt[1];
              sl(m, N.x, N.y, K.x, Lt + K.y, Dt.x, Dt.y, n, bt, yt.x, yt.y, Tt, ft), sl(m, N.x, N.y, et.x, Lt + et.y, Dt.x + Dt.w, Dt.y, n, bt, At.x, yt.y, Tt, ft), sl(m, N.x, N.y, ot.x, Lt + ot.y, Dt.x, Dt.y + Dt.h, n, bt, yt.x, At.y, Tt, ft), sl(m, N.x, N.y, dt.x, Lt + dt.y, Dt.x + Dt.w, Dt.y + Dt.h, n, bt, At.x, At.y, Tt, ft), zu(t.dynamicLayoutVertexArray, N, P), A.emplaceBack(St, St + 2, St + 1), A.emplaceBack(St + 1, St + 2, St + 3), L.vertexLength += 4, L.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(zt[0]), U !== s.length - 1 && Qt === s[U + 1].sectionIndex || t.programConfigurations.populatePaintArrays(m.length, l, l.index, { imagePositions: {}, canonical: x, formattedSection: k && k[Qt] });
            }
            t.placedSymbolArray.emplaceBack(N.x, N.y, O, this.glyphOffsetArray.length - O, B, y, w, N.segment, n ? n[0] : 0, n ? n[1] : 0, a[0], a[1], D, 0, !1, 0, T);
          }
          _addCollisionDebugVertex(t, s, n, a, M, l) {
            return s.emplaceBack(0, 0), t.emplaceBack(n.x, n.y, a, M, Math.round(l.x), Math.round(l.y));
          }
          addCollisionDebugVertices(t, s, n, a, M, l, D) {
            const N = M.segments.prepareSegment(4, M.layoutVertexArray, M.indexArray), y = N.vertexLength, w = M.layoutVertexArray, T = M.collisionVertexArray, x = D.anchorX, A = D.anchorY;
            this._addCollisionDebugVertex(w, T, l, x, A, new mt(t, s)), this._addCollisionDebugVertex(w, T, l, x, A, new mt(n, s)), this._addCollisionDebugVertex(w, T, l, x, A, new mt(n, a)), this._addCollisionDebugVertex(w, T, l, x, A, new mt(t, a)), N.vertexLength += 4;
            const m = M.indexArray;
            m.emplaceBack(y, y + 1), m.emplaceBack(y + 1, y + 2), m.emplaceBack(y + 2, y + 3), m.emplaceBack(y + 3, y), N.primitiveLength += 4;
          }
          addDebugCollisionBoxes(t, s, n, a) {
            for (let M = t; M < s; M++) {
              const l = this.collisionBoxArray.get(M);
              this.addCollisionDebugVertices(l.x1, l.y1, l.x2, l.y2, a ? this.textCollisionBox : this.iconCollisionBox, l.anchorPoint, n);
            }
          }
          generateCollisionDebugBuffers() {
            this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new du(Mt, Ag.members, Nt), this.iconCollisionBox = new du(Mt, Ag.members, Nt);
            for (let t = 0; t < this.symbolInstances.length; t++) {
              const s = this.symbolInstances.get(t);
              this.addDebugCollisionBoxes(s.textBoxStartIndex, s.textBoxEndIndex, s, !0), this.addDebugCollisionBoxes(s.verticalTextBoxStartIndex, s.verticalTextBoxEndIndex, s, !0), this.addDebugCollisionBoxes(s.iconBoxStartIndex, s.iconBoxEndIndex, s, !1), this.addDebugCollisionBoxes(s.verticalIconBoxStartIndex, s.verticalIconBoxEndIndex, s, !1);
            }
          }
          _deserializeCollisionBoxesForSymbol(t, s, n, a, M, l, D, N, y) {
            const w = {};
            for (let T = s; T < n; T++) {
              const x = t.get(T);
              w.textBox = { x1: x.x1, y1: x.y1, x2: x.x2, y2: x.y2, anchorPointX: x.anchorPointX, anchorPointY: x.anchorPointY }, w.textFeatureIndex = x.featureIndex;
              break;
            }
            for (let T = a; T < M; T++) {
              const x = t.get(T);
              w.verticalTextBox = { x1: x.x1, y1: x.y1, x2: x.x2, y2: x.y2, anchorPointX: x.anchorPointX, anchorPointY: x.anchorPointY }, w.verticalTextFeatureIndex = x.featureIndex;
              break;
            }
            for (let T = l; T < D; T++) {
              const x = t.get(T);
              w.iconBox = { x1: x.x1, y1: x.y1, x2: x.x2, y2: x.y2, anchorPointX: x.anchorPointX, anchorPointY: x.anchorPointY }, w.iconFeatureIndex = x.featureIndex;
              break;
            }
            for (let T = N; T < y; T++) {
              const x = t.get(T);
              w.verticalIconBox = { x1: x.x1, y1: x.y1, x2: x.x2, y2: x.y2, anchorPointX: x.anchorPointX, anchorPointY: x.anchorPointY }, w.verticalIconFeatureIndex = x.featureIndex;
              break;
            }
            return w;
          }
          deserializeCollisionBoxes(t) {
            this.collisionArrays = [];
            for (let s = 0; s < this.symbolInstances.length; s++) {
              const n = this.symbolInstances.get(s);
              this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t, n.textBoxStartIndex, n.textBoxEndIndex, n.verticalTextBoxStartIndex, n.verticalTextBoxEndIndex, n.iconBoxStartIndex, n.iconBoxEndIndex, n.verticalIconBoxStartIndex, n.verticalIconBoxEndIndex));
            }
          }
          hasTextData() {
            return this.text.segments.get().length > 0;
          }
          hasIconData() {
            return this.icon.segments.get().length > 0;
          }
          hasDebugData() {
            return this.textCollisionBox && this.iconCollisionBox;
          }
          hasTextCollisionBoxData() {
            return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
          }
          hasIconCollisionBoxData() {
            return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
          }
          addIndicesForPlacedSymbol(t, s) {
            const n = t.placedSymbolArray.get(s), a = n.vertexStartIndex + 4 * n.numGlyphs;
            for (let M = n.vertexStartIndex; M < a; M += 4) t.indexArray.emplaceBack(M, M + 2, M + 1), t.indexArray.emplaceBack(M + 1, M + 2, M + 3);
          }
          getSortedSymbolIndexes(t) {
            if (this.sortedAngle === t && this.symbolInstanceIndexes !== void 0) return this.symbolInstanceIndexes;
            const s = Math.sin(t), n = Math.cos(t), a = [], M = [], l = [];
            for (let D = 0; D < this.symbolInstances.length; ++D) {
              l.push(D);
              const N = this.symbolInstances.get(D);
              a.push(0 | Math.round(s * N.anchorX + n * N.anchorY)), M.push(N.featureIndex);
            }
            return l.sort(((D, N) => a[D] - a[N] || M[N] - M[D])), l;
          }
          addToSortKeyRanges(t, s) {
            const n = this.sortKeyRanges[this.sortKeyRanges.length - 1];
            n && n.sortKey === s ? n.symbolInstanceEnd = t + 1 : this.sortKeyRanges.push({ sortKey: s, symbolInstanceStart: t, symbolInstanceEnd: t + 1 });
          }
          sortFeatures(t) {
            if (this.sortFeaturesByY && this.sortedAngle !== t && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
              this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t), this.sortedAngle = t, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
              for (const s of this.symbolInstanceIndexes) {
                const n = this.symbolInstances.get(s);
                this.featureSortOrder.push(n.featureIndex), [n.rightJustifiedTextSymbolIndex, n.centerJustifiedTextSymbolIndex, n.leftJustifiedTextSymbolIndex].forEach(((a, M, l) => {
                  a >= 0 && l.indexOf(a) === M && this.addIndicesForPlacedSymbol(this.text, a);
                })), n.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, n.verticalPlacedTextSymbolIndex), n.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, n.placedIconSymbolIndex), n.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, n.verticalPlacedIconSymbolIndex);
              }
              this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
            }
          }
        }
        let Fg, Yg;
        jt("SymbolBucket", uo, { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), uo.MAX_GLYPHS = 65535, uo.addDynamicAttributes = zu;
        var yu = { get paint() {
          return Yg = Yg || new Ms({ "icon-opacity": new Bt(X.paint_symbol["icon-opacity"]), "icon-color": new Bt(X.paint_symbol["icon-color"]), "icon-halo-color": new Bt(X.paint_symbol["icon-halo-color"]), "icon-halo-width": new Bt(X.paint_symbol["icon-halo-width"]), "icon-halo-blur": new Bt(X.paint_symbol["icon-halo-blur"]), "icon-translate": new Et(X.paint_symbol["icon-translate"]), "icon-translate-anchor": new Et(X.paint_symbol["icon-translate-anchor"]), "text-opacity": new Bt(X.paint_symbol["text-opacity"]), "text-color": new Bt(X.paint_symbol["text-color"], { runtimeType: fs, getOverride: (i) => i.textColor, hasOverride: (i) => !!i.textColor }), "text-halo-color": new Bt(X.paint_symbol["text-halo-color"]), "text-halo-width": new Bt(X.paint_symbol["text-halo-width"]), "text-halo-blur": new Bt(X.paint_symbol["text-halo-blur"]), "text-translate": new Et(X.paint_symbol["text-translate"]), "text-translate-anchor": new Et(X.paint_symbol["text-translate-anchor"]) });
        }, get layout() {
          return Fg = Fg || new Ms({ "symbol-placement": new Et(X.layout_symbol["symbol-placement"]), "symbol-spacing": new Et(X.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new Et(X.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new Bt(X.layout_symbol["symbol-sort-key"]), "symbol-z-order": new Et(X.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new Et(X.layout_symbol["icon-allow-overlap"]), "icon-overlap": new Et(X.layout_symbol["icon-overlap"]), "icon-ignore-placement": new Et(X.layout_symbol["icon-ignore-placement"]), "icon-optional": new Et(X.layout_symbol["icon-optional"]), "icon-rotation-alignment": new Et(X.layout_symbol["icon-rotation-alignment"]), "icon-size": new Bt(X.layout_symbol["icon-size"]), "icon-text-fit": new Et(X.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new Et(X.layout_symbol["icon-text-fit-padding"]), "icon-image": new Bt(X.layout_symbol["icon-image"]), "icon-rotate": new Bt(X.layout_symbol["icon-rotate"]), "icon-padding": new Bt(X.layout_symbol["icon-padding"]), "icon-keep-upright": new Et(X.layout_symbol["icon-keep-upright"]), "icon-offset": new Bt(X.layout_symbol["icon-offset"]), "icon-anchor": new Bt(X.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new Et(X.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new Et(X.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new Et(X.layout_symbol["text-rotation-alignment"]), "text-field": new Bt(X.layout_symbol["text-field"]), "text-font": new Bt(X.layout_symbol["text-font"]), "text-size": new Bt(X.layout_symbol["text-size"]), "text-max-width": new Bt(X.layout_symbol["text-max-width"]), "text-line-height": new Et(X.layout_symbol["text-line-height"]), "text-letter-spacing": new Bt(X.layout_symbol["text-letter-spacing"]), "text-justify": new Bt(X.layout_symbol["text-justify"]), "text-radial-offset": new Bt(X.layout_symbol["text-radial-offset"]), "text-variable-anchor": new Et(X.layout_symbol["text-variable-anchor"]), "text-variable-anchor-offset": new Bt(X.layout_symbol["text-variable-anchor-offset"]), "text-anchor": new Bt(X.layout_symbol["text-anchor"]), "text-max-angle": new Et(X.layout_symbol["text-max-angle"]), "text-writing-mode": new Et(X.layout_symbol["text-writing-mode"]), "text-rotate": new Bt(X.layout_symbol["text-rotate"]), "text-padding": new Et(X.layout_symbol["text-padding"]), "text-keep-upright": new Et(X.layout_symbol["text-keep-upright"]), "text-transform": new Bt(X.layout_symbol["text-transform"]), "text-offset": new Bt(X.layout_symbol["text-offset"]), "text-allow-overlap": new Et(X.layout_symbol["text-allow-overlap"]), "text-overlap": new Et(X.layout_symbol["text-overlap"]), "text-ignore-placement": new Et(X.layout_symbol["text-ignore-placement"]), "text-optional": new Et(X.layout_symbol["text-optional"]) });
        } };
        class Ug {
          constructor(t) {
            if (t.property.overrides === void 0) throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
            this.type = t.property.overrides ? t.property.overrides.runtimeType : ce, this.defaultValue = t;
          }
          evaluate(t) {
            if (t.formattedSection) {
              const s = this.defaultValue.property.overrides;
              if (s && s.hasOverride(t.formattedSection)) return s.getOverride(t.formattedSection);
            }
            return t.feature && t.featureState ? this.defaultValue.evaluate(t.feature, t.featureState) : this.defaultValue.property.specification.default;
          }
          eachChild(t) {
            this.defaultValue.isConstant() || t(this.defaultValue.value._styleExpression.expression);
          }
          outputDefined() {
            return !1;
          }
          serialize() {
            return null;
          }
        }
        jt("FormatSectionOverride", Ug, { omit: ["defaultValue"] });
        class il extends Xs {
          constructor(t, s) {
            super(t, yu, s);
          }
          recalculate(t, s) {
            if (super.recalculate(t, s), this.layout.get("icon-rotation-alignment") === "auto" && (this.layout._values["icon-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-rotation-alignment") === "auto" && (this.layout._values["text-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment") === "map" ? "map" : "viewport"), this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), this.layout.get("symbol-placement") === "point") {
              const n = this.layout.get("text-writing-mode");
              if (n) {
                const a = [];
                for (const M of n) a.indexOf(M) < 0 && a.push(M);
                this.layout._values["text-writing-mode"] = a;
              } else this.layout._values["text-writing-mode"] = ["horizontal"];
            }
            this._setPaintOverrides();
          }
          getValueAndResolveTokens(t, s, n, a) {
            const M = this.layout.get(t).evaluate(s, {}, n, a), l = this._unevaluatedLayout._values[t];
            return l.isDataDriven() || Fa(l.value) || !M ? M : (function(D, N) {
              return N.replace(/{([^{}]+)}/g, ((y, w) => D && w in D ? String(D[w]) : ""));
            })(s.properties, M);
          }
          createBucket(t) {
            return new uo(t);
          }
          queryRadius() {
            return 0;
          }
          queryIntersectsFeature() {
            throw new Error("Should take a different path in FeatureIndex");
          }
          _setPaintOverrides() {
            for (const t of yu.paint.overridableProperties) {
              if (!il.hasPaintOverride(this.layout, t)) continue;
              const s = this.paint.get(t), n = new Ug(s), a = new ka(n, s.property.specification);
              let M = null;
              M = s.value.kind === "constant" || s.value.kind === "source" ? new pr("source", a) : new Ua("composite", a, s.value.zoomStops), this.paint._values[t] = new ei(s.property, M, s.parameters);
            }
          }
          _handleOverridablePaintPropertyUpdate(t, s, n) {
            return !(!this.layout || s.isDataDriven() || n.isDataDriven()) && il.hasPaintOverride(this.layout, t);
          }
          static hasPaintOverride(t, s) {
            const n = t.get("text-field"), a = yu.paint.properties[s];
            let M = !1;
            const l = (D) => {
              for (const N of D) if (a.overrides && a.overrides.hasOverride(N)) return void (M = !0);
            };
            if (n.value.kind === "constant" && n.value.value instanceof Fe) l(n.value.value.sections);
            else if (n.value.kind === "source" || n.value.kind === "composite") {
              const D = (y) => {
                M || (y instanceof Gi && ze(y.value) === Wr ? l(y.value.sections) : y instanceof Nr ? l(y.sections) : y.eachChild(D));
              }, N = n.value;
              N._styleExpression && D(N._styleExpression.expression);
            }
            return M;
          }
        }
        let Xg;
        var yz = { get paint() {
          return Xg = Xg || new Ms({ "background-color": new Et(X.paint_background["background-color"]), "background-pattern": new Uc(X.paint_background["background-pattern"]), "background-opacity": new Et(X.paint_background["background-opacity"]) });
        } };
        class Iz extends Xs {
          constructor(t, s) {
            super(t, yz, s);
          }
        }
        class wz extends Xs {
          constructor(t, s) {
            super(t, {}, s), this.onAdd = (n) => {
              this.implementation.onAdd && this.implementation.onAdd(n, n.painter.context.gl);
            }, this.onRemove = (n) => {
              this.implementation.onRemove && this.implementation.onRemove(n, n.painter.context.gl);
            }, this.implementation = t;
          }
          is3D() {
            return this.implementation.renderingMode === "3d";
          }
          hasOffscreenPass() {
            return this.implementation.prerender !== void 0;
          }
          recalculate() {
          }
          updateTransitions() {
          }
          hasTransition() {
            return !1;
          }
          serialize() {
            throw new Error("Custom layers cannot be serialized");
          }
        }
        class pz {
          constructor(t) {
            this._methodToThrottle = t, this._triggered = !1, typeof MessageChannel < "u" && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
              this._triggered = !1, this._methodToThrottle();
            });
          }
          trigger() {
            this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout((() => {
              this._triggered = !1, this._methodToThrottle();
            }), 0));
          }
          remove() {
            delete this._channel, this._methodToThrottle = () => {
            };
          }
        }
        const Tz = { once: !0 }, Iu = 63710088e-1;
        class zn {
          constructor(t, s) {
            if (isNaN(t) || isNaN(s)) throw new Error(`Invalid LngLat object: (${t}, ${s})`);
            if (this.lng = +t, this.lat = +s, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
          }
          wrap() {
            return new zn(Vs(this.lng, -180, 180), this.lat);
          }
          toArray() {
            return [this.lng, this.lat];
          }
          toString() {
            return `LngLat(${this.lng}, ${this.lat})`;
          }
          distanceTo(t) {
            const s = Math.PI / 180, n = this.lat * s, a = t.lat * s, M = Math.sin(n) * Math.sin(a) + Math.cos(n) * Math.cos(a) * Math.cos((t.lng - this.lng) * s);
            return Iu * Math.acos(Math.min(M, 1));
          }
          static convert(t) {
            if (t instanceof zn) return t;
            if (Array.isArray(t) && (t.length === 2 || t.length === 3)) return new zn(Number(t[0]), Number(t[1]));
            if (!Array.isArray(t) && typeof t == "object" && t !== null) return new zn(Number("lng" in t ? t.lng : t.lon), Number(t.lat));
            throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
          }
        }
        const Wg = 2 * Math.PI * Iu;
        function Pg(i) {
          return Wg * Math.cos(i * Math.PI / 180);
        }
        function Rg(i) {
          return (180 + i) / 360;
        }
        function Zg(i) {
          return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + i * Math.PI / 360))) / 360;
        }
        function Vg(i, t) {
          return i / Pg(t);
        }
        function Gg(i) {
          return 360 * i - 180;
        }
        function rl(i) {
          return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * i) * Math.PI / 180)) - 90;
        }
        function Hg(i, t) {
          return i * Pg(rl(t));
        }
        class EM {
          constructor(t, s, n = 0) {
            this.x = +t, this.y = +s, this.z = +n;
          }
          static fromLngLat(t, s = 0) {
            const n = zn.convert(t);
            return new EM(Rg(n.lng), Zg(n.lat), Vg(s, n.lat));
          }
          toLngLat() {
            return new zn(Gg(this.x), rl(this.y));
          }
          toAltitude() {
            return Hg(this.z, this.y);
          }
          meterInMercatorCoordinateUnits() {
            return 1 / Wg * (t = rl(this.y), 1 / Math.cos(t * Math.PI / 180));
            var t;
          }
        }
        function Jg(i, t, s) {
          var n = 2 * Math.PI * 6378137 / 256 / Math.pow(2, s);
          return [i * n - 2 * Math.PI * 6378137 / 2, t * n - 2 * Math.PI * 6378137 / 2];
        }
        class wu {
          constructor(t, s, n) {
            if (!(function(a, M, l) {
              return !(a < 0 || a > 25 || l < 0 || l >= Math.pow(2, a) || M < 0 || M >= Math.pow(2, a));
            })(t, s, n)) throw new Error(`x=${s}, y=${n}, z=${t} outside of bounds. 0<=x<${Math.pow(2, t)}, 0<=y<${Math.pow(2, t)} 0<=z<=25 `);
            this.z = t, this.x = s, this.y = n, this.key = go(0, t, t, s, n);
          }
          equals(t) {
            return this.z === t.z && this.x === t.x && this.y === t.y;
          }
          url(t, s, n) {
            const a = (l = this.y, D = this.z, N = Jg(256 * (M = this.x), 256 * (l = Math.pow(2, D) - l - 1), D), y = Jg(256 * (M + 1), 256 * (l + 1), D), N[0] + "," + N[1] + "," + y[0] + "," + y[1]);
            var M, l, D, N, y;
            const w = (function(T, x, A) {
              let m, L = "";
              for (let O = T; O > 0; O--) m = 1 << O - 1, L += (x & m ? 1 : 0) + (A & m ? 2 : 0);
              return L;
            })(this.z, this.x, this.y);
            return t[(this.x + this.y) % t.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(n === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, s > 1 ? "@2x" : "").replace(/{quadkey}/g, w).replace(/{bbox-epsg-3857}/g, a);
          }
          isChildOf(t) {
            const s = this.z - t.z;
            return s > 0 && t.x === this.x >> s && t.y === this.y >> s;
          }
          getTilePoint(t) {
            const s = Math.pow(2, this.z);
            return new mt((t.x * s - this.x) * se, (t.y * s - this.y) * se);
          }
          toString() {
            return `${this.z}/${this.x}/${this.y}`;
          }
        }
        class qg {
          constructor(t, s) {
            this.wrap = t, this.canonical = s, this.key = go(t, s.z, s.z, s.x, s.y);
          }
        }
        class si {
          constructor(t, s, n, a, M) {
            if (this.terrainRttPosMatrix32f = null, t < n) throw new Error(`overscaledZ should be >= z; overscaledZ = ${t}; z = ${n}`);
            this.overscaledZ = t, this.wrap = s, this.canonical = new wu(n, +a, +M), this.key = go(s, t, n, a, M);
          }
          clone() {
            return new si(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          equals(t) {
            return this.overscaledZ === t.overscaledZ && this.wrap === t.wrap && this.canonical.equals(t.canonical);
          }
          scaledTo(t) {
            if (t > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t}; overscaledZ = ${this.overscaledZ}`);
            const s = this.canonical.z - t;
            return t > this.canonical.z ? new si(t, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new si(t, this.wrap, t, this.canonical.x >> s, this.canonical.y >> s);
          }
          isOverscaled() {
            return this.overscaledZ > this.canonical.z;
          }
          calculateScaledKey(t, s) {
            if (t > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t}; overscaledZ = ${this.overscaledZ}`);
            const n = this.canonical.z - t;
            return t > this.canonical.z ? go(this.wrap * +s, t, this.canonical.z, this.canonical.x, this.canonical.y) : go(this.wrap * +s, t, t, this.canonical.x >> n, this.canonical.y >> n);
          }
          isChildOf(t) {
            if (t.wrap !== this.wrap || this.overscaledZ - t.overscaledZ <= 0) return !1;
            if (t.overscaledZ === 0) return this.overscaledZ > 0;
            const s = this.canonical.z - t.canonical.z;
            return !(s < 0) && t.canonical.x === this.canonical.x >> s && t.canonical.y === this.canonical.y >> s;
          }
          children(t) {
            if (this.overscaledZ >= t) return [new si(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
            const s = this.canonical.z + 1, n = 2 * this.canonical.x, a = 2 * this.canonical.y;
            return [new si(s, this.wrap, s, n, a), new si(s, this.wrap, s, n + 1, a), new si(s, this.wrap, s, n, a + 1), new si(s, this.wrap, s, n + 1, a + 1)];
          }
          isLessThan(t) {
            return this.wrap < t.wrap || !(this.wrap > t.wrap) && (this.overscaledZ < t.overscaledZ || !(this.overscaledZ > t.overscaledZ) && (this.canonical.x < t.canonical.x || !(this.canonical.x > t.canonical.x) && this.canonical.y < t.canonical.y));
          }
          wrapped() {
            return new si(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          unwrapTo(t) {
            return new si(this.overscaledZ, t, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          overscaleFactor() {
            return Math.pow(2, this.overscaledZ - this.canonical.z);
          }
          toUnwrapped() {
            return new qg(this.wrap, this.canonical);
          }
          toString() {
            return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
          }
          getTilePoint(t) {
            return this.canonical.getTilePoint(new EM(t.x - this.wrap, t.y));
          }
        }
        function go(i, t, s, n, a) {
          (i *= 2) < 0 && (i = -1 * i - 1);
          const M = 1 << s;
          return (M * M * i + M * a + n).toString(36) + s.toString(36) + t.toString(36);
        }
        function bM(i, t) {
          return t ? i.properties[t] : i.id;
        }
        function fz(i, t) {
          const s = { id: i.id };
          if (t.removeAllProperties && (delete i.removeProperties, delete i.addOrUpdateProperties, delete t.removeProperties), t.removeProperties) for (const n of t.removeProperties) {
            const a = i.addOrUpdateProperties.findIndex(((M) => M.key === n));
            a > -1 && i.addOrUpdateProperties.splice(a, 1);
          }
          return (i.removeAllProperties || t.removeAllProperties) && (s.removeAllProperties = !0), (i.removeProperties || t.removeProperties) && (s.removeProperties = [...i.removeProperties || [], ...t.removeProperties || []]), (i.addOrUpdateProperties || t.addOrUpdateProperties) && (s.addOrUpdateProperties = [...i.addOrUpdateProperties || [], ...t.addOrUpdateProperties || []]), (i.newGeometry || t.newGeometry) && (s.newGeometry = t.newGeometry || i.newGeometry), s;
        }
        function $g(i) {
          var t, s;
          if (!i) return {};
          const n = {};
          return n.removeAll = i.removeAll, n.remove = new Set(i.remove || []), n.add = new Map((t = i.add) === null || t === void 0 ? void 0 : t.map(((a) => [a.id, a]))), n.update = new Map((s = i.update) === null || s === void 0 ? void 0 : s.map(((a) => [a.id, a]))), n;
        }
        jt("CanonicalTileID", wu), jt("OverscaledTileID", si, { omit: ["terrainRttPosMatrix32f"] });
        class Kg {
          constructor(t) {
            this._stringToNumber = {}, this._numberToString = [];
            for (let s = 0; s < t.length; s++) {
              const n = t[s];
              this._stringToNumber[n] = s, this._numberToString[s] = n;
            }
          }
          encode(t) {
            return this._stringToNumber[t];
          }
          decode(t) {
            if (t >= this._numberToString.length) throw new Error(`Out of bounds. Index requested n=${t} can't be >= this._numberToString.length ${this._numberToString.length}`);
            return this._numberToString[t];
          }
        }
        class th {
          constructor(t, s, n, a, M) {
            this.type = "Feature", this._vectorTileFeature = t, t._z = s, t._x = n, t._y = a, this.properties = t.properties, this.id = M;
          }
          get geometry() {
            return this._geometry === void 0 && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;
          }
          set geometry(t) {
            this._geometry = t;
          }
          toJSON() {
            const t = { geometry: this.geometry };
            for (const s in this) s !== "_geometry" && s !== "_vectorTileFeature" && (t[s] = this[s]);
            return t;
          }
        }
        class ho {
          _name;
          dataBuffer;
          nullabilityBuffer;
          _size;
          constructor(t, s, n) {
            this._name = t, this.dataBuffer = s, typeof n == "number" ? this._size = n : (this.nullabilityBuffer = n, this._size = n.size());
          }
          getValue(t) {
            return this.nullabilityBuffer && !this.nullabilityBuffer.get(t) ? null : this.getValueFromBuffer(t);
          }
          has(t) {
            return this.nullabilityBuffer && this.nullabilityBuffer.get(t) || !this.nullabilityBuffer;
          }
          get name() {
            return this._name;
          }
          get size() {
            return this._size;
          }
        }
        class nl extends ho {
        }
        class pu extends nl {
          getValueFromBuffer(t) {
            return this.dataBuffer[t];
          }
        }
        class Tu extends nl {
          getValueFromBuffer(t) {
            return this.dataBuffer[t];
          }
        }
        class eh extends ho {
          delta;
          constructor(t, s, n, a) {
            super(t, s, a), this.delta = n;
          }
        }
        class fu extends eh {
          constructor(t, s, n, a) {
            super(t, Int32Array.of(s), n, a);
          }
          getValueFromBuffer(t) {
            return this.dataBuffer[0] + t * this.delta;
          }
        }
        class xu extends ho {
          constructor(t, s, n) {
            super(t, Int32Array.of(s), n);
          }
          getValueFromBuffer(t) {
            return this.dataBuffer[0];
          }
        }
        class xz {
          _name;
          _geometryVector;
          _idVector;
          _propertyVectors;
          _extent;
          propertyVectorsMap;
          constructor(t, s, n, a, M = 4096) {
            this._name = t, this._geometryVector = s, this._idVector = n, this._propertyVectors = a, this._extent = M;
          }
          get name() {
            return this._name;
          }
          get idVector() {
            return this._idVector;
          }
          get geometryVector() {
            return this._geometryVector;
          }
          get propertyVectors() {
            return this._propertyVectors;
          }
          getPropertyVector(t) {
            return this.propertyVectorsMap || (this.propertyVectorsMap = new Map(this._propertyVectors.map(((s) => [s.name, s])))), this.propertyVectorsMap.get(t);
          }
          *[Symbol.iterator]() {
            const t = this.geometryVector[Symbol.iterator]();
            let s = 0;
            for (; s < this.numFeatures; ) {
              let n;
              this.idVector && (n = this.containsMaxSaveIntegerValues(this.idVector) ? Number(this.idVector.getValue(s)) : this.idVector.getValue(s));
              const a = t?.next().value, M = {};
              for (const l of this.propertyVectors) {
                if (!l) continue;
                const D = l.name, N = l.getValue(s);
                N !== null && (M[D] = N);
              }
              s++, yield { id: n, geometry: a, properties: M };
            }
          }
          get numFeatures() {
            return this.geometryVector.numGeometries;
          }
          get extent() {
            return this._extent;
          }
          getFeatures() {
            const t = [], s = this.geometryVector.getGeometries();
            for (let n = 0; n < this.numFeatures; n++) {
              let a;
              this.idVector && (a = this.containsMaxSaveIntegerValues(this.idVector) ? Number(this.idVector.getValue(n)) : this.idVector.getValue(n));
              const M = { coordinates: s[n], type: this.geometryVector.geometryType(n) }, l = {};
              for (const D of this.propertyVectors) {
                if (!D) continue;
                const N = D.name, y = D.getValue(n);
                y !== null && (l[N] = y);
              }
              t.push({ id: a, geometry: M, properties: l });
            }
            return t;
          }
          containsMaxSaveIntegerValues(t) {
            return t instanceof pu || t instanceof xu && t instanceof fu || t instanceof Tu;
          }
        }
        class Az {
          value;
          constructor(t) {
            this.value = t;
          }
          get() {
            return this.value;
          }
          set(t) {
            this.value = t;
          }
          increment() {
            return this.value++;
          }
          add(t) {
            this.value += t;
          }
        }
        var cs, Ht, Er, Li, ca, Ps, He, Je, sh, ii;
        (function(i) {
          i.PRESENT = "PRESENT", i.DATA = "DATA", i.OFFSET = "OFFSET", i.LENGTH = "LENGTH";
        })(cs || (cs = {}));
        class Au {
          _dictionaryType;
          _offsetType;
          _lengthType;
          constructor(t, s, n) {
            this._dictionaryType = t, this._offsetType = s, this._lengthType = n;
          }
          get dictionaryType() {
            return this._dictionaryType;
          }
          get offsetType() {
            return this._offsetType;
          }
          get lengthType() {
            return this._lengthType;
          }
        }
        function Ze(i, t, s) {
          const n = new Int32Array(s);
          let a = 0, M = t.get();
          for (let l = 0; l < n.length; l++) {
            let D = i[M++], N = 127 & D;
            D < 128 || (D = i[M++], N |= (127 & D) << 7, D < 128 || (D = i[M++], N |= (127 & D) << 14, D < 128 || (D = i[M++], N |= (127 & D) << 21, D < 128 || (D = i[M++], N |= (15 & D) << 28)))), n[a++] = N;
          }
          return t.set(M), n;
        }
        function al(i, t, s) {
          const n = new BigInt64Array(s);
          for (let a = 0; a < n.length; a++) n[a] = jz(i, t);
          return n;
        }
        function mz(i, t) {
          let s, n;
          return n = i[t.get()], t.increment(), s = 127 & n, n < 128 ? s : (n = i[t.get()], t.increment(), s |= (127 & n) << 7, n < 128 ? s : (n = i[t.get()], t.increment(), s |= (127 & n) << 14, n < 128 ? s : (n = i[t.get()], t.increment(), s |= (127 & n) << 21, n < 128 ? s : (n = i[t.get()], s |= (15 & n) << 28, (function(a, M, l) {
            let D, N;
            if (N = M[l.get()], l.increment(), D = (112 & N) >> 4, N < 128 || (N = M[l.get()], l.increment(), D |= (127 & N) << 3, N < 128) || (N = M[l.get()], l.increment(), D |= (127 & N) << 10, N < 128) || (N = M[l.get()], l.increment(), D |= (127 & N) << 17, N < 128) || (N = M[l.get()], l.increment(), D |= (127 & N) << 24, N < 128) || (N = M[l.get()], l.increment(), D |= (1 & N) << 31, N < 128)) return 4294967296 * D + (a >>> 0);
            throw new Error("Expected varint not more than 10 bytes");
          })(s, i, t)))));
        }
        function ih(i, t, s, n) {
          throw new Error("FastPFor is not implemented yet.");
        }
        function la(i) {
          return i >>> 1 ^ -(1 & i);
        }
        function Do(i) {
          return i >> 1n ^ -(1n & i);
        }
        function jz(i, t) {
          let s = 0n, n = 0, a = t.get();
          for (; a < i.length; ) {
            const M = i[a++];
            if (s |= BigInt(127 & M) << BigInt(n), !(128 & M)) break;
            if (n += 7, n >= 64) throw new Error("Varint too long");
          }
          return t.set(a), s;
        }
        function rh(i, t, s) {
          const n = new Int32Array(s);
          let a = 0;
          for (let M = 0; M < t; M++) {
            const l = i[M];
            n.fill(i[M + t], a, a + l), a += l;
          }
          return n;
        }
        function nh(i, t, s) {
          const n = new BigInt64Array(s);
          let a = 0;
          for (let M = 0; M < t; M++) {
            const l = Number(i[M]);
            n.fill(i[M + t], a, a + l), a += l;
          }
          return n;
        }
        function ah(i, t, s) {
          const n = new Float64Array(s);
          let a = 0;
          for (let M = 0; M < t; M++) {
            const l = i[M];
            n.fill(i[M + t], a, a + l), a += l;
          }
          return n;
        }
        function mu(i) {
          const t = i.length / 4 * 4;
          let s = 1;
          if (t >= 4) for (let n = i[0]; s < t - 4; s += 4) n = i[s] += n, n = i[s + 1] += n, n = i[s + 2] += n, n = i[s + 3] += n;
          for (; s != i.length; ) i[s] += i[s - 1], ++s;
        }
        function oh(i) {
          i[0] = i[0] >>> 1 ^ -(1 & i[0]), i[1] = i[1] >>> 1 ^ -(1 & i[1]);
          const t = i.length / 4 * 4;
          let s = 2;
          if (t >= 4) for (; s < t - 4; s += 4) {
            const n = i[s], a = i[s + 1], M = i[s + 2], l = i[s + 3];
            i[s] = (n >>> 1 ^ -(1 & n)) + i[s - 2], i[s + 1] = (a >>> 1 ^ -(1 & a)) + i[s - 1], i[s + 2] = (M >>> 1 ^ -(1 & M)) + i[s], i[s + 3] = (l >>> 1 ^ -(1 & l)) + i[s + 1];
          }
          for (; s != i.length; s += 2) i[s] = (i[s] >>> 1 ^ -(1 & i[s])) + i[s - 2], i[s + 1] = (i[s + 1] >>> 1 ^ -(1 & i[s + 1])) + i[s - 1];
        }
        function Nn(i, t, s) {
          return Math.min(s, Math.max(t, i));
        }
        (function(i) {
          i.NONE = "NONE", i.DELTA = "DELTA", i.COMPONENTWISE_DELTA = "COMPONENTWISE_DELTA", i.RLE = "RLE", i.MORTON = "MORTON", i.PDE = "PDE";
        })(Ht || (Ht = {})), (function(i) {
          i.NONE = "NONE", i.FAST_PFOR = "FAST_PFOR", i.VARINT = "VARINT", i.ALP = "ALP";
        })(Er || (Er = {})), (function(i) {
          i.NONE = "NONE", i.SINGLE = "SINGLE", i.SHARED = "SHARED", i.VERTEX = "VERTEX", i.MORTON = "MORTON", i.FSST = "FSST";
        })(Li || (Li = {})), (function(i) {
          i.VERTEX = "VERTEX", i.INDEX = "INDEX", i.STRING = "STRING", i.KEY = "KEY";
        })(ca || (ca = {})), (function(i) {
          i.VAR_BINARY = "VAR_BINARY", i.GEOMETRIES = "GEOMETRIES", i.PARTS = "PARTS", i.RINGS = "RINGS", i.TRIANGLES = "TRIANGLES", i.SYMBOL = "SYMBOL", i.DICTIONARY = "DICTIONARY";
        })(Ps || (Ps = {}));
        class ua {
          _physicalStreamType;
          _logicalStreamType;
          _logicalLevelTechnique1;
          _logicalLevelTechnique2;
          _physicalLevelTechnique;
          _numValues;
          _byteLength;
          constructor(t, s, n, a, M, l, D) {
            this._physicalStreamType = t, this._logicalStreamType = s, this._logicalLevelTechnique1 = n, this._logicalLevelTechnique2 = a, this._physicalLevelTechnique = M, this._numValues = l, this._byteLength = D;
          }
          static decode(t, s) {
            const n = t[s.get()], a = Object.values(cs)[n >> 4];
            let M = null;
            switch (a) {
              case cs.DATA:
                M = new Au(Object.values(Li)[15 & n]);
                break;
              case cs.OFFSET:
                M = new Au(null, Object.values(ca)[15 & n]);
                break;
              case cs.LENGTH:
                M = new Au(null, null, Object.values(Ps)[15 & n]);
            }
            s.increment();
            const l = t[s.get()], D = Object.values(Ht)[l >> 5], N = Object.values(Ht)[l >> 2 & 7], y = Object.values(Er)[3 & l];
            s.increment();
            const w = Ze(t, s, 2);
            return new ua(a, M, D, N, y, w[0], w[1]);
          }
          get physicalStreamType() {
            return this._physicalStreamType;
          }
          get logicalStreamType() {
            return this._logicalStreamType;
          }
          get logicalLevelTechnique1() {
            return this._logicalLevelTechnique1;
          }
          get logicalLevelTechnique2() {
            return this._logicalLevelTechnique2;
          }
          get physicalLevelTechnique() {
            return this._physicalLevelTechnique;
          }
          get numValues() {
            return this._numValues;
          }
          get byteLength() {
            return this._byteLength;
          }
          getDecompressedCount() {
            return this._numValues;
          }
        }
        class ol extends ua {
          num_bits;
          coordinate_shift;
          constructor(t, s, n, a, M, l, D, N, y) {
            super(t, s, n, a, M, l, D), this.num_bits = N, this.coordinate_shift = y;
          }
          static decode(t, s) {
            const n = ua.decode(t, s), a = Ze(t, s, 2);
            return new ol(n.physicalStreamType, n.logicalStreamType, n.logicalLevelTechnique1, n.logicalLevelTechnique2, n.physicalLevelTechnique, n.numValues, n.byteLength, a[0], a[1]);
          }
          static decodePartial(t, s, n) {
            const a = Ze(s, n, 2);
            return new ol(t.physicalStreamType, t.logicalStreamType, t.logicalLevelTechnique1, t.logicalLevelTechnique2, t.physicalLevelTechnique, t.numValues, t.byteLength, a[0], a[1]);
          }
          numBits() {
            return this.num_bits;
          }
          coordinateShift() {
            return this.coordinate_shift;
          }
        }
        class QM extends ua {
          _runs;
          _numRleValues;
          constructor(t, s, n, a, M, l, D, N, y) {
            super(t, s, n, a, M, l, D), this._runs = N, this._numRleValues = y;
          }
          static decode(t, s) {
            const n = ua.decode(t, s), a = Ze(t, s, 2);
            return new QM(n.physicalStreamType, n.logicalStreamType, n.logicalLevelTechnique1, n.logicalLevelTechnique2, n.physicalLevelTechnique, n.numValues, n.byteLength, a[0], a[1]);
          }
          static decodePartial(t, s, n) {
            const a = Ze(s, n, 2);
            return new QM(t.physicalStreamType, t.logicalStreamType, t.logicalLevelTechnique1, t.logicalLevelTechnique2, t.physicalLevelTechnique, t.numValues, t.byteLength, a[0], a[1]);
          }
          get runs() {
            return this._runs;
          }
          get numRleValues() {
            return this._numRleValues;
          }
          getDecompressedCount() {
            return this._numRleValues;
          }
        }
        class ds {
          static decode(t, s) {
            const n = ua.decode(t, s);
            return n.logicalLevelTechnique1 === Ht.MORTON ? ol.decodePartial(n, t, s) : Ht.RLE !== n.logicalLevelTechnique1 && Ht.RLE !== n.logicalLevelTechnique2 || Er.NONE === n.physicalLevelTechnique ? n : QM.decodePartial(n, t, s);
          }
        }
        (function(i) {
          i[i.FLAT = 0] = "FLAT", i[i.CONST = 1] = "CONST", i[i.SEQUENCE = 2] = "SEQUENCE", i[i.DICTIONARY = 3] = "DICTIONARY", i[i.FSST_DICTIONARY = 4] = "FSST_DICTIONARY";
        })(He || (He = {}));
        class Ci {
          values;
          _size;
          constructor(t, s) {
            this.values = t, this._size = s;
          }
          get(t) {
            const s = Math.floor(t / 8);
            return (this.values[s] >> t % 8 & 1) == 1;
          }
          set(t, s) {
            const n = Math.floor(t / 8);
            this.values[n] = this.values[n] | (s ? 1 : 0) << t % 8;
          }
          getInt(t) {
            const s = Math.floor(t / 8);
            return this.values[s] >> t % 8 & 1;
          }
          size() {
            return this._size;
          }
          getBuffer() {
            return this.values;
          }
        }
        class Wt {
          constructor() {
          }
          static decodeIntStream(t, s, n, a, M) {
            const l = Wt.decodePhysicalLevelTechnique(t, s, n);
            return this.decodeIntBuffer(l, n, a, M);
          }
          static decodeLengthStreamToOffsetBuffer(t, s, n) {
            const a = Wt.decodePhysicalLevelTechnique(t, s, n);
            return this.decodeLengthToOffsetBuffer(a, n);
          }
          static decodePhysicalLevelTechnique(t, s, n) {
            const a = n.physicalLevelTechnique;
            if (a === Er.FAST_PFOR) return ih();
            if (a === Er.VARINT) return Ze(t, s, n.numValues);
            if (a === Er.NONE) {
              const M = s.get();
              s.add(n.byteLength);
              const l = t.subarray(M, s.get());
              return new Int32Array(l);
            }
            throw new Error("Specified physicalLevelTechnique is not supported (yet).");
          }
          static decodeConstIntStream(t, s, n, a) {
            const M = Wt.decodePhysicalLevelTechnique(t, s, n);
            if (M.length === 1) {
              const l = M[0];
              return a ? la(l) : l;
            }
            return a ? (function(l) {
              return la(l[1]);
            })(M) : (function(l) {
              return l[1];
            })(M);
          }
          static decodeSequenceIntStream(t, s, n) {
            return (function(a) {
              if (a.length == 2) {
                const M = la(a[1]);
                return [M, M];
              }
              return [la(a[2]), la(a[3])];
            })(Wt.decodePhysicalLevelTechnique(t, s, n));
          }
          static decodeSequenceLongStream(t, s, n) {
            return (function(a) {
              if (a.length == 2) {
                const M = Do(a[1]);
                return [M, M];
              }
              return [Do(a[2]), Do(a[3])];
            })(al(t, s, n.numValues));
          }
          static decodeLongStream(t, s, n, a) {
            const M = al(t, s, n.numValues);
            return this.decodeLongBuffer(M, n, a);
          }
          static decodeLongFloat64Stream(t, s, n, a) {
            const M = (function(l, D, N) {
              const y = new Float64Array(D);
              for (let w = 0; w < D; w++) y[w] = mz(l, N);
              return y;
            })(t, n.numValues, s);
            return this.decodeFloat64Buffer(M, n, a);
          }
          static decodeConstLongStream(t, s, n, a) {
            const M = al(t, s, n.numValues);
            if (M.length === 1) {
              const l = M[0];
              return a ? Do(l) : l;
            }
            return a ? (function(l) {
              return Do(l[1]);
            })(M) : (function(l) {
              return l[1];
            })(M);
          }
          static decodeIntBuffer(t, s, n, a) {
            switch (s.logicalLevelTechnique1) {
              case Ht.DELTA:
                return s.logicalLevelTechnique2 === Ht.RLE ? (function(M, l, D) {
                  const N = new Int32Array(D);
                  let y = 0, w = 0;
                  for (let T = 0; T < l; T++) {
                    const x = M[T], A = la(M[T + l]);
                    for (let m = 0; m < x; m++) w += A, N[y++] = w;
                  }
                  return N;
                })(t, s.runs, s.numRleValues) : ((function(M) {
                  M[0] = M[0] >>> 1 ^ -(1 & M[0]);
                  const l = M.length / 4 * 4;
                  let D = 1;
                  if (l >= 4) for (; D < l - 4; D += 4) {
                    const N = M[D], y = M[D + 1], w = M[D + 2], T = M[D + 3];
                    M[D] = (N >>> 1 ^ -(1 & N)) + M[D - 1], M[D + 1] = (y >>> 1 ^ -(1 & y)) + M[D], M[D + 2] = (w >>> 1 ^ -(1 & w)) + M[D + 1], M[D + 3] = (T >>> 1 ^ -(1 & T)) + M[D + 2];
                  }
                  for (; D != M.length; ++D) M[D] = (M[D] >>> 1 ^ -(1 & M[D])) + M[D - 1];
                })(t), t);
              case Ht.RLE:
                return (function(M, l, D) {
                  return D ? (function(N, y, w) {
                    const T = new Int32Array(w);
                    let x = 0;
                    for (let A = 0; A < y; A++) {
                      const m = N[A];
                      let L = N[A + y];
                      L = L >>> 1 ^ -(1 & L), T.fill(L, x, x + m), x += m;
                    }
                    return T;
                  })(M, l.runs, l.numRleValues) : rh(M, l.runs, l.numRleValues);
                })(t, s, n);
              case Ht.MORTON:
                return mu(t), t;
              case Ht.COMPONENTWISE_DELTA:
                return a ? ((function(M, l, D, N) {
                  let y = M[0] >>> 1 ^ -(1 & M[0]), w = M[1] >>> 1 ^ -(1 & M[1]);
                  M[0] = Nn(Math.round(y * l), D, N), M[1] = Nn(Math.round(w * l), D, N);
                  const T = M.length / 16;
                  let x = 2;
                  if (T >= 4) for (; x < T - 4; x += 4) {
                    const A = M[x], m = M[x + 1], L = (A >>> 1 ^ -(1 & A)) + y, O = (m >>> 1 ^ -(1 & m)) + w;
                    M[x] = Nn(Math.round(L * l), D, N), M[x + 1] = Nn(Math.round(O * l), D, N);
                    const B = M[x + 2], P = M[x + 3];
                    y = (B >>> 1 ^ -(1 & B)) + L, w = (P >>> 1 ^ -(1 & P)) + O, M[x + 2] = Nn(Math.round(y * l), D, N), M[x + 3] = Nn(Math.round(w * l), D, N);
                  }
                  for (; x != M.length; x += 2) y += M[x] >>> 1 ^ -(1 & M[x]), w += M[x + 1] >>> 1 ^ -(1 & M[x + 1]), M[x] = Nn(Math.round(y * l), D, N), M[x + 1] = Nn(Math.round(w * l), D, N);
                })(t, a.scale, a.min, a.max), t) : (oh(t), t);
              case Ht.NONE:
                return n && (function(M) {
                  for (let l = 0; l < M.length; l++) {
                    const D = M[l];
                    M[l] = D >>> 1 ^ -(1 & D);
                  }
                })(t), t;
              default:
                throw new Error(`The specified Logical level technique is not supported: ${s.logicalLevelTechnique1}`);
            }
          }
          static decodeLongBuffer(t, s, n) {
            switch (s.logicalLevelTechnique1) {
              case Ht.DELTA:
                return s.logicalLevelTechnique2 === Ht.RLE ? (function(a, M, l) {
                  const D = new BigInt64Array(l);
                  let N = 0, y = 0n;
                  for (let w = 0; w < M; w++) {
                    const T = Number(a[w]), x = Do(a[w + M]);
                    for (let A = 0; A < T; A++) y += x, D[N++] = y;
                  }
                  return D;
                })(t, s.runs, s.numRleValues) : ((function(a) {
                  a[0] = a[0] >> 1n ^ -(1n & a[0]);
                  const M = a.length / 4 * 4;
                  let l = 1;
                  if (M >= 4) for (; l < M - 4; l += 4) {
                    const D = a[l], N = a[l + 1], y = a[l + 2], w = a[l + 3];
                    a[l] = (D >> 1n ^ -(1n & D)) + a[l - 1], a[l + 1] = (N >> 1n ^ -(1n & N)) + a[l], a[l + 2] = (y >> 1n ^ -(1n & y)) + a[l + 1], a[l + 3] = (w >> 1n ^ -(1n & w)) + a[l + 2];
                  }
                  for (; l != a.length; ++l) a[l] = (a[l] >> 1n ^ -(1n & a[l])) + a[l - 1];
                })(t), t);
              case Ht.RLE:
                return (function(a, M, l) {
                  return l ? (function(D, N, y) {
                    const w = new BigInt64Array(y);
                    let T = 0;
                    for (let x = 0; x < N; x++) {
                      const A = Number(D[x]);
                      let m = D[x + N];
                      m = m >> 1n ^ -(1n & m), w.fill(m, T, T + A), T += A;
                    }
                    return w;
                  })(a, M.runs, M.numRleValues) : nh(a, M.runs, M.numRleValues);
                })(t, s, n);
              case Ht.NONE:
                return n && (function(a) {
                  for (let M = 0; M < a.length; M++) {
                    const l = a[M];
                    a[M] = l >> 1n ^ -(1n & l);
                  }
                })(t), t;
              default:
                throw new Error(`The specified Logical level technique is not supported: ${s.logicalLevelTechnique1}`);
            }
          }
          static decodeFloat64Buffer(t, s, n) {
            switch (s.logicalLevelTechnique1) {
              case Ht.DELTA:
                return s.logicalLevelTechnique2 === Ht.RLE && (t = ah(t, s.runs, s.numRleValues)), (function(a) {
                  a[0] = a[0] % 2 == 1 ? (a[0] + 1) / -2 : a[0] / 2;
                  const M = a.length / 4 * 4;
                  let l = 1;
                  if (M >= 4) for (; l < M - 4; l += 4) {
                    const D = a[l], N = a[l + 1], y = a[l + 2], w = a[l + 3];
                    a[l] = (D % 2 == 1 ? (D + 1) / -2 : D / 2) + a[l - 1], a[l + 1] = (N % 2 == 1 ? (N + 1) / -2 : N / 2) + a[l], a[l + 2] = (y % 2 == 1 ? (y + 1) / -2 : y / 2) + a[l + 1], a[l + 3] = (w % 2 == 1 ? (w + 1) / -2 : w / 2) + a[l + 2];
                  }
                  for (; l != a.length; ++l) a[l] = (a[l] % 2 == 1 ? (a[l] + 1) / -2 : a[l] / 2) + a[l - 1];
                })(t), t;
              case Ht.RLE:
                return (function(a, M, l) {
                  return l ? (function(D, N, y) {
                    const w = new Float64Array(y);
                    let T = 0;
                    for (let x = 0; x < N; x++) {
                      const A = D[x];
                      let m = D[x + N];
                      m = m % 2 == 1 ? (m + 1) / -2 : m / 2, w.fill(m, T, T + A), T += A;
                    }
                    return w;
                  })(a, M.runs, M.numRleValues) : ah(a, M.runs, M.numRleValues);
                })(t, s, n);
              case Ht.NONE:
                return n && (function(a) {
                  for (let M = 0; M < a.length; M++) {
                    const l = a[M];
                    a[M] = l % 2 == 1 ? (l + 1) / -2 : l / 2;
                  }
                })(t), t;
              default:
                throw new Error(`The specified Logical level technique is not supported: ${s.logicalLevelTechnique1}`);
            }
          }
          static decodeLengthToOffsetBuffer(t, s) {
            if (s.logicalLevelTechnique1 === Ht.DELTA && s.logicalLevelTechnique2 === Ht.NONE) return (function(n) {
              const a = new Int32Array(n.length + 1);
              a[0] = 0, a[1] = la(n[0]);
              let M = a[1], l = 2;
              for (; l != a.length; ++l) {
                const D = n[l - 1];
                M += D >>> 1 ^ -(1 & D), a[l] = a[l - 1] + M;
              }
              return a;
            })(t);
            if (s.logicalLevelTechnique1 === Ht.RLE && s.logicalLevelTechnique2 === Ht.NONE) return (function(n, a, M) {
              const l = new Int32Array(M + 1);
              l[0] = 0;
              let D = 1, N = l[0];
              for (let y = 0; y < a; y++) {
                const w = n[y], T = n[y + a];
                for (let x = D; x < D + w; x++) l[x] = T + N, N = l[x];
                D += w;
              }
              return l;
            })(t, s.runs, s.numRleValues);
            if (s.logicalLevelTechnique1 === Ht.NONE && s.logicalLevelTechnique2 === Ht.NONE) {
              (function(a) {
                let M = 0;
                for (let l = 0; l < a.length; l++) a[l] += M, M = a[l];
              })(t);
              const n = new Int32Array(s.numValues + 1);
              return n[0] = 0, n.set(t, 1), n;
            }
            if (s.logicalLevelTechnique1 === Ht.DELTA && s.logicalLevelTechnique2 === Ht.RLE) {
              const n = (function(a, M, l) {
                const D = new Int32Array(l + 1);
                D[0] = 0;
                let N = 1, y = D[0];
                for (let w = 0; w < M; w++) {
                  const T = a[w];
                  let x = a[w + M];
                  x = x >>> 1 ^ -(1 & x);
                  for (let A = N; A < N + T; A++) D[A] = x + y, y = D[A];
                  N += T;
                }
                return D;
              })(t, s.runs, s.numRleValues);
              return mu(n), n;
            }
            throw new Error("Only delta encoding is supported for transforming length to offset streams yet.");
          }
          static decodeNullableIntStream(t, s, n, a, M) {
            const l = n.physicalLevelTechnique === Er.FAST_PFOR ? ih() : Ze(t, s, n.numValues);
            return this.decodeNullableIntBuffer(l, n, a, M);
          }
          static decodeNullableLongStream(t, s, n, a, M) {
            const l = al(t, s, n.numValues);
            return this.decodeNullableLongBuffer(l, n, a, M);
          }
          static decodeNullableIntBuffer(t, s, n, a) {
            switch (s.logicalLevelTechnique1) {
              case Ht.DELTA:
                return s.logicalLevelTechnique2 === Ht.RLE && (t = rh(t, s.runs, s.numRleValues)), (function(M, l) {
                  const D = new Int32Array(M.size());
                  let N = 0;
                  M.get(0) ? (D[0] = M.get(0) ? l[0] >>> 1 ^ -(1 & l[0]) : 0, N = 1) : D[0] = 0;
                  let y = 1;
                  for (; y != D.length; ++y) D[y] = M.get(y) ? D[y - 1] + (l[N] >>> 1 ^ -(1 & l[N++])) : D[y - 1];
                  return D;
                })(a, t);
              case Ht.RLE:
                return (function(M, l, D, N) {
                  const y = l;
                  return D ? (function(w, T, x) {
                    const A = new Int32Array(w.size());
                    let m = 0;
                    for (let L = 0; L < x; L++) {
                      const O = T[L];
                      let B = T[L + x];
                      B = B >>> 1 ^ -(1 & B);
                      for (let P = m; P < m + O; P++) w.get(P) ? A[P] = B : (A[P] = 0, m++);
                      m += O;
                    }
                    return A;
                  })(N, M, y.runs) : (function(w, T, x) {
                    const A = new Int32Array(w.size());
                    let m = 0;
                    for (let L = 0; L < x; L++) {
                      const O = T[L], B = T[L + x];
                      for (let P = m; P < m + O; P++) w.get(P) ? A[P] = B : (A[P] = 0, m++);
                      m += O;
                    }
                    return A;
                  })(N, M, y.runs);
                })(t, s, n, a);
              case Ht.MORTON:
                return mu(t), t;
              case Ht.COMPONENTWISE_DELTA:
                return oh(t), t;
              case Ht.NONE:
                return t = n ? (function(M, l) {
                  const D = new Int32Array(M.size());
                  let N = 0, y = 0;
                  for (; y != D.length; ++y) if (M.get(y)) {
                    const w = l[N++];
                    D[y] = w >>> 1 ^ -(1 & w);
                  } else D[y] = 0;
                  return D;
                })(a, t) : (function(M, l) {
                  const D = new Int32Array(M.size());
                  let N = 0, y = 0;
                  for (; y != D.length; ++y) D[y] = M.get(y) ? l[N++] : 0;
                  return D;
                })(a, t), t;
              default:
                throw new Error("The specified Logical level technique is not supported");
            }
          }
          static decodeNullableLongBuffer(t, s, n, a) {
            switch (s.logicalLevelTechnique1) {
              case Ht.DELTA:
                return s.logicalLevelTechnique2 === Ht.RLE && (t = nh(t, s.runs, s.numRleValues)), (function(M, l) {
                  const D = new BigInt64Array(M.size());
                  let N = 0;
                  M.get(0) ? (D[0] = M.get(0) ? l[0] >> 1n ^ -(1n & l[0]) : 0n, N = 1) : D[0] = 0n;
                  let y = 1;
                  for (; y != D.length; ++y) D[y] = M.get(y) ? D[y - 1] + (l[N] >> 1n ^ -(1n & l[N++])) : D[y - 1];
                  return D;
                })(a, t);
              case Ht.RLE:
                return (function(M, l, D, N) {
                  const y = l;
                  return D ? (function(w, T, x) {
                    const A = new BigInt64Array(w.size());
                    let m = 0;
                    for (let L = 0; L < x; L++) {
                      const O = Number(T[L]);
                      let B = T[L + x];
                      B = B >> 1n ^ -(1n & B);
                      for (let P = m; P < m + O; P++) w.get(P) ? A[P] = B : (A[P] = 0n, m++);
                      m += O;
                    }
                    return A;
                  })(N, M, y.runs) : (function(w, T, x) {
                    const A = new BigInt64Array(w.size());
                    let m = 0;
                    for (let L = 0; L < x; L++) {
                      const O = Number(T[L]), B = T[L + x];
                      for (let P = m; P < m + O; P++) w.get(P) ? A[P] = B : (A[P] = 0n, m++);
                      m += O;
                    }
                    return A;
                  })(N, M, y.runs);
                })(t, s, n, a);
              case Ht.NONE:
                return t = n ? (function(M, l) {
                  const D = new BigInt64Array(M.size());
                  let N = 0, y = 0;
                  for (; y != D.length; ++y) if (M.get(y)) {
                    const w = l[N++];
                    D[y] = w >> 1n ^ -(1n & w);
                  } else D[y] = 0n;
                  return D;
                })(a, t) : (function(M, l) {
                  const D = new BigInt64Array(M.size());
                  let N = 0, y = 0;
                  for (; y != D.length; ++y) D[y] = M.get(y) ? l[N++] : 0n;
                  return D;
                })(a, t), t;
              default:
                throw new Error("The specified Logical level technique is not supported");
            }
          }
          static getVectorType(t, s, n, a) {
            const M = t.logicalLevelTechnique1;
            if (M === Ht.RLE) return t.runs === 1 ? He.CONST : He.FLAT;
            const l = s instanceof Ci ? s.size() : s;
            if (M === Ht.DELTA && t.logicalLevelTechnique2 === Ht.RLE) {
              const D = t.runs, N = 2;
              if (t.numRleValues !== l) return He.FLAT;
              if (D === 1) return He.SEQUENCE;
              if (D === 2) {
                const y = a.get();
                let w;
                if (t.physicalLevelTechnique === Er.VARINT) w = Ze(n, a, 4);
                else {
                  const T = a.get();
                  w = new Int32Array(n.buffer, n.byteOffset + T, 4);
                }
                if (a.set(y), w[2] === N && w[3] === N) return He.SEQUENCE;
              }
            }
            return t.numValues === 1 ? He.CONST : He.FLAT;
          }
        }
        class Mh extends nl {
          getValueFromBuffer(t) {
            return this.dataBuffer[t];
          }
        }
        class ch extends eh {
          constructor(t, s, n, a) {
            super(t, BigInt64Array.of(s), n, a);
          }
          getValueFromBuffer(t) {
            return this.dataBuffer[0] + BigInt(t) * this.delta;
          }
        }
        class zo {
          _geometryOffsets;
          _partOffsets;
          _ringOffsets;
          constructor(t, s, n) {
            this._geometryOffsets = t, this._partOffsets = s, this._ringOffsets = n;
          }
          get geometryOffsets() {
            return this._geometryOffsets;
          }
          get partOffsets() {
            return this._partOffsets;
          }
          get ringOffsets() {
            return this._ringOffsets;
          }
        }
        class _z {
          tileExtent;
          _numBits;
          _coordinateShift;
          minBound;
          maxBound;
          constructor(t, s) {
            this._coordinateShift = t < 0 ? Math.abs(t) : 0, this.tileExtent = s + this._coordinateShift, this._numBits = Math.ceil(Math.log2(this.tileExtent)), this.minBound = t, this.maxBound = s;
          }
          validateCoordinates(t) {
            if (t.x < this.minBound || t.y < this.minBound || t.x > this.maxBound || t.y > this.maxBound) throw new Error("The specified tile buffer size is currently not supported.");
          }
          numBits() {
            return this._numBits;
          }
          coordinateShift() {
            return this._coordinateShift;
          }
        }
        class No extends _z {
          encode(t) {
            this.validateCoordinates(t);
            const s = t.x + this._coordinateShift, n = t.y + this._coordinateShift;
            let a = 0;
            for (let M = 0; M < this._numBits; M++) a |= (s & 1 << M) << M | (n & 1 << M) << M + 1;
            return a;
          }
          decode(t) {
            return { x: this.decodeMorton(t) - this._coordinateShift, y: this.decodeMorton(t >> 1) - this._coordinateShift };
          }
          decodeMorton(t) {
            let s = 0;
            for (let n = 0; n < this._numBits; n++) s |= (t & 1 << 2 * n) >> n;
            return s;
          }
          static decode(t, s, n) {
            return { x: No.decodeMorton(t, s) - n, y: No.decodeMorton(t >> 1, s) - n };
          }
          static decodeMorton(t, s) {
            let n = 0;
            for (let a = 0; a < s; a++) n |= (t & 1 << 2 * a) >> a;
            return n;
          }
        }
        (function(i) {
          i[i.POINT = 0] = "POINT", i[i.LINESTRING = 1] = "LINESTRING", i[i.POLYGON = 2] = "POLYGON", i[i.MULTIPOINT = 3] = "MULTIPOINT", i[i.MULTILINESTRING = 4] = "MULTILINESTRING", i[i.MULTIPOLYGON = 5] = "MULTIPOLYGON";
        })(Je || (Je = {})), (function(i) {
          i[i.POINT = 0] = "POINT", i[i.LINESTRING = 1] = "LINESTRING", i[i.POLYGON = 2] = "POLYGON";
        })(sh || (sh = {})), (function(i) {
          i[i.MORTON = 0] = "MORTON", i[i.VEC_2 = 1] = "VEC_2", i[i.VEC_3 = 2] = "VEC_3";
        })(ii || (ii = {}));
        class Lz {
          createPoint(t) {
            return [[t]];
          }
          createMultiPoint(t) {
            return t.map(((s) => [s]));
          }
          createLineString(t) {
            return [t];
          }
          createMultiLineString(t) {
            return t;
          }
          createPolygon(t, s) {
            return [t, ...s];
          }
          createMultiPolygon(t) {
            return t.flat();
          }
        }
        function lh(i) {
          const t = new Array(i.numGeometries);
          let s = 1, n = 1, a = 1, M = 0;
          const l = new Lz();
          let D = 0, N = 0;
          const y = i.mortonSettings, w = i.topologyVector, T = w.geometryOffsets, x = w.partOffsets, A = w.ringOffsets, m = i.vertexOffsets, L = i.containsPolygonGeometry(), O = i.vertexBuffer;
          for (let B = 0; B < i.numGeometries; B++) {
            const P = i.geometryType(B);
            if (P === Je.POINT) {
              if (m && m.length !== 0) if (i.vertexBufferType === ii.VEC_2) {
                const k = 2 * m[N++], U = new mt(O[k], O[k + 1]);
                t[M++] = l.createPoint(U);
              } else {
                const k = m[N++], U = No.decode(O[k], y.numBits, y.coordinateShift), K = new mt(U.x, U.y);
                t[M++] = l.createPoint(K);
              }
              else {
                const k = new mt(O[D++], O[D++]);
                t[M++] = l.createPoint(k);
              }
              T && a++, x && s++, A && n++;
            } else if (P === Je.MULTIPOINT) {
              const k = T[a] - T[a - 1];
              a++;
              const U = new Array(k);
              if (m && m.length !== 0) {
                for (let K = 0; K < k; K++) {
                  const et = 2 * m[N++];
                  U[K] = new mt(O[et], O[et + 1]);
                }
                t[M++] = l.createMultiPoint(U);
              } else {
                for (let K = 0; K < k; K++) {
                  const et = O[D++], ot = O[D++];
                  U[K] = new mt(et, ot);
                }
                t[M++] = l.createMultiPoint(U);
              }
            } else if (P === Je.LINESTRING) {
              let k, U = 0;
              L ? (U = A[n] - A[n - 1], n++) : U = x[s] - x[s - 1], s++, m && m.length !== 0 ? (k = i.vertexBufferType === ii.VEC_2 ? _u(O, m, N, U, !1) : Lu(O, m, N, U, !1, y), N += U) : (k = ju(O, D, U, !1), D += 2 * U), t[M++] = l.createLineString(k), T && a++;
            } else if (P === Je.POLYGON) {
              const k = x[s] - x[s - 1];
              s++;
              const U = new Array(k - 1);
              let K = A[n] - A[n - 1];
              if (n++, m && m.length !== 0) {
                const et = i.vertexBufferType === ii.VEC_2 ? cl(O, m, N, K) : ll(O, m, N, K, 0, y);
                N += K;
                for (let ot = 0; ot < U.length; ot++) K = A[n] - A[n - 1], n++, U[ot] = i.vertexBufferType === ii.VEC_2 ? cl(O, m, N, K) : ll(O, m, N, K, 0, y), N += K;
                t[M++] = l.createPolygon(et, U);
              } else {
                const et = Ml(O, D, K);
                D += 2 * K;
                for (let ot = 0; ot < U.length; ot++) K = A[n] - A[n - 1], n++, U[ot] = Ml(O, D, K), D += 2 * K;
                t[M++] = l.createPolygon(et, U);
              }
              T && a++;
            } else if (P === Je.MULTILINESTRING) {
              const k = T[a] - T[a - 1];
              a++;
              const U = new Array(k);
              if (m && m.length !== 0) {
                for (let K = 0; K < k; K++) {
                  let et = 0;
                  L ? (et = A[n] - A[n - 1], n++) : et = x[s] - x[s - 1], s++;
                  const ot = i.vertexBufferType === ii.VEC_2 ? _u(O, m, N, et, !1) : Lu(O, m, N, et, !1, y);
                  U[K] = ot, N += et;
                }
                t[M++] = l.createMultiLineString(U);
              } else {
                for (let K = 0; K < k; K++) {
                  let et = 0;
                  L ? (et = A[n] - A[n - 1], n++) : et = x[s] - x[s - 1], s++, U[K] = ju(O, D, et, !1), D += 2 * et;
                }
                t[M++] = l.createMultiLineString(U);
              }
            } else {
              if (P !== Je.MULTIPOLYGON) throw new Error("The specified geometry type is currently not supported.");
              {
                const k = T[a] - T[a - 1];
                a++;
                const U = new Array(k);
                let K = 0;
                if (m && m.length !== 0) {
                  for (let et = 0; et < k; et++) {
                    const ot = x[s] - x[s - 1];
                    s++;
                    const dt = new Array(ot - 1);
                    K = A[n] - A[n - 1], n++;
                    const Dt = i.vertexBufferType === ii.VEC_2 ? cl(O, m, N, K) : ll(O, m, N, K, 0, y);
                    N += K;
                    for (let yt = 0; yt < dt.length; yt++) K = A[n] - A[n - 1], n++, dt[yt] = i.vertexBufferType === ii.VEC_2 ? cl(O, m, N, K) : ll(O, m, N, K, 0, y), N += K;
                    U[et] = l.createPolygon(Dt, dt);
                  }
                  t[M++] = l.createMultiPolygon(U);
                } else {
                  for (let et = 0; et < k; et++) {
                    const ot = x[s] - x[s - 1];
                    s++;
                    const dt = new Array(ot - 1);
                    K = A[n] - A[n - 1], n++;
                    const Dt = Ml(O, D, K);
                    D += 2 * K;
                    for (let yt = 0; yt < dt.length; yt++) {
                      const At = A[n] - A[n - 1];
                      n++, dt[yt] = Ml(O, D, At), D += 2 * At;
                    }
                    U[et] = l.createPolygon(Dt, dt);
                  }
                  t[M++] = l.createMultiPolygon(U);
                }
              }
            }
          }
          return t;
        }
        function Ml(i, t, s) {
          return ju(i, t, s, !0);
        }
        function cl(i, t, s, n) {
          return _u(i, t, s, n, !0);
        }
        function ll(i, t, s, n, a, M) {
          return Lu(i, t, s, n, !0, M);
        }
        function ju(i, t, s, n) {
          const a = new Array(n ? s + 1 : s);
          for (let M = 0; M < 2 * s; M += 2) a[M / 2] = new mt(i[t + M], i[t + M + 1]);
          return n && (a[a.length - 1] = a[0]), a;
        }
        function _u(i, t, s, n, a) {
          const M = new Array(a ? n + 1 : n);
          for (let l = 0; l < 2 * n; l += 2) {
            const D = 2 * t[s + l / 2];
            M[l / 2] = new mt(i[D], i[D + 1]);
          }
          return a && (M[M.length - 1] = M[0]), M;
        }
        function Lu(i, t, s, n, a, M) {
          const l = new Array(a ? n + 1 : n);
          for (let D = 0; D < n; D++) {
            const N = No.decode(i[t[s + D]], M.numBits, M.coordinateShift);
            l[D] = new mt(N.x, N.y);
          }
          return a && (l[l.length - 1] = l[0]), l;
        }
        class uh {
          _vertexBufferType;
          _topologyVector;
          _vertexOffsets;
          _vertexBuffer;
          _mortonSettings;
          constructor(t, s, n, a, M) {
            this._vertexBufferType = t, this._topologyVector = s, this._vertexOffsets = n, this._vertexBuffer = a, this._mortonSettings = M;
          }
          get vertexBufferType() {
            return this._vertexBufferType;
          }
          get topologyVector() {
            return this._topologyVector;
          }
          get vertexOffsets() {
            return this._vertexOffsets;
          }
          get vertexBuffer() {
            return this._vertexBuffer;
          }
          *[Symbol.iterator]() {
            const t = lh(this);
            let s = 0;
            for (; s < this.numGeometries; ) yield { coordinates: t[s], type: this.geometryType(s) }, s++;
          }
          getSimpleEncodedVertex(t) {
            const s = this.vertexOffsets ? 2 * this.vertexOffsets[t] : 2 * t;
            return [this.vertexBuffer[s], this.vertexBuffer[s + 1]];
          }
          getVertex(t) {
            if (this.vertexOffsets && this.mortonSettings) {
              const n = No.decode(this.vertexBuffer[this.vertexOffsets[t]], this.mortonSettings.numBits, this.mortonSettings.coordinateShift);
              return [n.x, n.y];
            }
            const s = this.vertexOffsets ? 2 * this.vertexOffsets[t] : 2 * t;
            return [this.vertexBuffer[s], this.vertexBuffer[s + 1]];
          }
          getGeometries() {
            return lh(this);
          }
          get mortonSettings() {
            return this._mortonSettings;
          }
        }
        class vM extends uh {
          _numGeometries;
          _geometryType;
          constructor(t, s, n, a, M, l, D) {
            super(n, a, M, l, D), this._numGeometries = t, this._geometryType = s;
          }
          static createMortonEncoded(t, s, n, a, M, l) {
            return new vM(t, s, ii.MORTON, n, a, M, l);
          }
          static create(t, s, n, a, M) {
            return new vM(t, s, ii.VEC_2, n, a, M);
          }
          geometryType(t) {
            return this._geometryType;
          }
          get numGeometries() {
            return this._numGeometries;
          }
          containsPolygonGeometry() {
            return this._geometryType === Je.POLYGON || this._geometryType === Je.MULTIPOLYGON;
          }
          containsSingleGeometryType() {
            return !0;
          }
        }
        class BM extends uh {
          _geometryTypes;
          constructor(t, s, n, a, M, l) {
            super(t, n, a, M, l), this._geometryTypes = s;
          }
          static createMortonEncoded(t, s, n, a, M) {
            return new BM(ii.MORTON, t, s, n, a, M);
          }
          static create(t, s, n, a) {
            return new BM(ii.VEC_2, t, s, n, a);
          }
          geometryType(t) {
            return this._geometryTypes[t];
          }
          get numGeometries() {
            return this._geometryTypes.length;
          }
          containsPolygonGeometry() {
            for (let t = 0; t < this.numGeometries; t++) if (this.geometryType(t) === Je.POLYGON || this.geometryType(t) === Je.MULTIPOLYGON) return !0;
            return !1;
          }
          containsSingleGeometryType() {
            return !1;
          }
        }
        class gh {
          _triangleOffsets;
          _indexBuffer;
          _vertexBuffer;
          _topologyVector;
          constructor(t, s, n, a) {
            this._triangleOffsets = t, this._indexBuffer = s, this._vertexBuffer = n, this._topologyVector = a;
          }
          get triangleOffsets() {
            return this._triangleOffsets;
          }
          get indexBuffer() {
            return this._indexBuffer;
          }
          get vertexBuffer() {
            return this._vertexBuffer;
          }
          get topologyVector() {
            return this._topologyVector;
          }
          getGeometries() {
            if (!this._topologyVector) throw new Error("Cannot convert GpuVector to coordinates without topology information");
            const t = new Array(this.numGeometries), s = this._topologyVector, n = s.partOffsets, a = s.ringOffsets, M = s.geometryOffsets;
            let l = 0, D = 1, N = 1, y = 1;
            for (let w = 0; w < this.numGeometries; w++) switch (this.geometryType(w)) {
              case Je.POLYGON:
                {
                  const T = n[D] - n[D - 1];
                  D++;
                  const x = [];
                  for (let A = 0; A < T; A++) {
                    const m = a[N] - a[N - 1];
                    N++;
                    const L = [];
                    for (let O = 0; O < m; O++) {
                      const B = this._vertexBuffer[l++], P = this._vertexBuffer[l++];
                      L.push(new mt(B, P));
                    }
                    L.length > 0 && L.push(L[0]), x.push(L);
                  }
                  t[w] = x, M && y++;
                }
                break;
              case Je.MULTIPOLYGON: {
                const T = M[y] - M[y - 1];
                y++;
                const x = [];
                for (let A = 0; A < T; A++) {
                  const m = n[D] - n[D - 1];
                  D++;
                  for (let L = 0; L < m; L++) {
                    const O = a[N] - a[N - 1];
                    N++;
                    const B = [];
                    for (let P = 0; P < O; P++) {
                      const k = this._vertexBuffer[l++], U = this._vertexBuffer[l++];
                      B.push(new mt(k, U));
                    }
                    B.length > 0 && B.push(B[0]), x.push(B);
                  }
                }
                t[w] = x;
              }
            }
            return t;
          }
          [Symbol.iterator]() {
            return null;
          }
        }
        class ul extends gh {
          _numGeometries;
          _geometryType;
          constructor(t, s, n, a, M, l) {
            super(n, a, M, l), this._numGeometries = t, this._geometryType = s;
          }
          static create(t, s, n, a, M, l) {
            return new ul(t, s, n, a, M, l);
          }
          geometryType(t) {
            return this._geometryType;
          }
          get numGeometries() {
            return this._numGeometries;
          }
          containsSingleGeometryType() {
            return !0;
          }
        }
        class gl extends gh {
          _geometryTypes;
          constructor(t, s, n, a, M) {
            super(s, n, a, M), this._geometryTypes = t;
          }
          static create(t, s, n, a, M) {
            return new gl(t, s, n, a, M);
          }
          geometryType(t) {
            return this._geometryTypes[t];
          }
          get numGeometries() {
            return this._geometryTypes.length;
          }
          containsSingleGeometryType() {
            return !1;
          }
        }
        function Cz(i, t, s, n, a) {
          const M = ds.decode(i, s);
          let l = null, D = null, N = null, y = null, w = null, T = null, x = null, A = null;
          if (Wt.getVectorType(M, n, i, s) === He.CONST) {
            const L = Wt.decodeConstIntStream(i, s, M, !1);
            for (let O = 0; O < t - 1; O++) {
              const B = ds.decode(i, s);
              switch (B.physicalStreamType) {
                case cs.LENGTH:
                  switch (B.logicalStreamType.lengthType) {
                    case Ps.GEOMETRIES:
                      l = Wt.decodeLengthStreamToOffsetBuffer(i, s, B);
                      break;
                    case Ps.PARTS:
                      D = Wt.decodeLengthStreamToOffsetBuffer(i, s, B);
                      break;
                    case Ps.RINGS:
                      N = Wt.decodeLengthStreamToOffsetBuffer(i, s, B);
                      break;
                    case Ps.TRIANGLES:
                      x = Wt.decodeLengthStreamToOffsetBuffer(i, s, B);
                  }
                  break;
                case cs.OFFSET:
                  switch (B.logicalStreamType.offsetType) {
                    case ca.VERTEX:
                      y = Wt.decodeIntStream(i, s, B, !1);
                      break;
                    case ca.INDEX:
                      A = Wt.decodeIntStream(i, s, B, !1);
                  }
                  break;
                case cs.DATA:
                  if (Li.VERTEX === B.logicalStreamType.dictionaryType) w = Wt.decodeIntStream(i, s, B, !0, a);
                  else {
                    const P = B;
                    T = { numBits: P.numBits(), coordinateShift: P.coordinateShift() }, w = Wt.decodeIntStream(i, s, B, !1, a);
                  }
              }
            }
            if (A !== null) {
              if (l != null || D != null) {
                const O = new zo(l, D, N);
                return ul.create(n, L, x, A, w, O);
              }
              return ul.create(n, L, x, A, w);
            }
            return T === null ? vM.create(n, L, new zo(l, D, N), y, w) : vM.createMortonEncoded(n, L, new zo(l, D, N), y, w, T);
          }
          const m = Wt.decodeIntStream(i, s, M, !1);
          for (let L = 0; L < t - 1; L++) {
            const O = ds.decode(i, s);
            switch (O.physicalStreamType) {
              case cs.LENGTH:
                switch (O.logicalStreamType.lengthType) {
                  case Ps.GEOMETRIES:
                    l = Wt.decodeIntStream(i, s, O, !1);
                    break;
                  case Ps.PARTS:
                    D = Wt.decodeIntStream(i, s, O, !1);
                    break;
                  case Ps.RINGS:
                    N = Wt.decodeIntStream(i, s, O, !1);
                    break;
                  case Ps.TRIANGLES:
                    x = Wt.decodeLengthStreamToOffsetBuffer(i, s, O);
                }
                break;
              case cs.OFFSET:
                switch (O.logicalStreamType.offsetType) {
                  case ca.VERTEX:
                    y = Wt.decodeIntStream(i, s, O, !1);
                    break;
                  case ca.INDEX:
                    A = Wt.decodeIntStream(i, s, O, !1);
                }
                break;
              case cs.DATA:
                if (Li.VERTEX === O.logicalStreamType.dictionaryType) w = Wt.decodeIntStream(i, s, O, !0, a);
                else {
                  const B = O;
                  T = { numBits: B.numBits(), coordinateShift: B.coordinateShift() }, w = Wt.decodeIntStream(i, s, O, !1, a);
                }
            }
          }
          return A !== null && D === null ? gl.create(m, x, A, w) : (l !== null ? (l = Cu(m, l, 2), D !== null && N !== null ? (D = hh(m, l, D, !1), N = (function(L, O, B, P) {
            const k = new Int32Array(B[B.length - 1] + 1);
            let U = 0;
            k[0] = U;
            let K = 1, et = 1, ot = 0;
            for (let dt = 0; dt < L.length; dt++) {
              const Dt = L[dt], yt = O[dt + 1] - O[dt];
              if (Dt !== 0 && Dt !== 3) for (let At = 0; At < yt; At++) {
                const Tt = B[K] - B[K - 1];
                K++;
                for (let ft = 0; ft < Tt; ft++) U = k[et++] = U + P[ot++];
              }
              else for (let At = 0; At < yt; At++) k[et++] = ++U, K++;
            }
            return k;
          })(m, l, D, N)) : D !== null && (D = (function(L, O, B) {
            const P = new Int32Array(O[O.length - 1] + 1);
            let k = 0;
            P[0] = k;
            let U = 1, K = 0;
            for (let et = 0; et < L.length; et++) {
              const ot = L[et], dt = O[et + 1] - O[et];
              if (ot === 4 || ot === 1) for (let Dt = 0; Dt < dt; Dt++) k = P[U++] = k + B[K++];
              else for (let Dt = 0; Dt < dt; Dt++) P[U++] = ++k;
            }
            return P;
          })(m, l, D))) : D !== null && N !== null ? (D = Cu(m, D, 1), N = hh(m, D, N, !0)) : D !== null && (D = Cu(m, D, 0)), A !== null ? gl.create(m, x, A, w, new zo(l, D, N)) : T === null ? BM.create(m, new zo(l, D, N), y, w) : BM.createMortonEncoded(m, new zo(l, D, N), y, w, T));
        }
        function Cu(i, t, s) {
          const n = new Int32Array(i.length + 1);
          let a = 0;
          n[0] = a;
          let M = 0;
          for (let l = 0; l < i.length; l++) a = n[l + 1] = a + (i[l] > s ? t[M++] : 1);
          return n;
        }
        function hh(i, t, s, n) {
          const a = new Int32Array(t[t.length - 1] + 1);
          let M = 0;
          a[0] = M;
          let l = 1, D = 0;
          for (let N = 0; N < i.length; N++) {
            const y = i[N], w = t[N + 1] - t[N];
            if (y === 5 || y === 2 || n && (y === 4 || y === 1)) for (let T = 0; T < w; T++) M = a[l++] = M + s[D++];
            else for (let T = 0; T < w; T++) a[l++] = ++M;
          }
          return a;
        }
        class Oz extends ho {
          dataVector;
          constructor(t, s, n) {
            super(t, s.getBuffer(), n), this.dataVector = s;
          }
          getValueFromBuffer(t) {
            return this.dataVector.get(t);
          }
        }
        class Ez extends nl {
          getValueFromBuffer(t) {
            return this.dataBuffer[t];
          }
        }
        class Dh extends ho {
          constructor(t, s, n) {
            super(t, BigInt64Array.of(s), n);
          }
          getValueFromBuffer(t) {
            return this.dataBuffer[0];
          }
        }
        function bz(i, t, s) {
          for (let n = 0; n < i; n++) {
            const a = ds.decode(t, s);
            s.add(a.byteLength);
          }
        }
        function SM(i, t, s) {
          return zh(i, Math.ceil(t / 8), s);
        }
        function zh(i, t, s) {
          const n = new Uint8Array(t);
          let a = 0;
          for (; a < t; ) {
            const M = i[s.increment()];
            if (M <= 127) {
              const l = M + 3, D = i[s.increment()], N = a + l;
              n.fill(D, a, N), a = N;
            } else {
              const l = 256 - M;
              for (let D = 0; D < l; D++) n[a++] = i[s.increment()];
            }
          }
          return n;
        }
        const Qz = new TextDecoder();
        function Ou(i, t, s) {
          return s - t >= 12 ? Qz.decode(i.subarray(t, s)) : (function(n, a, M) {
            let l = "", D = a;
            for (; D < M; ) {
              const N = n[D];
              let y, w, T, x = null, A = N > 239 ? 4 : N > 223 ? 3 : N > 191 ? 2 : 1;
              if (D + A > M) break;
              A === 1 ? N < 128 && (x = N) : A === 2 ? (y = n[D + 1], (192 & y) == 128 && (x = (31 & N) << 6 | 63 & y, x <= 127 && (x = null))) : A === 3 ? (y = n[D + 1], w = n[D + 2], (192 & y) == 128 && (192 & w) == 128 && (x = (15 & N) << 12 | (63 & y) << 6 | 63 & w, (x <= 2047 || x >= 55296 && x <= 57343) && (x = null))) : A === 4 && (y = n[D + 1], w = n[D + 2], T = n[D + 3], (192 & y) == 128 && (192 & w) == 128 && (192 & T) == 128 && (x = (15 & N) << 18 | (63 & y) << 12 | (63 & w) << 6 | 63 & T, (x <= 65535 || x >= 1114112) && (x = null))), x === null ? (x = 65533, A = 1) : x > 65535 && (x -= 65536, l += String.fromCharCode(x >>> 10 & 1023 | 55296), x = 56320 | 1023 & x), l += String.fromCharCode(x), D += A;
            }
            return l;
          })(i, t, s);
        }
        class Eu extends ho {
          offsetBuffer;
          constructor(t, s, n, a) {
            super(t, n, a), this.offsetBuffer = s;
          }
        }
        class Nh extends Eu {
          textEncoder;
          constructor(t, s, n, a) {
            super(t, s, n, a ?? s.length - 1), this.textEncoder = new TextEncoder();
          }
          getValueFromBuffer(t) {
            return Ou(this.dataBuffer, this.offsetBuffer[t], this.offsetBuffer[t + 1]);
          }
        }
        class yo extends Eu {
          indexBuffer;
          textEncoder;
          constructor(t, s, n, a, M) {
            super(t, n, a, M ?? s.length), this.indexBuffer = s, this.indexBuffer = s, this.textEncoder = new TextEncoder();
          }
          getValueFromBuffer(t) {
            const s = this.indexBuffer[t];
            return Ou(this.dataBuffer, this.offsetBuffer[s], this.offsetBuffer[s + 1]);
          }
        }
        class dh extends Eu {
          indexBuffer;
          symbolOffsetBuffer;
          symbolTableBuffer;
          textEncoder;
          symbolLengthBuffer;
          lengthBuffer;
          decodedDictionary;
          constructor(t, s, n, a, M, l, D) {
            super(t, n, a, D), this.indexBuffer = s, this.symbolOffsetBuffer = M, this.symbolTableBuffer = l, this.textEncoder = new TextEncoder();
          }
          getValueFromBuffer(t) {
            this.decodedDictionary == null && (this.symbolLengthBuffer == null && (this.symbolLengthBuffer = this.offsetToLengthBuffer(this.symbolOffsetBuffer), this.lengthBuffer = this.offsetToLengthBuffer(this.offsetBuffer)), this.decodedDictionary = (function(n, a, M) {
              const l = [], D = new Array(a.length).fill(0);
              for (let N = 1; N < a.length; N++) D[N] = D[N - 1] + a[N - 1];
              for (let N = 0; N < M.length; N++) if (M[N] === 255) l.push(M[++N]);
              else {
                const y = a[M[N]], w = D[M[N]];
                for (let T = 0; T < y; T++) l.push(n[w + T]);
              }
              return new Uint8Array(l);
            })(this.symbolTableBuffer, this.symbolLengthBuffer, this.dataBuffer));
            const s = this.indexBuffer[t];
            return Ou(this.decodedDictionary, this.offsetBuffer[s], this.offsetBuffer[s + 1]);
          }
          offsetToLengthBuffer(t) {
            const s = new Uint32Array(t.length - 1);
            let n = t[0];
            for (let a = 1; a < t.length; a++) {
              const M = t[a];
              s[a - 1] = M - n, n = M;
            }
            return s;
          }
        }
        class kM {
          static ROOT_COLUMN_NAME = "default";
          static NESTED_COLUMN_SEPARATOR = ":";
          constructor() {
          }
          static decode(t, s, n, a, M) {
            let l = null, D = null, N = null, y = null, w = null, T = null, x = null, A = null;
            for (let m = 0; m < a; m++) {
              const L = ds.decode(s, n);
              if (L.byteLength !== 0) switch (L.physicalStreamType) {
                case cs.PRESENT: {
                  const O = SM(s, L.numValues, n);
                  T = new Ci(O, L.numValues);
                  break;
                }
                case cs.OFFSET:
                  D = M != null || T != null ? Wt.decodeNullableIntStream(s, n, L, !1, M ?? T) : Wt.decodeIntStream(s, n, L, !1);
                  break;
                case cs.LENGTH: {
                  const O = Wt.decodeLengthStreamToOffsetBuffer(s, n, L);
                  Ps.DICTIONARY === L.logicalStreamType.lengthType ? l = O : Ps.SYMBOL === L.logicalStreamType.lengthType ? y = O : x = O;
                  break;
                }
                case cs.DATA: {
                  const O = s.subarray(n.get(), n.get() + L.byteLength);
                  n.add(L.byteLength);
                  const B = L.logicalStreamType.dictionaryType;
                  Li.FSST === B ? w = O : Li.SINGLE === B || Li.SHARED === B ? N = O : Li.NONE === B && (A = O);
                  break;
                }
              }
            }
            return this.decodeFsstDictionaryVector(t, w, D, l, N, y, M ?? T) ?? this.decodeDictionaryVector(t, N, D, l, M ?? T) ?? this.decodePlainStringVector(t, x, A, D, M ?? T);
          }
          static decodeFsstDictionaryVector(t, s, n, a, M, l, D) {
            return s ? new dh(t, n, a, M, l, s, D) : null;
          }
          static decodeDictionaryVector(t, s, n, a, M) {
            return s ? M ? new yo(t, n, a, s, M) : new yo(t, n, a, s) : null;
          }
          static decodePlainStringVector(t, s, n, a, M) {
            if (!s || !n) return null;
            if (a) return M ? new yo(t, a, s, n, M) : new yo(t, a, s, n);
            if (M && M.size() !== s.length - 1) {
              const l = new Int32Array(M.size());
              let D = 0;
              for (let N = 0; N < M.size(); N++) l[N] = M.get(N) ? D++ : 0;
              return new yo(t, l, s, n, M);
            }
            return M ? new Nh(t, s, n, M) : new Nh(t, s, n);
          }
          static decodeSharedDictionary(t, s, n, a, M) {
            let l = null, D = null, N = null, y = null, w = !1;
            for (; !w; ) {
              const m = ds.decode(t, s);
              switch (m.physicalStreamType) {
                case cs.LENGTH:
                  Ps.DICTIONARY === m.logicalStreamType.lengthType ? l = Wt.decodeLengthStreamToOffsetBuffer(t, s, m) : N = Wt.decodeLengthStreamToOffsetBuffer(t, s, m);
                  break;
                case cs.DATA:
                  Li.SINGLE === m.logicalStreamType.dictionaryType || Li.SHARED === m.logicalStreamType.dictionaryType ? (D = t.subarray(s.get(), s.get() + m.byteLength), w = !0) : y = t.subarray(s.get(), s.get() + m.byteLength), s.add(m.byteLength);
              }
            }
            const T = n.complexType.children, x = [];
            let A = 0;
            for (const m of T) {
              const L = Ze(t, s, 1)[0];
              if (L == 0) continue;
              const O = `${n.name}${m.name === kM.ROOT_COLUMN_NAME ? "" : kM.NESTED_COLUMN_SEPARATOR + m.name}`;
              if (M && !M.has(O)) {
                bz(L, t, s);
                continue;
              }
              if (L !== 2 || m.type !== "scalarField" || m.scalarField.physicalType !== 9) throw new Error("Currently only optional string fields are implemented for a struct.");
              const B = ds.decode(t, s), P = SM(t, B.numValues, s), k = ds.decode(t, s), U = (k instanceof QM ? k.numRleValues : k.numValues) !== a ? Wt.decodeNullableIntStream(t, s, k, !1, new Ci(P, B.numValues)) : Wt.decodeIntStream(t, s, k, !1);
              x[A++] = y ? new dh(O, U, l, D, N, y, new Ci(P, B.numValues)) : new yo(O, U, l, D, new Ci(P, B.numValues));
            }
            return x;
          }
        }
        function vz(i, t, s, n, a, M) {
          return s.type === "scalarType" ? (function(l, D, N, y, w, T) {
            let x = null, A = 0;
            if (l === 0) return null;
            if (T.nullable) {
              const L = ds.decode(D, N);
              A = L.numValues;
              const O = N.get(), B = SM(D, A, N);
              N.set(O + L.byteLength), x = new Ci(B, L.numValues);
            }
            const m = x ?? y;
            switch (w.physicalType) {
              case 4:
              case 3:
                return (function(L, O, B, P, k) {
                  const U = ds.decode(L, O), K = Wt.getVectorType(U, k, L, O), et = P.physicalType === 3;
                  if (K === He.FLAT) {
                    const ot = FM(k) ? Wt.decodeNullableIntStream(L, O, U, et, k) : Wt.decodeIntStream(L, O, U, et);
                    return new pu(B.name, ot, k);
                  }
                  if (K === He.SEQUENCE) {
                    const ot = Wt.decodeSequenceIntStream(L, O, U);
                    return new fu(B.name, ot[0], ot[1], U.numRleValues);
                  }
                  {
                    const ot = Wt.decodeConstIntStream(L, O, U, et);
                    return new xu(B.name, ot, k);
                  }
                })(D, N, T, w, m);
              case 9:
                return kM.decode(T.name, D, N, T.nullable ? l - 1 : l, x);
              case 0:
                return (function(L, O, B, P, k) {
                  const U = ds.decode(L, O), K = U.numValues, et = O.get(), ot = FM(k) ? (function(Dt, yt, At, Tt) {
                    const ft = zh(Dt, Math.ceil(yt / 8), At), zt = new Ci(ft, yt), bt = Tt.size(), Qt = new Ci(new Uint8Array(bt), bt);
                    let St = 0;
                    for (let Lt = 0; Lt < Tt.size(); Lt++) {
                      const Rt = !!Tt.get(Lt) && zt.get(St++);
                      Qt.set(Lt, Rt);
                    }
                    return Qt.getBuffer();
                  })(L, K, O, k) : SM(L, K, O);
                  O.set(et + U.byteLength);
                  const dt = new Ci(ot, K);
                  return new Oz(B.name, dt, k);
                })(D, N, T, 0, m);
              case 6:
              case 5:
                return (function(L, O, B, P, k) {
                  const U = ds.decode(L, O), K = Wt.getVectorType(U, P, L, O), et = k.physicalType === 5;
                  if (K === He.FLAT) {
                    const ot = FM(P) ? Wt.decodeNullableLongStream(L, O, U, et, P) : Wt.decodeLongStream(L, O, U, et);
                    return new Mh(B.name, ot, P);
                  }
                  if (K === He.SEQUENCE) {
                    const ot = Wt.decodeSequenceLongStream(L, O, U);
                    return new ch(B.name, ot[0], ot[1], U.numRleValues);
                  }
                  {
                    const ot = Wt.decodeConstLongStream(L, O, U, et);
                    return new Dh(B.name, ot, P);
                  }
                })(D, N, T, m, w);
              case 7:
                return (function(L, O, B, P) {
                  const k = ds.decode(L, O), U = FM(P) ? (function(K, et, ot, dt) {
                    const Dt = et.get(), yt = Dt + dt * Float32Array.BYTES_PER_ELEMENT, At = new Uint8Array(K.subarray(Dt, yt)).buffer, Tt = new Float32Array(At);
                    et.set(yt);
                    const ft = ot.size(), zt = new Float32Array(ft);
                    let bt = 0;
                    for (let Qt = 0; Qt < ft; Qt++) zt[Qt] = ot.get(Qt) ? Tt[bt++] : 0;
                    return zt;
                  })(L, O, P, k.numValues) : (function(K, et, ot) {
                    const dt = et.get(), Dt = dt + ot * Float32Array.BYTES_PER_ELEMENT, yt = new Uint8Array(K.subarray(dt, Dt)).buffer, At = new Float32Array(yt);
                    return et.set(Dt), At;
                  })(L, O, k.numValues);
                  return new Ez(B.name, U, P);
                })(D, N, T, m);
              case 8:
                return (function(L, O, B, P) {
                  const k = ds.decode(L, O), U = FM(P) ? (function(K, et, ot, dt) {
                    const Dt = et.get(), yt = Dt + dt * Float64Array.BYTES_PER_ELEMENT, At = new Uint8Array(K.subarray(Dt, yt)).buffer, Tt = new Float64Array(At);
                    et.set(yt);
                    const ft = ot.size(), zt = new Float64Array(ft);
                    let bt = 0;
                    for (let Qt = 0; Qt < ft; Qt++) zt[Qt] = ot.get(Qt) ? Tt[bt++] : 0;
                    return zt;
                  })(L, O, P, k.numValues) : (function(K, et, ot) {
                    const dt = et.get(), Dt = dt + ot * Float64Array.BYTES_PER_ELEMENT, yt = new Uint8Array(K.subarray(dt, Dt)).buffer, At = new Float64Array(yt);
                    return et.set(Dt), At;
                  })(L, O, k.numValues);
                  return new Tu(B.name, U, P);
                })(D, N, T, m);
              default:
                throw new Error(`The specified data type for the field is currently not supported: ${w}`);
            }
          })(n, i, t, a, s.scalarType, s) : n != 1 ? null : kM.decodeSharedDictionary(i, t, s, a, M);
        }
        function FM(i) {
          return i instanceof Ci;
        }
        class hl {
          static decodeColumnType(t) {
            switch (t) {
              case 0:
              case 1:
              case 2:
              case 3: {
                const s = {};
                s.nullable = !!(1 & t), s.columnScope = 0;
                const n = {};
                return n.physicalType = t > 1 ? 6 : 4, n.type = "physicalType", s.scalarType = n, s.type = "scalarType", s;
              }
              case 4: {
                const s = { nullable: !1, columnScope: 0 }, n = { type: "physicalType", physicalType: 0 };
                return s.type = "complexType", s.complexType = n, s;
              }
              case 30: {
                const s = { nullable: !1, columnScope: 0 }, n = { type: "physicalType", physicalType: 1 };
                return s.type = "complexType", s.complexType = n, s;
              }
              default:
                return this.mapScalarType(t);
            }
          }
          static columnTypeHasName(t) {
            return t >= 10;
          }
          static columnTypeHasChildren(t) {
            return t === 30;
          }
          static hasStreamCount(t) {
            if (t.name === "id") return !1;
            if (t.type === "scalarType") {
              const s = t.scalarType;
              if (s.type === "physicalType") switch (s.physicalType) {
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                default:
                  return !1;
                case 9:
                  return !0;
              }
              else if (s.type === "logicalType") return !1;
            } else if (t.type === "complexType") {
              const s = t.complexType;
              if (s.type === "physicalType") switch (s.physicalType) {
                case 0:
                case 1:
                  return !0;
                default:
                  return !1;
              }
            }
            return console.warn("Unexpected column type in hasStreamCount", t), !1;
          }
          static mapScalarType(t) {
            let s = null;
            switch (t) {
              case 10:
              case 11:
                s = 0;
                break;
              case 12:
              case 13:
                s = 1;
                break;
              case 14:
              case 15:
                s = 2;
                break;
              case 16:
              case 17:
                s = 3;
                break;
              case 18:
              case 19:
                s = 4;
                break;
              case 20:
              case 21:
                s = 5;
                break;
              case 22:
              case 23:
                s = 6;
                break;
              case 24:
              case 25:
                s = 7;
                break;
              case 26:
              case 27:
                s = 8;
                break;
              case 28:
              case 29:
                s = 9;
                break;
              default:
                return null;
            }
            const n = {};
            n.nullable = !!(1 & t), n.columnScope = 0;
            const a = { type: "physicalType" };
            return a.physicalType = s, n.type = "scalarType", n.scalarType = a, n;
          }
        }
        const Bz = new TextDecoder();
        function yh(i, t) {
          const s = Ze(i, t, 1)[0];
          if (s === 0) return "";
          const n = t.get(), a = i.subarray(n, n + s);
          return t.add(s), Bz.decode(a);
        }
        function Ih(i, t) {
          const s = Ze(i, t, 1)[0] >>> 0, n = !!(4 & s), a = !!(2 & s), M = Ze(i, t, 1)[0] >>> 0, l = {};
          if (1 & s && (l.nullable = !0), a) {
            const D = {};
            if (n ? (D.type = "logicalType", D.logicalType = M) : (D.type = "physicalType", D.physicalType = M), 8 & s) {
              const N = Ze(i, t, 1)[0] >>> 0;
              D.children = new Array(N);
              for (let y = 0; y < N; y++) D.children[y] = Ih(i, t);
            }
            l.type = "complexField", l.complexField = D;
          } else {
            const D = {};
            n ? (D.type = "logicalType", D.logicalType = M) : (D.type = "physicalType", D.physicalType = M), l.type = "scalarField", l.scalarField = D;
          }
          return l;
        }
        function Sz(i, t) {
          const s = Ze(i, t, 1)[0] >>> 0, n = hl.decodeColumnType(s);
          if (!n) throw new Error(`Unsupported column type code: ${s}`);
          if (hl.columnTypeHasName(s) ? n.name = yh(i, t) : s >= 0 && s <= 3 ? n.name = "id" : s === 4 && (n.name = "geometry"), hl.columnTypeHasChildren(s)) {
            const a = Ze(i, t, 1)[0] >>> 0, M = n.complexType;
            M.children = new Array(a);
            for (let l = 0; l < a; l++) M.children[l] = Ih(i, t);
          }
          return n;
        }
        function kz(i, t) {
          const s = { featureTables: [] }, n = {};
          n.name = yh(i, t);
          const a = Ze(i, t, 1)[0] >>> 0, M = Ze(i, t, 1)[0] >>> 0;
          n.columns = new Array(M);
          for (let l = 0; l < M; l++) n.columns[l] = Sz(i, t);
          return s.featureTables.push(n), [s, a];
        }
        function Fz(i, t, s, n, a, M, l = !1) {
          const D = t.scalarType.physicalType, N = Wt.getVectorType(a, M, i, s);
          if (D === 4) switch (N) {
            case He.FLAT: {
              const y = Wt.decodeIntStream(i, s, a, !1);
              return new pu(n, y, M);
            }
            case He.SEQUENCE: {
              const y = Wt.decodeSequenceIntStream(i, s, a);
              return new fu(n, y[0], y[1], a.numRleValues);
            }
            case He.CONST: {
              const y = Wt.decodeConstIntStream(i, s, a, !1);
              return new xu(n, y, M);
            }
          }
          else switch (N) {
            case He.FLAT: {
              if (l) {
                const w = Wt.decodeLongFloat64Stream(i, s, a, !1);
                return new Tu(n, w, M);
              }
              const y = Wt.decodeLongStream(i, s, a, !1);
              return new Mh(n, y, M);
            }
            case He.SEQUENCE: {
              const y = Wt.decodeSequenceLongStream(i, s, a);
              return new ch(n, y[0], y[1], a.numRleValues);
            }
            case He.CONST: {
              const y = Wt.decodeConstLongStream(i, s, a, !1);
              return new Dh(n, y, M);
            }
          }
          throw new Error("Vector type not supported for id column.");
        }
        class Yz {
          constructor(t, s) {
            var n;
            switch (this._featureData = t, this.properties = this._featureData.properties || {}, (n = this._featureData.geometry) === null || n === void 0 ? void 0 : n.type) {
              case Je.POINT:
              case Je.MULTIPOINT:
                this.type = 1;
                break;
              case Je.LINESTRING:
              case Je.MULTILINESTRING:
                this.type = 2;
                break;
              case Je.POLYGON:
              case Je.MULTIPOLYGON:
                this.type = 3;
                break;
              default:
                this.type = 0;
            }
            this.extent = s, this.id = Number(this._featureData.id);
          }
          projectPoint(t, s, n, a) {
            return [360 * (t.x + s) / a - 180, 360 / Math.PI * Math.atan(Math.exp((1 - 2 * (t.y + n) / a) * Math.PI)) - 90];
          }
          projectLine(t, s, n, a) {
            return t.map(((M) => this.projectPoint(M, s, n, a)));
          }
          toGeoJSON(t, s, n) {
            const a = this.extent * Math.pow(2, n), M = this.extent * t, l = this.extent * s, D = this.loadGeometry();
            let N;
            switch (this.type) {
              case 1: {
                const w = [];
                for (const x of D) w.push(x[0]);
                const T = this.projectLine(w, M, l, a);
                N = w.length === 1 ? { type: "Point", coordinates: T[0] } : { type: "MultiPoint", coordinates: T };
                break;
              }
              case 2: {
                const w = D.map(((T) => this.projectLine(T, M, l, a)));
                N = w.length === 1 ? { type: "LineString", coordinates: w[0] } : { type: "MultiLineString", coordinates: w };
                break;
              }
              case 3: {
                const w = Sn(D), T = [];
                for (const x of w) T.push(x.map(((A) => this.projectLine(A, M, l, a))));
                N = T.length === 1 ? { type: "Polygon", coordinates: T[0] } : { type: "MultiPolygon", coordinates: T };
                break;
              }
              default:
                throw new Error(`unknown feature type: ${this.type}`);
            }
            const y = { type: "Feature", geometry: N, properties: this.properties };
            return this.id != null && (y.id = this.id), y;
          }
          loadGeometry() {
            const t = [];
            for (const s of this._featureData.geometry.coordinates) {
              const n = [];
              for (const a of s) n.push(new mt(a.x, a.y));
              t.push(n);
            }
            return t;
          }
          bbox() {
            return [0, 0, 0, 0];
          }
        }
        class Uz {
          constructor(t) {
            this.features = [], this.featureTable = t, this.name = t.name, this.extent = t.extent, this.version = 2, this.features = t.getFeatures(), this.length = this.features.length;
          }
          feature(t) {
            return new Yz(this.features[t], this.extent);
          }
        }
        class wh {
          constructor(t) {
            this.layers = {};
            const s = (function(n, a, M = !0) {
              const l = new Az(0), D = [];
              for (; l.get() < n.length; ) {
                const N = Ze(n, l, 1)[0] >>> 0, y = l.get() + N;
                if (y > n.length) throw new Error(`Block overruns tile: ${y} > ${n.length}`);
                if (Ze(n, l, 1)[0] >>> 0 != 1) {
                  l.set(y);
                  continue;
                }
                const w = kz(n, l), T = w[1], x = w[0].featureTables[0];
                let A = null, m = null;
                const L = [];
                let O = 0;
                for (const P of x.columns) {
                  const k = P.name;
                  if (k === "id") {
                    let U = null;
                    if (P.nullable) {
                      const et = ds.decode(n, l), ot = l.get(), dt = SM(n, et.numValues, l);
                      l.set(ot + et.byteLength), U = new Ci(dt, et.numValues);
                    }
                    const K = ds.decode(n, l);
                    O = K.getDecompressedCount(), A = Fz(n, P, l, k, K, U ?? O, M);
                  } else if (k === "geometry") {
                    const U = Ze(n, l, 1)[0];
                    if (O === 0) {
                      const K = l.get();
                      O = ds.decode(n, l).getDecompressedCount(), l.set(K);
                    }
                    m = Cz(n, U, l, O, a);
                  } else {
                    const U = hl.hasStreamCount(P) ? Ze(n, l, 1)[0] : 1;
                    if (U === 0 && P.type === "scalarType") continue;
                    const K = vz(n, l, P, U, O, void 0);
                    K && (Array.isArray(K) ? L.push(...K) : L.push(K));
                  }
                }
                const B = new xz(x.name, m, A, L, T);
                D.push(B), l.set(y);
              }
              return D;
            })(new Uint8Array(t));
            this.layers = s.reduce(((n, a) => Object.assign(Object.assign({}, n), { [a.name]: new Uz(a) })), {});
          }
        }
        class ga {
          constructor() {
            this.minX = 1 / 0, this.maxX = -1 / 0, this.minY = 1 / 0, this.maxY = -1 / 0;
          }
          extend(t) {
            return this.minX = Math.min(this.minX, t.x), this.minY = Math.min(this.minY, t.y), this.maxX = Math.max(this.maxX, t.x), this.maxY = Math.max(this.maxY, t.y), this;
          }
          expandBy(t) {
            return this.minX -= t, this.minY -= t, this.maxX += t, this.maxY += t, (this.minX > this.maxX || this.minY > this.maxY) && (this.minX = 1 / 0, this.maxX = -1 / 0, this.minY = 1 / 0, this.maxY = -1 / 0), this;
          }
          shrinkBy(t) {
            return this.expandBy(-t);
          }
          map(t) {
            const s = new ga();
            return s.extend(t(new mt(this.minX, this.minY))), s.extend(t(new mt(this.maxX, this.minY))), s.extend(t(new mt(this.minX, this.maxY))), s.extend(t(new mt(this.maxX, this.maxY))), s;
          }
          static fromPoints(t) {
            const s = new ga();
            for (const n of t) s.extend(n);
            return s;
          }
          contains(t) {
            return t.x >= this.minX && t.x <= this.maxX && t.y >= this.minY && t.y <= this.maxY;
          }
          empty() {
            return this.minX > this.maxX;
          }
          width() {
            return this.maxX - this.minX;
          }
          height() {
            return this.maxY - this.minY;
          }
          covers(t) {
            return !this.empty() && !t.empty() && t.minX >= this.minX && t.maxX <= this.maxX && t.minY >= this.minY && t.maxY <= this.maxY;
          }
          intersects(t) {
            return !this.empty() && !t.empty() && t.minX <= this.maxX && t.maxX >= this.minX && t.minY <= this.maxY && t.maxY >= this.minY;
          }
        }
        const bu = "_geojsonTileLayer";
        class ph {
          constructor(t, s) {
            this.tileID = t, this.x = t.canonical.x, this.y = t.canonical.y, this.z = t.canonical.z, this.grid = new Hn(se, 16, 0), this.grid3D = new Hn(se, 16, 0), this.featureIndexArray = new Y(), this.promoteId = s;
          }
          insert(t, s, n, a, M, l) {
            const D = this.featureIndexArray.length;
            this.featureIndexArray.emplaceBack(n, a, M);
            const N = l ? this.grid3D : this.grid;
            for (let y = 0; y < s.length; y++) {
              const w = s[y], T = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
              for (let x = 0; x < w.length; x++) {
                const A = w[x];
                T[0] = Math.min(T[0], A.x), T[1] = Math.min(T[1], A.y), T[2] = Math.max(T[2], A.x), T[3] = Math.max(T[3], A.y);
              }
              T[0] < se && T[1] < se && T[2] >= 0 && T[3] >= 0 && N.insert(D, T[0], T[1], T[2], T[3]);
            }
          }
          loadVTLayers() {
            return this.vtLayers || (this.vtLayers = this.encoding !== "mlt" ? new Ng(new uu(this.rawTileData)).layers : new wh(this.rawTileData).layers, this.sourceLayerCoder = new Kg(this.vtLayers ? Object.keys(this.vtLayers).sort() : [bu])), this.vtLayers;
          }
          query(t, s, n, a) {
            this.loadVTLayers();
            const M = t.params, l = se / t.tileSize / t.scale, D = Xn(M.filter, M.globalState), N = t.queryGeometry, y = t.queryPadding * l, w = ga.fromPoints(N), T = this.grid.query(w.minX - y, w.minY - y, w.maxX + y, w.maxY + y), x = ga.fromPoints(t.cameraQueryGeometry).expandBy(y), A = this.grid3D.query(x.minX, x.minY, x.maxX, x.maxY, ((O, B, P, k) => (function(U, K, et, ot, dt) {
              for (const yt of U) if (K <= yt.x && et <= yt.y && ot >= yt.x && dt >= yt.y) return !0;
              const Dt = [new mt(K, et), new mt(K, dt), new mt(ot, dt), new mt(ot, et)];
              if (U.length > 2) {
                for (const yt of Dt) if (io(U, yt)) return !0;
              }
              for (let yt = 0; yt < U.length - 1; yt++) if ($h(U[yt], U[yt + 1], Dt)) return !0;
              return !1;
            })(t.cameraQueryGeometry, O - y, B - y, P + y, k + y)));
            for (const O of A) T.push(O);
            T.sort(Xz);
            const m = {};
            let L;
            for (let O = 0; O < T.length; O++) {
              const B = T[O];
              if (B === L) continue;
              L = B;
              const P = this.featureIndexArray.get(B);
              let k = null;
              this.loadMatchingFeature(m, P.bucketIndex, P.sourceLayerIndex, P.featureIndex, D, M.layers, M.availableImages, s, n, a, ((U, K, et) => (k || (k = sr(U)), K.queryIntersectsFeature({ queryGeometry: N, feature: U, featureState: et, geometry: k, zoom: this.z, transform: t.transform, pixelsToTileUnits: l, pixelPosMatrix: t.pixelPosMatrix, unwrappedTileID: this.tileID.toUnwrapped(), getElevation: t.getElevation }))));
            }
            return m;
          }
          loadMatchingFeature(t, s, n, a, M, l, D, N, y, w, T) {
            const x = this.bucketLayerIDs[s];
            if (l && !x.some(((O) => l.has(O)))) return;
            const A = this.sourceLayerCoder.decode(n), m = this.vtLayers[A].feature(a);
            if (M.needGeometry) {
              const O = _i(m, !0);
              if (!M.filter(new ie(this.tileID.overscaledZ), O, this.tileID.canonical)) return;
            } else if (!M.filter(new ie(this.tileID.overscaledZ), m)) return;
            const L = this.getId(m, A);
            for (let O = 0; O < x.length; O++) {
              const B = x[O];
              if (l && !l.has(B)) continue;
              const P = N[B];
              if (!P) continue;
              let k = {};
              L && w && (k = w.getState(P.sourceLayer || bu, L));
              const U = rs({}, y[B]);
              U.paint = Th(U.paint, P.paint, m, k, D), U.layout = Th(U.layout, P.layout, m, k, D);
              const K = !T || T(m, P, k);
              if (!K) continue;
              const et = new th(m, this.z, this.x, this.y, L);
              et.layer = U;
              let ot = t[B];
              ot === void 0 && (ot = t[B] = []), ot.push({ featureIndex: a, feature: et, intersectionZ: K });
            }
          }
          lookupSymbolFeatures(t, s, n, a, M, l, D, N) {
            const y = {};
            this.loadVTLayers();
            const w = Xn(M.filterSpec, M.globalState);
            for (const T of t) this.loadMatchingFeature(y, n, a, T, w, l, D, N, s);
            return y;
          }
          hasLayer(t) {
            for (const s of this.bucketLayerIDs) for (const n of s) if (t === n) return !0;
            return !1;
          }
          getId(t, s) {
            var n;
            let a = t.id;
            return this.promoteId && (a = t.properties[typeof this.promoteId == "string" ? this.promoteId : this.promoteId[s]], typeof a == "boolean" && (a = Number(a)), a === void 0 && (!((n = t.properties) === null || n === void 0) && n.cluster) && this.promoteId && (a = Number(t.properties.cluster_id))), a;
          }
        }
        function Th(i, t, s, n, a) {
          return Yi(i, ((M, l) => {
            const D = t instanceof xr ? t.get(l) : null;
            return D && D.evaluate ? D.evaluate(s, n, a) : D;
          }));
        }
        function Xz(i, t) {
          return t - i;
        }
        function fh(i, t, s, n, a) {
          const M = [];
          for (let l = 0; l < i.length; l++) {
            const D = i[l];
            let N;
            for (let y = 0; y < D.length - 1; y++) {
              let w = D[y], T = D[y + 1];
              w.x < t && T.x < t || (w.x < t ? w = new mt(t, w.y + (t - w.x) / (T.x - w.x) * (T.y - w.y))._round() : T.x < t && (T = new mt(t, w.y + (t - w.x) / (T.x - w.x) * (T.y - w.y))._round()), w.y < s && T.y < s || (w.y < s ? w = new mt(w.x + (s - w.y) / (T.y - w.y) * (T.x - w.x), s)._round() : T.y < s && (T = new mt(w.x + (s - w.y) / (T.y - w.y) * (T.x - w.x), s)._round()), w.x >= n && T.x >= n || (w.x >= n ? w = new mt(n, w.y + (n - w.x) / (T.x - w.x) * (T.y - w.y))._round() : T.x >= n && (T = new mt(n, w.y + (n - w.x) / (T.x - w.x) * (T.y - w.y))._round()), w.y >= a && T.y >= a || (w.y >= a ? w = new mt(w.x + (a - w.y) / (T.y - w.y) * (T.x - w.x), a)._round() : T.y >= a && (T = new mt(w.x + (a - w.y) / (T.y - w.y) * (T.x - w.x), a)._round()), N && w.equals(N[N.length - 1]) || (N = [w], M.push(N)), N.push(T)))));
            }
          }
          return M;
        }
        function xh(i, t, s, n, a) {
          switch (t) {
            case 1:
              return (function(M, l, D, N) {
                const y = [];
                for (const w of M) for (const T of w) {
                  const x = N === 0 ? T.x : T.y;
                  x >= l && x <= D && y.push([T]);
                }
                return y;
              })(i, s, n, a);
            case 2:
              return Ah(i, s, n, a, !1);
            case 3:
              return Ah(i, s, n, a, !0);
          }
          return [];
        }
        function Wz(i, t, s, n, a) {
          const M = n === 0 ? Pz : Rz;
          let l = [];
          const D = [];
          for (let w = 0; w < i.length - 1; w++) {
            const T = i[w], x = i[w + 1], A = n === 0 ? T.x : T.y, m = n === 0 ? x.x : x.y;
            let L = !1;
            A < t ? m > t && l.push(M(T, x, t)) : A > s ? m < s && l.push(M(T, x, s)) : l.push(T), m < t && A >= t && (l.push(M(T, x, t)), L = !0), m > s && A <= s && (l.push(M(T, x, s)), L = !0), !a && L && (D.push(l), l = []);
          }
          const N = i.length - 1, y = n === 0 ? i[N].x : i[N].y;
          return y >= t && y <= s && l.push(i[N]), a && l.length > 0 && !l[0].equals(l[l.length - 1]) && l.push(new mt(l[0].x, l[0].y)), l.length > 0 && D.push(l), D;
        }
        function Ah(i, t, s, n, a) {
          const M = [];
          for (const l of i) {
            const D = Wz(l, t, s, n, a);
            D.length > 0 && M.push(...D);
          }
          return M;
        }
        function Pz(i, t, s) {
          return new mt(s, i.y + (s - i.x) / (t.x - i.x) * (t.y - i.y));
        }
        function Rz(i, t, s) {
          return new mt(i.x + (s - i.y) / (t.y - i.y) * (t.x - i.x), s);
        }
        jt("FeatureIndex", ph, { omit: ["rawTileData", "sourceLayerCoder"] });
        class dn extends mt {
          constructor(t, s, n, a) {
            super(t, s), this.angle = n, a !== void 0 && (this.segment = a);
          }
          clone() {
            return new dn(this.x, this.y, this.angle, this.segment);
          }
        }
        function mh(i, t, s, n, a) {
          if (t.segment === void 0 || s === 0) return !0;
          let M = t, l = t.segment + 1, D = 0;
          for (; D > -s / 2; ) {
            if (l--, l < 0) return !1;
            D -= i[l].dist(M), M = i[l];
          }
          D += i[l].dist(i[l + 1]), l++;
          const N = [];
          let y = 0;
          for (; D < s / 2; ) {
            const w = i[l], T = i[l + 1];
            if (!T) return !1;
            let x = i[l - 1].angleTo(w) - w.angleTo(T);
            for (x = Math.abs((x + 3 * Math.PI) % (2 * Math.PI) - Math.PI), N.push({ distance: D, angleDelta: x }), y += x; D - N[0].distance > n; ) y -= N.shift().angleDelta;
            if (y > a) return !1;
            l++, D += w.dist(T);
          }
          return !0;
        }
        function jh(i) {
          let t = 0;
          for (let s = 0; s < i.length - 1; s++) t += i[s].dist(i[s + 1]);
          return t;
        }
        function _h(i, t, s) {
          return i ? 0.6 * t * s : 0;
        }
        function Lh(i, t) {
          return Math.max(i ? i.right - i.left : 0, t ? t.right - t.left : 0);
        }
        function Zz(i, t, s, n, a, M) {
          const l = _h(s, a, M), D = Lh(s, n) * M;
          let N = 0;
          const y = jh(i) / 2;
          for (let w = 0; w < i.length - 1; w++) {
            const T = i[w], x = i[w + 1], A = T.dist(x);
            if (N + A > y) {
              const m = (y - N) / A, L = $s.number(T.x, x.x, m), O = $s.number(T.y, x.y, m), B = new dn(L, O, x.angleTo(T), w);
              return B._round(), !l || mh(i, B, D, l, t) ? B : void 0;
            }
            N += A;
          }
        }
        function Vz(i, t, s, n, a, M, l, D, N) {
          const y = _h(n, M, l), w = Lh(n, a), T = w * l, x = i[0].x === 0 || i[0].x === N || i[0].y === 0 || i[0].y === N;
          return t - T < t / 4 && (t = T + t / 4), Ch(i, x ? t / 2 * D % t : (w / 2 + 2 * M) * l * D % t, t, y, s, T, x, !1, N);
        }
        function Ch(i, t, s, n, a, M, l, D, N) {
          const y = M / 2, w = jh(i);
          let T = 0, x = t - s, A = [];
          for (let m = 0; m < i.length - 1; m++) {
            const L = i[m], O = i[m + 1], B = L.dist(O), P = O.angleTo(L);
            for (; x + s < T + B; ) {
              x += s;
              const k = (x - T) / B, U = $s.number(L.x, O.x, k), K = $s.number(L.y, O.y, k);
              if (U >= 0 && U < N && K >= 0 && K < N && x - y >= 0 && x + y <= w) {
                const et = new dn(U, K, P, m);
                et._round(), n && !mh(i, et, M, n, a) || A.push(et);
              }
            }
            T += B;
          }
          return D || A.length || l || (A = Ch(i, T / 2, s, n, a, M, l, !0, N)), A;
        }
        function Oh(i, t, s, n) {
          const a = [], M = i.image, l = M.pixelRatio, D = M.paddedRect.w - 2, N = M.paddedRect.h - 2;
          let y = { x1: i.left, y1: i.top, x2: i.right, y2: i.bottom };
          const w = M.stretchX || [[0, D]], T = M.stretchY || [[0, N]], x = (zt, bt) => zt + bt[1] - bt[0], A = w.reduce(x, 0), m = T.reduce(x, 0), L = D - A, O = N - m;
          let B = 0, P = A, k = 0, U = m, K = 0, et = L, ot = 0, dt = O;
          if (M.content && n) {
            const zt = M.content, bt = zt[2] - zt[0], Qt = zt[3] - zt[1];
            (M.textFitWidth || M.textFitHeight) && (y = Bg(i)), B = Dl(w, 0, zt[0]), k = Dl(T, 0, zt[1]), P = Dl(w, zt[0], zt[2]), U = Dl(T, zt[1], zt[3]), K = zt[0] - B, ot = zt[1] - k, et = bt - P, dt = Qt - U;
          }
          const Dt = y.x1, yt = y.y1, At = y.x2 - Dt, Tt = y.y2 - yt, ft = (zt, bt, Qt, St) => {
            const Lt = zl(zt.stretch - B, P, At, Dt), Rt = Nl(zt.fixed - K, et, zt.stretch, A), ye = zl(bt.stretch - k, U, Tt, yt), We = Nl(bt.fixed - ot, dt, bt.stretch, m), us = zl(Qt.stretch - B, P, At, Dt), di = Nl(Qt.fixed - K, et, Qt.stretch, A), Ls = zl(St.stretch - k, U, Tt, yt), ss = Nl(St.fixed - ot, dt, St.stretch, m), gs = new mt(Lt, ye), Qe = new mt(us, ye), is = new mt(us, Ls), ys = new mt(Lt, Ls), Is = new mt(Rt / l, We / l), vs = new mt(di / l, ss / l), hs = t * Math.PI / 180;
            if (hs) {
              const qe = Math.sin(hs), me = Math.cos(hs), Pe = [me, -qe, qe, me];
              gs._matMult(Pe), Qe._matMult(Pe), ys._matMult(Pe), is._matMult(Pe);
            }
            const Bs = zt.stretch + zt.fixed, yi = bt.stretch + bt.fixed;
            return { tl: gs, tr: Qe, bl: ys, br: is, tex: { x: M.paddedRect.x + 1 + Bs, y: M.paddedRect.y + 1 + yi, w: Qt.stretch + Qt.fixed - Bs, h: St.stretch + St.fixed - yi }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: Is, pixelOffsetBR: vs, minFontScaleX: et / l / At, minFontScaleY: dt / l / Tt, isSDF: s };
          };
          if (n && (M.stretchX || M.stretchY)) {
            const zt = Eh(w, L, A), bt = Eh(T, O, m);
            for (let Qt = 0; Qt < zt.length - 1; Qt++) {
              const St = zt[Qt], Lt = zt[Qt + 1];
              for (let Rt = 0; Rt < bt.length - 1; Rt++) a.push(ft(St, bt[Rt], Lt, bt[Rt + 1]));
            }
          } else a.push(ft({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: D + 1 }, { fixed: 0, stretch: N + 1 }));
          return a;
        }
        function Dl(i, t, s) {
          let n = 0;
          for (const a of i) n += Math.max(t, Math.min(s, a[1])) - Math.max(t, Math.min(s, a[0]));
          return n;
        }
        function Eh(i, t, s) {
          const n = [{ fixed: -1, stretch: 0 }];
          for (const [a, M] of i) {
            const l = n[n.length - 1];
            n.push({ fixed: a - l.stretch, stretch: l.stretch }), n.push({ fixed: a - l.stretch, stretch: l.stretch + (M - a) });
          }
          return n.push({ fixed: t + 1, stretch: s }), n;
        }
        function zl(i, t, s, n) {
          return i / t * s + n;
        }
        function Nl(i, t, s, n) {
          return i - t * s / n;
        }
        jt("Anchor", dn);
        class dl {
          constructor(t, s, n, a, M, l, D, N, y, w) {
            var T;
            if (this.boxStartIndex = t.length, y) {
              let x = l.top, A = l.bottom;
              const m = l.collisionPadding;
              m && (x -= m[1], A += m[3]);
              let L = A - x;
              L > 0 && (L = Math.max(10, L), this.circleDiameter = L);
            } else {
              const x = !((T = l.image) === null || T === void 0) && T.content && (l.image.textFitWidth || l.image.textFitHeight) ? Bg(l) : { x1: l.left, y1: l.top, x2: l.right, y2: l.bottom };
              x.y1 = x.y1 * D - N[0], x.y2 = x.y2 * D + N[2], x.x1 = x.x1 * D - N[3], x.x2 = x.x2 * D + N[1];
              const A = l.collisionPadding;
              if (A && (x.x1 -= A[0] * D, x.y1 -= A[1] * D, x.x2 += A[2] * D, x.y2 += A[3] * D), w) {
                const m = new mt(x.x1, x.y1), L = new mt(x.x2, x.y1), O = new mt(x.x1, x.y2), B = new mt(x.x2, x.y2), P = w * Math.PI / 180;
                m._rotate(P), L._rotate(P), O._rotate(P), B._rotate(P), x.x1 = Math.min(m.x, L.x, O.x, B.x), x.x2 = Math.max(m.x, L.x, O.x, B.x), x.y1 = Math.min(m.y, L.y, O.y, B.y), x.y2 = Math.max(m.y, L.y, O.y, B.y);
              }
              t.emplaceBack(s.x, s.y, x.x1, x.y1, x.x2, x.y2, n, a, M);
            }
            this.boxEndIndex = t.length;
          }
        }
        class Gz {
          constructor(t = [], s = (n, a) => n < a ? -1 : n > a ? 1 : 0) {
            if (this.data = t, this.length = this.data.length, this.compare = s, this.length > 0) for (let n = (this.length >> 1) - 1; n >= 0; n--) this._down(n);
          }
          push(t) {
            this.data.push(t), this._up(this.length++);
          }
          pop() {
            if (this.length === 0) return;
            const t = this.data[0], s = this.data.pop();
            return --this.length > 0 && (this.data[0] = s, this._down(0)), t;
          }
          peek() {
            return this.data[0];
          }
          _up(t) {
            const { data: s, compare: n } = this, a = s[t];
            for (; t > 0; ) {
              const M = t - 1 >> 1, l = s[M];
              if (n(a, l) >= 0) break;
              s[t] = l, t = M;
            }
            s[t] = a;
          }
          _down(t) {
            const { data: s, compare: n } = this, a = this.length >> 1, M = s[t];
            for (; t < a; ) {
              let l = 1 + (t << 1);
              const D = l + 1;
              if (D < this.length && n(s[D], s[l]) < 0 && (l = D), n(s[l], M) >= 0) break;
              s[t] = s[l], t = l;
            }
            s[t] = M;
          }
        }
        function Hz(i, t = 1, s = !1) {
          const n = ga.fromPoints(i[0]), a = Math.min(n.width(), n.height());
          let M = a / 2;
          const l = new Gz([], Jz), { minX: D, minY: N, maxX: y, maxY: w } = n;
          if (a === 0) return new mt(D, N);
          for (let A = D; A < y; A += a) for (let m = N; m < w; m += a) l.push(new Io(A + M, m + M, M, i));
          let T = (function(A) {
            let m = 0, L = 0, O = 0;
            const B = A[0];
            for (let P = 0, k = B.length, U = k - 1; P < k; U = P++) {
              const K = B[P], et = B[U], ot = K.x * et.y - et.x * K.y;
              L += (K.x + et.x) * ot, O += (K.y + et.y) * ot, m += 3 * ot;
            }
            return new Io(L / m, O / m, 0, A);
          })(i), x = l.length;
          for (; l.length; ) {
            const A = l.pop();
            (A.d > T.d || !T.d) && (T = A, s && console.log("found best %d after %d probes", Math.round(1e4 * A.d) / 1e4, x)), A.max - T.d <= t || (M = A.h / 2, l.push(new Io(A.p.x - M, A.p.y - M, M, i)), l.push(new Io(A.p.x + M, A.p.y - M, M, i)), l.push(new Io(A.p.x - M, A.p.y + M, M, i)), l.push(new Io(A.p.x + M, A.p.y + M, M, i)), x += 4);
          }
          return s && (console.log(`num probes: ${x}`), console.log(`best distance: ${T.d}`)), T.p;
        }
        function Jz(i, t) {
          return t.max - i.max;
        }
        function Io(i, t, s, n) {
          this.p = new mt(i, t), this.h = s, this.d = (function(a, M) {
            let l = !1, D = 1 / 0;
            for (let N = 0; N < M.length; N++) {
              const y = M[N];
              for (let w = 0, T = y.length, x = T - 1; w < T; x = w++) {
                const A = y[w], m = y[x];
                A.y > a.y != m.y > a.y && a.x < (m.x - A.x) * (a.y - A.y) / (m.y - A.y) + A.x && (l = !l), D = Math.min(D, Vu(a, A, m));
              }
            }
            return (l ? 1 : -1) * Math.sqrt(D);
          })(this.p, n), this.max = this.d + this.h * Math.SQRT2;
        }
        var ls;
        b.aO = void 0, (ls = b.aO || (b.aO = {}))[ls.center = 1] = "center", ls[ls.left = 2] = "left", ls[ls.right = 3] = "right", ls[ls.top = 4] = "top", ls[ls.bottom = 5] = "bottom", ls[ls["top-left"] = 6] = "top-left", ls[ls["top-right"] = 7] = "top-right", ls[ls["bottom-left"] = 8] = "bottom-left", ls[ls["bottom-right"] = 9] = "bottom-right";
        const Qu = Number.POSITIVE_INFINITY;
        function bh(i, t) {
          return t[1] !== Qu ? (function(s, n, a) {
            let M = 0, l = 0;
            switch (n = Math.abs(n), a = Math.abs(a), s) {
              case "top-right":
              case "top-left":
              case "top":
                l = a - 7;
                break;
              case "bottom-right":
              case "bottom-left":
              case "bottom":
                l = 7 - a;
            }
            switch (s) {
              case "top-right":
              case "bottom-right":
              case "right":
                M = -n;
                break;
              case "top-left":
              case "bottom-left":
              case "left":
                M = n;
            }
            return [M, l];
          })(i, t[0], t[1]) : (function(s, n) {
            let a = 0, M = 0;
            n < 0 && (n = 0);
            const l = n / Math.SQRT2;
            switch (s) {
              case "top-right":
              case "top-left":
                M = l - 7;
                break;
              case "bottom-right":
              case "bottom-left":
                M = 7 - l;
                break;
              case "bottom":
                M = 7 - n;
                break;
              case "top":
                M = n - 7;
            }
            switch (s) {
              case "top-right":
              case "bottom-right":
                a = -l;
                break;
              case "top-left":
              case "bottom-left":
                a = l;
                break;
              case "left":
                a = n;
                break;
              case "right":
                a = -n;
            }
            return [a, M];
          })(i, t[0]);
        }
        function Qh(i, t, s) {
          var n;
          const a = i.layout, M = (n = a.get("text-variable-anchor-offset")) === null || n === void 0 ? void 0 : n.evaluate(t, {}, s);
          if (M) {
            const D = M.values, N = [];
            for (let y = 0; y < D.length; y += 2) {
              const w = N[y] = D[y], T = D[y + 1].map(((x) => x * Ge));
              w.startsWith("top") ? T[1] -= 7 : w.startsWith("bottom") && (T[1] += 7), N[y + 1] = T;
            }
            return new zs(N);
          }
          const l = a.get("text-variable-anchor");
          if (l) {
            let D;
            D = i._unevaluatedLayout.getValue("text-radial-offset") !== void 0 ? [a.get("text-radial-offset").evaluate(t, {}, s) * Ge, Qu] : a.get("text-offset").evaluate(t, {}, s).map(((y) => y * Ge));
            const N = [];
            for (const y of l) N.push(y, bh(y, D));
            return new zs(N);
          }
          return null;
        }
        function vu(i) {
          switch (i) {
            case "right":
            case "top-right":
            case "bottom-right":
              return "right";
            case "left":
            case "top-left":
            case "bottom-left":
              return "left";
          }
          return "center";
        }
        function qz(i, t, s, n, a, M, l, D, N, y, w, T) {
          let x = M.textMaxSize.evaluate(t, {});
          x === void 0 && (x = l);
          const A = i.layers[0].layout, m = A.get("icon-offset").evaluate(t, {}, w), L = Bh(s.horizontal), O = l / 24, B = i.tilePixelRatio * O, P = i.tilePixelRatio * x / 24, k = i.tilePixelRatio * D, U = i.tilePixelRatio * A.get("symbol-spacing"), K = A.get("text-padding") * i.tilePixelRatio, et = (function(Qt, St, Lt, Rt = 1) {
            const ye = Qt.get("icon-padding").evaluate(St, {}, Lt), We = ye && ye.values;
            return [We[0] * Rt, We[1] * Rt, We[2] * Rt, We[3] * Rt];
          })(A, t, w, i.tilePixelRatio), ot = A.get("text-max-angle") / 180 * Math.PI, dt = A.get("text-rotation-alignment") !== "viewport" && A.get("symbol-placement") !== "point", Dt = A.get("icon-rotation-alignment") === "map" && A.get("symbol-placement") !== "point", yt = A.get("symbol-placement"), At = U / 2, Tt = A.get("icon-text-fit");
          let ft;
          n && Tt !== "none" && (i.allowVerticalPlacement && s.vertical && (ft = Sg(n, s.vertical, Tt, A.get("icon-text-fit-padding"), m, O)), L && (n = Sg(n, L, Tt, A.get("icon-text-fit-padding"), m, O)));
          const zt = w ? T.line.getGranularityForZoomLevel(w.z) : 1, bt = (Qt, St) => {
            St.x < 0 || St.x >= se || St.y < 0 || St.y >= se || (function(Lt, Rt, ye, We, us, di, Ls, ss, gs, Qe, is, ys, Is, vs, hs, Bs, yi, qe, me, Pe, Oe, $e, br, Oi, XM) {
              const yn = Lt.addToLineVertexArray(Rt, ye);
              let ha, wo, po, To, Yh = 0, Uh = 0, Xh = 0, Wh = 0, Wu = -1, Pu = -1;
              const Qr = {};
              let Ph = Ai("");
              if (Lt.allowVerticalPlacement && We.vertical) {
                const ws = ss.layout.get("text-rotate").evaluate(Oe, {}, Oi) + 90;
                po = new dl(gs, Rt, Qe, is, ys, We.vertical, Is, vs, hs, ws), Ls && (To = new dl(gs, Rt, Qe, is, ys, Ls, yi, qe, hs, ws));
              }
              if (us) {
                const ws = ss.layout.get("icon-rotate").evaluate(Oe, {}), ri = ss.layout.get("icon-text-fit") !== "none", Da = Oh(us, ws, br, ri), bi = Ls ? Oh(Ls, ws, br, ri) : void 0;
                wo = new dl(gs, Rt, Qe, is, ys, us, yi, qe, !1, ws), Yh = 4 * Da.length;
                const za = Lt.iconSizeData;
                let ir = null;
                za.kind === "source" ? (ir = [Or * ss.layout.get("icon-size").evaluate(Oe, {})], ir[0] > Dn && we(`${Lt.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)) : za.kind === "composite" && (ir = [Or * $e.compositeIconSizes[0].evaluate(Oe, {}, Oi), Or * $e.compositeIconSizes[1].evaluate(Oe, {}, Oi)], (ir[0] > Dn || ir[1] > Dn) && we(`${Lt.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)), Lt.addSymbols(Lt.icon, Da, ir, Pe, me, Oe, b.ay.none, Rt, yn.lineStartIndex, yn.lineLength, -1, Oi), Wu = Lt.icon.placedSymbolArray.length - 1, bi && (Uh = 4 * bi.length, Lt.addSymbols(Lt.icon, bi, ir, Pe, me, Oe, b.ay.vertical, Rt, yn.lineStartIndex, yn.lineLength, -1, Oi), Pu = Lt.icon.placedSymbolArray.length - 1);
              }
              const Rh = Object.keys(We.horizontal);
              for (const ws of Rh) {
                const ri = We.horizontal[ws];
                if (!ha) {
                  Ph = Ai(ri.text);
                  const bi = ss.layout.get("text-rotate").evaluate(Oe, {}, Oi);
                  ha = new dl(gs, Rt, Qe, is, ys, ri, Is, vs, hs, bi);
                }
                const Da = ri.positionedLines.length === 1;
                if (Xh += vh(Lt, Rt, ri, di, ss, hs, Oe, Bs, yn, We.vertical ? b.ay.horizontal : b.ay.horizontalOnly, Da ? Rh : [ws], Qr, Wu, $e, Oi), Da) break;
              }
              We.vertical && (Wh += vh(Lt, Rt, We.vertical, di, ss, hs, Oe, Bs, yn, b.ay.vertical, ["vertical"], Qr, Pu, $e, Oi));
              const tN = ha ? ha.boxStartIndex : Lt.collisionBoxArray.length, eN = ha ? ha.boxEndIndex : Lt.collisionBoxArray.length, sN = po ? po.boxStartIndex : Lt.collisionBoxArray.length, iN = po ? po.boxEndIndex : Lt.collisionBoxArray.length, rN = wo ? wo.boxStartIndex : Lt.collisionBoxArray.length, nN = wo ? wo.boxEndIndex : Lt.collisionBoxArray.length, aN = To ? To.boxStartIndex : Lt.collisionBoxArray.length, oN = To ? To.boxEndIndex : Lt.collisionBoxArray.length;
              let Ei = -1;
              const Il = (ws, ri) => ws && ws.circleDiameter ? Math.max(ws.circleDiameter, ri) : ri;
              Ei = Il(ha, Ei), Ei = Il(po, Ei), Ei = Il(wo, Ei), Ei = Il(To, Ei);
              const Zh = Ei > -1 ? 1 : 0;
              Zh && (Ei *= XM / Ge), Lt.glyphOffsetArray.length >= uo.MAX_GLYPHS && we("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), Oe.sortKey !== void 0 && Lt.addToSortKeyRanges(Lt.symbolInstances.length, Oe.sortKey);
              const MN = Qh(ss, Oe, Oi), [cN, lN] = (function(ws, ri) {
                const Da = ws.length, bi = ri?.values;
                if (bi?.length > 0) for (let za = 0; za < bi.length; za += 2) {
                  const ir = bi[za + 1];
                  ws.emplaceBack(b.aO[bi[za]], ir[0], ir[1]);
                }
                return [Da, ws.length];
              })(Lt.textAnchorOffsets, MN);
              Lt.symbolInstances.emplaceBack(Rt.x, Rt.y, Qr.right >= 0 ? Qr.right : -1, Qr.center >= 0 ? Qr.center : -1, Qr.left >= 0 ? Qr.left : -1, Qr.vertical || -1, Wu, Pu, Ph, tN, eN, sN, iN, rN, nN, aN, oN, Qe, Xh, Wh, Yh, Uh, Zh, 0, Is, Ei, cN, lN);
            })(i, St, Qt, s, n, a, ft, i.layers[0], i.collisionBoxArray, t.index, t.sourceLayerIndex, i.index, B, [K, K, K, K], dt, N, k, et, Dt, m, t, M, y, w, l);
          };
          if (yt === "line") for (const Qt of fh(t.geometry, 0, 0, se, se)) {
            const St = Ma(Qt, zt), Lt = Vz(St, U, ot, s.vertical || L, n, 24, P, i.overscaling, se);
            for (const Rt of Lt) L && $z(i, L.text, At, Rt) || bt(St, Rt);
          }
          else if (yt === "line-center") {
            for (const Qt of t.geometry) if (Qt.length > 1) {
              const St = Ma(Qt, zt), Lt = Zz(St, ot, s.vertical || L, n, 24, P);
              Lt && bt(St, Lt);
            }
          } else if (t.type === "Polygon") for (const Qt of Sn(t.geometry, 0)) {
            const St = Hz(Qt, 16);
            bt(Ma(Qt[0], zt, !0), new dn(St.x, St.y, 0));
          }
          else if (t.type === "LineString") for (const Qt of t.geometry) {
            const St = Ma(Qt, zt);
            bt(St, new dn(St[0].x, St[0].y, 0));
          }
          else if (t.type === "Point") for (const Qt of t.geometry) for (const St of Qt) bt([St], new dn(St.x, St.y, 0));
        }
        function vh(i, t, s, n, a, M, l, D, N, y, w, T, x, A, m) {
          const L = (function(P, k, U, K, et, ot, dt, Dt) {
            const yt = K.layout.get("text-rotate").evaluate(ot, {}) * Math.PI / 180, At = [];
            for (const Tt of k.positionedLines) for (const ft of Tt.positionedGlyphs) {
              if (!ft.rect) continue;
              const zt = ft.rect || {};
              let bt = 4, Qt = !0, St = 1, Lt = 0;
              const Rt = (et || Dt) && ft.vertical, ye = ft.metrics.advance * ft.scale / 2;
              if (Dt && k.verticalizable && (Lt = Tt.lineOffset / 2 - (ft.imageName ? -(Ge - ft.metrics.width * ft.scale) / 2 : (ft.scale - 1) * Ge)), ft.imageName) {
                const qe = dt[ft.imageName];
                Qt = qe.sdf, St = qe.pixelRatio, bt = 1 / St;
              }
              const We = et ? [ft.x + ye, ft.y] : [0, 0];
              let us = et ? [0, 0] : [ft.x + ye + U[0], ft.y + U[1] - Lt], di = [0, 0];
              Rt && (di = us, us = [0, 0]);
              const Ls = ft.metrics.isDoubleResolution ? 2 : 1, ss = (ft.metrics.left - bt) * ft.scale - ye + us[0], gs = (-ft.metrics.top - bt) * ft.scale + us[1], Qe = ss + zt.w / Ls * ft.scale / St, is = gs + zt.h / Ls * ft.scale / St, ys = new mt(ss, gs), Is = new mt(Qe, gs), vs = new mt(ss, is), hs = new mt(Qe, is);
              if (Rt) {
                const qe = new mt(-ye, ye - -17), me = -Math.PI / 2, Pe = 12 - ye, Oe = new mt(22 - Pe, -(ft.imageName ? Pe : 0)), $e = new mt(...di);
                ys._rotateAround(me, qe)._add(Oe)._add($e), Is._rotateAround(me, qe)._add(Oe)._add($e), vs._rotateAround(me, qe)._add(Oe)._add($e), hs._rotateAround(me, qe)._add(Oe)._add($e);
              }
              if (yt) {
                const qe = Math.sin(yt), me = Math.cos(yt), Pe = [me, -qe, qe, me];
                ys._matMult(Pe), Is._matMult(Pe), vs._matMult(Pe), hs._matMult(Pe);
              }
              const Bs = new mt(0, 0), yi = new mt(0, 0);
              At.push({ tl: ys, tr: Is, bl: vs, br: hs, tex: zt, writingMode: k.writingMode, glyphOffset: We, sectionIndex: ft.sectionIndex, isSDF: Qt, pixelOffsetTL: Bs, pixelOffsetBR: yi, minFontScaleX: 0, minFontScaleY: 0 });
            }
            return At;
          })(0, s, D, a, M, l, n, i.allowVerticalPlacement), O = i.textSizeData;
          let B = null;
          O.kind === "source" ? (B = [Or * a.layout.get("text-size").evaluate(l, {})], B[0] > Dn && we(`${i.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)) : O.kind === "composite" && (B = [Or * A.compositeTextSizes[0].evaluate(l, {}, m), Or * A.compositeTextSizes[1].evaluate(l, {}, m)], (B[0] > Dn || B[1] > Dn) && we(`${i.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)), i.addSymbols(i.text, L, B, D, M, l, y, t, N.lineStartIndex, N.lineLength, x, m);
          for (const P of w) T[P] = i.text.placedSymbolArray.length - 1;
          return 4 * L.length;
        }
        function Bh(i) {
          for (const t in i) return i[t];
          return null;
        }
        function $z(i, t, s, n) {
          const a = i.compareText;
          if (t in a) {
            const M = a[t];
            for (let l = M.length - 1; l >= 0; l--) if (n.dist(M[l]) < s) return !0;
          } else a[t] = [];
          return a[t].push(n), !1;
        }
        const Sh = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
        class Bu {
          static from(t) {
            if (!(t instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
            const [s, n] = new Uint8Array(t, 0, 2);
            if (s !== 219) throw new Error("Data does not appear to be in a KDBush format.");
            const a = n >> 4;
            if (a !== 1) throw new Error(`Got v${a} data when expected v1.`);
            const M = Sh[15 & n];
            if (!M) throw new Error("Unrecognized array type.");
            const [l] = new Uint16Array(t, 2, 1), [D] = new Uint32Array(t, 4, 1);
            return new Bu(D, l, M, t);
          }
          constructor(t, s = 64, n = Float64Array, a) {
            if (isNaN(t) || t < 0) throw new Error(`Unpexpected numItems value: ${t}.`);
            this.numItems = +t, this.nodeSize = Math.min(Math.max(+s, 2), 65535), this.ArrayType = n, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
            const M = Sh.indexOf(this.ArrayType), l = 2 * t * this.ArrayType.BYTES_PER_ELEMENT, D = t * this.IndexArrayType.BYTES_PER_ELEMENT, N = (8 - D % 8) % 8;
            if (M < 0) throw new Error(`Unexpected typed array class: ${n}.`);
            a && a instanceof ArrayBuffer ? (this.data = a, this.ids = new this.IndexArrayType(this.data, 8, t), this.coords = new this.ArrayType(this.data, 8 + D + N, 2 * t), this._pos = 2 * t, this._finished = !0) : (this.data = new ArrayBuffer(8 + l + D + N), this.ids = new this.IndexArrayType(this.data, 8, t), this.coords = new this.ArrayType(this.data, 8 + D + N, 2 * t), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, 16 + M]), new Uint16Array(this.data, 2, 1)[0] = s, new Uint32Array(this.data, 4, 1)[0] = t);
          }
          add(t, s) {
            const n = this._pos >> 1;
            return this.ids[n] = n, this.coords[this._pos++] = t, this.coords[this._pos++] = s, n;
          }
          finish() {
            const t = this._pos >> 1;
            if (t !== this.numItems) throw new Error(`Added ${t} items when expected ${this.numItems}.`);
            return Su(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
          }
          range(t, s, n, a) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            const { ids: M, coords: l, nodeSize: D } = this, N = [0, M.length - 1, 0], y = [];
            for (; N.length; ) {
              const w = N.pop() || 0, T = N.pop() || 0, x = N.pop() || 0;
              if (T - x <= D) {
                for (let O = x; O <= T; O++) {
                  const B = l[2 * O], P = l[2 * O + 1];
                  B >= t && B <= n && P >= s && P <= a && y.push(M[O]);
                }
                continue;
              }
              const A = x + T >> 1, m = l[2 * A], L = l[2 * A + 1];
              m >= t && m <= n && L >= s && L <= a && y.push(M[A]), (w === 0 ? t <= m : s <= L) && (N.push(x), N.push(A - 1), N.push(1 - w)), (w === 0 ? n >= m : a >= L) && (N.push(A + 1), N.push(T), N.push(1 - w));
            }
            return y;
          }
          within(t, s, n) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            const { ids: a, coords: M, nodeSize: l } = this, D = [0, a.length - 1, 0], N = [], y = n * n;
            for (; D.length; ) {
              const w = D.pop() || 0, T = D.pop() || 0, x = D.pop() || 0;
              if (T - x <= l) {
                for (let O = x; O <= T; O++) Fh(M[2 * O], M[2 * O + 1], t, s) <= y && N.push(a[O]);
                continue;
              }
              const A = x + T >> 1, m = M[2 * A], L = M[2 * A + 1];
              Fh(m, L, t, s) <= y && N.push(a[A]), (w === 0 ? t - n <= m : s - n <= L) && (D.push(x), D.push(A - 1), D.push(1 - w)), (w === 0 ? t + n >= m : s + n >= L) && (D.push(A + 1), D.push(T), D.push(1 - w));
            }
            return N;
          }
        }
        function Su(i, t, s, n, a, M) {
          if (a - n <= s) return;
          const l = n + a >> 1;
          kh(i, t, l, n, a, M), Su(i, t, s, n, l - 1, 1 - M), Su(i, t, s, l + 1, a, 1 - M);
        }
        function kh(i, t, s, n, a, M) {
          for (; a > n; ) {
            if (a - n > 600) {
              const y = a - n + 1, w = s - n + 1, T = Math.log(y), x = 0.5 * Math.exp(2 * T / 3), A = 0.5 * Math.sqrt(T * x * (y - x) / y) * (w - y / 2 < 0 ? -1 : 1);
              kh(i, t, s, Math.max(n, Math.floor(s - w * x / y + A)), Math.min(a, Math.floor(s + (y - w) * x / y + A)), M);
            }
            const l = t[2 * s + M];
            let D = n, N = a;
            for (YM(i, t, n, s), t[2 * a + M] > l && YM(i, t, n, a); D < N; ) {
              for (YM(i, t, D, N), D++, N--; t[2 * D + M] < l; ) D++;
              for (; t[2 * N + M] > l; ) N--;
            }
            t[2 * n + M] === l ? YM(i, t, n, N) : (N++, YM(i, t, N, a)), N <= s && (n = N + 1), s <= N && (a = N - 1);
          }
        }
        function YM(i, t, s, n) {
          ku(i, s, n), ku(t, 2 * s, 2 * n), ku(t, 2 * s + 1, 2 * n + 1);
        }
        function ku(i, t, s) {
          const n = i[t];
          i[t] = i[s], i[s] = n;
        }
        function Fh(i, t, s, n) {
          const a = i - s, M = t - n;
          return a * a + M * M;
        }
        var Fu;
        b.cG = void 0, (Fu = b.cG || (b.cG = {})).create = "create", Fu.load = "load", Fu.fullLoad = "fullLoad";
        let yl = null, UM = [];
        const Yu = 1e3 / 60, Uu = "loadTime", Xu = "fullLoadTime", Kz = { mark(i) {
          performance.mark(i);
        }, frame(i) {
          const t = i;
          yl != null && UM.push(t - yl), yl = t;
        }, clearMetrics() {
          yl = null, UM = [], performance.clearMeasures(Uu), performance.clearMeasures(Xu);
          for (const i in b.cG) performance.clearMarks(b.cG[i]);
        }, getPerformanceMetrics() {
          performance.measure(Uu, b.cG.create, b.cG.load), performance.measure(Xu, b.cG.create, b.cG.fullLoad);
          const i = performance.getEntriesByName(Uu)[0].duration, t = performance.getEntriesByName(Xu)[0].duration, s = UM.length, n = 1 / (UM.reduce(((M, l) => M + l), 0) / s / 1e3), a = UM.filter(((M) => M > Yu)).reduce(((M, l) => M + (l - Yu) / Yu), 0);
          return { loadTime: i, fullLoadTime: t, fps: n, percentDroppedFrames: a / (s + a) * 100, totalFrames: s };
        } };
        b.$ = rr, b.A = Ie, b.B = Ha, b.C = fr, b.D = Et, b.E = rt, b.F = function([i, t, s]) {
          return t += 90, t *= Math.PI / 180, s *= Math.PI / 180, { x: i * Math.cos(t) * Math.sin(s), y: i * Math.sin(t) * Math.sin(s), z: i * Math.cos(s) };
        }, b.G = $s, b.H = ie, b.I = gu, b.J = Ul, b.K = function(i) {
          if (pe == null) {
            const t = i.navigator ? i.navigator.userAgent : null;
            pe = !!i.safari || !(!t || !(/\b(iPad|iPhone|iPod)\b/.test(t) || t.match("Safari") && !t.match("Chrome")));
          }
          return pe;
        }, b.L = class {
          constructor(i, t) {
            this.target = i, this.mapId = t, this.resolveRejects = {}, this.tasks = {}, this.taskQueue = [], this.abortControllers = {}, this.messageHandlers = {}, this.invoker = new pz((() => this.process())), this.subscription = Xi(this.target, "message", ((s) => this.receive(s)), !1), this.globalScope = ai(self) ? i : window;
          }
          registerMessageHandler(i, t) {
            this.messageHandlers[i] = t;
          }
          unregisterMessageHandler(i) {
            delete this.messageHandlers[i];
          }
          sendAsync(i, t) {
            return new Promise(((s, n) => {
              const a = Math.round(1e18 * Math.random()).toString(36).substring(0, 10), M = t ? Xi(t.signal, "abort", (() => {
                M?.unsubscribe(), delete this.resolveRejects[a];
                const N = { id: a, type: "<cancel>", origin: location.origin, targetMapId: i.targetMapId, sourceMapId: this.mapId };
                this.target.postMessage(N);
              }), Tz) : null;
              this.resolveRejects[a] = { resolve: (N) => {
                M?.unsubscribe(), s(N);
              }, reject: (N) => {
                M?.unsubscribe(), n(N);
              } };
              const l = [], D = Object.assign(Object.assign({}, i), { id: a, sourceMapId: this.mapId, origin: location.origin, data: Jn(i.data, l) });
              this.target.postMessage(D, { transfer: l });
            }));
          }
          receive(i) {
            const t = i.data, s = t.id;
            if (!(t.origin !== "file://" && location.origin !== "file://" && t.origin !== "resource://android" && location.origin !== "resource://android" && t.origin !== location.origin || t.targetMapId && this.mapId !== t.targetMapId)) {
              if (t.type === "<cancel>") {
                delete this.tasks[s];
                const n = this.abortControllers[s];
                return delete this.abortControllers[s], void (n && n.abort());
              }
              if (ai(self) || t.mustQueue) return this.tasks[s] = t, this.taskQueue.push(s), void this.invoker.trigger();
              this.processTask(s, t);
            }
          }
          process() {
            if (this.taskQueue.length === 0) return;
            const i = this.taskQueue.shift(), t = this.tasks[i];
            delete this.tasks[i], this.taskQueue.length > 0 && this.invoker.trigger(), t && this.processTask(i, t);
          }
          processTask(i, t) {
            return u(this, void 0, void 0, (function* () {
              if (t.type === "<response>") {
                const a = this.resolveRejects[i];
                return delete this.resolveRejects[i], a ? void (t.error ? a.reject(fi(t.error)) : a.resolve(fi(t.data))) : void 0;
              }
              if (!this.messageHandlers[t.type]) return void this.completeTask(i, new Error(`Could not find a registered handler for ${t.type}, map ID: ${this.mapId}, available handlers: ${Object.keys(this.messageHandlers).join(", ")}`));
              const s = fi(t.data), n = new AbortController();
              this.abortControllers[i] = n;
              try {
                const a = yield this.messageHandlers[t.type](t.sourceMapId, s, n);
                this.completeTask(i, null, a);
              } catch (a) {
                this.completeTask(i, a);
              }
            }));
          }
          completeTask(i, t, s) {
            const n = [];
            delete this.abortControllers[i];
            const a = { id: i, type: "<response>", sourceMapId: this.mapId, origin: location.origin, error: t ? Jn(t) : null, data: Jn(s, n) };
            this.target.postMessage(a, { transfer: n });
          }
          remove() {
            this.invoker.remove(), this.subscription.unsubscribe();
          }
        }, b.M = ur, b.N = function() {
          var i = new Ie(16);
          return Ie != Float32Array && (i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0), i[0] = 1, i[5] = 1, i[10] = 1, i[15] = 1, i;
        }, b.O = function(i, t, s) {
          var n, a, M, l, D, N, y, w, T, x, A, m, L = s[0], O = s[1], B = s[2];
          return t === i ? (i[12] = t[0] * L + t[4] * O + t[8] * B + t[12], i[13] = t[1] * L + t[5] * O + t[9] * B + t[13], i[14] = t[2] * L + t[6] * O + t[10] * B + t[14], i[15] = t[3] * L + t[7] * O + t[11] * B + t[15]) : (a = t[1], M = t[2], l = t[3], D = t[4], N = t[5], y = t[6], w = t[7], T = t[8], x = t[9], A = t[10], m = t[11], i[0] = n = t[0], i[1] = a, i[2] = M, i[3] = l, i[4] = D, i[5] = N, i[6] = y, i[7] = w, i[8] = T, i[9] = x, i[10] = A, i[11] = m, i[12] = n * L + D * O + T * B + t[12], i[13] = a * L + N * O + x * B + t[13], i[14] = M * L + y * O + A * B + t[14], i[15] = l * L + w * O + m * B + t[15]), i;
        }, b.P = mt, b.Q = function(i, t, s) {
          var n = s[0], a = s[1], M = s[2];
          return i[0] = t[0] * n, i[1] = t[1] * n, i[2] = t[2] * n, i[3] = t[3] * n, i[4] = t[4] * a, i[5] = t[5] * a, i[6] = t[6] * a, i[7] = t[7] * a, i[8] = t[8] * M, i[9] = t[9] * M, i[10] = t[10] * M, i[11] = t[11] * M, i[12] = t[12], i[13] = t[13], i[14] = t[14], i[15] = t[15], i;
        }, b.R = Qs, b.S = function(i, t, s) {
          var n = t[0], a = t[1], M = t[2], l = t[3], D = t[4], N = t[5], y = t[6], w = t[7], T = t[8], x = t[9], A = t[10], m = t[11], L = t[12], O = t[13], B = t[14], P = t[15], k = s[0], U = s[1], K = s[2], et = s[3];
          return i[0] = k * n + U * D + K * T + et * L, i[1] = k * a + U * N + K * x + et * O, i[2] = k * M + U * y + K * A + et * B, i[3] = k * l + U * w + K * m + et * P, i[4] = (k = s[4]) * n + (U = s[5]) * D + (K = s[6]) * T + (et = s[7]) * L, i[5] = k * a + U * N + K * x + et * O, i[6] = k * M + U * y + K * A + et * B, i[7] = k * l + U * w + K * m + et * P, i[8] = (k = s[8]) * n + (U = s[9]) * D + (K = s[10]) * T + (et = s[11]) * L, i[9] = k * a + U * N + K * x + et * O, i[10] = k * M + U * y + K * A + et * B, i[11] = k * l + U * w + K * m + et * P, i[12] = (k = s[12]) * n + (U = s[13]) * D + (K = s[14]) * T + (et = s[15]) * L, i[13] = k * a + U * N + K * x + et * O, i[14] = k * M + U * y + K * A + et * B, i[15] = k * l + U * w + K * m + et * P, i;
        }, b.T = su, b.U = function(i, t) {
          const s = {};
          for (let n = 0; n < t.length; n++) {
            const a = t[n];
            a in i && (s[a] = i[a]);
          }
          return s;
        }, b.V = zn, b.W = Vs, b.X = Zg, b.Y = Rg, b.Z = gt, b._ = u, b.a = Wi, b.a$ = Ii, b.a0 = Yr, b.a1 = si, b.a2 = Gg, b.a3 = rl, b.a4 = se, b.a5 = function(i, t, s) {
          if (!i) return t || {};
          if (!t) return i || {};
          const n = $g(i), a = $g(t);
          (function(l, D) {
            D.removeAll && (l.add.clear(), l.update.clear(), l.remove.clear(), D.remove.clear());
            for (const N of D.remove) l.add.delete(N), l.update.delete(N);
            for (const [N, y] of D.update) {
              const w = l.update.get(N);
              w && (D.update.set(N, fz(w, y)), l.update.delete(N));
            }
          })(n, a);
          const M = {};
          if ((n.removeAll || a.removeAll) && (M.removeAll = !0), M.remove = /* @__PURE__ */ new Set([...n.remove, ...a.remove]), M.add = new Map([...n.add, ...a.add]), M.update = new Map([...n.update, ...a.update]), M.remove.size && M.add.size) for (const l of M.add.keys()) M.remove.delete(l);
          return (function(l) {
            const D = {};
            return l.removeAll && (D.removeAll = l.removeAll), l.remove && (D.remove = Array.from(l.remove)), l.add && (D.add = Array.from(l.add.values())), l.update && (D.update = Array.from(l.update.values())), D;
          })(M);
        }, b.a6 = function(i, t) {
          if (i == null) return !0;
          if (i.type === "Feature") return bM(i, t) != null;
          if (i.type === "FeatureCollection") {
            const s = /* @__PURE__ */ new Set();
            for (const n of i.features) {
              const a = bM(n, t);
              if (a == null || s.has(a)) return !1;
              s.add(a);
            }
            return !0;
          }
          return !1;
        }, b.a7 = function(i, t) {
          const s = /* @__PURE__ */ new Map();
          if (i != null) if (i.type === "Feature") s.set(bM(i, t), i);
          else for (const n of i.features) s.set(bM(n, t), n);
          return s;
        }, b.a8 = function(i, t, s) {
          var n, a;
          if (t.removeAll) i.clear();
          else if (t.remove) for (const M of t.remove) i.delete(M);
          if (t.add) for (const M of t.add) {
            const l = bM(M, s);
            l != null && i.set(l, M);
          }
          if (t.update) for (const M of t.update) {
            let l = i.get(M.id);
            if (!l) continue;
            const D = !!M.newGeometry, N = M.removeAllProperties || ((n = M.removeProperties) === null || n === void 0 ? void 0 : n.length) > 0 || ((a = M.addOrUpdateProperties) === null || a === void 0 ? void 0 : a.length) > 0;
            if ((D || N) && (l = Object.assign({}, l), i.set(M.id, l), D && (l.geometry = M.newGeometry), N)) {
              if (l.properties = M.removeAllProperties ? {} : Object.assign({}, l.properties || {}), M.removeProperties) for (const y of M.removeProperties) delete l.properties[y];
              if (M.addOrUpdateProperties) for (const { key: y, value: w } of M.addOrUpdateProperties) l.properties[y] = w;
            }
          }
        }, b.a9 = bu, b.aA = function(i, t) {
          var s = t[0], n = t[1], a = t[2], M = t[3], l = t[4], D = t[5], N = t[6], y = t[7], w = t[8], T = t[9], x = t[10], A = t[11], m = t[12], L = t[13], O = t[14], B = t[15], P = s * D - n * l, k = s * N - a * l, U = s * y - M * l, K = n * N - a * D, et = n * y - M * D, ot = a * y - M * N, dt = w * L - T * m, Dt = w * O - x * m, yt = w * B - A * m, At = T * O - x * L, Tt = T * B - A * L, ft = x * B - A * O, zt = P * ft - k * Tt + U * At + K * yt - et * Dt + ot * dt;
          return zt ? (i[0] = (D * ft - N * Tt + y * At) * (zt = 1 / zt), i[1] = (a * Tt - n * ft - M * At) * zt, i[2] = (L * ot - O * et + B * K) * zt, i[3] = (x * et - T * ot - A * K) * zt, i[4] = (N * yt - l * ft - y * Dt) * zt, i[5] = (s * ft - a * yt + M * Dt) * zt, i[6] = (O * U - m * ot - B * k) * zt, i[7] = (w * ot - x * U + A * k) * zt, i[8] = (l * Tt - D * yt + y * dt) * zt, i[9] = (n * yt - s * Tt - M * dt) * zt, i[10] = (m * et - L * U + B * P) * zt, i[11] = (T * U - w * et - A * P) * zt, i[12] = (D * Dt - l * At - N * dt) * zt, i[13] = (s * At - n * Dt + a * dt) * zt, i[14] = (L * k - m * K - O * P) * zt, i[15] = (w * K - T * k + x * P) * zt, i) : null;
        }, b.aB = Zs, b.aC = function(i) {
          var t = i[0], s = i[1];
          return Math.sqrt(t * t + s * s);
        }, b.aD = function(i) {
          return i[0] = 0, i[1] = 0, i;
        }, b.aE = function(i, t, s) {
          return i[0] = t[0] * s, i[1] = t[1] * s, i;
        }, b.aF = zu, b.aG = Tn, b.aH = function(i, t, s, n) {
          const a = t.y - i.y, M = t.x - i.x, l = n.y - s.y, D = n.x - s.x, N = l * M - D * a;
          if (N === 0) return null;
          const y = (D * (i.y - s.y) - l * (i.x - s.x)) / N;
          return new mt(i.x + y * M, i.y + y * a);
        }, b.aI = fh, b.aJ = Ru, b.aK = function(i) {
          let t = 1 / 0, s = 1 / 0, n = -1 / 0, a = -1 / 0;
          for (const M of i) t = Math.min(t, M.x), s = Math.min(s, M.y), n = Math.max(n, M.x), a = Math.max(a, M.y);
          return [t, s, n, a];
        }, b.aL = Ge, b.aM = kr, b.aN = function(i, t, s, n, a = !1) {
          if (!s[0] && !s[1]) return [0, 0];
          const M = a ? n === "map" ? -i.bearingInRadians : 0 : n === "viewport" ? i.bearingInRadians : 0;
          if (M) {
            const l = Math.sin(M), D = Math.cos(M);
            s = [s[0] * D - s[1] * l, s[0] * l + s[1] * D];
          }
          return [a ? s[0] : kr(t, s[0], i.zoom), a ? s[1] : kr(t, s[1], i.zoom)];
        }, b.aP = Du, b.aQ = vu, b.aR = hu, b.aS = Bu, b.aT = Ee, b.aU = Kc, b.aV = W, b.aW = Yt, b.aX = wt, b.aY = Ts, b.aZ = Hg, b.a_ = Bi, b.aa = EM, b.ab = ga, b.ac = 25, b.ad = wu, b.ae = (i) => {
          const t = window.document.createElement("video");
          return t.muted = !0, new Promise(((s) => {
            t.onloadstart = () => {
              s(t);
            };
            for (const n of i) {
              const a = window.document.createElement("source");
              E(n) || (t.crossOrigin = "Anonymous"), a.src = n, t.appendChild(a);
            }
          }));
        }, b.af = It, b.ag = function() {
          return Fr++;
        }, b.ah = z, b.ai = uo, b.aj = Xn, b.ak = _i, b.al = th, b.am = function(i) {
          const t = {};
          if (i.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, ((s, n, a, M) => {
            const l = a || M;
            return t[n] = !l || l.toLowerCase(), "";
          })), t["max-age"]) {
            const s = parseInt(t["max-age"], 10);
            isNaN(s) ? delete t["max-age"] : t["max-age"] = s;
          }
          return t;
        }, b.an = Ds, b.ao = 85.051129, b.ap = cr, b.aq = function(i) {
          return Math.pow(2, i);
        }, b.ar = Sr, b.as = Vg, b.at = function(i) {
          return Math.log(i) / Math.LN2;
        }, b.au = function(i) {
          var t = i[0], s = i[1];
          return t * t + s * s;
        }, b.av = class {
          constructor(i, t) {
            this.max = i, this.onRemove = t, this.reset();
          }
          reset() {
            for (const i in this.data) for (const t of this.data[i]) t.timeout && clearTimeout(t.timeout), this.onRemove(t.value);
            return this.data = {}, this.order = [], this;
          }
          add(i, t, s) {
            const n = i.wrapped().key;
            this.data[n] === void 0 && (this.data[n] = []);
            const a = { value: t, timeout: void 0 };
            if (s !== void 0 && (a.timeout = setTimeout((() => {
              this.remove(i, a);
            }), s)), this.data[n].push(a), this.order.push(n), this.order.length > this.max) {
              const M = this._getAndRemoveByKey(this.order[0]);
              M && this.onRemove(M);
            }
            return this;
          }
          has(i) {
            return i.wrapped().key in this.data;
          }
          getAndRemove(i) {
            return this.has(i) ? this._getAndRemoveByKey(i.wrapped().key) : null;
          }
          _getAndRemoveByKey(i) {
            const t = this.data[i].shift();
            return t.timeout && clearTimeout(t.timeout), this.data[i].length === 0 && delete this.data[i], this.order.splice(this.order.indexOf(i), 1), t.value;
          }
          getByKey(i) {
            const t = this.data[i];
            return t ? t[0].value : null;
          }
          get(i) {
            return this.has(i) ? this.data[i.wrapped().key][0].value : null;
          }
          remove(i, t) {
            if (!this.has(i)) return this;
            const s = i.wrapped().key, n = t === void 0 ? 0 : this.data[s].indexOf(t), a = this.data[s][n];
            return this.data[s].splice(n, 1), a.timeout && clearTimeout(a.timeout), this.data[s].length === 0 && delete this.data[s], this.onRemove(a.value), this.order.splice(this.order.indexOf(s), 1), this;
          }
          setMaxSize(i) {
            for (this.max = i; this.order.length > this.max; ) {
              const t = this._getAndRemoveByKey(this.order[0]);
              t && this.onRemove(t);
            }
            return this;
          }
          filter(i) {
            const t = [];
            for (const s in this.data) for (const n of this.data[s]) i(n.value) || t.push(n);
            for (const s of t) this.remove(s.value.tileID, s);
          }
        }, b.aw = function(i) {
          if (!i.length) return /* @__PURE__ */ new Set();
          const t = Math.max(...i.map(((N) => N.canonical.z)));
          let s = 1 / 0, n = -1 / 0, a = 1 / 0, M = -1 / 0;
          const l = [];
          for (const N of i) {
            const { x: y, y: w, z: T } = N.canonical, x = Math.pow(2, t - T), A = y * x, m = w * x;
            l.push({ id: N, x: A, y: m }), A < s && (s = A), A > n && (n = A), m < a && (a = m), m > M && (M = m);
          }
          const D = /* @__PURE__ */ new Set();
          for (const N of l) N.x !== s && N.x !== n && N.y !== a && N.y !== M || D.add(N.id);
          return D;
        }, b.ax = function(i, t) {
          let s = 0, n = 0;
          if (i.kind === "constant") n = i.layoutSize;
          else if (i.kind !== "source") {
            const { interpolationType: a, minZoom: M, maxZoom: l } = i, D = a ? Ds(es.interpolationFactor(a, t, M, l), 0, 1) : 0;
            i.kind === "camera" ? n = $s.number(i.minSize, i.maxSize, D) : s = D;
          }
          return { uSizeT: s, uSize: n };
        }, b.az = function(i, { uSize: t, uSizeT: s }, { lowerSize: n, upperSize: a }) {
          return i.kind === "source" ? n / Or : i.kind === "composite" ? $s.number(n / Or, a / Or, s) : t;
        }, b.b = oi, b.b$ = class extends Ws {
          constructor(i, t) {
            super(i, t), this.current = _r;
          }
          set(i) {
            if (i[12] !== this.current[12] || i[0] !== this.current[0]) return this.current = i, void this.gl.uniformMatrix4fv(this.location, !1, i);
            for (let t = 1; t < 16; t++) if (i[t] !== this.current[t]) {
              this.current = i, this.gl.uniformMatrix4fv(this.location, !1, i);
              break;
            }
          }
        }, b.b0 = function(i) {
          var t = new Ie(3);
          return t[0] = i[0], t[1] = i[1], t[2] = i[2], t;
        }, b.b1 = function(i, t, s) {
          return i[0] = t[0] - s[0], i[1] = t[1] - s[1], i[2] = t[2] - s[2], i;
        }, b.b2 = function(i, t) {
          var s = t[0], n = t[1], a = t[2], M = s * s + n * n + a * a;
          return M > 0 && (M = 1 / Math.sqrt(M)), i[0] = t[0] * M, i[1] = t[1] * M, i[2] = t[2] * M, i;
        }, b.b3 = nr, b.b4 = function(i, t) {
          return i[0] * t[0] + i[1] * t[1] + i[2] * t[2];
        }, b.b5 = function(i, t, s) {
          return i[0] = t[0] * s[0], i[1] = t[1] * s[1], i[2] = t[2] * s[2], i[3] = t[3] * s[3], i;
        }, b.b6 = ps, b.b7 = function(i, t, s) {
          const n = t[0] * s[0] + t[1] * s[1] + t[2] * s[2];
          return n === 0 ? null : (-(i[0] * s[0] + i[1] * s[1] + i[2] * s[2]) - s[3]) / n;
        }, b.b8 = ar, b.b9 = function(i, t, s) {
          return i[0] = t[0] * s, i[1] = t[1] * s, i[2] = t[2] * s, i[3] = t[3] * s, i;
        }, b.bA = xn, b.bB = function(i, t, s) {
          var n = s[0], a = s[1], M = s[2], l = s[3], D = t[0], N = t[1], y = t[2], w = a * y - M * N, T = M * D - n * y, x = n * N - a * D;
          return i[0] = D + l * (w += w) + a * (x += x) - M * (T += T), i[1] = N + l * T + M * w - n * x, i[2] = y + l * x + n * T - a * w, i;
        }, b.bC = function(i, t, s) {
          const n = (a = [i[0], i[1], i[2], t[0], t[1], t[2], s[0], s[1], s[2]])[0] * ((w = a[8]) * (l = a[4]) - (D = a[5]) * (y = a[7])) + a[1] * (-w * (M = a[3]) + D * (N = a[6])) + a[2] * (y * M - l * N);
          var a, M, l, D, N, y, w;
          if (n === 0) return null;
          const T = nr([], [t[0], t[1], t[2]], [s[0], s[1], s[2]]), x = nr([], [s[0], s[1], s[2]], [i[0], i[1], i[2]]), A = nr([], [i[0], i[1], i[2]], [t[0], t[1], t[2]]), m = Bi([], T, -i[3]);
          return Ii(m, m, Bi([], x, -t[3])), Ii(m, m, Bi([], A, -s[3])), Bi(m, m, 1 / n), m;
        }, b.bD = Iu, b.bE = function() {
          return new Float64Array(4);
        }, b.bF = function(i, t, s, n) {
          var a = [], M = [];
          return a[0] = t[0] - s[0], a[1] = t[1] - s[1], a[2] = t[2] - s[2], M[0] = a[0] * Math.cos(n) - a[1] * Math.sin(n), M[1] = a[0] * Math.sin(n) + a[1] * Math.cos(n), M[2] = a[2], i[0] = M[0] + s[0], i[1] = M[1] + s[1], i[2] = M[2] + s[2], i;
        }, b.bG = function(i, t, s, n) {
          var a = [], M = [];
          return a[0] = t[0] - s[0], a[1] = t[1] - s[1], a[2] = t[2] - s[2], M[0] = a[0], M[1] = a[1] * Math.cos(n) - a[2] * Math.sin(n), M[2] = a[1] * Math.sin(n) + a[2] * Math.cos(n), i[0] = M[0] + s[0], i[1] = M[1] + s[1], i[2] = M[2] + s[2], i;
        }, b.bH = function(i, t, s, n) {
          var a = [], M = [];
          return a[0] = t[0] - s[0], a[1] = t[1] - s[1], a[2] = t[2] - s[2], M[0] = a[2] * Math.sin(n) + a[0] * Math.cos(n), M[1] = a[1], M[2] = a[2] * Math.cos(n) - a[0] * Math.sin(n), i[0] = M[0] + s[0], i[1] = M[1] + s[1], i[2] = M[2] + s[2], i;
        }, b.bI = function(i, t, s) {
          var n = Math.sin(s), a = Math.cos(s), M = t[0], l = t[1], D = t[2], N = t[3], y = t[8], w = t[9], T = t[10], x = t[11];
          return t !== i && (i[4] = t[4], i[5] = t[5], i[6] = t[6], i[7] = t[7], i[12] = t[12], i[13] = t[13], i[14] = t[14], i[15] = t[15]), i[0] = M * a - y * n, i[1] = l * a - w * n, i[2] = D * a - T * n, i[3] = N * a - x * n, i[8] = M * n + y * a, i[9] = l * n + w * a, i[10] = D * n + T * a, i[11] = N * n + x * a, i;
        }, b.bJ = function(i, t) {
          const s = ni(i, 360), n = ni(t, 360), a = n - s, M = n > s ? a - 360 : a + 360;
          return Math.abs(a) < Math.abs(M) ? a : M;
        }, b.bK = function(i) {
          return i[0] = 0, i[1] = 0, i[2] = 0, i;
        }, b.bL = function(i, t, s, n) {
          const a = Math.sqrt(i * i + t * t), M = Math.sqrt(s * s + n * n);
          i /= a, t /= a, s /= M, n /= M;
          const l = Math.acos(i * s + t * n);
          return -t * s + i * n > 0 ? l : -l;
        }, b.bM = function(i, t) {
          const s = ni(i, 2 * Math.PI), n = ni(t, 2 * Math.PI);
          return Math.min(Math.abs(s - n), Math.abs(s - n + 2 * Math.PI), Math.abs(s - n - 2 * Math.PI));
        }, b.bN = function() {
          const i = {}, t = X.$version;
          for (const s in X.$root) {
            const n = X.$root[s];
            if (n.required) {
              let a = null;
              a = s === "version" ? t : n.type === "array" ? [] : {}, a != null && (i[s] = a);
            }
          }
          return i;
        }, b.bO = Os, b.bP = aM, b.bQ = function i(t, s) {
          if (Array.isArray(t)) {
            if (!Array.isArray(s) || t.length !== s.length) return !1;
            for (let n = 0; n < t.length; n++) if (!i(t[n], s[n])) return !1;
            return !0;
          }
          if (typeof t == "object" && t !== null && s !== null) {
            if (typeof s != "object" || Object.keys(t).length !== Object.keys(s).length) return !1;
            for (const n in t) if (!i(t[n], s[n])) return !1;
            return !0;
          }
          return t === s;
        }, b.bR = function(i) {
          i = i.slice();
          const t = /* @__PURE__ */ Object.create(null);
          for (let s = 0; s < i.length; s++) t[i[s].id] = i[s];
          for (let s = 0; s < i.length; s++) "ref" in i[s] && (i[s] = lt(i[s], t[i[s].ref]));
          return i;
        }, b.bS = function(i, t) {
          if (i.type === "custom") return new wz(i, t);
          switch (i.type) {
            case "background":
              return new Iz(i, t);
            case "circle":
              return new rD(i, t);
            case "color-relief":
              return new lD(i, t);
            case "fill":
              return new AD(i, t);
            case "fill-extrusion":
              return new BD(i, t);
            case "heatmap":
              return new aD(i, t);
            case "hillshade":
              return new MD(i, t);
            case "line":
              return new WD(i, t);
            case "raster":
              return new Zl(i, t);
            case "symbol":
              return new il(i, t);
          }
        }, b.bT = (i) => i.type === "raster", b.bU = ks, b.bV = function(i, t) {
          if (!i) return [{ command: "setStyle", args: [t] }];
          let s = [];
          try {
            if (!ut(i.version, t.version)) return [{ command: "setStyle", args: [t] }];
            ut(i.center, t.center) || s.push({ command: "setCenter", args: [t.center] }), ut(i.state, t.state) || s.push({ command: "setGlobalState", args: [t.state] }), ut(i.centerAltitude, t.centerAltitude) || s.push({ command: "setCenterAltitude", args: [t.centerAltitude] }), ut(i.zoom, t.zoom) || s.push({ command: "setZoom", args: [t.zoom] }), ut(i.bearing, t.bearing) || s.push({ command: "setBearing", args: [t.bearing] }), ut(i.pitch, t.pitch) || s.push({ command: "setPitch", args: [t.pitch] }), ut(i.roll, t.roll) || s.push({ command: "setRoll", args: [t.roll] }), ut(i.sprite, t.sprite) || s.push({ command: "setSprite", args: [t.sprite] }), ut(i.glyphs, t.glyphs) || s.push({ command: "setGlyphs", args: [t.glyphs] }), ut(i.transition, t.transition) || s.push({ command: "setTransition", args: [t.transition] }), ut(i.light, t.light) || s.push({ command: "setLight", args: [t.light] }), ut(i.terrain, t.terrain) || s.push({ command: "setTerrain", args: [t.terrain] }), ut(i.sky, t.sky) || s.push({ command: "setSky", args: [t.sky] }), ut(i.projection, t.projection) || s.push({ command: "setProjection", args: [t.projection] });
            const n = {}, a = [];
            (function(l, D, N, y) {
              let w;
              for (w in D = D || {}, l = l || {}) Object.prototype.hasOwnProperty.call(l, w) && (Object.prototype.hasOwnProperty.call(D, w) || vt(w, N, y));
              for (w in D) Object.prototype.hasOwnProperty.call(D, w) && (Object.prototype.hasOwnProperty.call(l, w) ? ut(l[w], D[w]) || (l[w].type === "geojson" && D[w].type === "geojson" && _e(l, D, w) ? ht(N, { command: "setGeoJSONSourceData", args: [w, D[w].data] }) : Xt(w, D, N, y)) : _t(w, D, N));
            })(i.sources, t.sources, a, n);
            const M = [];
            i.layers && i.layers.forEach(((l) => {
              "source" in l && n[l.source] ? s.push({ command: "removeLayer", args: [l.id] }) : M.push(l);
            })), s = s.concat(a), (function(l, D, N) {
              D = D || [];
              const y = (l = l || []).map(te), w = D.map(te), T = l.reduce(oe, {}), x = D.reduce(oe, {}), A = y.slice(), m = /* @__PURE__ */ Object.create(null);
              let L, O, B, P, k;
              for (let U = 0, K = 0; U < y.length; U++) L = y[U], Object.prototype.hasOwnProperty.call(x, L) ? K++ : (ht(N, { command: "removeLayer", args: [L] }), A.splice(A.indexOf(L, K), 1));
              for (let U = 0, K = 0; U < w.length; U++) L = w[w.length - 1 - U], A[A.length - 1 - U] !== L && (Object.prototype.hasOwnProperty.call(T, L) ? (ht(N, { command: "removeLayer", args: [L] }), A.splice(A.lastIndexOf(L, A.length - K), 1)) : K++, P = A[A.length - U], ht(N, { command: "addLayer", args: [x[L], P] }), A.splice(A.length - U, 0, L), m[L] = !0);
              for (let U = 0; U < w.length; U++) if (L = w[U], O = T[L], B = x[L], !m[L] && !ut(O, B)) if (ut(O.source, B.source) && ut(O["source-layer"], B["source-layer"]) && ut(O.type, B.type)) {
                for (k in Zt(O.layout, B.layout, N, L, null, "setLayoutProperty"), Zt(O.paint, B.paint, N, L, null, "setPaintProperty"), ut(O.filter, B.filter) || ht(N, { command: "setFilter", args: [L, B.filter] }), ut(O.minzoom, B.minzoom) && ut(O.maxzoom, B.maxzoom) || ht(N, { command: "setLayerZoomRange", args: [L, B.minzoom, B.maxzoom] }), O) Object.prototype.hasOwnProperty.call(O, k) && k !== "layout" && k !== "paint" && k !== "filter" && k !== "metadata" && k !== "minzoom" && k !== "maxzoom" && (k.indexOf("paint.") === 0 ? Zt(O[k], B[k], N, L, k.slice(6), "setPaintProperty") : ut(O[k], B[k]) || ht(N, { command: "setLayerProperty", args: [L, k, B[k]] }));
                for (k in B) Object.prototype.hasOwnProperty.call(B, k) && !Object.prototype.hasOwnProperty.call(O, k) && k !== "layout" && k !== "paint" && k !== "filter" && k !== "metadata" && k !== "minzoom" && k !== "maxzoom" && (k.indexOf("paint.") === 0 ? Zt(O[k], B[k], N, L, k.slice(6), "setPaintProperty") : ut(O[k], B[k]) || ht(N, { command: "setLayerProperty", args: [L, k, B[k]] }));
              } else ht(N, { command: "removeLayer", args: [L] }), P = A[A.lastIndexOf(L) + 1], ht(N, { command: "addLayer", args: [B, P] });
            })(M, t.layers, s);
          } catch (n) {
            console.warn("Unable to compute style diff:", n), s = [{ command: "setStyle", args: [t] }];
          }
          return s;
        }, b.bW = function(i) {
          const t = [], s = i.id;
          return s === void 0 && t.push({ message: `layers.${s}: missing required property "id"` }), i.render === void 0 && t.push({ message: `layers.${s}: missing required method "render"` }), i.renderingMode && i.renderingMode !== "2d" && i.renderingMode !== "3d" && t.push({ message: `layers.${s}: property "renderingMode" must be either "2d" or "3d"` }), t;
        }, b.bX = Yi, b.bY = Mr, b.bZ = class extends Ws {
          constructor(i, t) {
            super(i, t), this.current = 0;
          }
          set(i) {
            this.current !== i && (this.current = i, this.gl.uniform1i(this.location, i));
          }
        }, b.b_ = ji, b.ba = function(i, t) {
          return i[0] * t[0] + i[1] * t[1] + i[2] * t[2] + i[3];
        }, b.bb = qg, b.bc = go, b.bd = function(i, t, s, n, a) {
          var M = 1 / Math.tan(t / 2);
          if (i[0] = M / s, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = M, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[11] = -1, i[12] = 0, i[13] = 0, i[15] = 0, a != null && a !== 1 / 0) {
            var l = 1 / (n - a);
            i[10] = (a + n) * l, i[14] = 2 * a * n * l;
          } else i[10] = -1, i[14] = -2 * n;
          return i;
        }, b.be = function(i) {
          var t = new Ie(16);
          return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], t[9] = i[9], t[10] = i[10], t[11] = i[11], t[12] = i[12], t[13] = i[13], t[14] = i[14], t[15] = i[15], t;
        }, b.bf = function(i, t, s) {
          var n = Math.sin(s), a = Math.cos(s), M = t[0], l = t[1], D = t[2], N = t[3], y = t[4], w = t[5], T = t[6], x = t[7];
          return t !== i && (i[8] = t[8], i[9] = t[9], i[10] = t[10], i[11] = t[11], i[12] = t[12], i[13] = t[13], i[14] = t[14], i[15] = t[15]), i[0] = M * a + y * n, i[1] = l * a + w * n, i[2] = D * a + T * n, i[3] = N * a + x * n, i[4] = y * a - M * n, i[5] = w * a - l * n, i[6] = T * a - D * n, i[7] = x * a - N * n, i;
        }, b.bg = function(i, t, s) {
          var n = Math.sin(s), a = Math.cos(s), M = t[4], l = t[5], D = t[6], N = t[7], y = t[8], w = t[9], T = t[10], x = t[11];
          return t !== i && (i[0] = t[0], i[1] = t[1], i[2] = t[2], i[3] = t[3], i[12] = t[12], i[13] = t[13], i[14] = t[14], i[15] = t[15]), i[4] = M * a + y * n, i[5] = l * a + w * n, i[6] = D * a + T * n, i[7] = N * a + x * n, i[8] = y * a - M * n, i[9] = w * a - l * n, i[10] = T * a - D * n, i[11] = x * a - N * n, i;
        }, b.bh = function() {
          const i = new Float32Array(16);
          return Sr(i), i;
        }, b.bi = function() {
          const i = new Float64Array(16);
          return Sr(i), i;
        }, b.bj = function() {
          return new Float64Array(16);
        }, b.bk = function(i, t, s) {
          const n = new Float64Array(4);
          return xn(n, i, t - 90, s), n;
        }, b.bl = function(i, t, s, n) {
          var a, M, l, D, N, y = t[0], w = t[1], T = t[2], x = t[3], A = s[0], m = s[1], L = s[2], O = s[3];
          return (M = y * A + w * m + T * L + x * O) < 0 && (M = -M, A = -A, m = -m, L = -L, O = -O), 1 - M > je ? (a = Math.acos(M), l = Math.sin(a), D = Math.sin((1 - n) * a) / l, N = Math.sin(n * a) / l) : (D = 1 - n, N = n), i[0] = D * y + N * A, i[1] = D * w + N * m, i[2] = D * T + N * L, i[3] = D * x + N * O, i;
        }, b.bm = function(i) {
          const t = new Float64Array(9);
          var s, n, a, M, l, D, N, y, w, T, x, A, m, L, O, B, P, k;
          T = (a = (n = i)[0]) * (N = a + a), x = (M = n[1]) * N, m = (l = n[2]) * N, L = l * (y = M + M), B = (D = n[3]) * N, P = D * y, k = D * (w = l + l), (s = t)[0] = 1 - (A = M * y) - (O = l * w), s[3] = x - k, s[6] = m + P, s[1] = x + k, s[4] = 1 - T - O, s[7] = L - B, s[2] = m - P, s[5] = L + B, s[8] = 1 - T - A;
          const U = Ts(-Math.asin(Ds(t[2], -1, 1)));
          let K, et;
          return Math.hypot(t[5], t[8]) < 1e-3 ? (K = 0, et = -Ts(Math.atan2(t[3], t[4]))) : (K = Ts(t[5] === 0 && t[8] === 0 ? 0 : Math.atan2(t[5], t[8])), et = Ts(t[1] === 0 && t[0] === 0 ? 0 : Math.atan2(t[1], t[0]))), { roll: K, pitch: U + 90, bearing: et };
        }, b.bn = function(i, t) {
          return i.roll == t.roll && i.pitch == t.pitch && i.bearing == t.bearing;
        }, b.bo = Vt, b.bp = mi, b.bq = oo, b.br = jM, b.bs = ao, b.bt = or, b.bu = Ia, b.bv = os, b.bw = function(i, t, s, n, a) {
          return or(n, a, Ds((i - t) / (s - t), 0, 1));
        }, b.bx = ni, b.by = function() {
          return new Float64Array(3);
        }, b.bz = function(i, t, s, n) {
          return i[0] = t[0] + s[0] * n, i[1] = t[1] + s[1] * n, i[2] = t[2] + s[2] * n, i;
        }, b.c = Ur, b.c$ = class {
          constructor(i) {
            this._marks = { start: [i.url, "start"].join("#"), end: [i.url, "end"].join("#"), measure: i.url.toString() }, performance.mark(this._marks.start);
          }
          finish() {
            performance.mark(this._marks.end);
            let i = performance.getEntriesByName(this._marks.measure);
            return i.length === 0 && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), i = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), i;
          }
        }, b.c0 = bs, b.c1 = class extends Ws {
          constructor(i, t) {
            super(i, t), this.current = [0, 0, 0];
          }
          set(i) {
            i[0] === this.current[0] && i[1] === this.current[1] && i[2] === this.current[2] || (this.current = i, this.gl.uniform3f(this.location, i[0], i[1], i[2]));
          }
        }, b.c2 = class extends Ws {
          constructor(i, t) {
            super(i, t), this.current = [0, 0];
          }
          set(i) {
            i[0] === this.current[0] && i[1] === this.current[1] || (this.current = i, this.gl.uniform2f(this.location, i[0], i[1]));
          }
        }, b.c3 = Br, b.c4 = function(i, t) {
          var s = Math.sin(t), n = Math.cos(t);
          return i[0] = n, i[1] = s, i[2] = 0, i[3] = -s, i[4] = n, i[5] = 0, i[6] = 0, i[7] = 0, i[8] = 1, i;
        }, b.c5 = function(i, t, s) {
          var n = t[0], a = t[1], M = t[2];
          return i[0] = n * s[0] + a * s[3] + M * s[6], i[1] = n * s[1] + a * s[4] + M * s[7], i[2] = n * s[2] + a * s[5] + M * s[8], i;
        }, b.c6 = function(i, t, s, n, a, M, l) {
          var D = 1 / (t - s), N = 1 / (n - a), y = 1 / (M - l);
          return i[0] = -2 * D, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = -2 * N, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = 2 * y, i[11] = 0, i[12] = (t + s) * D, i[13] = (a + n) * N, i[14] = (l + M) * y, i[15] = 1, i;
        }, b.c7 = class extends Ws {
          constructor(i, t) {
            super(i, t), this.current = new Array();
          }
          set(i) {
            if (i != this.current) {
              this.current = i;
              const t = new Float32Array(4 * i.length);
              for (let s = 0; s < i.length; s++) t[4 * s] = i[s].r, t[4 * s + 1] = i[s].g, t[4 * s + 2] = i[s].b, t[4 * s + 3] = i[s].a;
              this.gl.uniform4fv(this.location, t);
            }
          }
        }, b.c8 = class extends Ws {
          constructor(i, t) {
            super(i, t), this.current = new Array();
          }
          set(i) {
            if (i != this.current) {
              this.current = i;
              const t = new Float32Array(i);
              this.gl.uniform1fv(this.location, t);
            }
          }
        }, b.c9 = class extends $a {
        }, b.cA = function(i) {
          return mn[i] || jn[i];
        }, b.cB = function(i, t, s) {
          var n = t[0], a = t[1];
          return i[0] = s[0] * n + s[4] * a + s[12], i[1] = s[1] * n + s[5] * a + s[13], i;
        }, b.cC = function(i, t) {
          const { x: s, y: n } = EM.fromLngLat(t);
          return !(i < 0 || i > 25 || n < 0 || n >= 1 || s < 0 || s >= 1);
        }, b.cD = function(i, t) {
          return i[0] = t[0], i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = t[1], i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = t[2], i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, i;
        }, b.cE = class extends ra {
        }, b.cF = Kz, b.cH = function(i) {
          return i.message === lr;
        }, b.cI = Hs, b.cJ = function(i, t) {
          Wi.REGISTERED_PROTOCOLS[i] = t;
        }, b.cK = function(i) {
          delete Wi.REGISTERED_PROTOCOLS[i];
        }, b.cL = function(i, t) {
          const s = {};
          for (let a = 0; a < i.length; a++) {
            const M = t && t[i[a].id] || xc(i[a]);
            t && (t[i[a].id] = M);
            let l = s[M];
            l || (l = s[M] = []), l.push(i[a]);
          }
          const n = [];
          for (const a in s) n.push(s[a]);
          return n;
        }, b.cM = jt, b.cN = Kg, b.cO = ph, b.cP = Qg, b.cQ = function(i) {
          i.bucket.createArrays(), i.bucket.tilePixelRatio = se / (512 * i.bucket.overscaling), i.bucket.compareText = {}, i.bucket.iconsNeedLinear = !1;
          const t = i.bucket.layers[0], s = t.layout, n = t._unevaluatedLayout._values, a = { layoutIconSize: n["icon-size"].possiblyEvaluate(new ie(i.bucket.zoom + 1), i.canonical), layoutTextSize: n["text-size"].possiblyEvaluate(new ie(i.bucket.zoom + 1), i.canonical), textMaxSize: n["text-size"].possiblyEvaluate(new ie(18)) };
          if (i.bucket.textSizeData.kind === "composite") {
            const { minZoom: y, maxZoom: w } = i.bucket.textSizeData;
            a.compositeTextSizes = [n["text-size"].possiblyEvaluate(new ie(y), i.canonical), n["text-size"].possiblyEvaluate(new ie(w), i.canonical)];
          }
          if (i.bucket.iconSizeData.kind === "composite") {
            const { minZoom: y, maxZoom: w } = i.bucket.iconSizeData;
            a.compositeIconSizes = [n["icon-size"].possiblyEvaluate(new ie(y), i.canonical), n["icon-size"].possiblyEvaluate(new ie(w), i.canonical)];
          }
          const M = s.get("text-line-height") * Ge, l = s.get("text-rotation-alignment") !== "viewport" && s.get("symbol-placement") !== "point", D = s.get("text-keep-upright"), N = s.get("text-size");
          for (const y of i.bucket.features) {
            const w = s.get("text-font").evaluate(y, {}, i.canonical).join(","), T = N.evaluate(y, {}, i.canonical), x = a.layoutTextSize.evaluate(y, {}, i.canonical), A = a.layoutIconSize.evaluate(y, {}, i.canonical), m = { horizontal: {}, vertical: void 0 }, L = y.text;
            let O, B = [0, 0];
            if (L) {
              const U = L.toString(), K = s.get("text-letter-spacing").evaluate(y, {}, i.canonical) * Ge, et = Ja(U) ? K : 0, ot = s.get("text-anchor").evaluate(y, {}, i.canonical), dt = Qh(t, y, i.canonical);
              if (!dt) {
                const Tt = s.get("text-radial-offset").evaluate(y, {}, i.canonical);
                B = Tt ? bh(ot, [Tt * Ge, Qu]) : s.get("text-offset").evaluate(y, {}, i.canonical).map(((ft) => ft * Ge));
              }
              let Dt = l ? "center" : s.get("text-justify").evaluate(y, {}, i.canonical);
              const yt = s.get("symbol-placement") === "point" ? s.get("text-max-width").evaluate(y, {}, i.canonical) * Ge : 1 / 0, At = () => {
                i.bucket.allowVerticalPlacement && qn(U) && (m.vertical = el(L, i.glyphMap, i.glyphPositions, i.imagePositions, w, yt, M, ot, "left", et, B, b.ay.vertical, !0, x, T));
              };
              if (!l && dt) {
                const Tt = /* @__PURE__ */ new Set();
                if (Dt === "auto") for (let zt = 0; zt < dt.values.length; zt += 2) Tt.add(vu(dt.values[zt]));
                else Tt.add(Dt);
                let ft = !1;
                for (const zt of Tt) if (!m.horizontal[zt]) if (ft) m.horizontal[zt] = m.horizontal[0];
                else {
                  const bt = el(L, i.glyphMap, i.glyphPositions, i.imagePositions, w, yt, M, "center", zt, et, B, b.ay.horizontal, !1, x, T);
                  bt && (m.horizontal[zt] = bt, ft = bt.positionedLines.length === 1);
                }
                At();
              } else {
                Dt === "auto" && (Dt = vu(ot));
                const Tt = el(L, i.glyphMap, i.glyphPositions, i.imagePositions, w, yt, M, ot, Dt, et, B, b.ay.horizontal, !1, x, T);
                Tt && (m.horizontal[Dt] = Tt), At(), qn(U) && l && D && (m.vertical = el(L, i.glyphMap, i.glyphPositions, i.imagePositions, w, yt, M, ot, Dt, et, B, b.ay.vertical, !1, x, T));
              }
            }
            let P = !1;
            if (y.icon && y.icon.name) {
              const U = i.imageMap[y.icon.name];
              U && (O = zz(i.imagePositions[y.icon.name], s.get("icon-offset").evaluate(y, {}, i.canonical), s.get("icon-anchor").evaluate(y, {}, i.canonical)), P = !!U.sdf, i.bucket.sdfIcons === void 0 ? i.bucket.sdfIcons = P : i.bucket.sdfIcons !== P && we("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (U.pixelRatio !== i.bucket.pixelRatio || s.get("icon-rotate").constantOr(1) !== 0) && (i.bucket.iconsNeedLinear = !0));
            }
            const k = Bh(m.horizontal) || m.vertical;
            i.bucket.iconsInText = !!k && k.iconsInText, (k || O) && qz(i.bucket, y, m, O, i.imageMap, a, x, A, B, P, i.canonical, i.subdivisionGranularity);
          }
          i.showCollisionBoxes && i.bucket.generateCollisionDebugBuffers();
        }, b.cR = au, b.cS = Mu, b.cT = cu, b.cU = zg, b.cV = uu, b.cW = Mo, b.cX = function(i, t, s, n, a, M) {
          let l = xh(i, t, s, a, 0);
          return l = xh(l, t, n, M, 1), l;
        }, b.cY = class {
          constructor(i) {
            this.maxEntries = i, this.map = /* @__PURE__ */ new Map();
          }
          get(i) {
            const t = this.map.get(i);
            return t !== void 0 && (this.map.delete(i), this.map.set(i, t)), t;
          }
          set(i, t) {
            if (this.map.has(i)) this.map.delete(i);
            else if (this.map.size >= this.maxEntries) {
              const s = this.map.keys().next().value;
              this.map.delete(s);
            }
            this.map.set(i, t);
          }
          clear() {
            this.map.clear();
          }
        }, b.cZ = Ng, b.c_ = wh, b.ca = VD, b.cb = class extends Ka {
        }, b.cc = eu, b.cd = function(i) {
          return i <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(i) / Math.LN2));
        }, b.ce = eg, b.cf = function(i, t, s) {
          var n = t[0], a = t[1], M = t[2], l = s[3] * n + s[7] * a + s[11] * M + s[15];
          return i[0] = (s[0] * n + s[4] * a + s[8] * M + s[12]) / (l = l || 1), i[1] = (s[1] * n + s[5] * a + s[9] * M + s[13]) / l, i[2] = (s[2] * n + s[6] * a + s[10] * M + s[14]) / l, i;
        }, b.cg = class extends DM {
        }, b.ch = class extends o {
        }, b.ci = function(i, t) {
          return i[0] === t[0] && i[1] === t[1] && i[2] === t[2] && i[3] === t[3] && i[4] === t[4] && i[5] === t[5] && i[6] === t[6] && i[7] === t[7] && i[8] === t[8] && i[9] === t[9] && i[10] === t[10] && i[11] === t[11] && i[12] === t[12] && i[13] === t[13] && i[14] === t[14] && i[15] === t[15];
        }, b.cj = function(i, t) {
          var s = i[0], n = i[1], a = i[2], M = i[3], l = i[4], D = i[5], N = i[6], y = i[7], w = i[8], T = i[9], x = i[10], A = i[11], m = i[12], L = i[13], O = i[14], B = i[15], P = t[0], k = t[1], U = t[2], K = t[3], et = t[4], ot = t[5], dt = t[6], Dt = t[7], yt = t[8], At = t[9], Tt = t[10], ft = t[11], zt = t[12], bt = t[13], Qt = t[14], St = t[15];
          return Math.abs(s - P) <= je * Math.max(1, Math.abs(s), Math.abs(P)) && Math.abs(n - k) <= je * Math.max(1, Math.abs(n), Math.abs(k)) && Math.abs(a - U) <= je * Math.max(1, Math.abs(a), Math.abs(U)) && Math.abs(M - K) <= je * Math.max(1, Math.abs(M), Math.abs(K)) && Math.abs(l - et) <= je * Math.max(1, Math.abs(l), Math.abs(et)) && Math.abs(D - ot) <= je * Math.max(1, Math.abs(D), Math.abs(ot)) && Math.abs(N - dt) <= je * Math.max(1, Math.abs(N), Math.abs(dt)) && Math.abs(y - Dt) <= je * Math.max(1, Math.abs(y), Math.abs(Dt)) && Math.abs(w - yt) <= je * Math.max(1, Math.abs(w), Math.abs(yt)) && Math.abs(T - At) <= je * Math.max(1, Math.abs(T), Math.abs(At)) && Math.abs(x - Tt) <= je * Math.max(1, Math.abs(x), Math.abs(Tt)) && Math.abs(A - ft) <= je * Math.max(1, Math.abs(A), Math.abs(ft)) && Math.abs(m - zt) <= je * Math.max(1, Math.abs(m), Math.abs(zt)) && Math.abs(L - bt) <= je * Math.max(1, Math.abs(L), Math.abs(bt)) && Math.abs(O - Qt) <= je * Math.max(1, Math.abs(O), Math.abs(Qt)) && Math.abs(B - St) <= je * Math.max(1, Math.abs(B), Math.abs(St));
        }, b.ck = function(i, t) {
          return i[0] = t[0], i[1] = t[1], i[2] = t[2], i[3] = t[3], i[4] = t[4], i[5] = t[5], i[6] = t[6], i[7] = t[7], i[8] = t[8], i[9] = t[9], i[10] = t[10], i[11] = t[11], i[12] = t[12], i[13] = t[13], i[14] = t[14], i[15] = t[15], i;
        }, b.cl = (i) => i.type === "symbol", b.cm = (i) => i.type === "circle", b.cn = (i) => i.type === "heatmap", b.co = (i) => i.type === "line", b.cp = (i) => i.type === "fill", b.cq = (i) => i.type === "fill-extrusion", b.cr = (i) => i.type === "hillshade", b.cs = (i) => i.type === "color-relief", b.ct = (i) => i.type === "background", b.cu = (i) => i.type === "custom", b.cv = ki, b.cw = function(i, t, s) {
          const n = ya(t.x - s.x, t.y - s.y), a = ya(i.x - s.x, i.y - s.y);
          var M, l;
          return Ts(Math.atan2(n[0] * a[1] - n[1] * a[0], (M = n)[0] * (l = a)[0] + M[1] * l[1]));
        }, b.cx = Fi, b.cy = function(i, t) {
          return jn[t] && (i instanceof MouseEvent || i instanceof WheelEvent);
        }, b.cz = function(i, t) {
          return mn[t] && "touches" in i;
        }, b.d = E, b.d0 = function(i, t, s, n, a) {
          return u(this, void 0, void 0, (function* () {
            if (rr()) try {
              return yield Yr(i, t, s, n, a);
            } catch {
            }
            return (function(M, l, D, N, y) {
              const w = M.width, T = M.height;
              Ui && ci || (Ui = new OffscreenCanvas(w, T), ci = Ui.getContext("2d", { willReadFrequently: !0 })), Ui.width = w, Ui.height = T, ci.drawImage(M, 0, 0, w, T);
              const x = ci.getImageData(l, D, N, y);
              return ci.clearRect(0, 0, w, T), x.data;
            })(i, t, s, n, a);
          }));
        }, b.d1 = rg, b.d2 = Qi, b.d3 = Ya, b.d4 = qi, b.e = rs, b.f = (i) => u(void 0, void 0, void 0, (function* () {
          if (i.byteLength === 0) return createImageBitmap(new ImageData(1, 1));
          const t = new Blob([new Uint8Array(i)], { type: "image/png" });
          try {
            return createImageBitmap(t);
          } catch (s) {
            throw new Error(`Could not load image because of ${s.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`);
          }
        })), b.g = Xr, b.h = (i) => new Promise(((t, s) => {
          const n = new Image();
          n.onload = () => {
            t(n), URL.revokeObjectURL(n.src), n.onload = null, window.requestAnimationFrame((() => {
              n.src = Mi;
            }));
          }, n.onerror = () => s(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
          const a = new Blob([new Uint8Array(i)], { type: "image/png" });
          n.src = i.byteLength ? URL.createObjectURL(a) : Mi;
        })), b.i = ai, b.j = (i, t) => tt(rs(i, { type: "json" }), t), b.k = H, b.l = V, b.m = tt, b.n = (i, t) => tt(rs(i, { type: "arrayBuffer" }), t), b.o = function(i) {
          return new uu(i).readFields(oz, []);
        }, b.p = bg, b.q = function(i) {
          return /[\u02EA\u02EB\u1100-\u11FF\u2E80-\u2FDF\u3000-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u4DBF\u4E00-\uA48C\uA490-\uA4C6\uA960-\uA97C\uAC00-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFE10-\uFE1F\uFE30-\uFE4F\uFF00-\uFFEF]|\uD81B[\uDFE0-\uDFFF]|[\uD81C-\uD822\uD840-\uD868\uD86A-\uD86D\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD88C][\uDC00-\uDFFF]|\uD823[\uDC00-\uDCD5\uDCFF-\uDD1E\uDD80-\uDDF2]|\uD82B[\uDFF0-\uDFFF]|\uD82C[\uDC00-\uDEFB]|\uD83C[\uDE00-\uDEFF]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEAD\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0\uDFF0-\uDFFF]|\uD87B[\uDC00-\uDE5D]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD88D[\uDC00-\uDC79]/gim.test(String.fromCodePoint(i));
        }, b.r = TM, b.s = Xi, b.t = Ms, b.u = X, b.v = Vn, b.w = we, b.x = Fc, b.y = Yl, b.z = $n;
      })), Tl("worker", ["./shared"], (function(b) {
        class u {
          constructor(E, Q) {
            this.keyCache = {}, E && this.replace(E, Q);
          }
          replace(E, Q) {
            this._layerConfigs = {}, this._layers = {}, this.update(E, [], Q);
          }
          update(E, Q, S) {
            for (const H of E) {
              this._layerConfigs[H.id] = H;
              const rt = this._layers[H.id] = b.bS(H, S);
              rt._featureFilter = b.aj(rt.filter, S), this.keyCache[H.id] && delete this.keyCache[H.id];
            }
            for (const H of Q) delete this.keyCache[H], delete this._layerConfigs[H], delete this._layers[H];
            this.familiesBySource = {};
            const V = b.cL(Object.values(this._layerConfigs), this.keyCache);
            for (const H of V) {
              const rt = H.map(((_t) => this._layers[_t.id])), X = rt[0];
              if (X.visibility === "none") continue;
              const it = X.source || "";
              let lt = this.familiesBySource[it];
              lt || (lt = this.familiesBySource[it] = {});
              const ut = X.sourceLayer || b.a9;
              let ht = lt[ut];
              ht || (ht = lt[ut] = []), ht.push(rt);
            }
          }
        }
        class mt {
          constructor(E) {
            const Q = {}, S = [];
            for (const X in E) {
              const it = E[X], lt = Q[X] = {};
              for (const ut in it) {
                const ht = it[+ut];
                if (!ht || ht.bitmap.width === 0 || ht.bitmap.height === 0) continue;
                const _t = { x: 0, y: 0, w: ht.bitmap.width + 2, h: ht.bitmap.height + 2 };
                S.push(_t), lt[ut] = { rect: _t, metrics: ht.metrics };
              }
            }
            const { w: V, h: H } = b.p(S), rt = new b.r({ width: V || 1, height: H || 1 });
            for (const X in E) {
              const it = E[X];
              for (const lt in it) {
                const ut = it[+lt];
                if (!ut || ut.bitmap.width === 0 || ut.bitmap.height === 0) continue;
                const ht = Q[X][lt].rect;
                b.r.copy(ut.bitmap, rt, { x: 0, y: 0 }, { x: ht.x + 1, y: ht.y + 1 }, ut.bitmap);
              }
            }
            this.image = rt, this.positions = Q;
          }
        }
        b.cM("GlyphAtlas", mt);
        class Qi {
          constructor(E) {
            this.tileID = new b.a1(E.tileID.overscaledZ, E.tileID.wrap, E.tileID.canonical.z, E.tileID.canonical.x, E.tileID.canonical.y), this.uid = E.uid, this.zoom = E.zoom, this.pixelRatio = E.pixelRatio, this.tileSize = E.tileSize, this.source = E.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = E.showCollisionBoxes, this.collectResourceTiming = !!E.collectResourceTiming, this.returnDependencies = !!E.returnDependencies, this.promoteId = E.promoteId, this.inFlightDependencies = [];
          }
          parse(E, Q, S, V, H) {
            return b._(this, void 0, void 0, (function* () {
              this.status = "parsing", this.data = E, this.collisionBoxArray = new b.ah();
              const rt = new b.cN(Object.keys(E.layers).sort()), X = new b.cO(this.tileID, this.promoteId);
              X.bucketLayerIDs = [];
              const it = {}, lt = { featureIndex: X, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, dashDependencies: {}, availableImages: S, subdivisionGranularity: H }, ut = Q.familiesBySource[this.source];
              for (const Ot in ut) {
                const kt = E.layers[Ot];
                if (!kt) continue;
                kt.version === 1 && b.w(`Vector tile source "${this.source}" layer "${Ot}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
                const fs = rt.encode(Ot), gr = [];
                for (let Ve = 0; Ve < kt.length; Ve++) {
                  const Ft = kt.feature(Ve), wi = X.getId(Ft, Ot);
                  gr.push({ feature: Ft, id: wi, index: Ve, sourceLayerIndex: fs });
                }
                for (const Ve of ut[Ot]) {
                  const Ft = Ve[0];
                  Ft.source !== this.source && b.w(`layer.source = ${Ft.source} does not equal this.source = ${this.source}`), Ft.isHidden(this.zoom, !0) || (Cs(Ve, this.zoom, S), (it[Ft.id] = Ft.createBucket({ index: X.bucketLayerIDs.length, layers: Ve, zoom: this.zoom, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: fs, sourceID: this.source })).populate(gr, lt, this.tileID.canonical), X.bucketLayerIDs.push(Ve.map(((wi) => wi.id))));
                }
              }
              const ht = b.bX(lt.glyphDependencies, ((Ot) => Object.keys(Ot).map(Number)));
              this.inFlightDependencies.forEach(((Ot) => Ot?.abort())), this.inFlightDependencies = [];
              let _t = Promise.resolve({});
              if (Object.keys(ht).length) {
                const Ot = new AbortController();
                this.inFlightDependencies.push(Ot), _t = V.sendAsync({ type: "GG", data: { stacks: ht, source: this.source, tileID: this.tileID, type: "glyphs" } }, Ot);
              }
              const vt = Object.keys(lt.iconDependencies);
              let Xt = Promise.resolve({});
              if (vt.length) {
                const Ot = new AbortController();
                this.inFlightDependencies.push(Ot), Xt = V.sendAsync({ type: "GI", data: { icons: vt, source: this.source, tileID: this.tileID, type: "icons" } }, Ot);
              }
              const _e = Object.keys(lt.patternDependencies);
              let Zt = Promise.resolve({});
              if (_e.length) {
                const Ot = new AbortController();
                this.inFlightDependencies.push(Ot), Zt = V.sendAsync({ type: "GI", data: { icons: _e, source: this.source, tileID: this.tileID, type: "patterns" } }, Ot);
              }
              const te = lt.dashDependencies;
              let oe = Promise.resolve({});
              if (Object.keys(te).length) {
                const Ot = new AbortController();
                this.inFlightDependencies.push(Ot), oe = V.sendAsync({ type: "GDA", data: { dashes: te } }, Ot);
              }
              const [It, De, Me, ke] = yield Promise.all([_t, Xt, Zt, oe]), ce = new mt(It), pt = new b.cP(De, Me);
              for (const Ot in it) {
                const kt = it[Ot];
                kt instanceof b.ai ? (Cs(kt.layers, this.zoom, S), b.cQ({ bucket: kt, glyphMap: It, glyphPositions: ce.positions, imageMap: De, imagePositions: pt.iconPositions, showCollisionBoxes: this.showCollisionBoxes, canonical: this.tileID.canonical, subdivisionGranularity: lt.subdivisionGranularity })) : kt.hasDependencies && (kt instanceof b.cR || kt instanceof b.cS || kt instanceof b.cT) && (Cs(kt.layers, this.zoom, S), kt.addFeatures(lt, this.tileID.canonical, pt.patternPositions, ke));
              }
              return this.status = "done", { buckets: Object.values(it).filter(((Ot) => !Ot.isEmpty())), featureIndex: X, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: ce.image, imageAtlas: pt, dashPositions: ke, glyphMap: this.returnDependencies ? It : null, iconMap: this.returnDependencies ? De : null, glyphPositions: this.returnDependencies ? ce.positions : null };
            }));
          }
        }
        function Cs(tt, E, Q) {
          const S = new b.H(E);
          for (const V of tt) V.recalculate(S, Q);
        }
        class vr extends b.cW {
          constructor(E, Q) {
            super(new b.cV(), 0, Q, [], []), this.feature = E, this.type = E.type, this.properties = E.tags ? E.tags : {}, "id" in E && (typeof E.id == "string" ? this.id = parseInt(E.id, 10) : typeof E.id != "number" || isNaN(E.id) || (this.id = E.id));
          }
          loadGeometry() {
            const E = [], Q = this.feature.type === 1 ? [this.feature.geometry] : this.feature.geometry;
            for (const S of Q) {
              const V = [];
              for (const H of S) V.push(new b.P(H[0], H[1]));
              E.push(V);
            }
            return E;
          }
        }
        class wn extends b.cU {
          constructor(E, Q) {
            super(new b.cV()), this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.version = Q ? Q.version : 1, this.extent = Q ? Q.extent : 4096, this.length = E.length, this.features = E;
          }
          feature(E) {
            return new vr(this.features[E], this.extent);
          }
        }
        function Ke(tt, E) {
          E.writeVarintField(15, tt.version || 1), E.writeStringField(1, tt.name || ""), E.writeVarintField(5, tt.extent || 4096);
          const Q = { keys: [], values: [], keycache: {}, valuecache: {} };
          for (let H = 0; H < tt.length; H++) Q.feature = tt.feature(H), E.writeMessage(2, vi, Q);
          const S = Q.keys;
          for (const H of S) E.writeStringField(3, H);
          const V = Q.values;
          for (const H of V) E.writeMessage(4, Ie, H);
        }
        function vi(tt, E) {
          if (!tt.feature) return;
          const Q = tt.feature;
          Q.id !== void 0 && E.writeVarintField(1, Q.id), E.writeMessage(2, $t, tt), E.writeVarintField(3, Q.type), E.writeMessage(4, je, Q);
        }
        function $t(tt, E) {
          for (const Q in tt.feature?.properties) {
            let S = tt.feature.properties[Q], V = tt.keycache[Q];
            if (S === null) continue;
            V === void 0 && (tt.keys.push(Q), V = tt.keys.length - 1, tt.keycache[Q] = V), E.writeVarint(V), typeof S != "string" && typeof S != "boolean" && typeof S != "number" && (S = JSON.stringify(S));
            const H = typeof S + ":" + S;
            let rt = tt.valuecache[H];
            rt === void 0 && (tt.values.push(S), rt = tt.values.length - 1, tt.valuecache[H] = rt), E.writeVarint(rt);
          }
        }
        function gt(tt, E) {
          return (E << 3) + (7 & tt);
        }
        function rr(tt) {
          return tt << 1 ^ tt >> 31;
        }
        function je(tt, E) {
          const Q = tt.loadGeometry(), S = tt.type;
          let V = 0, H = 0;
          for (const rt of Q) {
            let X = 1;
            S === 1 && (X = rt.length), E.writeVarint(gt(1, X));
            const it = S === 3 ? rt.length - 1 : rt.length;
            for (let lt = 0; lt < it; lt++) {
              lt === 1 && S !== 1 && E.writeVarint(gt(2, it - 1));
              const ut = rt[lt].x - V, ht = rt[lt].y - H;
              E.writeVarint(rr(ut)), E.writeVarint(rr(ht)), V += ut, H += ht;
            }
            tt.type === 3 && E.writeVarint(gt(7, 1));
          }
        }
        function Ie(tt, E) {
          const Q = typeof tt;
          Q === "string" ? E.writeStringField(1, tt) : Q === "boolean" ? E.writeBooleanField(7, tt) : Q === "number" && (tt % 1 != 0 ? E.writeDoubleField(3, tt) : tt < 0 ? E.writeSVarintField(6, tt) : E.writeVarintField(5, tt));
        }
        class Br extends b.cW {
          constructor(E, Q, S, V, H) {
            super(new b.cV(), 0, H, [], []), this.type = E, this.properties = S || {}, this.extent = H, this.pointsArray = Q, this.id = V;
          }
          loadGeometry() {
            return this.pointsArray.map(((E) => E.map(((Q) => new b.P(Q.x, Q.y)))));
          }
        }
        class Sr extends b.cU {
          constructor(E, Q, S) {
            super(new b.cV()), this.version = 2, this._myFeatures = E, this.name = Q, this.length = E.length, this.extent = S;
          }
          feature(E) {
            return this._myFeatures[E];
          }
        }
        class pn {
          constructor() {
            this.layers = {};
          }
          addLayer(E) {
            this.layers[E.name] = E;
          }
        }
        function ps(tt) {
          let E = (function(Q) {
            const S = new b.cV();
            return (function(V, H) {
              for (const rt in V.layers) H.writeMessage(3, Ke, V.layers[rt]);
            })(Q, S), S.finish();
          })(tt);
          return E.byteOffset === 0 && E.byteLength === E.buffer.byteLength || (E = new Uint8Array(E)), { vectorTile: tt, rawData: E.buffer };
        }
        function da(tt, E, Q) {
          const { extent: S } = tt, V = Math.pow(2, Q.z - E.z), H = (Q.x - E.x * V) * S, rt = (Q.y - E.y * V) * S, X = [];
          for (let it = 0; it < tt.length; it++) {
            const lt = tt.feature(it);
            let ut = lt.loadGeometry();
            for (const _t of ut) for (const vt of _t) vt.x = vt.x * V - H, vt.y = vt.y * V - rt;
            const ht = 128;
            ut = b.cX(ut, lt.type, -ht, -ht, S + ht, S + ht), ut.length !== 0 && X.push(new Br(lt.type, ut, lt.properties, lt.id, S));
          }
          return new Sr(X, tt.name, S);
        }
        class Ii {
          constructor(E, Q, S) {
            this.actor = E, this.layerIndex = Q, this.availableImages = S, this.fetching = {}, this.loading = {}, this.loaded = {}, this.overzoomedTileResultCache = new b.cY(1e3);
          }
          loadVectorTile(E, Q) {
            return b._(this, void 0, void 0, (function* () {
              const S = yield b.n(E.request, Q);
              try {
                return { vectorTile: E.encoding !== "mlt" ? new b.cZ(new b.cV(S.data)) : new b.c_(S.data), rawData: S.data, cacheControl: S.cacheControl, expires: S.expires };
              } catch (V) {
                const H = new Uint8Array(S.data);
                let rt = `Unable to parse the tile at ${E.request.url}, `;
                throw rt += H[0] === 31 && H[1] === 139 ? "please make sure the data is not gzipped and that you have configured the relevant header in the server" : `got error: ${V.message}`, new Error(rt);
              }
            }));
          }
          loadTile(E) {
            return b._(this, void 0, void 0, (function* () {
              const { uid: Q, overzoomParameters: S } = E;
              S && (E.request = S.overzoomRequest);
              const V = !!(E && E.request && E.request.collectResourceTiming) && new b.c$(E.request), H = new Qi(E);
              this.loading[Q] = H;
              const rt = new AbortController();
              H.abort = rt;
              try {
                const X = yield this.loadVectorTile(E, rt);
                if (delete this.loading[Q], !X) return null;
                if (S) {
                  const _t = this._getOverzoomTile(E, X.vectorTile);
                  X.rawData = _t.rawData, X.vectorTile = _t.vectorTile;
                }
                const it = X.rawData, lt = {};
                X.expires && (lt.expires = X.expires), X.cacheControl && (lt.cacheControl = X.cacheControl);
                const ut = {};
                if (V) {
                  const _t = V.finish();
                  _t && (ut.resourceTiming = JSON.parse(JSON.stringify(_t)));
                }
                H.vectorTile = X.vectorTile;
                const ht = H.parse(X.vectorTile, this.layerIndex, this.availableImages, this.actor, E.subdivisionGranularity);
                this.loaded[Q] = H, this.fetching[Q] = { rawTileData: it, cacheControl: lt, resourceTiming: ut };
                try {
                  const _t = yield ht;
                  return b.e({ rawTileData: it.slice(0), encoding: E.encoding }, _t, lt, ut);
                } finally {
                  delete this.fetching[Q];
                }
              } catch (X) {
                throw delete this.loading[Q], H.status = "done", this.loaded[Q] = H, X;
              }
            }));
          }
          _getOverzoomTile(E, Q) {
            const { tileID: S, source: V, overzoomParameters: H } = E, { maxZoomTileID: rt } = H, X = `${rt.key}_${S.key}`, it = this.overzoomedTileResultCache.get(X);
            if (it) return it;
            const lt = new pn(), ut = this.layerIndex.familiesBySource[V];
            for (const _t in ut) {
              const vt = Q.layers[_t];
              if (!vt) continue;
              const Xt = da(vt, rt, S.canonical);
              Xt.length > 0 && lt.addLayer(Xt);
            }
            const ht = ps(lt);
            return this.overzoomedTileResultCache.set(X, ht), ht;
          }
          reloadTile(E) {
            return b._(this, void 0, void 0, (function* () {
              const Q = E.uid;
              if (!this.loaded || !this.loaded[Q]) throw new Error("Should not be trying to reload a tile that was never loaded or has been removed");
              const S = this.loaded[Q];
              if (S.showCollisionBoxes = E.showCollisionBoxes, S.status === "parsing") {
                const V = yield S.parse(S.vectorTile, this.layerIndex, this.availableImages, this.actor, E.subdivisionGranularity);
                let H;
                if (this.fetching[Q]) {
                  const { rawTileData: rt, cacheControl: X, resourceTiming: it } = this.fetching[Q];
                  delete this.fetching[Q], H = b.e({ rawTileData: rt.slice(0), encoding: E.encoding }, V, X, it);
                } else H = V;
                return H;
              }
              if (S.status === "done" && S.vectorTile) return S.parse(S.vectorTile, this.layerIndex, this.availableImages, this.actor, E.subdivisionGranularity);
            }));
          }
          abortTile(E) {
            return b._(this, void 0, void 0, (function* () {
              const Q = this.loading, S = E.uid;
              Q && Q[S] && Q[S].abort && (Q[S].abort.abort(), delete Q[S]);
            }));
          }
          removeTile(E) {
            return b._(this, void 0, void 0, (function* () {
              this.loaded && this.loaded[E.uid] && delete this.loaded[E.uid];
            }));
          }
        }
        class Bi {
          constructor() {
            this.loaded = {};
          }
          loadTile(E) {
            return b._(this, void 0, void 0, (function* () {
              const { uid: Q, encoding: S, rawImageData: V, redFactor: H, greenFactor: rt, blueFactor: X, baseShift: it } = E, lt = V.width + 2, ut = V.height + 2, ht = b.b(V) ? new b.R({ width: lt, height: ut }, yield b.d0(V, -1, -1, lt, ut)) : V, _t = new b.d1(Q, ht, S, H, rt, X, it);
              return this.loaded = this.loaded || {}, this.loaded[Q] = _t, _t;
            }));
          }
          removeTile(E) {
            const Q = this.loaded, S = E.uid;
            Q && Q[S] && delete Q[S];
          }
        }
        var nr, Si, ar = (function() {
          if (Si) return nr;
          function tt(Q, S) {
            if (Q.length !== 0) {
              E(Q[0], S);
              for (var V = 1; V < Q.length; V++) E(Q[V], !S);
            }
          }
          function E(Q, S) {
            for (var V = 0, H = 0, rt = 0, X = Q.length, it = X - 1; rt < X; it = rt++) {
              var lt = (Q[rt][0] - Q[it][0]) * (Q[it][1] + Q[rt][1]), ut = V + lt;
              H += Math.abs(V) >= Math.abs(lt) ? V - ut + lt : lt - ut + V, V = ut;
            }
            V + H >= 0 != !!S && Q.reverse();
          }
          return Si = 1, nr = function Q(S, V) {
            var H, rt = S && S.type;
            if (rt === "FeatureCollection") for (H = 0; H < S.features.length; H++) Q(S.features[H], V);
            else if (rt === "GeometryCollection") for (H = 0; H < S.geometries.length; H++) Q(S.geometries[H], V);
            else if (rt === "Feature") Q(S.geometry, V);
            else if (rt === "Polygon") tt(S.coordinates, V);
            else if (rt === "MultiPolygon") for (H = 0; H < S.coordinates.length; H++) tt(S.coordinates[H], V);
            return S;
          };
        })(), Tn = b.d2(ar);
        const fn = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: !1, generateId: !1, reduce: null, map: (tt) => tt }, xn = Math.fround || (Zs = new Float32Array(1), (tt) => (Zs[0] = +tt, Zs[0]));
        var Zs;
        class ya {
          constructor(E) {
            this.options = Object.assign(Object.create(fn), E), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
          }
          load(E) {
            const { log: Q, minZoom: S, maxZoom: V } = this.options;
            Q && console.time("total time");
            const H = `prepare ${E.length} points`;
            Q && console.time(H), this.points = E;
            const rt = [];
            for (let it = 0; it < E.length; it++) {
              const lt = E[it];
              if (!lt.geometry) continue;
              const [ut, ht] = lt.geometry.coordinates, _t = xn(ni(ut)), vt = xn(or(ht));
              rt.push(_t, vt, 1 / 0, it, -1, 1), this.options.reduce && rt.push(0);
            }
            let X = this.trees[V + 1] = this._createTree(rt);
            Q && console.timeEnd(H);
            for (let it = V; it >= S; it--) {
              const lt = +Date.now();
              X = this.trees[it] = this._createTree(this._cluster(X, it)), Q && console.log("z%d: %d clusters in %dms", it, X.numItems, +Date.now() - lt);
            }
            return Q && console.timeEnd("total time"), this;
          }
          getClusters(E, Q) {
            let S = ((E[0] + 180) % 360 + 360) % 360 - 180;
            const V = Math.max(-90, Math.min(90, E[1]));
            let H = E[2] === 180 ? 180 : ((E[2] + 180) % 360 + 360) % 360 - 180;
            const rt = Math.max(-90, Math.min(90, E[3]));
            if (E[2] - E[0] >= 360) S = -180, H = 180;
            else if (S > H) {
              const ht = this.getClusters([S, V, 180, rt], Q), _t = this.getClusters([-180, V, H, rt], Q);
              return ht.concat(_t);
            }
            const X = this.trees[this._limitZoom(Q)], it = X.range(ni(S), or(rt), ni(H), or(V)), lt = X.data, ut = [];
            for (const ht of it) {
              const _t = this.stride * ht;
              ut.push(lt[_t + 5] > 1 ? se(lt, _t, this.clusterProps) : this.points[lt[_t + 3]]);
            }
            return ut;
          }
          getChildren(E) {
            const Q = this._getOriginId(E), S = this._getOriginZoom(E), V = "No cluster with the specified id.", H = this.trees[S];
            if (!H) throw new Error(V);
            const rt = H.data;
            if (Q * this.stride >= rt.length) throw new Error(V);
            const X = this.options.radius / (this.options.extent * Math.pow(2, S - 1)), it = H.within(rt[Q * this.stride], rt[Q * this.stride + 1], X), lt = [];
            for (const ut of it) {
              const ht = ut * this.stride;
              rt[ht + 4] === E && lt.push(rt[ht + 5] > 1 ? se(rt, ht, this.clusterProps) : this.points[rt[ht + 3]]);
            }
            if (lt.length === 0) throw new Error(V);
            return lt;
          }
          getLeaves(E, Q, S) {
            const V = [];
            return this._appendLeaves(V, E, Q = Q || 10, S = S || 0, 0), V;
          }
          getTile(E, Q, S) {
            const V = this.trees[this._limitZoom(E)], H = Math.pow(2, E), { extent: rt, radius: X } = this.options, it = X / rt, lt = (S - it) / H, ut = (S + 1 + it) / H, ht = { features: [] };
            return this._addTileFeatures(V.range((Q - it) / H, lt, (Q + 1 + it) / H, ut), V.data, Q, S, H, ht), Q === 0 && this._addTileFeatures(V.range(1 - it / H, lt, 1, ut), V.data, H, S, H, ht), Q === H - 1 && this._addTileFeatures(V.range(0, lt, it / H, ut), V.data, -1, S, H, ht), ht.features.length ? ht : null;
          }
          getClusterExpansionZoom(E) {
            let Q = this._getOriginZoom(E) - 1;
            for (; Q <= this.options.maxZoom; ) {
              const S = this.getChildren(E);
              if (Q++, S.length !== 1) break;
              E = S[0].properties.cluster_id;
            }
            return Q;
          }
          _appendLeaves(E, Q, S, V, H) {
            const rt = this.getChildren(Q);
            for (const X of rt) {
              const it = X.properties;
              if (it && it.cluster ? H + it.point_count <= V ? H += it.point_count : H = this._appendLeaves(E, it.cluster_id, S, V, H) : H < V ? H++ : E.push(X), E.length === S) break;
            }
            return H;
          }
          _createTree(E) {
            const Q = new b.aS(E.length / this.stride | 0, this.options.nodeSize, Float32Array);
            for (let S = 0; S < E.length; S += this.stride) Q.add(E[S], E[S + 1]);
            return Q.finish(), Q.data = E, Q;
          }
          _addTileFeatures(E, Q, S, V, H, rt) {
            for (const X of E) {
              const it = X * this.stride, lt = Q[it + 5] > 1;
              let ut, ht, _t;
              if (lt) ut = kr(Q, it, this.clusterProps), ht = Q[it], _t = Q[it + 1];
              else {
                const _e = this.points[Q[it + 3]];
                ut = _e.properties;
                const [Zt, te] = _e.geometry.coordinates;
                ht = ni(Zt), _t = or(te);
              }
              const vt = { type: 1, geometry: [[Math.round(this.options.extent * (ht * H - S)), Math.round(this.options.extent * (_t * H - V))]], tags: ut };
              let Xt;
              Xt = lt || this.options.generateId ? Q[it + 3] : this.points[Q[it + 3]].id, Xt !== void 0 && (vt.id = Xt), rt.features.push(vt);
            }
          }
          _limitZoom(E) {
            return Math.max(this.options.minZoom, Math.min(Math.floor(+E), this.options.maxZoom + 1));
          }
          _cluster(E, Q) {
            const { radius: S, extent: V, reduce: H, minPoints: rt } = this.options, X = S / (V * Math.pow(2, Q)), it = E.data, lt = [], ut = this.stride;
            for (let ht = 0; ht < it.length; ht += ut) {
              if (it[ht + 2] <= Q) continue;
              it[ht + 2] = Q;
              const _t = it[ht], vt = it[ht + 1], Xt = E.within(it[ht], it[ht + 1], X), _e = it[ht + 5];
              let Zt = _e;
              for (const te of Xt) {
                const oe = te * ut;
                it[oe + 2] > Q && (Zt += it[oe + 5]);
              }
              if (Zt > _e && Zt >= rt) {
                let te, oe = _t * _e, It = vt * _e, De = -1;
                const Me = (ht / ut << 5) + (Q + 1) + this.points.length;
                for (const ke of Xt) {
                  const ce = ke * ut;
                  if (it[ce + 2] <= Q) continue;
                  it[ce + 2] = Q;
                  const pt = it[ce + 5];
                  oe += it[ce] * pt, It += it[ce + 1] * pt, it[ce + 4] = Me, H && (te || (te = this._map(it, ht, !0), De = this.clusterProps.length, this.clusterProps.push(te)), H(te, this._map(it, ce)));
                }
                it[ht + 4] = Me, lt.push(oe / Zt, It / Zt, 1 / 0, Me, -1, Zt), H && lt.push(De);
              } else {
                for (let te = 0; te < ut; te++) lt.push(it[ht + te]);
                if (Zt > 1) for (const te of Xt) {
                  const oe = te * ut;
                  if (!(it[oe + 2] <= Q)) {
                    it[oe + 2] = Q;
                    for (let It = 0; It < ut; It++) lt.push(it[oe + It]);
                  }
                }
              }
            }
            return lt;
          }
          _getOriginId(E) {
            return E - this.points.length >> 5;
          }
          _getOriginZoom(E) {
            return (E - this.points.length) % 32;
          }
          _map(E, Q, S) {
            if (E[Q + 5] > 1) {
              const rt = this.clusterProps[E[Q + 6]];
              return S ? Object.assign({}, rt) : rt;
            }
            const V = this.points[E[Q + 3]].properties, H = this.options.map(V);
            return S && H === V ? Object.assign({}, H) : H;
          }
        }
        function se(tt, E, Q) {
          return { type: "Feature", id: tt[E + 3], properties: kr(tt, E, Q), geometry: { type: "Point", coordinates: [(S = tt[E], 360 * (S - 0.5)), Ia(tt[E + 1])] } };
          var S;
        }
        function kr(tt, E, Q) {
          const S = tt[E + 5], V = S >= 1e4 ? `${Math.round(S / 1e3)}k` : S >= 1e3 ? Math.round(S / 100) / 10 + "k" : S, H = tt[E + 6], rt = H === -1 ? {} : Object.assign({}, Q[H]);
          return Object.assign(rt, { cluster: !0, cluster_id: tt[E + 3], point_count: S, point_count_abbreviated: V });
        }
        function ni(tt) {
          return tt / 360 + 0.5;
        }
        function or(tt) {
          const E = Math.sin(tt * Math.PI / 180), Q = 0.5 - 0.25 * Math.log((1 + E) / (1 - E)) / Math.PI;
          return Q < 0 ? 0 : Q > 1 ? 1 : Q;
        }
        function Ia(tt) {
          const E = (180 - 360 * tt) * Math.PI / 180;
          return 360 * Math.atan(Math.exp(E)) / Math.PI - 90;
        }
        function ki(tt, E, Q, S) {
          let V = S;
          const H = E + (Q - E >> 1);
          let rt, X = Q - E;
          const it = tt[E], lt = tt[E + 1], ut = tt[Q], ht = tt[Q + 1];
          for (let _t = E + 3; _t < Q; _t += 3) {
            const vt = Fi(tt[_t], tt[_t + 1], it, lt, ut, ht);
            if (vt > V) rt = _t, V = vt;
            else if (vt === V) {
              const Xt = Math.abs(_t - H);
              Xt < X && (rt = _t, X = Xt);
            }
          }
          V > S && (rt - E > 3 && ki(tt, E, rt, S), tt[rt + 2] = V, Q - rt > 3 && ki(tt, rt, Q, S));
        }
        function Fi(tt, E, Q, S, V, H) {
          let rt = V - Q, X = H - S;
          if (rt !== 0 || X !== 0) {
            const it = ((tt - Q) * rt + (E - S) * X) / (rt * rt + X * X);
            it > 1 ? (Q = V, S = H) : it > 0 && (Q += rt * it, S += X * it);
          }
          return rt = tt - Q, X = E - S, rt * rt + X * X;
        }
        function Ds(tt, E, Q, S) {
          const V = { id: tt ?? null, type: E, geometry: Q, tags: S, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
          if (E === "Point" || E === "MultiPoint" || E === "LineString") Vs(V, Q);
          else if (E === "Polygon") Vs(V, Q[0]);
          else if (E === "MultiLineString") for (const H of Q) Vs(V, H);
          else if (E === "MultiPolygon") for (const H of Q) Vs(V, H[0]);
          return V;
        }
        function Vs(tt, E) {
          for (let Q = 0; Q < E.length; Q += 3) tt.minX = Math.min(tt.minX, E[Q]), tt.minY = Math.min(tt.minY, E[Q + 1]), tt.maxX = Math.max(tt.maxX, E[Q]), tt.maxY = Math.max(tt.maxY, E[Q + 1]);
        }
        function rs(tt, E, Q, S) {
          if (!E.geometry) return;
          const V = E.geometry.coordinates;
          if (V && V.length === 0) return;
          const H = E.geometry.type, rt = Math.pow(Q.tolerance / ((1 << Q.maxZoom) * Q.extent), 2);
          let X = [], it = E.id;
          if (Q.promoteId ? it = E.properties[Q.promoteId] : Q.generateId && (it = S || 0), H === "Point") Fr(V, X);
          else if (H === "MultiPoint") for (const lt of V) Fr(lt, X);
          else if (H === "LineString") Yi(V, X, rt, !1);
          else if (H === "MultiLineString") {
            if (Q.lineMetrics) {
              for (const lt of V) X = [], Yi(lt, X, rt, !1), tt.push(Ds(it, "LineString", X, E.properties));
              return;
            }
            Mr(V, X, rt, !1);
          } else if (H === "Polygon") Mr(V, X, rt, !0);
          else {
            if (H !== "MultiPolygon") {
              if (H === "GeometryCollection") {
                for (const lt of E.geometry.geometries) rs(tt, { id: it, geometry: lt, properties: E.properties }, Q, S);
                return;
              }
              throw new Error("Input data is not a valid GeoJSON object.");
            }
            for (const lt of V) {
              const ut = [];
              Mr(lt, ut, rt, !0), X.push(ut);
            }
          }
          tt.push(Ds(it, H, X, E.properties));
        }
        function Fr(tt, E) {
          E.push(ks(tt[0]), An(tt[1]), 0);
        }
        function Yi(tt, E, Q, S) {
          let V, H, rt = 0;
          for (let it = 0; it < tt.length; it++) {
            const lt = ks(tt[it][0]), ut = An(tt[it][1]);
            E.push(lt, ut, 0), it > 0 && (rt += S ? (V * ut - lt * H) / 2 : Math.sqrt(Math.pow(lt - V, 2) + Math.pow(ut - H, 2))), V = lt, H = ut;
          }
          const X = E.length - 3;
          E[2] = 1, ki(E, 0, X, Q), E[X + 2] = 1, E.size = Math.abs(rt), E.start = 0, E.end = E.size;
        }
        function Mr(tt, E, Q, S) {
          for (let V = 0; V < tt.length; V++) {
            const H = [];
            Yi(tt[V], H, Q, S), E.push(H);
          }
        }
        function ks(tt) {
          return tt / 360 + 0.5;
        }
        function An(tt) {
          const E = Math.sin(tt * Math.PI / 180), Q = 0.5 - 0.25 * Math.log((1 + E) / (1 - E)) / Math.PI;
          return Q < 0 ? 0 : Q > 1 ? 1 : Q;
        }
        function we(tt, E, Q, S, V, H, rt, X) {
          if (S /= E, H >= (Q /= E) && rt < S) return tt;
          if (rt < Q || H >= S) return null;
          const it = [];
          for (const lt of tt) {
            const ut = lt.geometry;
            let ht = lt.type;
            const _t = V === 0 ? lt.minX : lt.minY, vt = V === 0 ? lt.maxX : lt.maxY;
            if (_t >= Q && vt < S) {
              it.push(lt);
              continue;
            }
            if (vt < Q || _t >= S) continue;
            let Xt = [];
            if (ht === "Point" || ht === "MultiPoint") Gs(ut, Xt, Q, S, V);
            else if (ht === "LineString") ai(ut, Xt, Q, S, V, !1, X.lineMetrics);
            else if (ht === "MultiLineString") oi(ut, Xt, Q, S, V, !1);
            else if (ht === "Polygon") oi(ut, Xt, Q, S, V, !0);
            else if (ht === "MultiPolygon") for (const _e of ut) {
              const Zt = [];
              oi(_e, Zt, Q, S, V, !0), Zt.length && Xt.push(Zt);
            }
            if (Xt.length) {
              if (X.lineMetrics && ht === "LineString") {
                for (const _e of Xt) it.push(Ds(lt.id, ht, _e, lt.tags));
                continue;
              }
              ht !== "LineString" && ht !== "MultiLineString" || (Xt.length === 1 ? (ht = "LineString", Xt = Xt[0]) : ht = "MultiLineString"), ht !== "Point" && ht !== "MultiPoint" || (ht = Xt.length === 3 ? "Point" : "MultiPoint"), it.push(Ds(lt.id, ht, Xt, lt.tags));
            }
          }
          return it.length ? it : null;
        }
        function Gs(tt, E, Q, S, V) {
          for (let H = 0; H < tt.length; H += 3) {
            const rt = tt[H + V];
            rt >= Q && rt <= S && Mi(E, tt[H], tt[H + 1], tt[H + 2]);
          }
        }
        function ai(tt, E, Q, S, V, H, rt) {
          let X = pe(tt);
          const it = V === 0 ? Yr : Ui;
          let lt, ut, ht = tt.start;
          for (let Zt = 0; Zt < tt.length - 3; Zt += 3) {
            const te = tt[Zt], oe = tt[Zt + 1], It = tt[Zt + 2], De = tt[Zt + 3], Me = tt[Zt + 4], ke = V === 0 ? te : oe, ce = V === 0 ? De : Me;
            let pt = !1;
            rt && (lt = Math.sqrt(Math.pow(te - De, 2) + Math.pow(oe - Me, 2))), ke < Q ? ce > Q && (ut = it(X, te, oe, De, Me, Q), rt && (X.start = ht + lt * ut)) : ke > S ? ce < S && (ut = it(X, te, oe, De, Me, S), rt && (X.start = ht + lt * ut)) : Mi(X, te, oe, It), ce < Q && ke >= Q && (ut = it(X, te, oe, De, Me, Q), pt = !0), ce > S && ke <= S && (ut = it(X, te, oe, De, Me, S), pt = !0), !H && pt && (rt && (X.end = ht + lt * ut), E.push(X), X = pe(tt)), rt && (ht += lt);
          }
          let _t = tt.length - 3;
          const vt = tt[_t], Xt = tt[_t + 1], _e = V === 0 ? vt : Xt;
          _e >= Q && _e <= S && Mi(X, vt, Xt, tt[_t + 2]), _t = X.length - 3, H && _t >= 3 && (X[_t] !== X[0] || X[_t + 1] !== X[1]) && Mi(X, X[0], X[1], X[2]), X.length && E.push(X);
        }
        function pe(tt) {
          const E = [];
          return E.size = tt.size, E.start = tt.start, E.end = tt.end, E;
        }
        function oi(tt, E, Q, S, V, H) {
          for (const rt of tt) ai(rt, E, Q, S, V, H, !1);
        }
        function Mi(tt, E, Q, S) {
          tt.push(E, Q, S);
        }
        function Yr(tt, E, Q, S, V, H) {
          const rt = (H - E) / (S - E);
          return Mi(tt, H, Q + (V - Q) * rt, 1), rt;
        }
        function Ui(tt, E, Q, S, V, H) {
          const rt = (H - Q) / (V - Q);
          return Mi(tt, E + (S - E) * rt, H, 1), rt;
        }
        function ci(tt, E) {
          const Q = [];
          for (let S = 0; S < tt.length; S++) {
            const V = tt[S], H = V.type;
            let rt;
            if (H === "Point" || H === "MultiPoint" || H === "LineString") rt = Xi(V.geometry, E);
            else if (H === "MultiLineString" || H === "Polygon") {
              rt = [];
              for (const X of V.geometry) rt.push(Xi(X, E));
            } else if (H === "MultiPolygon") {
              rt = [];
              for (const X of V.geometry) {
                const it = [];
                for (const lt of X) it.push(Xi(lt, E));
                rt.push(it);
              }
            }
            Q.push(Ds(V.id, H, rt, V.tags));
          }
          return Q;
        }
        function Xi(tt, E) {
          const Q = [];
          Q.size = tt.size, tt.start !== void 0 && (Q.start = tt.start, Q.end = tt.end);
          for (let S = 0; S < tt.length; S += 3) Q.push(tt[S] + E, tt[S + 1], tt[S + 2]);
          return Q;
        }
        function cr(tt, E) {
          if (tt.transformed) return tt;
          const Q = 1 << tt.z, S = tt.x, V = tt.y;
          for (const H of tt.features) {
            const rt = H.geometry, X = H.type;
            if (H.geometry = [], X === 1) for (let it = 0; it < rt.length; it += 2) H.geometry.push(Ts(rt[it], rt[it + 1], E, Q, S, V));
            else for (let it = 0; it < rt.length; it++) {
              const lt = [];
              for (let ut = 0; ut < rt[it].length; ut += 2) lt.push(Ts(rt[it][ut], rt[it][ut + 1], E, Q, S, V));
              H.geometry.push(lt);
            }
          }
          return tt.transformed = !0, tt;
        }
        function Ts(tt, E, Q, S, V, H) {
          return [Math.round(Q * (tt * S - V)), Math.round(Q * (E * S - H))];
        }
        function mn(tt, E, Q, S, V) {
          const H = E === V.maxZoom ? 0 : V.tolerance / ((1 << E) * V.extent), rt = { features: [], numPoints: 0, numSimplified: 0, numFeatures: tt.length, source: null, x: Q, y: S, z: E, transformed: !1, minX: 2, minY: 1, maxX: -1, maxY: 0 };
          for (const X of tt) jn(rt, X, H, V);
          return rt;
        }
        function jn(tt, E, Q, S) {
          const V = E.geometry, H = E.type, rt = [];
          if (tt.minX = Math.min(tt.minX, E.minX), tt.minY = Math.min(tt.minY, E.minY), tt.maxX = Math.max(tt.maxX, E.maxX), tt.maxY = Math.max(tt.maxY, E.maxY), H === "Point" || H === "MultiPoint") for (let X = 0; X < V.length; X += 3) rt.push(V[X], V[X + 1]), tt.numPoints++, tt.numSimplified++;
          else if (H === "LineString") lr(rt, V, tt, Q, !1, !1);
          else if (H === "MultiLineString" || H === "Polygon") for (let X = 0; X < V.length; X++) lr(rt, V[X], tt, Q, H === "Polygon", X === 0);
          else if (H === "MultiPolygon") for (let X = 0; X < V.length; X++) {
            const it = V[X];
            for (let lt = 0; lt < it.length; lt++) lr(rt, it[lt], tt, Q, !0, lt === 0);
          }
          if (rt.length) {
            let X = E.tags || null;
            if (H === "LineString" && S.lineMetrics) {
              X = {};
              for (const lt in E.tags) X[lt] = E.tags[lt];
              X.mapbox_clip_start = V.start / V.size, X.mapbox_clip_end = V.end / V.size;
            }
            const it = { geometry: rt, type: H === "Polygon" || H === "MultiPolygon" ? 3 : H === "LineString" || H === "MultiLineString" ? 2 : 1, tags: X };
            E.id !== null && (it.id = E.id), tt.features.push(it);
          }
        }
        function lr(tt, E, Q, S, V, H) {
          const rt = S * S;
          if (S > 0 && E.size < (V ? rt : S)) return void (Q.numPoints += E.length / 3);
          const X = [];
          for (let it = 0; it < E.length; it += 3) (S === 0 || E[it + 2] > rt) && (Q.numSimplified++, X.push(E[it], E[it + 1])), Q.numPoints++;
          V && (function(it, lt) {
            let ut = 0;
            for (let ht = 0, _t = it.length, vt = _t - 2; ht < _t; vt = ht, ht += 2) ut += (it[ht] - it[vt]) * (it[ht + 1] + it[vt + 1]);
            if (ut > 0 === lt) for (let ht = 0, _t = it.length; ht < _t / 2; ht += 2) {
              const vt = it[ht], Xt = it[ht + 1];
              it[ht] = it[_t - 2 - ht], it[ht + 1] = it[_t - 1 - ht], it[_t - 2 - ht] = vt, it[_t - 1 - ht] = Xt;
            }
          })(X, H), tt.push(X);
        }
        const Ur = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: !1, promoteId: null, generateId: !1, debug: 0 };
        class Wi {
          constructor(E, Q) {
            const S = (Q = this.options = (function(H, rt) {
              for (const X in rt) H[X] = rt[X];
              return H;
            })(Object.create(Ur), Q)).debug;
            if (S && console.time("preprocess data"), Q.maxZoom < 0 || Q.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
            if (Q.promoteId && Q.generateId) throw new Error("promoteId and generateId cannot be used together.");
            let V = (function(H, rt) {
              const X = [];
              if (H.type === "FeatureCollection") for (let it = 0; it < H.features.length; it++) rs(X, H.features[it], rt, it);
              else rs(X, H.type === "Feature" ? H : { geometry: H }, rt);
              return X;
            })(E, Q);
            this.tiles = {}, this.tileCoords = [], S && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", Q.indexMaxZoom, Q.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), V = (function(H, rt) {
              const X = rt.buffer / rt.extent;
              let it = H;
              const lt = we(H, 1, -1 - X, X, 0, -1, 2, rt), ut = we(H, 1, 1 - X, 2 + X, 0, -1, 2, rt);
              return (lt || ut) && (it = we(H, 1, -X, 1 + X, 0, -1, 2, rt) || [], lt && (it = ci(lt, 1).concat(it)), ut && (it = it.concat(ci(ut, -1)))), it;
            })(V, Q), V.length && this.splitTile(V, 0, 0, 0), S && (V.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
          }
          splitTile(E, Q, S, V, H, rt, X) {
            const it = [E, Q, S, V], lt = this.options, ut = lt.debug;
            for (; it.length; ) {
              V = it.pop(), S = it.pop(), Q = it.pop(), E = it.pop();
              const ht = 1 << Q, _t = Xr(Q, S, V);
              let vt = this.tiles[_t];
              if (!vt && (ut > 1 && console.time("creation"), vt = this.tiles[_t] = mn(E, Q, S, V, lt), this.tileCoords.push({ z: Q, x: S, y: V }), ut)) {
                ut > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", Q, S, V, vt.numFeatures, vt.numPoints, vt.numSimplified), console.timeEnd("creation"));
                const pt = `z${Q}`;
                this.stats[pt] = (this.stats[pt] || 0) + 1, this.total++;
              }
              if (vt.source = E, H == null) {
                if (Q === lt.indexMaxZoom || vt.numPoints <= lt.indexMaxPoints) continue;
              } else {
                if (Q === lt.maxZoom || Q === H) continue;
                if (H != null) {
                  const pt = H - Q;
                  if (S !== rt >> pt || V !== X >> pt) continue;
                }
              }
              if (vt.source = null, E.length === 0) continue;
              ut > 1 && console.time("clipping");
              const Xt = 0.5 * lt.buffer / lt.extent, _e = 0.5 - Xt, Zt = 0.5 + Xt, te = 1 + Xt;
              let oe = null, It = null, De = null, Me = null, ke = we(E, ht, S - Xt, S + Zt, 0, vt.minX, vt.maxX, lt), ce = we(E, ht, S + _e, S + te, 0, vt.minX, vt.maxX, lt);
              E = null, ke && (oe = we(ke, ht, V - Xt, V + Zt, 1, vt.minY, vt.maxY, lt), It = we(ke, ht, V + _e, V + te, 1, vt.minY, vt.maxY, lt), ke = null), ce && (De = we(ce, ht, V - Xt, V + Zt, 1, vt.minY, vt.maxY, lt), Me = we(ce, ht, V + _e, V + te, 1, vt.minY, vt.maxY, lt), ce = null), ut > 1 && console.timeEnd("clipping"), it.push(oe || [], Q + 1, 2 * S, 2 * V), it.push(It || [], Q + 1, 2 * S, 2 * V + 1), it.push(De || [], Q + 1, 2 * S + 1, 2 * V), it.push(Me || [], Q + 1, 2 * S + 1, 2 * V + 1);
            }
          }
          getTile(E, Q, S) {
            E = +E, Q = +Q, S = +S;
            const V = this.options, { extent: H, debug: rt } = V;
            if (E < 0 || E > 24) return null;
            const X = 1 << E, it = Xr(E, Q = Q + X & X - 1, S);
            if (this.tiles[it]) return cr(this.tiles[it], H);
            rt > 1 && console.log("drilling down to z%d-%d-%d", E, Q, S);
            let lt, ut = E, ht = Q, _t = S;
            for (; !lt && ut > 0; ) ut--, ht >>= 1, _t >>= 1, lt = this.tiles[Xr(ut, ht, _t)];
            return lt && lt.source ? (rt > 1 && (console.log("found parent tile z%d-%d-%d", ut, ht, _t), console.time("drilling down")), this.splitTile(lt.source, ut, ht, _t, E, Q, S), rt > 1 && console.timeEnd("drilling down"), this.tiles[it] ? cr(this.tiles[it], H) : null) : null;
          }
        }
        function Xr(tt, E, Q) {
          return 32 * ((1 << tt) * Q + E) + tt;
        }
        class ur extends Ii {
          constructor(E, Q, S, V = Hs) {
            super(E, Q, S), this._dataUpdateable = /* @__PURE__ */ new Map(), this._createGeoJSONIndex = V;
          }
          loadVectorTile(E, Q) {
            return b._(this, void 0, void 0, (function* () {
              const S = E.tileID.canonical;
              if (!this._geoJSONIndex) throw new Error("Unable to parse the data into a cluster or geojson");
              const V = this._geoJSONIndex.getTile(S.z, S.x, S.y);
              return V ? ps(new wn(V.features, { version: 2, extent: b.a4 })) : null;
            }));
          }
          loadData(E) {
            return b._(this, void 0, void 0, (function* () {
              var Q;
              (Q = this._pendingRequest) === null || Q === void 0 || Q.abort();
              const S = this._startPerformance(E);
              this._pendingRequest = new AbortController();
              try {
                (!this._pendingData || E.request || E.data || E.dataDiff) && (this._pendingData = this.loadAndProcessGeoJSON(E, this._pendingRequest));
                const V = yield this._pendingData;
                this._geoJSONIndex = this._createGeoJSONIndex(V, E), this.loaded = {};
                const H = E.dataDiff && b.a6(V) ? { applyDiff: !0 } : { data: V };
                return this._finishPerformance(S, E, H), H;
              } catch (V) {
                if (delete this._pendingRequest, b.cH(V)) return { abandoned: !0 };
                throw V;
              }
            }));
          }
          _startPerformance(E) {
            var Q;
            if (!((Q = E?.request) === null || Q === void 0) && Q.collectResourceTiming) return new b.c$(E.request);
          }
          _finishPerformance(E, Q, S) {
            if (!E) return;
            const V = E.finish();
            V && (S.resourceTiming = {}, S.resourceTiming[Q.source] = JSON.parse(JSON.stringify(V)));
          }
          getData() {
            return b._(this, void 0, void 0, (function* () {
              return this._pendingData;
            }));
          }
          reloadTile(E) {
            const Q = this.loaded;
            return Q && Q[E.uid] ? super.reloadTile(E) : this.loadTile(E);
          }
          loadAndProcessGeoJSON(E, Q) {
            return b._(this, void 0, void 0, (function* () {
              let S;
              if (E.request ? S = yield this.loadGeoJSONFromUrl(E.request, E.promoteId, Q) : E.data ? S = this._loadGeoJSONFromObject(E.data, E.promoteId) : E.dataDiff && (S = this._loadGeoJSONFromDiff(E.dataDiff, E.promoteId, E.source)), delete this._pendingRequest, typeof S != "object") throw new Error(`Input data given to '${E.source}' is not a valid GeoJSON object.`);
              return Tn(S, !0), E.filter && (S = this._filterGeoJSON(S, E.filter)), S;
            }));
          }
          loadGeoJSONFromUrl(E, Q, S) {
            return b._(this, void 0, void 0, (function* () {
              const V = yield b.j(E, S);
              return this._dataUpdateable = b.a6(V.data, Q) ? b.a7(V.data, Q) : void 0, V.data;
            }));
          }
          _loadGeoJSONFromObject(E, Q) {
            return this._dataUpdateable = b.a6(E, Q) ? b.a7(E, Q) : void 0, E;
          }
          _loadGeoJSONFromDiff(E, Q, S) {
            if (!this._dataUpdateable) throw new Error(`Cannot update existing geojson data in ${S}`);
            b.a8(this._dataUpdateable, E, Q);
            const V = Array.from(this._dataUpdateable.values());
            return this._toFeatureCollection(V);
          }
          _filterGeoJSON(E, Q) {
            const S = b.d3(Q, { type: "boolean", "property-type": "data-driven", overridable: !1, transition: !1 });
            if (S.result === "error") throw new Error(S.value.map(((H) => `${H.key}: ${H.message}`)).join(", "));
            const V = E.features.filter(((H) => S.value.evaluate({ zoom: 0 }, H)));
            return this._toFeatureCollection(V);
          }
          _toFeatureCollection(E) {
            return { type: "FeatureCollection", features: E };
          }
          removeSource(E) {
            return b._(this, void 0, void 0, (function* () {
              this._pendingRequest && this._pendingRequest.abort();
            }));
          }
          getClusterExpansionZoom(E) {
            return this._geoJSONIndex.getClusterExpansionZoom(E.clusterId);
          }
          getClusterChildren(E) {
            return this._geoJSONIndex.getChildren(E.clusterId);
          }
          getClusterLeaves(E) {
            return this._geoJSONIndex.getLeaves(E.clusterId, E.limit, E.offset);
          }
        }
        function Hs(tt, E) {
          return E.cluster ? new ya((function({ superclusterOptions: Q, clusterProperties: S }) {
            if (!S || !Q) return Q;
            const V = {}, H = {}, rt = { accumulated: null, zoom: 0 }, X = { properties: null }, it = Object.keys(S);
            for (const lt of it) {
              const [ut, ht] = S[lt], _t = b.d3(ht), vt = b.d3(typeof ut == "string" ? [ut, ["accumulated"], ["get", lt]] : ut);
              V[lt] = _t.value, H[lt] = vt.value;
            }
            return Q.map = (lt) => {
              X.properties = lt;
              const ut = {};
              for (const ht of it) ut[ht] = V[ht].evaluate(rt, X);
              return ut;
            }, Q.reduce = (lt, ut) => {
              X.properties = ut;
              for (const ht of it) rt.accumulated = lt[ht], lt[ht] = H[ht].evaluate(rt, X);
            }, Q;
          })(E)).load(tt.features) : (function(Q, S) {
            return new Wi(Q, S);
          })(tt, E.geojsonVtOptions);
        }
        class Os {
          constructor(E) {
            this.self = E, this.actor = new b.L(E), this.layerIndexes = {}, this.availableImages = {}, this.workerSources = {}, this.demWorkerSources = {}, this.externalWorkerSourceTypes = {}, this.globalStates = /* @__PURE__ */ new Map(), this.self.registerWorkerSource = (Q, S) => {
              if (this.externalWorkerSourceTypes[Q]) throw new Error(`Worker source with name "${Q}" already registered.`);
              this.externalWorkerSourceTypes[Q] = S;
            }, this.self.addProtocol = b.cJ, this.self.removeProtocol = b.cK, this.self.registerRTLTextPlugin = (Q) => {
              b.d4.setMethods(Q);
            }, this.actor.registerMessageHandler("LDT", ((Q, S) => this._getDEMWorkerSource(Q, S.source).loadTile(S))), this.actor.registerMessageHandler("RDT", ((Q, S) => b._(this, void 0, void 0, (function* () {
              this._getDEMWorkerSource(Q, S.source).removeTile(S);
            })))), this.actor.registerMessageHandler("GCEZ", ((Q, S) => b._(this, void 0, void 0, (function* () {
              return this._getWorkerSource(Q, S.type, S.source).getClusterExpansionZoom(S);
            })))), this.actor.registerMessageHandler("GCC", ((Q, S) => b._(this, void 0, void 0, (function* () {
              return this._getWorkerSource(Q, S.type, S.source).getClusterChildren(S);
            })))), this.actor.registerMessageHandler("GCL", ((Q, S) => b._(this, void 0, void 0, (function* () {
              return this._getWorkerSource(Q, S.type, S.source).getClusterLeaves(S);
            })))), this.actor.registerMessageHandler("LD", ((Q, S) => this._getWorkerSource(Q, S.type, S.source).loadData(S))), this.actor.registerMessageHandler("GD", ((Q, S) => this._getWorkerSource(Q, S.type, S.source).getData())), this.actor.registerMessageHandler("LT", ((Q, S) => this._getWorkerSource(Q, S.type, S.source).loadTile(S))), this.actor.registerMessageHandler("RT", ((Q, S) => this._getWorkerSource(Q, S.type, S.source).reloadTile(S))), this.actor.registerMessageHandler("AT", ((Q, S) => this._getWorkerSource(Q, S.type, S.source).abortTile(S))), this.actor.registerMessageHandler("RMT", ((Q, S) => this._getWorkerSource(Q, S.type, S.source).removeTile(S))), this.actor.registerMessageHandler("RS", ((Q, S) => b._(this, void 0, void 0, (function* () {
              if (!this.workerSources[Q] || !this.workerSources[Q][S.type] || !this.workerSources[Q][S.type][S.source]) return;
              const V = this.workerSources[Q][S.type][S.source];
              delete this.workerSources[Q][S.type][S.source], V.removeSource !== void 0 && V.removeSource(S);
            })))), this.actor.registerMessageHandler("RM", ((Q) => b._(this, void 0, void 0, (function* () {
              delete this.layerIndexes[Q], delete this.availableImages[Q], delete this.workerSources[Q], delete this.demWorkerSources[Q], this.globalStates.delete(Q);
            })))), this.actor.registerMessageHandler("SR", ((Q, S) => b._(this, void 0, void 0, (function* () {
              this.referrer = S;
            })))), this.actor.registerMessageHandler("SRPS", ((Q, S) => this._syncRTLPluginState(Q, S))), this.actor.registerMessageHandler("IS", ((Q, S) => b._(this, void 0, void 0, (function* () {
              this.self.importScripts(S);
            })))), this.actor.registerMessageHandler("SI", ((Q, S) => this._setImages(Q, S))), this.actor.registerMessageHandler("UL", ((Q, S) => b._(this, void 0, void 0, (function* () {
              this._getLayerIndex(Q).update(S.layers, S.removedIds, this._getGlobalState(Q));
            })))), this.actor.registerMessageHandler("UGS", ((Q, S) => b._(this, void 0, void 0, (function* () {
              const V = this._getGlobalState(Q);
              for (const H in S) V[H] = S[H];
            })))), this.actor.registerMessageHandler("SL", ((Q, S) => b._(this, void 0, void 0, (function* () {
              this._getLayerIndex(Q).replace(S, this._getGlobalState(Q));
            }))));
          }
          _getGlobalState(E) {
            let Q = this.globalStates.get(E);
            return Q || (Q = {}, this.globalStates.set(E, Q)), Q;
          }
          _setImages(E, Q) {
            return b._(this, void 0, void 0, (function* () {
              this.availableImages[E] = Q;
              for (const S in this.workerSources[E]) {
                const V = this.workerSources[E][S];
                for (const H in V) V[H].availableImages = Q;
              }
            }));
          }
          _syncRTLPluginState(E, Q) {
            return b._(this, void 0, void 0, (function* () {
              return yield b.d4.syncState(Q, this.self.importScripts);
            }));
          }
          _getAvailableImages(E) {
            let Q = this.availableImages[E];
            return Q || (Q = []), Q;
          }
          _getLayerIndex(E) {
            let Q = this.layerIndexes[E];
            return Q || (Q = this.layerIndexes[E] = new u()), Q;
          }
          _getWorkerSource(E, Q, S) {
            if (this.workerSources[E] || (this.workerSources[E] = {}), this.workerSources[E][Q] || (this.workerSources[E][Q] = {}), !this.workerSources[E][Q][S]) {
              const V = { sendAsync: (H, rt) => (H.targetMapId = E, this.actor.sendAsync(H, rt)) };
              switch (Q) {
                case "vector":
                  this.workerSources[E][Q][S] = new Ii(V, this._getLayerIndex(E), this._getAvailableImages(E));
                  break;
                case "geojson":
                  this.workerSources[E][Q][S] = new ur(V, this._getLayerIndex(E), this._getAvailableImages(E));
                  break;
                default:
                  this.workerSources[E][Q][S] = new this.externalWorkerSourceTypes[Q](V, this._getLayerIndex(E), this._getAvailableImages(E));
              }
            }
            return this.workerSources[E][Q][S];
          }
          _getDEMWorkerSource(E, Q) {
            return this.demWorkerSources[E] || (this.demWorkerSources[E] = {}), this.demWorkerSources[E][Q] || (this.demWorkerSources[E][Q] = new Bi()), this.demWorkerSources[E][Q];
          }
        }
        return b.i(self) && (self.worker = new Os(self)), Os;
      })), Tl("index", ["exports", "./shared"], (function(b, u) {
        var mt = "5.13.0";
        function Qi() {
          var g = new u.A(4);
          return u.A != Float32Array && (g[1] = 0, g[2] = 0), g[0] = 1, g[3] = 1, g;
        }
        let Cs, vr, wn;
        const Ke = { frame(g, e, r) {
          const o = requestAnimationFrame(((h) => {
            c(), e(h);
          })), { unsubscribe: c } = u.s(g.signal, "abort", (() => {
            c(), cancelAnimationFrame(o), r(u.c());
          }), !1);
        }, frameAsync(g) {
          return new Promise(((e, r) => {
            this.frame(g, e, r);
          }));
        }, getImageData(g, e = 0) {
          return this.getImageCanvasContext(g).getImageData(-e, -e, g.width + 2 * e, g.height + 2 * e);
        }, getImageCanvasContext(g) {
          const e = window.document.createElement("canvas"), r = e.getContext("2d", { willReadFrequently: !0 });
          if (!r) throw new Error("failed to create canvas 2d context");
          return e.width = g.width, e.height = g.height, r.drawImage(g, 0, 0, g.width, g.height), r;
        }, resolveURL: (g) => (Cs || (Cs = document.createElement("a")), Cs.href = g, Cs.href), hardwareConcurrency: typeof navigator < "u" && navigator.hardwareConcurrency || 4, get prefersReducedMotion() {
          return wn !== void 0 ? wn : !!matchMedia && (vr == null && (vr = matchMedia("(prefers-reduced-motion: reduce)")), vr.matches);
        }, set prefersReducedMotion(g) {
          wn = g;
        } }, vi = new class {
          constructor() {
            this._realTime = typeof performance < "u" && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date), this._frozenAt = null;
          }
          getCurrentTime() {
            return this._frozenAt !== null ? this._frozenAt : this._realTime();
          }
          setNow(g) {
            this._frozenAt = g;
          }
          restoreNow() {
            this._frozenAt = null;
          }
          isFrozen() {
            return this._frozenAt !== null;
          }
        }();
        function $t() {
          return vi.getCurrentTime();
        }
        class gt {
          static testProp(e) {
            if (!gt.docStyle) return e[0];
            for (let r = 0; r < e.length; r++) if (e[r] in gt.docStyle) return e[r];
            return e[0];
          }
          static create(e, r, o) {
            const c = window.document.createElement(e);
            return r !== void 0 && (c.className = r), o && o.appendChild(c), c;
          }
          static createNS(e, r) {
            return window.document.createElementNS(e, r);
          }
          static disableDrag() {
            gt.docStyle && gt.selectProp && (gt.userSelect = gt.docStyle[gt.selectProp], gt.docStyle[gt.selectProp] = "none");
          }
          static enableDrag() {
            gt.docStyle && gt.selectProp && (gt.docStyle[gt.selectProp] = gt.userSelect);
          }
          static setTransform(e, r) {
            e.style[gt.transformProp] = r;
          }
          static addEventListener(e, r, o, c = {}) {
            e.addEventListener(r, o, "passive" in c ? c : c.capture);
          }
          static removeEventListener(e, r, o, c = {}) {
            e.removeEventListener(r, o, "passive" in c ? c : c.capture);
          }
          static suppressClickInternal(e) {
            e.preventDefault(), e.stopPropagation(), window.removeEventListener("click", gt.suppressClickInternal, !0);
          }
          static suppressClick() {
            window.addEventListener("click", gt.suppressClickInternal, !0), window.setTimeout((() => {
              window.removeEventListener("click", gt.suppressClickInternal, !0);
            }), 0);
          }
          static getScale(e) {
            const r = e.getBoundingClientRect();
            return { x: r.width / e.offsetWidth || 1, y: r.height / e.offsetHeight || 1, boundingClientRect: r };
          }
          static getPoint(e, r, o) {
            const c = r.boundingClientRect;
            return new u.P((o.clientX - c.left) / r.x - e.clientLeft, (o.clientY - c.top) / r.y - e.clientTop);
          }
          static mousePos(e, r) {
            const o = gt.getScale(e);
            return gt.getPoint(e, o, r);
          }
          static touchPos(e, r) {
            const o = [], c = gt.getScale(e);
            for (let h = 0; h < r.length; h++) o.push(gt.getPoint(e, c, r[h]));
            return o;
          }
          static mouseButton(e) {
            return e.button;
          }
          static remove(e) {
            e.parentNode && e.parentNode.removeChild(e);
          }
          static sanitize(e) {
            const r = new DOMParser().parseFromString(e, "text/html").body || document.createElement("body"), o = r.querySelectorAll("script");
            for (const c of o) c.remove();
            return gt.clean(r), r.innerHTML;
          }
          static isPossiblyDangerous(e, r) {
            const o = r.replace(/\s+/g, "").toLowerCase();
            return !(!["src", "href", "xlink:href"].includes(e) || !o.includes("javascript:") && !o.includes("data:")) || !!e.startsWith("on") || void 0;
          }
          static clean(e) {
            const r = e.children;
            for (const o of r) gt.removeAttributes(o), gt.clean(o);
          }
          static removeAttributes(e) {
            for (const { name: r, value: o } of e.attributes) gt.isPossiblyDangerous(r, o) && e.removeAttribute(r);
          }
        }
        gt.docStyle = typeof window < "u" && window.document && window.document.documentElement.style, gt.selectProp = gt.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]), gt.transformProp = gt.testProp(["transform", "WebkitTransform"]);
        const rr = { supported: !1, testSupport: function(g) {
          !Br && Ie && (Sr ? pn(g) : je = g);
        } };
        let je, Ie, Br = !1, Sr = !1;
        function pn(g) {
          const e = g.createTexture();
          g.bindTexture(g.TEXTURE_2D, e);
          try {
            if (g.texImage2D(g.TEXTURE_2D, 0, g.RGBA, g.RGBA, g.UNSIGNED_BYTE, Ie), g.isContextLost()) return;
            rr.supported = !0;
          } catch {
          }
          g.deleteTexture(e), Br = !0;
        }
        var ps;
        typeof document < "u" && (Ie = document.createElement("img"), Ie.onload = () => {
          je && pn(je), je = null, Sr = !0;
        }, Ie.onerror = () => {
          Br = !0, je = null;
        }, Ie.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="), (function(g) {
          let e, r, o, c;
          g.resetRequestQueue = () => {
            e = [], r = 0, o = 0, c = {};
          }, g.addThrottleControl = (I) => {
            const p = o++;
            return c[p] = I, p;
          }, g.removeThrottleControl = (I) => {
            delete c[I], z();
          }, g.getImage = (I, p, f = !0) => new Promise(((_, j) => {
            rr.supported && (I.headers || (I.headers = {}), I.headers.accept = "image/webp,*/*"), u.e(I, { type: "image" }), e.push({ abortController: p, requestParameters: I, supportImageRefresh: f, state: "queued", onError: (C) => {
              j(C);
            }, onSuccess: (C) => {
              _(C);
            } }), z();
          }));
          const h = (I) => u._(this, void 0, void 0, (function* () {
            I.state = "running";
            const { requestParameters: p, supportImageRefresh: f, onError: _, onSuccess: j, abortController: C } = I, v = f === !1 && !u.i(self) && !u.g(p.url) && (!p.headers || Object.keys(p.headers).reduce(((W, Z) => W && Z === "accept"), !0));
            r++;
            const F = v ? d(p, C) : u.m(p, C);
            try {
              const W = yield F;
              delete I.abortController, I.state = "completed", W.data instanceof HTMLImageElement || u.b(W.data) ? j(W) : W.data && j({ data: yield (Y = W.data, typeof createImageBitmap == "function" ? u.f(Y) : u.h(Y)), cacheControl: W.cacheControl, expires: W.expires });
            } catch (W) {
              delete I.abortController, _(W);
            } finally {
              r--, z();
            }
            var Y;
          })), z = () => {
            const I = (() => {
              for (const p of Object.keys(c)) if (c[p]()) return !0;
              return !1;
            })() ? u.a.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : u.a.MAX_PARALLEL_IMAGE_REQUESTS;
            for (let p = r; p < I && e.length > 0; p++) {
              const f = e.shift();
              f.abortController.signal.aborted ? p-- : h(f);
            }
          }, d = (I, p) => new Promise(((f, _) => {
            const j = new Image(), C = I.url, v = I.credentials;
            v && v === "include" ? j.crossOrigin = "use-credentials" : (v && v === "same-origin" || !u.d(C)) && (j.crossOrigin = "anonymous"), p.signal.addEventListener("abort", (() => {
              j.src = "", _(u.c());
            })), j.fetchPriority = "high", j.onload = () => {
              j.onerror = j.onload = null, f({ data: j });
            }, j.onerror = () => {
              j.onerror = j.onload = null, p.signal.aborted || _(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
            }, j.src = C;
          }));
        })(ps || (ps = {})), ps.resetRequestQueue();
        class da {
          constructor(e) {
            this._transformRequestFn = e ?? null;
          }
          transformRequest(e, r) {
            return this._transformRequestFn && this._transformRequestFn(e, r) || { url: e };
          }
          setTransformRequest(e) {
            this._transformRequestFn = e;
          }
        }
        function Ii(g) {
          const e = [];
          if (typeof g == "string") e.push({ id: "default", url: g });
          else if (g && g.length > 0) {
            const r = [];
            for (const { id: o, url: c } of g) {
              const h = `${o}${c}`;
              r.indexOf(h) === -1 && (r.push(h), e.push({ id: o, url: c }));
            }
          }
          return e;
        }
        function Bi(g, e, r) {
          try {
            const o = new URL(g);
            return o.pathname += `${e}${r}`, o.toString();
          } catch {
            throw new Error(`Invalid sprite URL "${g}", must be absolute. Modify style specification directly or use TransformStyleFunction to correct the issue dynamically`);
          }
        }
        function nr(g) {
          const { userImage: e } = g;
          return !!(e && e.render && e.render()) && (g.data.replace(new Uint8Array(e.data.buffer)), !0);
        }
        class Si extends u.E {
          constructor() {
            super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = !1, this.requestors = [], this.patterns = {}, this.atlasImage = new u.R({ width: 1, height: 1 }), this.dirty = !0;
          }
          destroy() {
            this.atlasTexture && (this.atlasTexture.destroy(), this.atlasTexture = null);
            for (const e of Object.keys(this.images)) this.removeImage(e);
            this.patterns = {}, this.atlasImage = new u.R({ width: 1, height: 1 }), this.dirty = !0;
          }
          isLoaded() {
            return this.loaded;
          }
          setLoaded(e) {
            if (this.loaded !== e && (this.loaded = e, e)) {
              for (const { ids: r, promiseResolve: o } of this.requestors) o(this._getImagesForIds(r));
              this.requestors = [];
            }
          }
          getImage(e) {
            const r = this.images[e];
            if (r && !r.data && r.spriteData) {
              const o = r.spriteData;
              r.data = new u.R({ width: o.width, height: o.height }, o.context.getImageData(o.x, o.y, o.width, o.height).data), r.spriteData = null;
            }
            return r;
          }
          addImage(e, r) {
            if (this.images[e]) throw new Error(`Image id ${e} already exist, use updateImage instead`);
            this._validate(e, r) && (this.images[e] = r);
          }
          _validate(e, r) {
            let o = !0;
            const c = r.data || r.spriteData;
            return this._validateStretch(r.stretchX, c && c.width) || (this.fire(new u.k(new Error(`Image "${e}" has invalid "stretchX" value`))), o = !1), this._validateStretch(r.stretchY, c && c.height) || (this.fire(new u.k(new Error(`Image "${e}" has invalid "stretchY" value`))), o = !1), this._validateContent(r.content, r) || (this.fire(new u.k(new Error(`Image "${e}" has invalid "content" value`))), o = !1), o;
          }
          _validateStretch(e, r) {
            if (!e) return !0;
            let o = 0;
            for (const c of e) {
              if (c[0] < o || c[1] < c[0] || r < c[1]) return !1;
              o = c[1];
            }
            return !0;
          }
          _validateContent(e, r) {
            if (!e) return !0;
            if (e.length !== 4) return !1;
            const o = r.spriteData, c = o && o.width || r.data.width, h = o && o.height || r.data.height;
            return !(e[0] < 0 || c < e[0] || e[1] < 0 || h < e[1] || e[2] < 0 || c < e[2] || e[3] < 0 || h < e[3] || e[2] < e[0] || e[3] < e[1]);
          }
          updateImage(e, r, o = !0) {
            const c = this.getImage(e);
            if (o && (c.data.width !== r.data.width || c.data.height !== r.data.height)) throw new Error(`size mismatch between old image (${c.data.width}x${c.data.height}) and new image (${r.data.width}x${r.data.height}).`);
            r.version = c.version + 1, this.images[e] = r, this.updatedImages[e] = !0;
          }
          removeImage(e) {
            const r = this.images[e];
            delete this.images[e], delete this.patterns[e], r.userImage && r.userImage.onRemove && r.userImage.onRemove();
          }
          listImages() {
            return Object.keys(this.images);
          }
          getImages(e) {
            return new Promise(((r, o) => {
              let c = !0;
              if (!this.isLoaded()) for (const h of e) this.images[h] || (c = !1);
              this.isLoaded() || c ? r(this._getImagesForIds(e)) : this.requestors.push({ ids: e, promiseResolve: r });
            }));
          }
          _getImagesForIds(e) {
            const r = {};
            for (const o of e) {
              let c = this.getImage(o);
              c || (this.fire(new u.l("styleimagemissing", { id: o })), c = this.getImage(o)), c ? r[o] = { data: c.data.clone(), pixelRatio: c.pixelRatio, sdf: c.sdf, version: c.version, stretchX: c.stretchX, stretchY: c.stretchY, content: c.content, textFitWidth: c.textFitWidth, textFitHeight: c.textFitHeight, hasRenderCallback: !!(c.userImage && c.userImage.render) } : u.w(`Image "${o}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
            }
            return r;
          }
          getPixelSize() {
            const { width: e, height: r } = this.atlasImage;
            return { width: e, height: r };
          }
          getPattern(e) {
            const r = this.patterns[e], o = this.getImage(e);
            if (!o) return null;
            if (r && r.position.version === o.version) return r.position;
            if (r) r.position.version = o.version;
            else {
              const c = { w: o.data.width + 2, h: o.data.height + 2, x: 0, y: 0 }, h = new u.I(c, o);
              this.patterns[e] = { bin: c, position: h };
            }
            return this._updatePatternAtlas(), this.patterns[e].position;
          }
          bind(e) {
            const r = e.gl;
            this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = !1) : this.atlasTexture = new u.T(e, this.atlasImage, r.RGBA), this.atlasTexture.bind(r.LINEAR, r.CLAMP_TO_EDGE);
          }
          _updatePatternAtlas() {
            const e = [];
            for (const h in this.patterns) e.push(this.patterns[h].bin);
            const { w: r, h: o } = u.p(e), c = this.atlasImage;
            c.resize({ width: r || 1, height: o || 1 });
            for (const h in this.patterns) {
              const { bin: z } = this.patterns[h], d = z.x + 1, I = z.y + 1, p = this.getImage(h).data, f = p.width, _ = p.height;
              u.R.copy(p, c, { x: 0, y: 0 }, { x: d, y: I }, { width: f, height: _ }), u.R.copy(p, c, { x: 0, y: _ - 1 }, { x: d, y: I - 1 }, { width: f, height: 1 }), u.R.copy(p, c, { x: 0, y: 0 }, { x: d, y: I + _ }, { width: f, height: 1 }), u.R.copy(p, c, { x: f - 1, y: 0 }, { x: d - 1, y: I }, { width: 1, height: _ }), u.R.copy(p, c, { x: 0, y: 0 }, { x: d + f, y: I }, { width: 1, height: _ });
            }
            this.dirty = !0;
          }
          beginFrame() {
            this.callbackDispatchedThisFrame = {};
          }
          dispatchRenderCallbacks(e) {
            for (const r of e) {
              if (this.callbackDispatchedThisFrame[r]) continue;
              this.callbackDispatchedThisFrame[r] = !0;
              const o = this.getImage(r);
              o || u.w(`Image with ID: "${r}" was not found`), nr(o) && this.updateImage(r, o);
            }
          }
          cloneImages() {
            const e = {};
            for (const r in this.images) {
              const o = this.images[r];
              e[r] = Object.assign(Object.assign({}, o), { data: o.data ? o.data.clone() : null });
            }
            return e;
          }
        }
        const ar = 1e20;
        function Tn(g, e, r, o, c, h, z, d, I) {
          for (let p = e; p < e + o; p++) fn(g, r * h + p, h, c, z, d, I);
          for (let p = r; p < r + c; p++) fn(g, p * h + e, 1, o, z, d, I);
        }
        function fn(g, e, r, o, c, h, z) {
          h[0] = 0, z[0] = -ar, z[1] = ar, c[0] = g[e];
          for (let d = 1, I = 0, p = 0; d < o; d++) {
            c[d] = g[e + d * r];
            const f = d * d;
            do {
              const _ = h[I];
              p = (c[d] - c[_] + f - _ * _) / (d - _) / 2;
            } while (p <= z[I] && --I > -1);
            I++, h[I] = d, z[I] = p, z[I + 1] = ar;
          }
          for (let d = 0, I = 0; d < o; d++) {
            for (; z[I + 1] < d; ) I++;
            const p = h[I], f = d - p;
            g[e + d * r] = c[p] + f * f;
          }
        }
        const xn = u.v.layout_symbol["text-font"].default.join(",");
        class Zs {
          constructor(e, r, o) {
            this.requestManager = e, this.localIdeographFontFamily = r, this.entries = {}, this.lang = o;
          }
          setURL(e) {
            this.url = e;
          }
          getGlyphs(e) {
            return u._(this, void 0, void 0, (function* () {
              const r = [];
              for (const h in e) for (const z of e[h]) r.push(this._getAndCacheGlyphsPromise(h, z));
              const o = yield Promise.all(r), c = {};
              for (const { stack: h, id: z, glyph: d } of o) c[h] || (c[h] = {}), c[h][z] = d && { id: d.id, bitmap: d.bitmap.clone(), metrics: d.metrics };
              return c;
            }));
          }
          _getAndCacheGlyphsPromise(e, r) {
            return u._(this, void 0, void 0, (function* () {
              let o = this.entries[e];
              o || (o = this.entries[e] = { glyphs: {}, requests: {}, ranges: {} });
              let c = o.glyphs[r];
              return c !== void 0 ? { stack: e, id: r, glyph: c } : !this.url || this._charUsesLocalIdeographFontFamily(r) ? (c = o.glyphs[r] = this._drawGlyph(o, e, r), { stack: e, id: r, glyph: c }) : yield this._downloadAndCacheRangePromise(e, r);
            }));
          }
          _downloadAndCacheRangePromise(e, r) {
            return u._(this, void 0, void 0, (function* () {
              const o = this.entries[e], c = Math.floor(r / 256);
              if (o.ranges[c]) return { stack: e, id: r, glyph: null };
              if (!o.requests[c]) {
                const h = Zs.loadGlyphRange(e, c, this.url, this.requestManager);
                o.requests[c] = h;
              }
              try {
                const h = yield o.requests[c];
                for (const z in h) o.glyphs[+z] = h[+z];
                return o.ranges[c] = !0, { stack: e, id: r, glyph: h[r] || null };
              } catch (h) {
                const z = o.glyphs[r] = this._drawGlyph(o, e, r);
                return this._warnOnMissingGlyphRange(z, c, r, h), { stack: e, id: r, glyph: z };
              }
            }));
          }
          _warnOnMissingGlyphRange(e, r, o, c) {
            const h = 256 * r, z = h + 255, d = o.toString(16).padStart(4, "0").toUpperCase();
            u.w(`Unable to load glyph range ${r}, ${h}-${z}. Rendering codepoint U+${d} locally instead. ${c}`);
          }
          _charUsesLocalIdeographFontFamily(e) {
            return !!this.localIdeographFontFamily && u.q(e);
          }
          _drawGlyph(e, r, o) {
            const c = r === xn && this.localIdeographFontFamily !== "" && this._charUsesLocalIdeographFontFamily(o), h = c ? "ideographTinySDF" : "tinySDF";
            e[h] || (e[h] = this._createTinySDF(c ? this.localIdeographFontFamily : r));
            const z = e[h].draw(String.fromCodePoint(o));
            return { id: o, bitmap: new u.r({ width: z.width || 60, height: z.height || 60 }, z.data), metrics: { width: z.glyphWidth / 2 || 24, height: z.glyphHeight / 2 || 24, left: z.glyphLeft / 2 + 0.5 || 0, top: z.glyphTop / 2 - 27.5 || -8, advance: z.glyphAdvance / 2 || 24, isDoubleResolution: !0 } };
          }
          _createTinySDF(e) {
            const r = e ? e.split(",") : [];
            r.push("sans-serif");
            const o = r.map(((c) => /[-\w]+/.test(c) ? c : `'${CSS.escape(c)}'`)).join(",");
            return new Zs.TinySDF({ fontSize: 48, buffer: 6, radius: 16, cutoff: 0.25, fontFamily: o, fontWeight: this._fontWeight(r[0]), fontStyle: this._fontStyle(r[0]), lang: this.lang });
          }
          _fontStyle(e) {
            return /italic/i.test(e) ? "italic" : /oblique/i.test(e) ? "oblique" : "normal";
          }
          _fontWeight(e) {
            const r = { thin: 100, hairline: 100, "extra light": 200, "ultra light": 200, light: 300, normal: 400, regular: 400, medium: 500, semibold: 600, demibold: 600, bold: 700, "extra bold": 800, "ultra bold": 800, black: 900, heavy: 900, "extra black": 950, "ultra black": 950 };
            let o;
            for (const [c, h] of Object.entries(r)) new RegExp(`\\b${c}\\b`, "i").test(e) && (o = `${h}`);
            return o;
          }
          destroy() {
            for (const e in this.entries) {
              const r = this.entries[e];
              r.tinySDF && (r.tinySDF = null), r.ideographTinySDF && (r.ideographTinySDF = null), r.glyphs = {}, r.requests = {}, r.ranges = {};
            }
            this.entries = {};
          }
        }
        Zs.loadGlyphRange = function(g, e, r, o) {
          return u._(this, void 0, void 0, (function* () {
            const c = 256 * e, h = c + 255, z = o.transformRequest(r.replace("{fontstack}", g).replace("{range}", `${c}-${h}`), "Glyphs"), d = yield u.n(z, new AbortController());
            if (!d || !d.data) throw new Error(`Could not load glyph range. range: ${e}, ${c}-${h}`);
            const I = {};
            for (const p of u.o(d.data)) I[p.id] = p;
            return I;
          }));
        }, Zs.TinySDF = class {
          constructor({ fontSize: g = 24, buffer: e = 3, radius: r = 8, cutoff: o = 0.25, fontFamily: c = "sans-serif", fontWeight: h = "normal", fontStyle: z = "normal", lang: d = null } = {}) {
            this.buffer = e, this.cutoff = o, this.radius = r, this.lang = d;
            const I = this.size = g + 4 * e, p = this._createCanvas(I), f = this.ctx = p.getContext("2d", { willReadFrequently: !0 });
            f.font = `${z} ${h} ${g}px ${c}`, f.textBaseline = "alphabetic", f.textAlign = "left", f.fillStyle = "black", this.gridOuter = new Float64Array(I * I), this.gridInner = new Float64Array(I * I), this.f = new Float64Array(I), this.z = new Float64Array(I + 1), this.v = new Uint16Array(I);
          }
          _createCanvas(g) {
            const e = document.createElement("canvas");
            return e.width = e.height = g, e;
          }
          draw(g) {
            const { width: e, actualBoundingBoxAscent: r, actualBoundingBoxDescent: o, actualBoundingBoxLeft: c, actualBoundingBoxRight: h } = this.ctx.measureText(g), z = Math.ceil(r), d = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(h - c))), I = Math.min(this.size - this.buffer, z + Math.ceil(o)), p = d + 2 * this.buffer, f = I + 2 * this.buffer, _ = Math.max(p * f, 0), j = new Uint8ClampedArray(_), C = { data: j, width: p, height: f, glyphWidth: d, glyphHeight: I, glyphTop: z, glyphLeft: 0, glyphAdvance: e };
            if (d === 0 || I === 0) return C;
            const { ctx: v, buffer: F, gridInner: Y, gridOuter: W } = this;
            this.lang && (v.lang = this.lang), v.clearRect(F, F, d, I), v.fillText(g, F, F + z);
            const Z = v.getImageData(F, F, d, I);
            W.fill(ar, 0, _), Y.fill(0, 0, _);
            for (let J = 0; J < I; J++) for (let R = 0; R < d; R++) {
              const q = Z.data[4 * (J * d + R) + 3] / 255;
              if (q === 0) continue;
              const $ = (J + F) * p + R + F;
              if (q === 1) W[$] = 0, Y[$] = ar;
              else {
                const G = 0.5 - q;
                W[$] = G > 0 ? G * G : 0, Y[$] = G < 0 ? G * G : 0;
              }
            }
            Tn(W, 0, 0, p, f, p, this.f, this.v, this.z), Tn(Y, F, F, d, I, p, this.f, this.v, this.z);
            for (let J = 0; J < _; J++) {
              const R = Math.sqrt(W[J]) - Math.sqrt(Y[J]);
              j[J] = Math.round(255 - 255 * (R / this.radius + this.cutoff));
            }
            return C;
          }
        };
        class ya {
          constructor() {
            this.specification = u.u.light.position;
          }
          possiblyEvaluate(e, r) {
            return u.F(e.expression.evaluate(r));
          }
          interpolate(e, r, o) {
            return { x: u.G.number(e.x, r.x, o), y: u.G.number(e.y, r.y, o), z: u.G.number(e.z, r.z, o) };
          }
        }
        let se;
        class kr extends u.E {
          constructor(e) {
            super(), se = se || new u.t({ anchor: new u.D(u.u.light.anchor), position: new ya(), color: new u.D(u.u.light.color), intensity: new u.D(u.u.light.intensity) }), this._transitionable = new u.x(se, void 0), this.setLight(e), this._transitioning = this._transitionable.untransitioned();
          }
          getLight() {
            return this._transitionable.serialize();
          }
          setLight(e, r = {}) {
            if (!this._validate(u.y, e, r)) for (const o in e) {
              const c = e[o];
              o.endsWith(u.z) ? this._transitionable.setTransition(o.slice(0, -u.z.length), c) : this._transitionable.setValue(o, c);
            }
          }
          updateTransitions(e) {
            this._transitioning = this._transitionable.transitioned(e, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(e) {
            this.properties = this._transitioning.possiblyEvaluate(e);
          }
          _validate(e, r, o) {
            return (!o || o.validate !== !1) && u.B(this, e.call(u.C, { value: r, style: { glyphs: !0, sprite: !0 }, styleSpec: u.u }));
          }
        }
        const ni = new u.t({ "sky-color": new u.D(u.u.sky["sky-color"]), "horizon-color": new u.D(u.u.sky["horizon-color"]), "fog-color": new u.D(u.u.sky["fog-color"]), "fog-ground-blend": new u.D(u.u.sky["fog-ground-blend"]), "horizon-fog-blend": new u.D(u.u.sky["horizon-fog-blend"]), "sky-horizon-blend": new u.D(u.u.sky["sky-horizon-blend"]), "atmosphere-blend": new u.D(u.u.sky["atmosphere-blend"]) });
        class or extends u.E {
          constructor(e) {
            super(), this._transitionable = new u.x(ni, void 0), this.setSky(e), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new u.H(0));
          }
          setSky(e, r = {}) {
            if (!this._validate(u.J, e, r)) {
              e || (e = { "sky-color": "transparent", "horizon-color": "transparent", "fog-color": "transparent", "fog-ground-blend": 1, "atmosphere-blend": 0 });
              for (const o in e) {
                const c = e[o];
                o.endsWith(u.z) ? this._transitionable.setTransition(o.slice(0, -u.z.length), c) : this._transitionable.setValue(o, c);
              }
            }
          }
          getSky() {
            return this._transitionable.serialize();
          }
          updateTransitions(e) {
            this._transitioning = this._transitionable.transitioned(e, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(e) {
            this.properties = this._transitioning.possiblyEvaluate(e);
          }
          _validate(e, r, o = {}) {
            return o?.validate !== !1 && u.B(this, e.call(u.C, u.e({ value: r, style: { glyphs: !0, sprite: !0 }, styleSpec: u.u })));
          }
          calculateFogBlendOpacity(e) {
            return e < 60 ? 0 : e < 70 ? (e - 60) / 10 : 1;
          }
        }
        class Ia {
          constructor(e, r) {
            this.width = e, this.height = r, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};
          }
          getDash(e, r) {
            const o = e.join(",") + String(r);
            return this.dashEntry[o] || (this.dashEntry[o] = this.addDash(e, r)), this.dashEntry[o];
          }
          getDashRanges(e, r, o) {
            const c = [];
            let h = e.length % 2 == 1 ? -e[e.length - 1] * o : 0, z = e[0] * o, d = !0;
            c.push({ left: h, right: z, isDash: d, zeroLength: e[0] === 0 });
            let I = e[0];
            for (let p = 1; p < e.length; p++) {
              d = !d;
              const f = e[p];
              h = I * o, I += f, z = I * o, c.push({ left: h, right: z, isDash: d, zeroLength: f === 0 });
            }
            return c;
          }
          addRoundDash(e, r, o) {
            const c = r / 2;
            for (let h = -o; h <= o; h++) {
              const z = this.width * (this.nextRow + o + h);
              let d = 0, I = e[d];
              for (let p = 0; p < this.width; p++) {
                p / I.right > 1 && (I = e[++d]);
                const f = Math.abs(p - I.left), _ = Math.abs(p - I.right), j = Math.min(f, _);
                let C;
                const v = h / o * (c + 1);
                if (I.isDash) {
                  const F = c - Math.abs(v);
                  C = Math.sqrt(j * j + F * F);
                } else C = c - Math.sqrt(j * j + v * v);
                this.data[z + p] = Math.max(0, Math.min(255, C + 128));
              }
            }
          }
          addRegularDash(e) {
            for (let d = e.length - 1; d >= 0; --d) {
              const I = e[d], p = e[d + 1];
              I.zeroLength ? e.splice(d, 1) : p && p.isDash === I.isDash && (p.left = I.left, e.splice(d, 1));
            }
            const r = e[0], o = e[e.length - 1];
            r.isDash === o.isDash && (r.left = o.left - this.width, o.right = r.right + this.width);
            const c = this.width * this.nextRow;
            let h = 0, z = e[h];
            for (let d = 0; d < this.width; d++) {
              d / z.right > 1 && (z = e[++h]);
              const I = Math.abs(d - z.left), p = Math.abs(d - z.right), f = Math.min(I, p);
              this.data[c + d] = Math.max(0, Math.min(255, (z.isDash ? f : -f) + 128));
            }
          }
          addDash(e, r) {
            const o = r ? 7 : 0, c = 2 * o + 1;
            if (this.nextRow + c > this.height) return u.w("LineAtlas out of space"), null;
            let h = 0;
            for (let d = 0; d < e.length; d++) h += e[d];
            if (h !== 0) {
              const d = this.width / h, I = this.getDashRanges(e, this.width, d);
              r ? this.addRoundDash(I, d, o) : this.addRegularDash(I);
            }
            const z = { y: this.nextRow + o, height: 2 * o, width: h };
            return this.nextRow += c, this.dirty = !0, z;
          }
          bind(e) {
            const r = e.gl;
            this.texture ? (r.bindTexture(r.TEXTURE_2D, this.texture), this.dirty && (this.dirty = !1, r.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, this.width, this.height, r.ALPHA, r.UNSIGNED_BYTE, this.data))) : (this.texture = r.createTexture(), r.bindTexture(r.TEXTURE_2D, this.texture), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_S, r.REPEAT), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_T, r.REPEAT), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MIN_FILTER, r.LINEAR), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MAG_FILTER, r.LINEAR), r.texImage2D(r.TEXTURE_2D, 0, r.ALPHA, this.width, this.height, 0, r.ALPHA, r.UNSIGNED_BYTE, this.data));
          }
        }
        const ki = "maplibre_preloaded_worker_pool";
        class Fi {
          constructor() {
            this.active = {};
          }
          acquire(e) {
            if (!this.workers) for (this.workers = []; this.workers.length < Fi.workerCount; ) this.workers.push(new Worker(u.a.WORKER_URL));
            return this.active[e] = !0, this.workers.slice();
          }
          release(e) {
            delete this.active[e], this.numActive() === 0 && (this.workers.forEach(((r) => {
              r.terminate();
            })), this.workers = null);
          }
          isPreloaded() {
            return !!this.active[ki];
          }
          numActive() {
            return Object.keys(this.active).length;
          }
        }
        const Ds = Math.floor(Ke.hardwareConcurrency / 2);
        let Vs, rs;
        function Fr() {
          return Vs || (Vs = new Fi()), Vs;
        }
        Fi.workerCount = u.K(globalThis) ? Math.max(Math.min(Ds, 3), 1) : 1;
        class Yi {
          constructor(e, r) {
            this.workerPool = e, this.actors = [], this.currentActor = 0, this.id = r;
            const o = this.workerPool.acquire(r);
            for (let c = 0; c < o.length; c++) {
              const h = new u.L(o[c], r);
              h.name = `Worker ${c}`, this.actors.push(h);
            }
            if (!this.actors.length) throw new Error("No actors found");
          }
          broadcast(e, r) {
            const o = [];
            for (const c of this.actors) o.push(c.sendAsync({ type: e, data: r }));
            return Promise.all(o);
          }
          getActor() {
            return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
          }
          remove(e = !0) {
            this.actors.forEach(((r) => {
              r.remove();
            })), this.actors = [], e && this.workerPool.release(this.id);
          }
          registerMessageHandler(e, r) {
            for (const o of this.actors) o.registerMessageHandler(e, r);
          }
          unregisterMessageHandler(e) {
            for (const r of this.actors) r.unregisterMessageHandler(e);
          }
        }
        function Mr() {
          return rs || (rs = new Yi(Fr(), u.M), rs.registerMessageHandler("GR", ((g, e, r) => u.m(e, r)))), rs;
        }
        function ks(g, e) {
          const r = u.N();
          return u.O(r, r, [1, 1, 0]), u.Q(r, r, [0.5 * g.width, 0.5 * g.height, 1]), g.calculatePosMatrix ? u.S(r, r, g.calculatePosMatrix(e.toUnwrapped())) : r;
        }
        function An(g, e, r, o, c, h, z) {
          var d;
          const I = (function(j, C, v) {
            if (j) for (const F of j) {
              const Y = C[F];
              if (Y && Y.source === v && Y.type === "fill-extrusion") return !0;
            }
            else for (const F in C) {
              const Y = C[F];
              if (Y.source === v && Y.type === "fill-extrusion") return !0;
            }
            return !1;
          })((d = c?.layers) !== null && d !== void 0 ? d : null, e, g.id), p = h.maxPitchScaleFactor(), f = g.tilesIn(o, p, I);
          f.sort(we);
          const _ = [];
          for (const j of f) _.push({ wrappedTileID: j.tileID.wrapped().key, queryResults: j.tile.queryRenderedFeatures(e, r, g.getState(), j.queryGeometry, j.cameraQueryGeometry, j.scale, c, h, p, ks(h, j.tileID), z ? (C, v) => z(j.tileID, C, v) : void 0) });
          return (function(j, C) {
            for (const v in j) for (const F of j[v]) Gs(F, C);
            return j;
          })((function(j) {
            const C = {}, v = {};
            for (const F of j) {
              const Y = F.queryResults, W = F.wrappedTileID, Z = v[W] = v[W] || {};
              for (const J in Y) {
                const R = Y[J], q = Z[J] = Z[J] || {}, $ = C[J] = C[J] || [];
                for (const G of R) q[G.featureIndex] || (q[G.featureIndex] = !0, $.push(G));
              }
            }
            return C;
          })(_), g);
        }
        function we(g, e) {
          const r = g.tileID, o = e.tileID;
          return r.overscaledZ - o.overscaledZ || r.canonical.y - o.canonical.y || r.wrap - o.wrap || r.canonical.x - o.canonical.x;
        }
        function Gs(g, e) {
          const r = g.feature, o = e.getFeatureState(r.layer["source-layer"], r.id);
          r.source = r.layer.source, r.layer["source-layer"] && (r.sourceLayer = r.layer["source-layer"]), r.state = o;
        }
        function ai(g, e, r) {
          return u._(this, void 0, void 0, (function* () {
            let o = g;
            if (g.url ? o = (yield u.j(e.transformRequest(g.url, "Source"), r)).data : yield Ke.frameAsync(r), !o) return null;
            const c = u.U(u.e(o, g), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]);
            return "vector_layers" in o && o.vector_layers && (c.vectorLayerIds = o.vector_layers.map(((h) => h.id))), c;
          }));
        }
        class pe {
          constructor(e, r) {
            e && (r ? this.setSouthWest(e).setNorthEast(r) : Array.isArray(e) && (e.length === 4 ? this.setSouthWest([e[0], e[1]]).setNorthEast([e[2], e[3]]) : this.setSouthWest(e[0]).setNorthEast(e[1])));
          }
          setNorthEast(e) {
            return this._ne = e instanceof u.V ? new u.V(e.lng, e.lat) : u.V.convert(e), this;
          }
          setSouthWest(e) {
            return this._sw = e instanceof u.V ? new u.V(e.lng, e.lat) : u.V.convert(e), this;
          }
          extend(e) {
            const r = this._sw, o = this._ne;
            let c, h;
            if (e instanceof u.V) c = e, h = e;
            else {
              if (!(e instanceof pe)) return Array.isArray(e) ? e.length === 4 || e.every(Array.isArray) ? this.extend(pe.convert(e)) : this.extend(u.V.convert(e)) : e && ("lng" in e || "lon" in e) && "lat" in e ? this.extend(u.V.convert(e)) : this;
              if (c = e._sw, h = e._ne, !c || !h) return this;
            }
            return r || o ? (r.lng = Math.min(c.lng, r.lng), r.lat = Math.min(c.lat, r.lat), o.lng = Math.max(h.lng, o.lng), o.lat = Math.max(h.lat, o.lat)) : (this._sw = new u.V(c.lng, c.lat), this._ne = new u.V(h.lng, h.lat)), this;
          }
          getCenter() {
            return new u.V((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
          }
          getSouthWest() {
            return this._sw;
          }
          getNorthEast() {
            return this._ne;
          }
          getNorthWest() {
            return new u.V(this.getWest(), this.getNorth());
          }
          getSouthEast() {
            return new u.V(this.getEast(), this.getSouth());
          }
          getWest() {
            return this._sw.lng;
          }
          getSouth() {
            return this._sw.lat;
          }
          getEast() {
            return this._ne.lng;
          }
          getNorth() {
            return this._ne.lat;
          }
          toArray() {
            return [this._sw.toArray(), this._ne.toArray()];
          }
          toString() {
            return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
          }
          isEmpty() {
            return !(this._sw && this._ne);
          }
          contains(e) {
            const { lng: r, lat: o } = u.V.convert(e);
            let c = this._sw.lng <= r && r <= this._ne.lng;
            return this._sw.lng > this._ne.lng && (c = this._sw.lng >= r && r >= this._ne.lng), this._sw.lat <= o && o <= this._ne.lat && c;
          }
          intersects(e) {
            if ((e = pe.convert(e)).getNorth() < this.getSouth() || e.getSouth() > this.getNorth()) return !1;
            const r = u.W(this.getWest(), -180, 180), o = u.W(this.getEast(), -180, 180), c = u.W(e.getWest(), -180, 180), h = u.W(e.getEast(), -180, 180), z = r > o, d = c > h;
            return !(!z || !d) || (z ? h >= r || c <= o : d ? o >= c || r <= h : !(c > o || h < r));
          }
          static convert(e) {
            return e instanceof pe ? e : e && new pe(e);
          }
          static fromLngLat(e, r = 0) {
            const o = 360 * r / 40075017, c = o / Math.cos(Math.PI / 180 * e.lat);
            return new pe(new u.V(e.lng - c, e.lat - o), new u.V(e.lng + c, e.lat + o));
          }
          adjustAntiMeridian() {
            const e = new u.V(this._sw.lng, this._sw.lat), r = new u.V(this._ne.lng, this._ne.lat);
            return new pe(e, e.lng > r.lng ? new u.V(r.lng + 360, r.lat) : r);
          }
        }
        class oi {
          constructor(e, r, o) {
            this.bounds = pe.convert(this.validateBounds(e)), this.minzoom = r || 0, this.maxzoom = o || 24;
          }
          validateBounds(e) {
            return Array.isArray(e) && e.length === 4 ? [Math.max(-180, e[0]), Math.max(-90, e[1]), Math.min(180, e[2]), Math.min(90, e[3])] : [-180, -90, 180, 90];
          }
          contains(e) {
            const r = Math.pow(2, e.z), o = Math.floor(u.Y(this.bounds.getWest()) * r), c = Math.floor(u.X(this.bounds.getNorth()) * r), h = Math.ceil(u.Y(this.bounds.getEast()) * r), z = Math.ceil(u.X(this.bounds.getSouth()) * r);
            return e.x >= o && e.x < h && e.y >= c && e.y < z;
          }
        }
        class Mi extends u.E {
          constructor(e, r, o, c) {
            if (super(), this.id = e, this.dispatcher = o, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, u.e(this, u.U(r, ["url", "scheme", "tileSize", "promoteId", "encoding"])), this._options = u.e({ type: "vector" }, r), this._collectResourceTiming = r.collectResourceTiming, this.tileSize !== 512) throw new Error("vector tile sources must have a tileSize of 512");
            this.setEventedParent(c);
          }
          load() {
            return u._(this, void 0, void 0, (function* () {
              this._loaded = !1, this.fire(new u.l("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
              try {
                const e = yield ai(this._options, this.map._requestManager, this._tileJSONRequest);
                this._tileJSONRequest = null, this._loaded = !0, this.map.style.tileManagers[this.id].clearTiles(), e && (u.e(this, e), e.bounds && (this.tileBounds = new oi(e.bounds, this.minzoom, this.maxzoom)), this.fire(new u.l("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new u.l("data", { dataType: "source", sourceDataType: "content" })));
              } catch (e) {
                this._tileJSONRequest = null, this._loaded = !0, this.fire(new u.k(e));
              }
            }));
          }
          loaded() {
            return this._loaded;
          }
          hasTile(e) {
            return !this.tileBounds || this.tileBounds.contains(e.canonical);
          }
          onAdd(e) {
            this.map = e, this.load();
          }
          setSourceProperty(e) {
            this._tileJSONRequest && this._tileJSONRequest.abort(), e(), this.load();
          }
          setTiles(e) {
            return this.setSourceProperty((() => {
              this._options.tiles = e;
            })), this;
          }
          setUrl(e) {
            return this.setSourceProperty((() => {
              this.url = e, this._options.url = e;
            })), this;
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
          }
          serialize() {
            return u.e({}, this._options);
          }
          loadTile(e) {
            return u._(this, void 0, void 0, (function* () {
              const r = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), o = { request: this.map._requestManager.transformRequest(r, "Tile"), uid: e.uid, tileID: e.tileID, zoom: e.tileID.overscaledZ, tileSize: this.tileSize * e.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, subdivisionGranularity: this.map.style.projection.subdivisionGranularity, encoding: this.encoding, overzoomParameters: this._getOverzoomParameters(e) };
              o.request.collectResourceTiming = this._collectResourceTiming;
              let c = "RT";
              if (e.actor && e.state !== "expired") {
                if (e.state === "loading") return new Promise(((h, z) => {
                  e.reloadPromise = { resolve: h, reject: z };
                }));
              } else e.actor = this.dispatcher.getActor(), c = "LT";
              e.abortController = new AbortController();
              try {
                const h = yield e.actor.sendAsync({ type: c, data: o }, e.abortController);
                if (delete e.abortController, e.aborted) return;
                this._afterTileLoadWorkerResponse(e, h);
              } catch (h) {
                if (delete e.abortController, e.aborted) return;
                if (h && h.status !== 404) throw h;
                this._afterTileLoadWorkerResponse(e, null);
              }
            }));
          }
          _getOverzoomParameters(e) {
            if (e.tileID.canonical.z <= this.maxzoom || this.map._zoomLevelsToOverscale === void 0) return;
            const r = e.tileID.scaledTo(this.maxzoom).canonical, o = r.url(this.tiles, this.map.getPixelRatio(), this.scheme);
            return { maxZoomTileID: r, overzoomRequest: this.map._requestManager.transformRequest(o, "Tile") };
          }
          _afterTileLoadWorkerResponse(e, r) {
            if (r && r.resourceTiming && (e.resourceTiming = r.resourceTiming), r && this.map._refreshExpiredTiles && e.setExpiryData(r), e.loadVectorData(r, this.map.painter), e.reloadPromise) {
              const o = e.reloadPromise;
              e.reloadPromise = null, this.loadTile(e).then(o.resolve).catch(o.reject);
            }
          }
          abortTile(e) {
            return u._(this, void 0, void 0, (function* () {
              e.abortController && (e.abortController.abort(), delete e.abortController), e.actor && (yield e.actor.sendAsync({ type: "AT", data: { uid: e.uid, type: this.type, source: this.id } }));
            }));
          }
          unloadTile(e) {
            return u._(this, void 0, void 0, (function* () {
              e.unloadVectorData(), e.actor && (yield e.actor.sendAsync({ type: "RMT", data: { uid: e.uid, type: this.type, source: this.id } }));
            }));
          }
          hasTransition() {
            return !1;
          }
        }
        class Yr extends u.E {
          constructor(e, r, o, c) {
            super(), this.id = e, this.dispatcher = o, this.setEventedParent(c), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = u.e({ type: "raster" }, r), u.e(this, u.U(r, ["url", "scheme", "tileSize"]));
          }
          load() {
            return u._(this, arguments, void 0, (function* (e = !1) {
              this._loaded = !1, this.fire(new u.l("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
              try {
                const r = yield ai(this._options, this.map._requestManager, this._tileJSONRequest);
                this._tileJSONRequest = null, this._loaded = !0, r && (u.e(this, r), r.bounds && (this.tileBounds = new oi(r.bounds, this.minzoom, this.maxzoom)), this.fire(new u.l("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new u.l("data", { dataType: "source", sourceDataType: "content", sourceDataChanged: e })));
              } catch (r) {
                this._tileJSONRequest = null, this._loaded = !0, this.fire(new u.k(r));
              }
            }));
          }
          loaded() {
            return this._loaded;
          }
          onAdd(e) {
            this.map = e, this.load();
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
          }
          setSourceProperty(e) {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null), e(), this.load(!0);
          }
          setTiles(e) {
            return this.setSourceProperty((() => {
              this._options.tiles = e;
            })), this;
          }
          setUrl(e) {
            return this.setSourceProperty((() => {
              this.url = e, this._options.url = e;
            })), this;
          }
          serialize() {
            return u.e({}, this._options);
          }
          hasTile(e) {
            return !this.tileBounds || this.tileBounds.contains(e.canonical);
          }
          loadTile(e) {
            return u._(this, void 0, void 0, (function* () {
              const r = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
              e.abortController = new AbortController();
              try {
                const o = yield ps.getImage(this.map._requestManager.transformRequest(r, "Tile"), e.abortController, this.map._refreshExpiredTiles);
                if (delete e.abortController, e.aborted) return void (e.state = "unloaded");
                if (o && o.data) {
                  this.map._refreshExpiredTiles && (o.cacheControl || o.expires) && e.setExpiryData({ cacheControl: o.cacheControl, expires: o.expires });
                  const c = this.map.painter.context, h = c.gl, z = o.data;
                  e.texture = this.map.painter.getTileTexture(z.width), e.texture ? e.texture.update(z, { useMipmap: !0 }) : (e.texture = new u.T(c, z, h.RGBA, { useMipmap: !0 }), e.texture.bind(h.LINEAR, h.CLAMP_TO_EDGE, h.LINEAR_MIPMAP_NEAREST)), e.state = "loaded";
                }
              } catch (o) {
                if (delete e.abortController, e.aborted) e.state = "unloaded";
                else if (o) throw e.state = "errored", o;
              }
            }));
          }
          abortTile(e) {
            return u._(this, void 0, void 0, (function* () {
              e.abortController && (e.abortController.abort(), delete e.abortController);
            }));
          }
          unloadTile(e) {
            return u._(this, void 0, void 0, (function* () {
              e.texture && this.map.painter.saveTileTexture(e.texture);
            }));
          }
          hasTransition() {
            return !1;
          }
        }
        class Ui extends Yr {
          constructor(e, r, o, c) {
            super(e, r, o, c), this.type = "raster-dem", this.maxzoom = 22, this._options = u.e({ type: "raster-dem" }, r), this.encoding = r.encoding || "mapbox", this.redFactor = r.redFactor, this.greenFactor = r.greenFactor, this.blueFactor = r.blueFactor, this.baseShift = r.baseShift;
          }
          loadTile(e) {
            return u._(this, void 0, void 0, (function* () {
              const r = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), o = this.map._requestManager.transformRequest(r, "Tile");
              e.neighboringTiles = this._getNeighboringTiles(e.tileID), e.abortController = new AbortController();
              try {
                const c = yield ps.getImage(o, e.abortController, this.map._refreshExpiredTiles);
                if (delete e.abortController, e.aborted) return void (e.state = "unloaded");
                if (c && c.data) {
                  const h = c.data;
                  this.map._refreshExpiredTiles && (c.cacheControl || c.expires) && e.setExpiryData({ cacheControl: c.cacheControl, expires: c.expires });
                  const z = u.b(h) && u.Z() ? h : yield this.readImageNow(h), d = { type: this.type, uid: e.uid, source: this.id, rawImageData: z, encoding: this.encoding, redFactor: this.redFactor, greenFactor: this.greenFactor, blueFactor: this.blueFactor, baseShift: this.baseShift };
                  if (!e.actor || e.state === "expired") {
                    e.actor = this.dispatcher.getActor();
                    const I = yield e.actor.sendAsync({ type: "LDT", data: d });
                    e.dem = I, e.needsHillshadePrepare = !0, e.needsTerrainPrepare = !0, e.state = "loaded";
                  }
                }
              } catch (c) {
                if (delete e.abortController, e.aborted) e.state = "unloaded";
                else if (c) throw e.state = "errored", c;
              }
            }));
          }
          readImageNow(e) {
            return u._(this, void 0, void 0, (function* () {
              if (typeof VideoFrame < "u" && u.$()) {
                const r = e.width + 2, o = e.height + 2;
                try {
                  return new u.R({ width: r, height: o }, yield u.a0(e, -1, -1, r, o));
                } catch {
                }
              }
              return Ke.getImageData(e, 1);
            }));
          }
          _getNeighboringTiles(e) {
            const r = e.canonical, o = Math.pow(2, r.z), c = (r.x - 1 + o) % o, h = r.x === 0 ? e.wrap - 1 : e.wrap, z = (r.x + 1 + o) % o, d = r.x + 1 === o ? e.wrap + 1 : e.wrap, I = {};
            return I[new u.a1(e.overscaledZ, h, r.z, c, r.y).key] = { backfilled: !1 }, I[new u.a1(e.overscaledZ, d, r.z, z, r.y).key] = { backfilled: !1 }, r.y > 0 && (I[new u.a1(e.overscaledZ, h, r.z, c, r.y - 1).key] = { backfilled: !1 }, I[new u.a1(e.overscaledZ, e.wrap, r.z, r.x, r.y - 1).key] = { backfilled: !1 }, I[new u.a1(e.overscaledZ, d, r.z, z, r.y - 1).key] = { backfilled: !1 }), r.y + 1 < o && (I[new u.a1(e.overscaledZ, h, r.z, c, r.y + 1).key] = { backfilled: !1 }, I[new u.a1(e.overscaledZ, e.wrap, r.z, r.x, r.y + 1).key] = { backfilled: !1 }, I[new u.a1(e.overscaledZ, d, r.z, z, r.y + 1).key] = { backfilled: !1 }), I;
          }
          unloadTile(e) {
            return u._(this, void 0, void 0, (function* () {
              e.demTexture && this.map.painter.saveTileTexture(e.demTexture), e.fbo && (e.fbo.destroy(), delete e.fbo), e.dem && delete e.dem, delete e.neighboringTiles, e.state = "unloaded", e.actor && (yield e.actor.sendAsync({ type: "RDT", data: { type: this.type, uid: e.uid, source: this.id } }));
            }));
          }
        }
        function ci(g) {
          return g.type === "GeometryCollection" ? g.geometries.map(((e) => e.coordinates)).flat(1 / 0) : g.coordinates.flat(1 / 0);
        }
        function Xi(g) {
          const e = new pe();
          let r;
          switch (g.type) {
            case "FeatureCollection":
              r = g.features.map(((o) => ci(o.geometry))).flat(1 / 0);
              break;
            case "Feature":
              r = ci(g.geometry);
              break;
            default:
              r = ci(g);
          }
          if (r.length == 0) return e;
          for (let o = 0; o < r.length - 1; o += 2) e.extend([r[o], r[o + 1]]);
          return e;
        }
        class cr extends u.E {
          constructor(e, r, o, c) {
            super(), this.id = e, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._removed = !1, this._isUpdatingWorker = !1, this._pendingWorkerUpdate = { data: r.data }, this.actor = o.getActor(), this.setEventedParent(c), this._data = typeof r.data == "string" ? { url: r.data } : { geojson: r.data }, this._options = u.e({}, r), this._collectResourceTiming = r.collectResourceTiming, r.maxzoom !== void 0 && (this.maxzoom = r.maxzoom), r.type && (this.type = r.type), r.attribution && (this.attribution = r.attribution), this.promoteId = r.promoteId, r.clusterMaxZoom !== void 0 && this.maxzoom <= r.clusterMaxZoom && u.w(`The maxzoom value "${this.maxzoom}" is expected to be greater than the clusterMaxZoom value "${r.clusterMaxZoom}".`), this.workerOptions = u.e({ source: this.id, cluster: r.cluster || !1, geojsonVtOptions: { buffer: this._pixelsToTileUnits(r.buffer !== void 0 ? r.buffer : 128), tolerance: this._pixelsToTileUnits(r.tolerance !== void 0 ? r.tolerance : 0.375), extent: u.a4, maxZoom: this.maxzoom, lineMetrics: r.lineMetrics || !1, generateId: r.generateId || !1 }, superclusterOptions: { maxZoom: this._getClusterMaxZoom(r.clusterMaxZoom), minPoints: Math.max(2, r.clusterMinPoints || 2), extent: u.a4, radius: this._pixelsToTileUnits(r.clusterRadius || 50), log: !1, generateId: r.generateId || !1 }, clusterProperties: r.clusterProperties, filter: r.filter }, r.workerOptions), typeof this.promoteId == "string" && (this.workerOptions.promoteId = this.promoteId);
          }
          _hasPendingWorkerUpdate() {
            return this._pendingWorkerUpdate.data !== void 0 || this._pendingWorkerUpdate.diff !== void 0 || this._pendingWorkerUpdate.optionsChanged;
          }
          _pixelsToTileUnits(e) {
            return e * (u.a4 / this.tileSize);
          }
          _getClusterMaxZoom(e) {
            const r = e ? Math.round(e) : this.maxzoom - 1;
            return Number.isInteger(e) || e === void 0 || u.w(`Integer expected for option 'clusterMaxZoom': provided value "${e}" rounded to "${r}"`), r;
          }
          load() {
            return u._(this, void 0, void 0, (function* () {
              yield this._updateWorkerData();
            }));
          }
          onAdd(e) {
            this.map = e, this.load();
          }
          setData(e, r) {
            this._data = typeof e == "string" ? { url: e } : { geojson: e }, this._pendingWorkerUpdate = { data: e };
            const o = this._updateWorkerData();
            return r ? o : this;
          }
          updateData(e, r) {
            this._pendingWorkerUpdate.diff = u.a5(this._pendingWorkerUpdate.diff, e);
            const o = this._updateWorkerData();
            return r ? o : this;
          }
          getData() {
            return u._(this, void 0, void 0, (function* () {
              const e = u.e({ type: this.type }, this.workerOptions);
              return this.actor.sendAsync({ type: "GD", data: e });
            }));
          }
          getBounds() {
            return u._(this, void 0, void 0, (function* () {
              return Xi(yield this.getData());
            }));
          }
          setClusterOptions(e) {
            return this.workerOptions.cluster = e.cluster, e.clusterRadius !== void 0 && (this.workerOptions.superclusterOptions.radius = this._pixelsToTileUnits(e.clusterRadius)), e.clusterMaxZoom !== void 0 && (this.workerOptions.superclusterOptions.maxZoom = this._getClusterMaxZoom(e.clusterMaxZoom)), this._pendingWorkerUpdate.optionsChanged = !0, this._updateWorkerData(), this;
          }
          getClusterExpansionZoom(e) {
            return this.actor.sendAsync({ type: "GCEZ", data: { type: this.type, clusterId: e, source: this.id } });
          }
          getClusterChildren(e) {
            return this.actor.sendAsync({ type: "GCC", data: { type: this.type, clusterId: e, source: this.id } });
          }
          getClusterLeaves(e, r, o) {
            return this.actor.sendAsync({ type: "GCL", data: { type: this.type, source: this.id, clusterId: e, limit: r, offset: o } });
          }
          _updateWorkerData() {
            return u._(this, void 0, void 0, (function* () {
              if (this._isUpdatingWorker) return;
              if (!this._hasPendingWorkerUpdate()) return void u.w(`No pending worker updates for GeoJSONSource ${this.id}.`);
              const { data: e, diff: r } = this._pendingWorkerUpdate, o = u.e({ type: this.type }, this.workerOptions);
              e ? (typeof e == "string" ? (o.request = this.map._requestManager.transformRequest(Ke.resolveURL(e), "Source"), o.request.collectResourceTiming = this._collectResourceTiming) : o.data = e, this._pendingWorkerUpdate.data = void 0) : r && (o.dataDiff = r, this._pendingWorkerUpdate.diff = void 0), this._pendingWorkerUpdate.optionsChanged = void 0, this._isUpdatingWorker = !0, this.fire(new u.l("dataloading", { dataType: "source" }));
              try {
                const c = yield this.actor.sendAsync({ type: "LD", data: o });
                if (this._isUpdatingWorker = !1, this._removed || c.abandoned) return void this.fire(new u.l("dataabort", { dataType: "source" }));
                c.applyDiff ? this._applyDiff(r) : this._data = { geojson: c.data };
                let h = null;
                c.resourceTiming && c.resourceTiming[this.id] && (h = c.resourceTiming[this.id].slice(0));
                const z = { dataType: "source" };
                this._collectResourceTiming && h && h.length > 0 && u.e(z, { resourceTiming: h }), this.fire(new u.l("data", Object.assign(Object.assign({}, z), { sourceDataType: "metadata" }))), this.fire(new u.l("data", Object.assign(Object.assign({}, z), { sourceDataType: "content", shouldReloadTileOptions: this._getShouldReloadTileOptions(r) })));
              } catch (c) {
                if (this._isUpdatingWorker = !1, this._removed) return void this.fire(new u.l("dataabort", { dataType: "source" }));
                this.fire(new u.k(c));
              } finally {
                this._hasPendingWorkerUpdate() && this._updateWorkerData();
              }
            }));
          }
          _applyDiff(e) {
            const r = typeof this.promoteId == "string" ? this.promoteId : void 0;
            this._data.url || this._data.updateable || !u.a6(this._data.geojson, r) || (this._data = { updateable: u.a7(this._data.geojson, r) }), e && this._data.updateable ? u.a8(this._data.updateable, e, r) : u.w("Cannot apply GeoJSONSource#updateData due to internal error");
          }
          _getShouldReloadTileOptions(e) {
            if (this._options.cluster || !e || e.removeAll) return;
            const { add: r = [], update: o = [], remove: c = [] } = e || {}, h = /* @__PURE__ */ new Set([...o.map(((z) => z.id)), ...c]);
            for (const z of h.values()) if (typeof z != "number" && this.promoteId == null) return void u.w(`GeoJSONSource "${this.id}": updateData is slower when using string GeoJSON feature IDs (e.g. "${z}"). Consider using promoteId or numeric IDs for better performance.`);
            return { nextBounds: [...o.map(((z) => z.newGeometry)), ...r.map(((z) => z.geometry))].filter(Boolean).map(((z) => Xi(z))), prevIds: h };
          }
          shouldReloadTile(e, { nextBounds: r, prevIds: o }) {
            if (!e.latestFeatureIndex) return e.state !== "unloaded";
            const c = e.latestFeatureIndex.loadVTLayers();
            for (let I = 0; I < e.latestFeatureIndex.featureIndexArray.length; I++) {
              const p = e.latestFeatureIndex.featureIndexArray.get(I), f = c[u.a9].feature(p.featureIndex), _ = e.latestFeatureIndex.getId(f, u.a9);
              if (o.has(_)) return !0;
            }
            const { buffer: h, extent: z } = this.workerOptions.geojsonVtOptions, d = (function({ x: I, y: p, z: f }, _ = 0) {
              const j = u.a2((I - _) / Math.pow(2, f)), C = u.a3((p + 1 + _) / Math.pow(2, f)), v = u.a2((I + 1 + _) / Math.pow(2, f)), F = u.a3((p - _) / Math.pow(2, f));
              return new pe([j, C], [v, F]);
            })(e.tileID.canonical, h / z);
            for (const I of r) if (d.intersects(I)) return !0;
            return !1;
          }
          loaded() {
            return !this._isUpdatingWorker && !this._hasPendingWorkerUpdate();
          }
          loadTile(e) {
            return u._(this, void 0, void 0, (function* () {
              const r = e.actor ? "RT" : "LT";
              e.actor = this.actor;
              const o = { type: this.type, uid: e.uid, tileID: e.tileID, zoom: e.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, subdivisionGranularity: this.map.style.projection.subdivisionGranularity };
              e.abortController = new AbortController();
              const c = yield this.actor.sendAsync({ type: r, data: o }, e.abortController);
              delete e.abortController, e.unloadVectorData(), e.aborted || e.loadVectorData(c, this.map.painter, r === "RT");
            }));
          }
          abortTile(e) {
            return u._(this, void 0, void 0, (function* () {
              e.abortController && (e.abortController.abort(), delete e.abortController), e.aborted = !0;
            }));
          }
          unloadTile(e) {
            return u._(this, void 0, void 0, (function* () {
              e.unloadVectorData(), yield this.actor.sendAsync({ type: "RMT", data: { uid: e.uid, type: this.type, source: this.id } });
            }));
          }
          onRemove() {
            this._removed = !0, this.actor.sendAsync({ type: "RS", data: { type: this.type, source: this.id } });
          }
          serialize() {
            return u.e({}, this._options, { type: this.type, data: this._data.updateable ? { type: "FeatureCollection", features: Array.from(this._data.updateable.values()) } : this._data.url || this._data.geojson });
          }
          hasTransition() {
            return !1;
          }
        }
        class Ts extends u.E {
          constructor(e, r, o, c) {
            super(), this.flippedWindingOrder = !1, this.id = e, this.dispatcher = o, this.coordinates = r.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.setEventedParent(c), this.options = r;
          }
          load(e) {
            return u._(this, void 0, void 0, (function* () {
              this._loaded = !1, this.fire(new u.l("dataloading", { dataType: "source" })), this.url = this.options.url, this._request = new AbortController();
              try {
                const r = yield ps.getImage(this.map._requestManager.transformRequest(this.url, "Image"), this._request);
                this._request = null, this._loaded = !0, r && r.data && (this.image = r.data, e && (this.coordinates = e), this._finishLoading());
              } catch (r) {
                this._request = null, this._loaded = !0, this.fire(new u.k(r));
              }
            }));
          }
          loaded() {
            return this._loaded;
          }
          updateImage(e) {
            return e.url ? (this._request && (this._request.abort(), this._request = null), this.options.url = e.url, this.load(e.coordinates).finally((() => {
              this.texture = null;
            })), this) : this;
          }
          _finishLoading() {
            this.map && (this.setCoordinates(this.coordinates), this.fire(new u.l("data", { dataType: "source", sourceDataType: "metadata" })));
          }
          onAdd(e) {
            this.map = e, this.load();
          }
          onRemove() {
            this._request && (this._request.abort(), this._request = null);
          }
          setCoordinates(e) {
            this.coordinates = e;
            const r = e.map(u.aa.fromLngLat);
            var o;
            return this.tileID = (function(c) {
              const h = u.ab.fromPoints(c), z = h.width(), d = h.height(), I = Math.max(z, d), p = Math.max(0, Math.floor(-Math.log(I) / Math.LN2)), f = Math.pow(2, p);
              return new u.ad(p, Math.floor((h.minX + h.maxX) / 2 * f), Math.floor((h.minY + h.maxY) / 2 * f));
            })(r), this.terrainTileRanges = this._getOverlappingTileRanges(r), this.minzoom = this.maxzoom = this.tileID.z, this.tileCoords = r.map(((c) => this.tileID.getTilePoint(c)._round())), this.flippedWindingOrder = ((o = this.tileCoords)[1].x - o[0].x) * (o[2].y - o[0].y) - (o[1].y - o[0].y) * (o[2].x - o[0].x) < 0, this.fire(new u.l("data", { dataType: "source", sourceDataType: "content" })), this;
          }
          prepare() {
            if (Object.keys(this.tiles).length === 0 || !this.image) return;
            const e = this.map.painter.context, r = e.gl;
            this.texture || (this.texture = new u.T(e, this.image, r.RGBA), this.texture.bind(r.LINEAR, r.CLAMP_TO_EDGE));
            let o = !1;
            for (const c in this.tiles) {
              const h = this.tiles[c];
              h.state !== "loaded" && (h.state = "loaded", h.texture = this.texture, o = !0);
            }
            o && this.fire(new u.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
          }
          loadTile(e) {
            return u._(this, void 0, void 0, (function* () {
              this.tileID && this.tileID.equals(e.tileID.canonical) ? (this.tiles[String(e.tileID.wrap)] = e, e.buckets = {}) : e.state = "errored";
            }));
          }
          serialize() {
            return { type: "image", url: this.options.url, coordinates: this.coordinates };
          }
          hasTransition() {
            return !1;
          }
          _getOverlappingTileRanges(e) {
            const { minX: r, minY: o, maxX: c, maxY: h } = u.ab.fromPoints(e), z = {};
            for (let d = 0; d <= u.ac; d++) {
              const I = Math.pow(2, d), p = Math.floor(r * I), f = Math.floor(o * I), _ = Math.floor(c * I), j = Math.floor(h * I);
              z[d] = { minTileX: p, minTileY: f, maxTileX: _, maxTileY: j };
            }
            return z;
          }
        }
        class mn extends Ts {
          constructor(e, r, o, c) {
            super(e, r, o, c), this.roundZoom = !0, this.type = "video", this.options = r;
          }
          load() {
            return u._(this, void 0, void 0, (function* () {
              this._loaded = !1;
              const e = this.options;
              this.urls = [];
              for (const r of e.urls) this.urls.push(this.map._requestManager.transformRequest(r, "Source").url);
              try {
                const r = yield u.ae(this.urls);
                if (this._loaded = !0, !r) return;
                this.video = r, this.video.loop = !0, this.video.addEventListener("playing", (() => {
                  this.map.triggerRepaint();
                })), this.map && this.video.play(), this._finishLoading();
              } catch (r) {
                this.fire(new u.k(r));
              }
            }));
          }
          pause() {
            this.video && this.video.pause();
          }
          play() {
            this.video && this.video.play();
          }
          seek(e) {
            if (this.video) {
              const r = this.video.seekable;
              e < r.start(0) || e > r.end(0) ? this.fire(new u.k(new u.af(`sources.${this.id}`, null, `Playback for this video can be set only between the ${r.start(0)} and ${r.end(0)}-second mark.`))) : this.video.currentTime = e;
            }
          }
          getVideo() {
            return this.video;
          }
          onAdd(e) {
            this.map || (this.map = e, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
          }
          prepare() {
            if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2) return;
            const e = this.map.painter.context, r = e.gl;
            this.texture ? this.video.paused || (this.texture.bind(r.LINEAR, r.CLAMP_TO_EDGE), r.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, r.RGBA, r.UNSIGNED_BYTE, this.video)) : (this.texture = new u.T(e, this.video, r.RGBA), this.texture.bind(r.LINEAR, r.CLAMP_TO_EDGE));
            let o = !1;
            for (const c in this.tiles) {
              const h = this.tiles[c];
              h.state !== "loaded" && (h.state = "loaded", h.texture = this.texture, o = !0);
            }
            o && this.fire(new u.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
          }
          serialize() {
            return { type: "video", urls: this.urls, coordinates: this.coordinates };
          }
          hasTransition() {
            return this.video && !this.video.paused;
          }
        }
        class jn extends Ts {
          constructor(e, r, o, c) {
            super(e, r, o, c), r.coordinates ? Array.isArray(r.coordinates) && r.coordinates.length === 4 && !r.coordinates.some(((h) => !Array.isArray(h) || h.length !== 2 || h.some(((z) => typeof z != "number")))) || this.fire(new u.k(new u.af(`sources.${e}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new u.k(new u.af(`sources.${e}`, null, 'missing required property "coordinates"'))), r.animate && typeof r.animate != "boolean" && this.fire(new u.k(new u.af(`sources.${e}`, null, 'optional "animate" property must be a boolean value'))), r.canvas ? typeof r.canvas == "string" || r.canvas instanceof HTMLCanvasElement || this.fire(new u.k(new u.af(`sources.${e}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new u.k(new u.af(`sources.${e}`, null, 'missing required property "canvas"'))), this.options = r, this.animate = r.animate === void 0 || r.animate;
          }
          load() {
            return u._(this, void 0, void 0, (function* () {
              this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new u.k(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
                this._playing = !0, this.map.triggerRepaint();
              }, this.pause = function() {
                this._playing && (this.prepare(), this._playing = !1);
              }, this._finishLoading());
            }));
          }
          getCanvas() {
            return this.canvas;
          }
          onAdd(e) {
            this.map = e, this.load(), this.canvas && this.animate && this.play();
          }
          onRemove() {
            this.pause();
          }
          prepare() {
            let e = !1;
            if (this.canvas.width !== this.width && (this.width = this.canvas.width, e = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, e = !0), this._hasInvalidDimensions() || Object.keys(this.tiles).length === 0) return;
            const r = this.map.painter.context, o = r.gl;
            this.texture ? (e || this._playing) && this.texture.update(this.canvas, { premultiply: !0 }) : this.texture = new u.T(r, this.canvas, o.RGBA, { premultiply: !0 });
            let c = !1;
            for (const h in this.tiles) {
              const z = this.tiles[h];
              z.state !== "loaded" && (z.state = "loaded", z.texture = this.texture, c = !0);
            }
            c && this.fire(new u.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
          }
          serialize() {
            return { type: "canvas", animate: this.animate, canvas: this.options.canvas, coordinates: this.coordinates };
          }
          hasTransition() {
            return this._playing;
          }
          _hasInvalidDimensions() {
            for (const e of [this.canvas.width, this.canvas.height]) if (isNaN(e) || e <= 0) return !0;
            return !1;
          }
        }
        const lr = {}, Ur = (g) => {
          switch (g) {
            case "geojson":
              return cr;
            case "image":
              return Ts;
            case "raster":
              return Yr;
            case "raster-dem":
              return Ui;
            case "vector":
              return Mi;
            case "video":
              return mn;
            case "canvas":
              return jn;
          }
          return lr[g];
        }, Wi = "RTLPluginLoaded";
        class Xr extends u.E {
          constructor() {
            super(...arguments), this.status = "unavailable", this.url = null, this.dispatcher = Mr();
          }
          _syncState(e) {
            return this.status = e, this.dispatcher.broadcast("SRPS", { pluginStatus: e, pluginURL: this.url }).catch(((r) => {
              throw this.status = "error", r;
            }));
          }
          getRTLTextPluginStatus() {
            return this.status;
          }
          clearRTLTextPlugin() {
            this.status = "unavailable", this.url = null;
          }
          setRTLTextPlugin(e) {
            return u._(this, arguments, void 0, (function* (r, o = !1) {
              if (this.url) throw new Error("setRTLTextPlugin cannot be called multiple times.");
              if (this.url = Ke.resolveURL(r), !this.url) throw new Error(`requested url ${r} is invalid`);
              if (this.status === "unavailable") {
                if (!o) return this._requestImport();
                this.status = "deferred", this._syncState(this.status);
              } else if (this.status === "requested") return this._requestImport();
            }));
          }
          _requestImport() {
            return u._(this, void 0, void 0, (function* () {
              yield this._syncState("loading"), this.status = "loaded", this.fire(new u.l(Wi));
            }));
          }
          lazyLoad() {
            this.status === "unavailable" ? this.status = "requested" : this.status === "deferred" && this._requestImport();
          }
        }
        let ur = null;
        function Hs() {
          return ur || (ur = new Xr()), ur;
        }
        var Os, tt;
        (function(g) {
          g[g.Base = 0] = "Base", g[g.Parent = 1] = "Parent";
        })(Os || (Os = {})), (function(g) {
          g[g.Departing = 0] = "Departing", g[g.Incoming = 1] = "Incoming";
        })(tt || (tt = {}));
        class E {
          constructor(e, r) {
            this.timeAdded = 0, this.fadeEndTime = 0, this.fadeOpacity = 1, this.tileID = e, this.uid = u.ag(), this.uses = 0, this.tileSize = r, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.rtt = [], this.rttCoords = {}, this.expiredRequestCount = 0, this.state = "loading";
          }
          isRenderable(e) {
            return this.hasData() && (!this.fadeEndTime || this.fadeOpacity > 0) && (e || !this.holdingForSymbolFade());
          }
          setCrossFadeLogic({ fadingRole: e, fadingDirection: r, fadingParentID: o, fadeEndTime: c }) {
            this.resetFadeLogic(), this.fadingRole = e, this.fadingDirection = r, this.fadingParentID = o, this.fadeEndTime = c;
          }
          setSelfFadeLogic(e) {
            this.resetFadeLogic(), this.selfFading = !0, this.fadeEndTime = e;
          }
          resetFadeLogic() {
            this.fadingRole = null, this.fadingDirection = null, this.fadingParentID = null, this.selfFading = !1, this.timeAdded = $t(), this.fadeEndTime = 0, this.fadeOpacity = 1;
          }
          wasRequested() {
            return this.state === "errored" || this.state === "loaded" || this.state === "reloading";
          }
          clearTextures(e) {
            this.demTexture && e.saveTileTexture(this.demTexture), this.demTexture = null;
          }
          loadVectorData(e, r, o) {
            if (this.hasData() && this.unloadVectorData(), this.state = "loaded", e) {
              e.featureIndex && (this.latestFeatureIndex = e.featureIndex, e.rawTileData ? (this.latestRawTileData = e.rawTileData, this.latestFeatureIndex.rawTileData = e.rawTileData, this.latestFeatureIndex.encoding = e.encoding) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData, this.latestFeatureIndex.encoding = this.latestEncoding)), this.collisionBoxArray = e.collisionBoxArray, this.buckets = (function(c, h) {
                const z = {};
                if (!h) return z;
                for (const d of c) {
                  const I = d.layerIds.map(((p) => h.getLayer(p))).filter(Boolean);
                  if (I.length !== 0) {
                    d.layers = I, d.stateDependentLayerIds && (d.stateDependentLayers = d.stateDependentLayerIds.map(((p) => I.filter(((f) => f.id === p))[0])));
                    for (const p of I) z[p.id] = d;
                  }
                }
                return z;
              })(e.buckets, r?.style), this.hasSymbolBuckets = !1;
              for (const c in this.buckets) {
                const h = this.buckets[c];
                if (h instanceof u.ai) {
                  if (this.hasSymbolBuckets = !0, !o) break;
                  h.justReloaded = !0;
                }
              }
              if (this.hasRTLText = !1, this.hasSymbolBuckets) for (const c in this.buckets) {
                const h = this.buckets[c];
                if (h instanceof u.ai && h.hasRTLText) {
                  this.hasRTLText = !0, Hs().lazyLoad();
                  break;
                }
              }
              this.queryPadding = 0;
              for (const c in this.buckets) {
                const h = this.buckets[c];
                this.queryPadding = Math.max(this.queryPadding, r.style.getLayer(c).queryRadius(h));
              }
              e.imageAtlas && (this.imageAtlas = e.imageAtlas), e.glyphAtlasImage && (this.glyphAtlasImage = e.glyphAtlasImage), this.dashPositions = e.dashPositions;
            } else this.collisionBoxArray = new u.ah();
          }
          unloadVectorData() {
            for (const e in this.buckets) this.buckets[e].destroy();
            this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.dashPositions && (this.dashPositions = null), this.latestFeatureIndex = null, this.state = "unloaded";
          }
          getBucket(e) {
            return this.buckets[e.id];
          }
          upload(e) {
            for (const o in this.buckets) {
              const c = this.buckets[o];
              c.uploadPending() && c.upload(e);
            }
            const r = e.gl;
            this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new u.T(e, this.imageAtlas.image, r.RGBA), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new u.T(e, this.glyphAtlasImage, r.ALPHA), this.glyphAtlasImage = null);
          }
          prepare(e) {
            this.imageAtlas && this.imageAtlas.patchUpdatedImages(e, this.imageAtlasTexture);
          }
          queryRenderedFeatures(e, r, o, c, h, z, d, I, p, f, _) {
            return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ queryGeometry: c, cameraQueryGeometry: h, scale: z, tileSize: this.tileSize, pixelPosMatrix: f, transform: I, params: d, queryPadding: this.queryPadding * p, getElevation: _ }, e, r, o) : {};
          }
          querySourceFeatures(e, r) {
            const o = this.latestFeatureIndex;
            if (!o || !o.rawTileData) return;
            const c = o.loadVTLayers(), h = r && r.sourceLayer ? r.sourceLayer : "", z = c[u.a9] || c[h];
            if (!z) return;
            const d = u.aj(r?.filter, r?.globalState), { z: I, x: p, y: f } = this.tileID.canonical, _ = { z: I, x: p, y: f };
            for (let j = 0; j < z.length; j++) {
              const C = z.feature(j);
              if (d.needGeometry) {
                const Y = u.ak(C, !0);
                if (!d.filter(new u.H(this.tileID.overscaledZ), Y, this.tileID.canonical)) continue;
              } else if (!d.filter(new u.H(this.tileID.overscaledZ), C)) continue;
              const v = o.getId(C, h), F = new u.al(C, I, p, f, v);
              F.tile = _, e.push(F);
            }
          }
          hasData() {
            return this.state === "loaded" || this.state === "reloading" || this.state === "expired";
          }
          patternsLoaded() {
            return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
          }
          setExpiryData(e) {
            const r = this.expirationTime;
            if (e.cacheControl) {
              const o = u.am(e.cacheControl);
              o["max-age"] && (this.expirationTime = Date.now() + 1e3 * o["max-age"]);
            } else e.expires && (this.expirationTime = new Date(e.expires).getTime());
            if (this.expirationTime) {
              const o = Date.now();
              let c = !1;
              if (this.expirationTime > o) c = !1;
              else if (r) if (this.expirationTime < r) c = !0;
              else {
                const h = this.expirationTime - r;
                h ? this.expirationTime = o + Math.max(h, 3e4) : c = !0;
              }
              else c = !0;
              c ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
            }
          }
          getExpiryTimeout() {
            if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
          }
          setFeatureState(e, r) {
            if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || Object.keys(e).length === 0) return;
            const o = this.latestFeatureIndex.loadVTLayers();
            for (const c in this.buckets) {
              if (!r.style.hasLayer(c)) continue;
              const h = this.buckets[c], z = h.layers[0].sourceLayer || u.a9, d = o[z], I = e[z];
              if (!d || !I || Object.keys(I).length === 0) continue;
              h.update(I, d, this.imageAtlas && this.imageAtlas.patternPositions || {}, this.dashPositions || {});
              const p = r && r.style && r.style.getLayer(c);
              p && (this.queryPadding = Math.max(this.queryPadding, p.queryRadius(h)));
            }
          }
          holdingForSymbolFade() {
            return this.symbolFadeHoldUntil !== void 0;
          }
          symbolFadeFinished() {
            return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < $t();
          }
          clearSymbolFadeHold() {
            this.symbolFadeHoldUntil = void 0;
          }
          setSymbolHoldDuration(e) {
            this.symbolFadeHoldUntil = $t() + e;
          }
          setDependencies(e, r) {
            const o = {};
            for (const c of r) o[c] = !0;
            this.dependencies[e] = o;
          }
          hasDependency(e, r) {
            for (const o of e) {
              const c = this.dependencies[o];
              if (c) {
                for (const h of r) if (c[h]) return !0;
              }
            }
            return !1;
          }
        }
        class Q {
          constructor() {
            this.state = {}, this.stateChanges = {}, this.deletedStates = {};
          }
          updateState(e, r, o) {
            const c = String(r);
            if (this.stateChanges[e] = this.stateChanges[e] || {}, this.stateChanges[e][c] = this.stateChanges[e][c] || {}, u.e(this.stateChanges[e][c], o), this.deletedStates[e] === null) {
              this.deletedStates[e] = {};
              for (const h in this.state[e]) h !== c && (this.deletedStates[e][h] = null);
            } else if (this.deletedStates[e] && this.deletedStates[e][c] === null) {
              this.deletedStates[e][c] = {};
              for (const h in this.state[e][c]) o[h] || (this.deletedStates[e][c][h] = null);
            } else for (const h in o) this.deletedStates[e] && this.deletedStates[e][c] && this.deletedStates[e][c][h] === null && delete this.deletedStates[e][c][h];
          }
          removeFeatureState(e, r, o) {
            if (this.deletedStates[e] === null) return;
            const c = String(r);
            if (this.deletedStates[e] = this.deletedStates[e] || {}, o && r !== void 0) this.deletedStates[e][c] !== null && (this.deletedStates[e][c] = this.deletedStates[e][c] || {}, this.deletedStates[e][c][o] = null);
            else if (r !== void 0) if (this.stateChanges[e] && this.stateChanges[e][c]) for (o in this.deletedStates[e][c] = {}, this.stateChanges[e][c]) this.deletedStates[e][c][o] = null;
            else this.deletedStates[e][c] = null;
            else this.deletedStates[e] = null;
          }
          getState(e, r) {
            const o = String(r), c = u.e({}, (this.state[e] || {})[o], (this.stateChanges[e] || {})[o]);
            if (this.deletedStates[e] === null) return {};
            if (this.deletedStates[e]) {
              const h = this.deletedStates[e][r];
              if (h === null) return {};
              for (const z in h) delete c[z];
            }
            return c;
          }
          initializeTileState(e, r) {
            e.setFeatureState(this.state, r);
          }
          coalesceChanges(e, r) {
            const o = {};
            for (const c in this.stateChanges) {
              this.state[c] = this.state[c] || {};
              const h = {};
              for (const z in this.stateChanges[c]) this.state[c][z] || (this.state[c][z] = {}), u.e(this.state[c][z], this.stateChanges[c][z]), h[z] = this.state[c][z];
              o[c] = h;
            }
            for (const c in this.deletedStates) {
              this.state[c] = this.state[c] || {};
              const h = {};
              if (this.deletedStates[c] === null) for (const z in this.state[c]) h[z] = {}, this.state[c][z] = {};
              else for (const z in this.deletedStates[c]) {
                if (this.deletedStates[c][z] === null) this.state[c][z] = {};
                else for (const d of Object.keys(this.deletedStates[c][z])) delete this.state[c][z][d];
                h[z] = this.state[c][z];
              }
              o[c] = o[c] || {}, u.e(o[c], h);
            }
            if (this.stateChanges = {}, this.deletedStates = {}, Object.keys(o).length !== 0) for (const c in e) e[c].setFeatureState(o, r);
          }
        }
        const S = 89.25;
        function V(g, e) {
          const r = u.an(e.lat, -u.ao, u.ao);
          return new u.P(u.Y(e.lng) * g, u.X(r) * g);
        }
        function H(g, e) {
          return new u.aa(e.x / g, e.y / g).toLngLat();
        }
        function rt(g) {
          return g.cameraToCenterDistance * Math.min(0.85 * Math.tan(u.ap(90 - g.pitch)), Math.tan(u.ap(S - g.pitch)));
        }
        function X(g, e) {
          const r = g.canonical, o = e / u.aq(r.z), c = r.x + Math.pow(2, r.z) * g.wrap, h = u.ar(new Float64Array(16));
          return u.O(h, h, [c * o, r.y * o, 0]), u.Q(h, h, [o / u.a4, o / u.a4, 1]), h;
        }
        function it(g, e, r, o, c) {
          const h = u.aa.fromLngLat(g, e), z = c * u.as(1, g.lat), d = z * Math.cos(u.ap(r)), I = Math.sqrt(z * z - d * d), p = I * Math.sin(u.ap(-o)), f = I * Math.cos(u.ap(-o));
          return new u.aa(h.x + p, h.y + f, h.z + d);
        }
        function lt(g, e, r) {
          const o = e.intersectsFrustum(g);
          if (!r || o === 0) return o;
          const c = e.intersectsPlane(r);
          return c === 0 ? 0 : o === 2 && c === 2 ? 2 : 1;
        }
        function ut(g, e, r) {
          let o = 0;
          const c = (r - e) / 10;
          for (let h = 0; h < 10; h++) o += c * Math.pow(Math.cos(e + (h + 0.5) / 10 * (r - e)), g);
          return o;
        }
        function ht(g, e) {
          return function(r, o, c, h, z) {
            const d = 2 * ((g - 1) / u.at(Math.cos(u.ap(S - z)) / Math.cos(u.ap(S))) - 1), I = Math.acos(c / h), p = 2 * ut(d - 1, 0, u.ap(z / 2)), f = Math.min(u.ap(S), I + u.ap(z / 2)), _ = ut(d - 1, Math.min(f, I - u.ap(z / 2)), f), j = Math.atan(o / c), C = Math.hypot(o, c);
            let v = r;
            return v += u.at(h / C / Math.max(0.5, Math.cos(u.ap(z / 2)))), v += d * u.at(Math.cos(j)) / 2, v -= u.at(Math.max(1, _ / p / e)) / 2, v;
          };
        }
        const _t = ht(9.314, 3);
        function vt(g, e) {
          const r = (e.roundZoom ? Math.round : Math.floor)(g.zoom + u.at(g.tileSize / e.tileSize));
          return Math.max(0, r);
        }
        function Xt(g, e) {
          const r = g.getCameraFrustum(), o = g.getClippingPlane(), c = g.screenPointToMercatorCoordinate(g.getCameraPoint()), h = u.aa.fromLngLat(g.center, g.elevation);
          c.z = h.z + Math.cos(g.pitchInRadians) * g.cameraToCenterDistance / g.worldSize;
          const z = g.getCoveringTilesDetailsProvider(), d = z.allowVariableZoom(g, e), I = vt(g, e), p = e.minzoom || 0, f = e.maxzoom !== void 0 ? e.maxzoom : g.maxZoom, _ = Math.min(Math.max(0, I), f), j = Math.pow(2, _), C = [j * c.x, j * c.y, 0], v = [j * h.x, j * h.y, 0], F = Math.hypot(h.x - c.x, h.y - c.y), Y = Math.abs(h.z - c.z), W = Math.hypot(F, Y), Z = (q) => ({ zoom: 0, x: 0, y: 0, wrap: q, fullyVisible: !1 }), J = [], R = [];
          if (g.renderWorldCopies && z.allowWorldCopies()) for (let q = 1; q <= 3; q++) J.push(Z(-q)), J.push(Z(q));
          for (J.push(Z(0)); J.length > 0; ) {
            const q = J.pop(), $ = q.x, G = q.y;
            let st = q.fullyVisible;
            const ct = { x: $, y: G, z: q.zoom }, nt = z.getTileBoundingVolume(ct, q.wrap, g.elevation, e);
            if (!st) {
              const wt = lt(r, nt, o);
              if (wt === 0) continue;
              st = wt === 2;
            }
            const at = z.distanceToTile2d(c.x, c.y, ct, nt);
            let Mt = I;
            d && (Mt = (e.calculateTileZoom || _t)(g.zoom + u.at(g.tileSize / e.tileSize), at, Y, W, g.fov)), Mt = (e.roundZoom ? Math.round : Math.floor)(Mt), Mt = Math.max(0, Mt);
            const xt = Math.min(Mt, f);
            if (q.wrap = z.getWrap(h, ct, q.wrap), q.zoom >= xt) {
              if (q.zoom < p) continue;
              const wt = _ - q.zoom, Nt = C[0] - 0.5 - ($ << wt), Ct = C[1] - 0.5 - (G << wt), Ut = e.reparseOverscaled ? Math.max(q.zoom, Mt) : q.zoom;
              R.push({ tileID: new u.a1(q.zoom === f ? Ut : q.zoom, q.wrap, q.zoom, $, G), distanceSq: u.au([v[0] - 0.5 - $, v[1] - 0.5 - G]), tileDistanceToCamera: Math.sqrt(Nt * Nt + Ct * Ct) });
            } else for (let wt = 0; wt < 4; wt++) J.push({ zoom: q.zoom + 1, x: ($ << 1) + wt % 2, y: (G << 1) + (wt >> 1), wrap: q.wrap, fullyVisible: st });
          }
          return R.sort(((q, $) => q.distanceSq - $.distanceSq)).map(((q) => q.tileID));
        }
        const _e = u.ab.fromPoints([new u.P(0, 0), new u.P(u.a4, u.a4)]);
        class Zt extends u.E {
          constructor(e, r, o) {
            super(), this.id = e, this.dispatcher = o, this.on("data", ((c) => this._dataHandler(c))), this.on("dataloading", (() => {
              this._sourceErrored = !1;
            })), this.on("error", (() => {
              this._sourceErrored = this._source.loaded();
            })), this._source = ((c, h, z, d) => {
              const I = new (Ur(h.type))(c, h, z, d);
              if (I.id !== c) throw new Error(`Expected Source id to be ${c} instead of ${I.id}`);
              return I;
            })(e, r, o, this), this._tiles = {}, this._cache = new u.av(0, ((c) => this._unloadTile(c))), this._timers = {}, this._maxTileCacheSize = null, this._maxTileCacheZoomLevels = null, this._rasterFadeDuration = 0, this._maxFadingAncestorLevels = 5, this._state = new Q(), this._didEmitContent = !1, this._updated = !1;
          }
          onAdd(e) {
            this.map = e, this._maxTileCacheSize = e ? e._maxTileCacheSize : null, this._maxTileCacheZoomLevels = e ? e._maxTileCacheZoomLevels : null, this._source && this._source.onAdd && this._source.onAdd(e);
          }
          onRemove(e) {
            this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(e);
          }
          loaded() {
            if (this._sourceErrored) return !0;
            if (!this._sourceLoaded || !this._source.loaded()) return !1;
            if (!(this.used === void 0 && this.usedForTerrain === void 0 || this.used || this.usedForTerrain)) return !0;
            if (!this._updated) return !1;
            for (const e in this._tiles) {
              const r = this._tiles[e];
              if (r.state !== "loaded" && r.state !== "errored") return !1;
            }
            return !0;
          }
          getSource() {
            return this._source;
          }
          getState() {
            return this._state;
          }
          pause() {
            this._paused = !0;
          }
          resume() {
            if (!this._paused) return;
            const e = this._shouldReloadOnResume;
            this._paused = !1, this._shouldReloadOnResume = !1, e && this.reload(), this.transform && this.update(this.transform, this.terrain);
          }
          _loadTile(e, r, o) {
            return u._(this, void 0, void 0, (function* () {
              try {
                yield this._source.loadTile(e), this._tileLoaded(e, r, o);
              } catch (c) {
                e.state = "errored", c.status !== 404 ? this._source.fire(new u.k(c, { tile: e })) : this.update(this.transform, this.terrain);
              }
            }));
          }
          _unloadTile(e) {
            this._source.unloadTile && this._source.unloadTile(e);
          }
          _abortTile(e) {
            this._source.abortTile && this._source.abortTile(e), this._source.fire(new u.l("dataabort", { tile: e, coord: e.tileID, dataType: "source" }));
          }
          serialize() {
            return this._source.serialize();
          }
          prepare(e) {
            this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
            for (const r in this._tiles) {
              const o = this._tiles[r];
              o.upload(e), o.prepare(this.map.style.imageManager);
            }
          }
          getIds() {
            return Object.values(this._tiles).map(((e) => e.tileID)).sort(te).map(((e) => e.key));
          }
          getRenderableIds(e) {
            const r = [];
            for (const o in this._tiles) this._isIdRenderable(o, e) && r.push(this._tiles[o]);
            return e ? r.sort(((o, c) => {
              const h = o.tileID, z = c.tileID, d = new u.P(h.canonical.x, h.canonical.y)._rotate(-this.transform.bearingInRadians), I = new u.P(z.canonical.x, z.canonical.y)._rotate(-this.transform.bearingInRadians);
              return h.overscaledZ - z.overscaledZ || I.y - d.y || I.x - d.x;
            })).map(((o) => o.tileID.key)) : r.map(((o) => o.tileID)).sort(te).map(((o) => o.key));
          }
          hasRenderableParent(e) {
            const r = e.overscaledZ - 1;
            if (r >= this._source.minzoom) {
              const o = this.getLoadedTile(e.scaledTo(r));
              if (o) return this._isIdRenderable(o.tileID.key);
            }
            return !1;
          }
          _isIdRenderable(e, r = !1) {
            var o;
            return (o = this._tiles[e]) === null || o === void 0 ? void 0 : o.isRenderable(r);
          }
          reload(e, r = void 0) {
            if (this._paused) this._shouldReloadOnResume = !0;
            else {
              this._cache.reset();
              for (const o in this._tiles) r && this._source.shouldReloadTile && !this._source.shouldReloadTile(this._tiles[o], r) || (e ? this._reloadTile(o, "expired") : this._tiles[o].state !== "errored" && this._reloadTile(o, "reloading"));
            }
          }
          _reloadTile(e, r) {
            return u._(this, void 0, void 0, (function* () {
              const o = this._tiles[e];
              o && (o.state !== "loading" && (o.state = r), yield this._loadTile(o, e, r));
            }));
          }
          _tileLoaded(e, r, o) {
            e.timeAdded = $t(), e.selfFading && (e.fadeEndTime = e.timeAdded + this._rasterFadeDuration), o === "expired" && (e.refreshedUponExpiration = !0), this._setTileReloadTimer(r, e), this.getSource().type === "raster-dem" && e.dem && this._backfillDEM(e), this._state.initializeTileState(e, this.map ? this.map.painter : null), e.aborted || this._source.fire(new u.l("data", { dataType: "source", tile: e, coord: e.tileID }));
          }
          _backfillDEM(e) {
            const r = this.getRenderableIds();
            for (let c = 0; c < r.length; c++) {
              const h = r[c];
              if (e.neighboringTiles && e.neighboringTiles[h]) {
                const z = this.getTileByID(h);
                o(e, z), o(z, e);
              }
            }
            function o(c, h) {
              c.needsHillshadePrepare = !0, c.needsTerrainPrepare = !0;
              let z = h.tileID.canonical.x - c.tileID.canonical.x;
              const d = h.tileID.canonical.y - c.tileID.canonical.y, I = Math.pow(2, c.tileID.canonical.z), p = h.tileID.key;
              z === 0 && d === 0 || Math.abs(d) > 1 || (Math.abs(z) > 1 && (Math.abs(z + I) === 1 ? z += I : Math.abs(z - I) === 1 && (z -= I)), h.dem && c.dem && (c.dem.backfillBorder(h.dem, z, d), c.neighboringTiles && c.neighboringTiles[p] && (c.neighboringTiles[p].backfilled = !0)));
            }
          }
          getTile(e) {
            return this.getTileByID(e.key);
          }
          getTileByID(e) {
            return this._tiles[e];
          }
          _retainLoadedChildren(e, r) {
            const o = this._getLoadedDescendents(r), c = /* @__PURE__ */ new Set();
            for (const h of r) {
              const z = o[h.key];
              if (!z?.length) {
                c.add(h);
                continue;
              }
              const d = h.overscaledZ + Zt.maxOverzooming, I = z.filter(((_) => _.tileID.overscaledZ <= d));
              if (!I.length) {
                c.add(h);
                continue;
              }
              const p = Math.min(...I.map(((_) => _.tileID.overscaledZ))), f = I.filter(((_) => _.tileID.overscaledZ === p)).map(((_) => _.tileID));
              for (const _ of f) e[_.key] = _;
              this._areDescendentsComplete(f, p, h.overscaledZ) || c.add(h);
            }
            return c;
          }
          _getLoadedDescendents(e) {
            var r;
            const o = {};
            for (const c in this._tiles) {
              const h = this._tiles[c];
              if (h.hasData()) for (const z of e) h.tileID.isChildOf(z) && (o[r = z.key] || (o[r] = [])).push(h);
            }
            return o;
          }
          _areDescendentsComplete(e, r, o) {
            return e.length === 1 && e[0].isOverscaled() ? e[0].overscaledZ === r : Math.pow(4, r - o) === e.length;
          }
          getLoadedTile(e) {
            const r = this._tiles[e.key];
            return r?.hasData() ? r : null;
          }
          updateCacheSize(e) {
            const r = Math.ceil(e.width / this._source.tileSize) + 1, o = Math.ceil(e.height / this._source.tileSize) + 1, c = Math.floor(r * o * (this._maxTileCacheZoomLevels === null ? u.a.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels)), h = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, c) : c;
            this._cache.setMaxSize(h);
          }
          handleWrapJump(e) {
            const r = Math.round((e - (this._prevLng === void 0 ? e : this._prevLng)) / 360);
            if (this._prevLng = e, r) {
              const o = {};
              for (const c in this._tiles) {
                const h = this._tiles[c];
                h.tileID = h.tileID.unwrapTo(h.tileID.wrap + r), o[h.tileID.key] = h;
              }
              this._tiles = o, this._resetTileReloadTimers();
            }
          }
          update(e, r) {
            if (!this._sourceLoaded || this._paused) return;
            let o;
            this.transform = e, this.terrain = r, this.updateCacheSize(e), this.handleWrapJump(this.transform.center.lng), this.used || this.usedForTerrain ? this._source.tileID ? o = e.getVisibleUnwrappedCoordinates(this._source.tileID).map(((I) => new u.a1(I.canonical.z, I.wrap, I.canonical.z, I.canonical.x, I.canonical.y))) : (o = Xt(e, { tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.type === "vector" && this.map._zoomLevelsToOverscale !== void 0 ? e.maxZoom - this.map._zoomLevelsToOverscale : this._source.maxzoom, roundZoom: !this.usedForTerrain && this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled, terrain: r, calculateTileZoom: this._source.calculateTileZoom }), this._source.hasTile && (o = o.filter(((I) => this._source.hasTile(I))))) : o = [], this.usedForTerrain && (o = this._addTerrainIdealTiles(o));
            const c = o.length === 0 && !this._updated && this._didEmitContent;
            this._updated = !0, c && this.fire(new u.l("data", { sourceDataType: "idle", dataType: "source", sourceId: this.id }));
            const h = vt(e, this._source), z = this._updateRetainedTiles(o, h), d = oe(this._source.type);
            d && this._rasterFadeDuration > 0 && !r && this._updateFadingTiles(o, z), d ? this._cleanUpRasterTiles(z) : this._cleanUpVectorTiles(z);
          }
          _cleanUpRasterTiles(e) {
            for (const r in this._tiles) e[r] || this._removeTile(r);
          }
          _cleanUpVectorTiles(e) {
            for (const r in this._tiles) {
              const o = this._tiles[r];
              e[r] ? o.clearSymbolFadeHold() : o.hasSymbolBuckets ? o.holdingForSymbolFade() ? o.symbolFadeFinished() && this._removeTile(r) : o.setSymbolHoldDuration(this.map._fadeDuration) : this._removeTile(r);
            }
          }
          _addTerrainIdealTiles(e) {
            const r = [];
            for (const o of e) if (o.canonical.z > this._source.minzoom) {
              const c = o.scaledTo(o.canonical.z - 1);
              r.push(c);
              const h = o.scaledTo(Math.max(this._source.minzoom, Math.min(o.canonical.z, 5)));
              r.push(h);
            }
            return e.concat(r);
          }
          releaseSymbolFadeTiles() {
            for (const e in this._tiles) this._tiles[e].holdingForSymbolFade() && this._removeTile(e);
          }
          _updateRetainedTiles(e, r) {
            var o;
            const c = /* @__PURE__ */ new Set();
            for (const p of e) this._addTile(p).hasData() || c.add(p);
            const h = e.reduce(((p, f) => (p[f.key] = f, p)), {}), z = this._retainLoadedChildren(h, c), d = {}, I = Math.max(r - Zt.maxUnderzooming, this._source.minzoom);
            for (const p of z) {
              let f = this._tiles[p.key], _ = f?.wasRequested();
              for (let j = p.overscaledZ - 1; j >= I; --j) {
                const C = p.scaledTo(j);
                if (d[C.key]) break;
                if (d[C.key] = !0, f = this.getTile(C), !f && _ && (f = this._addTile(C)), f) {
                  const v = f.hasData();
                  if ((v || !(!((o = this.map) === null || o === void 0) && o.cancelPendingTileRequestsWhileZooming) || _) && (h[C.key] = C), _ = f.wasRequested(), v) break;
                }
              }
            }
            return h;
          }
          _updateFadingTiles(e, r) {
            const o = $t(), c = u.aw(e);
            for (const h of e) {
              const z = this._tiles[h.key];
              z.fadingDirection !== tt.Departing && z.fadeOpacity !== 0 || z.resetFadeLogic(), this._updateFadingAncestor(z, r, o) || this._updateFadingDescendents(z, r, o) || this._updateFadingEdge(z, c, o) || z.resetFadeLogic();
            }
          }
          _updateFadingAncestor(e, r, o) {
            if (!e.hasData()) return !1;
            const { tileID: c, fadingRole: h, fadingDirection: z, fadingParentID: d } = e;
            if (h === Os.Base && z === tt.Incoming && d) return r[d.key] = d, !0;
            const I = Math.max(c.overscaledZ - this._maxFadingAncestorLevels, this._source.minzoom);
            for (let p = c.overscaledZ - 1; p >= I; p--) {
              const f = c.scaledTo(p), _ = this.getLoadedTile(f);
              if (_) return e.setCrossFadeLogic({ fadingRole: Os.Base, fadingDirection: tt.Incoming, fadingParentID: _.tileID, fadeEndTime: o + this._rasterFadeDuration }), _.setCrossFadeLogic({ fadingRole: Os.Parent, fadingDirection: tt.Departing, fadeEndTime: o + this._rasterFadeDuration }), r[f.key] = f, !0;
            }
            return !1;
          }
          _updateFadingDescendents(e, r, o) {
            if (!e.hasData()) return !1;
            const c = e.tileID.children(this._source.maxzoom);
            let h = this._updateFadingChildren(e, c, r, o);
            if (h) return !0;
            for (const z of c) {
              const d = z.children(this._source.maxzoom);
              this._updateFadingChildren(e, d, r, o) && (h = !0);
            }
            return h;
          }
          _updateFadingChildren(e, r, o, c) {
            if (r[0].overscaledZ >= this._source.maxzoom) return !1;
            let h = !1;
            for (const z of r) {
              const d = this.getLoadedTile(z);
              if (!d) continue;
              const { fadingRole: I, fadingDirection: p, fadingParentID: f } = d;
              I === Os.Base && p === tt.Departing && f || (d.setCrossFadeLogic({ fadingRole: Os.Base, fadingDirection: tt.Departing, fadingParentID: e.tileID, fadeEndTime: c + this._rasterFadeDuration }), e.setCrossFadeLogic({ fadingRole: Os.Parent, fadingDirection: tt.Incoming, fadeEndTime: c + this._rasterFadeDuration })), o[z.key] = z, h = !0;
            }
            return h;
          }
          _updateFadingEdge(e, r, o) {
            const c = e.tileID;
            return !!e.selfFading || !e.hasData() && !!r.has(c) && (e.setSelfFadeLogic(o + this._rasterFadeDuration), !0);
          }
          _addTile(e) {
            let r = this._tiles[e.key];
            if (r) return r;
            r = this._cache.getAndRemove(e), r && (r.resetFadeLogic(), this._setTileReloadTimer(e.key, r), r.tileID = e, this._state.initializeTileState(r, this.map ? this.map.painter : null));
            const o = r;
            return r || (r = new E(e, this._source.tileSize * e.overscaleFactor()), this._loadTile(r, e.key, r.state)), r.uses++, this._tiles[e.key] = r, o || this._source.fire(new u.l("dataloading", { tile: r, coord: r.tileID, dataType: "source" })), r;
          }
          _setTileReloadTimer(e, r) {
            this._clearTileReloadTimer(e);
            const o = r.getExpiryTimeout();
            o && (this._timers[e] = setTimeout((() => {
              this._reloadTile(e, "expired"), delete this._timers[e];
            }), o));
          }
          _clearTileReloadTimer(e) {
            const r = this._timers[e];
            r && (clearTimeout(r), delete this._timers[e]);
          }
          _resetTileReloadTimers() {
            for (const e in this._timers) clearTimeout(this._timers[e]), delete this._timers[e];
            for (const e in this._tiles) this._setTileReloadTimer(e, this._tiles[e]);
          }
          refreshTiles(e) {
            for (const r in this._tiles) (this._isIdRenderable(r) || this._tiles[r].state == "errored") && e.some(((o) => o.equals(this._tiles[r].tileID.canonical))) && this._reloadTile(r, "expired");
          }
          _removeTile(e) {
            const r = this._tiles[e];
            r && (r.uses--, delete this._tiles[e], this._clearTileReloadTimer(e), r.uses > 0 || (r.hasData() && r.state !== "reloading" ? this._cache.add(r.tileID, r, r.getExpiryTimeout()) : (r.aborted = !0, this._abortTile(r), this._unloadTile(r))));
          }
          _dataHandler(e) {
            e.dataType === "source" && (e.sourceDataType !== "metadata" ? e.sourceDataType === "content" && this._sourceLoaded && !this._paused && (this.reload(e.sourceDataChanged, e.shouldReloadTileOptions), this.transform && this.update(this.transform, this.terrain), this._didEmitContent = !0) : this._sourceLoaded = !0);
          }
          clearTiles() {
            this._shouldReloadOnResume = !1, this._paused = !1;
            for (const e in this._tiles) this._removeTile(e);
            this._cache.reset();
          }
          tilesIn(e, r, o) {
            const c = [], h = this.transform;
            if (!h) return c;
            const z = h.getCoveringTilesDetailsProvider().allowWorldCopies(), d = o ? h.getCameraQueryGeometry(e) : e, I = (C) => h.screenPointToMercatorCoordinate(C, this.terrain), p = this.transformBbox(e, I, !z), f = this.transformBbox(d, I, !z), _ = this.getIds(), j = u.ab.fromPoints(f);
            for (let C = 0; C < _.length; C++) {
              const v = this._tiles[_[C]];
              if (v.holdingForSymbolFade()) continue;
              const F = z ? [v.tileID] : [v.tileID.unwrapTo(-1), v.tileID.unwrapTo(0)], Y = Math.pow(2, h.zoom - v.tileID.overscaledZ), W = r * v.queryPadding * u.a4 / v.tileSize / Y;
              for (const Z of F) {
                const J = j.map(((R) => Z.getTilePoint(new u.aa(R.x, R.y))));
                if (J.expandBy(W), J.intersects(_e)) {
                  const R = p.map((($) => Z.getTilePoint($))), q = f.map((($) => Z.getTilePoint($)));
                  c.push({ tile: v, tileID: z ? Z : Z.unwrapTo(0), queryGeometry: R, cameraQueryGeometry: q, scale: Y });
                }
              }
            }
            return c;
          }
          transformBbox(e, r, o) {
            let c = e.map(r);
            if (o) {
              const h = u.ab.fromPoints(e);
              h.shrinkBy(1e-3 * Math.min(h.width(), h.height()));
              const z = h.map(r);
              u.ab.fromPoints(c).covers(z) || (c = c.map(((d) => d.x > 0.5 ? new u.aa(d.x - 1, d.y, d.z) : d)));
            }
            return c;
          }
          getVisibleCoordinates(e) {
            const r = this.getRenderableIds(e).map(((o) => this._tiles[o].tileID));
            return this.transform && this.transform.populateCache(r), r;
          }
          hasTransition() {
            if (this._source.hasTransition()) return !0;
            if (oe(this._source.type) && this._rasterFadeDuration > 0) {
              const e = $t();
              for (const r in this._tiles) if (this._tiles[r].fadeEndTime >= e) return !0;
            }
            return !1;
          }
          setRasterFadeDuration(e) {
            this._rasterFadeDuration = e;
          }
          setFeatureState(e, r, o) {
            this._state.updateState(e = e || u.a9, r, o);
          }
          removeFeatureState(e, r, o) {
            this._state.removeFeatureState(e = e || u.a9, r, o);
          }
          getFeatureState(e, r) {
            return this._state.getState(e = e || u.a9, r);
          }
          setDependencies(e, r, o) {
            const c = this._tiles[e];
            c && c.setDependencies(r, o);
          }
          reloadTilesForDependencies(e, r) {
            for (const o in this._tiles) this._tiles[o].hasDependency(e, r) && this._reloadTile(o, "reloading");
            this._cache.filter(((o) => !o.hasDependency(e, r)));
          }
        }
        function te(g, e) {
          const r = Math.abs(2 * g.wrap) - +(g.wrap < 0), o = Math.abs(2 * e.wrap) - +(e.wrap < 0);
          return g.overscaledZ - e.overscaledZ || o - r || e.canonical.y - g.canonical.y || e.canonical.x - g.canonical.x;
        }
        function oe(g) {
          return g === "raster" || g === "image" || g === "video";
        }
        Zt.maxUnderzooming = 10, Zt.maxOverzooming = 3;
        class It {
          constructor(e, r) {
            this.reset(e, r);
          }
          reset(e, r) {
            this.points = e || [], this._distances = [0];
            for (let o = 1; o < this.points.length; o++) this._distances[o] = this._distances[o - 1] + this.points[o].dist(this.points[o - 1]);
            this.length = this._distances[this._distances.length - 1], this.padding = Math.min(r || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
          }
          lerp(e) {
            if (this.points.length === 1) return this.points[0];
            e = u.an(e, 0, 1);
            let r = 1, o = this._distances[r];
            const c = e * this.paddedLength + this.padding;
            for (; o < c && r < this._distances.length; ) o = this._distances[++r];
            const h = r - 1, z = this._distances[h], d = o - z, I = d > 0 ? (c - z) / d : 0;
            return this.points[h].mult(1 - I).add(this.points[r].mult(I));
          }
        }
        function De(g, e) {
          let r = !0;
          return g === "always" || g !== "never" && e !== "never" || (r = !1), r;
        }
        class Me {
          constructor(e, r, o) {
            const c = this.boxCells = [], h = this.circleCells = [];
            this.xCellCount = Math.ceil(e / o), this.yCellCount = Math.ceil(r / o);
            for (let z = 0; z < this.xCellCount * this.yCellCount; z++) c.push([]), h.push([]);
            this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e, this.height = r, this.xScale = this.xCellCount / e, this.yScale = this.yCellCount / r, this.boxUid = 0, this.circleUid = 0;
          }
          keysLength() {
            return this.boxKeys.length + this.circleKeys.length;
          }
          insert(e, r, o, c, h) {
            this._forEachCell(r, o, c, h, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e), this.bboxes.push(r), this.bboxes.push(o), this.bboxes.push(c), this.bboxes.push(h);
          }
          insertCircle(e, r, o, c) {
            this._forEachCell(r - c, o - c, r + c, o + c, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e), this.circles.push(r), this.circles.push(o), this.circles.push(c);
          }
          _insertBoxCell(e, r, o, c, h, z) {
            this.boxCells[h].push(z);
          }
          _insertCircleCell(e, r, o, c, h, z) {
            this.circleCells[h].push(z);
          }
          _query(e, r, o, c, h, z, d) {
            if (o < 0 || e > this.width || c < 0 || r > this.height) return [];
            const I = [];
            if (e <= 0 && r <= 0 && this.width <= o && this.height <= c) {
              if (h) return [{ key: null, x1: e, y1: r, x2: o, y2: c }];
              for (let p = 0; p < this.boxKeys.length; p++) I.push({ key: this.boxKeys[p], x1: this.bboxes[4 * p], y1: this.bboxes[4 * p + 1], x2: this.bboxes[4 * p + 2], y2: this.bboxes[4 * p + 3] });
              for (let p = 0; p < this.circleKeys.length; p++) {
                const f = this.circles[3 * p], _ = this.circles[3 * p + 1], j = this.circles[3 * p + 2];
                I.push({ key: this.circleKeys[p], x1: f - j, y1: _ - j, x2: f + j, y2: _ + j });
              }
            } else this._forEachCell(e, r, o, c, this._queryCell, I, { hitTest: h, overlapMode: z, seenUids: { box: {}, circle: {} } }, d);
            return I;
          }
          query(e, r, o, c) {
            return this._query(e, r, o, c, !1, null);
          }
          hitTest(e, r, o, c, h, z) {
            return this._query(e, r, o, c, !0, h, z).length > 0;
          }
          hitTestCircle(e, r, o, c, h) {
            const z = e - o, d = e + o, I = r - o, p = r + o;
            if (d < 0 || z > this.width || p < 0 || I > this.height) return !1;
            const f = [];
            return this._forEachCell(z, I, d, p, this._queryCellCircle, f, { hitTest: !0, overlapMode: c, circle: { x: e, y: r, radius: o }, seenUids: { box: {}, circle: {} } }, h), f.length > 0;
          }
          _queryCell(e, r, o, c, h, z, d, I) {
            const { seenUids: p, hitTest: f, overlapMode: _ } = d, j = this.boxCells[h];
            if (j !== null) {
              const v = this.bboxes;
              for (const F of j) if (!p.box[F]) {
                p.box[F] = !0;
                const Y = 4 * F, W = this.boxKeys[F];
                if (e <= v[Y + 2] && r <= v[Y + 3] && o >= v[Y + 0] && c >= v[Y + 1] && (!I || I(W)) && (!f || !De(_, W.overlapMode)) && (z.push({ key: W, x1: v[Y], y1: v[Y + 1], x2: v[Y + 2], y2: v[Y + 3] }), f)) return !0;
              }
            }
            const C = this.circleCells[h];
            if (C !== null) {
              const v = this.circles;
              for (const F of C) if (!p.circle[F]) {
                p.circle[F] = !0;
                const Y = 3 * F, W = this.circleKeys[F];
                if (this._circleAndRectCollide(v[Y], v[Y + 1], v[Y + 2], e, r, o, c) && (!I || I(W)) && (!f || !De(_, W.overlapMode))) {
                  const Z = v[Y], J = v[Y + 1], R = v[Y + 2];
                  if (z.push({ key: W, x1: Z - R, y1: J - R, x2: Z + R, y2: J + R }), f) return !0;
                }
              }
            }
            return !1;
          }
          _queryCellCircle(e, r, o, c, h, z, d, I) {
            const { circle: p, seenUids: f, overlapMode: _ } = d, j = this.boxCells[h];
            if (j !== null) {
              const v = this.bboxes;
              for (const F of j) if (!f.box[F]) {
                f.box[F] = !0;
                const Y = 4 * F, W = this.boxKeys[F];
                if (this._circleAndRectCollide(p.x, p.y, p.radius, v[Y + 0], v[Y + 1], v[Y + 2], v[Y + 3]) && (!I || I(W)) && !De(_, W.overlapMode)) return z.push(!0), !0;
              }
            }
            const C = this.circleCells[h];
            if (C !== null) {
              const v = this.circles;
              for (const F of C) if (!f.circle[F]) {
                f.circle[F] = !0;
                const Y = 3 * F, W = this.circleKeys[F];
                if (this._circlesCollide(v[Y], v[Y + 1], v[Y + 2], p.x, p.y, p.radius) && (!I || I(W)) && !De(_, W.overlapMode)) return z.push(!0), !0;
              }
            }
          }
          _forEachCell(e, r, o, c, h, z, d, I) {
            const p = this._convertToXCellCoord(e), f = this._convertToYCellCoord(r), _ = this._convertToXCellCoord(o), j = this._convertToYCellCoord(c);
            for (let C = p; C <= _; C++) for (let v = f; v <= j; v++) if (h.call(this, e, r, o, c, this.xCellCount * v + C, z, d, I)) return;
          }
          _convertToXCellCoord(e) {
            return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e * this.xScale)));
          }
          _convertToYCellCoord(e) {
            return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e * this.yScale)));
          }
          _circlesCollide(e, r, o, c, h, z) {
            const d = c - e, I = h - r, p = o + z;
            return p * p > d * d + I * I;
          }
          _circleAndRectCollide(e, r, o, c, h, z, d) {
            const I = (z - c) / 2, p = Math.abs(e - (c + I));
            if (p > I + o) return !1;
            const f = (d - h) / 2, _ = Math.abs(r - (h + f));
            if (_ > f + o) return !1;
            if (p <= I || _ <= f) return !0;
            const j = p - I, C = _ - f;
            return j * j + C * C <= o * o;
          }
        }
        function ke(g, e, r) {
          const o = u.N();
          if (!g) {
            const { vecSouth: _, vecEast: j } = pt(e), C = Qi();
            C[0] = j[0], C[1] = j[1], C[2] = _[0], C[3] = _[1], c = C, (f = (z = (h = C)[0]) * (p = h[3]) - (I = h[2]) * (d = h[1])) && (c[0] = p * (f = 1 / f), c[1] = -d * f, c[2] = -I * f, c[3] = z * f), o[0] = C[0], o[1] = C[1], o[4] = C[2], o[5] = C[3];
          }
          var c, h, z, d, I, p, f;
          return u.Q(o, o, [1 / r, 1 / r, 1]), o;
        }
        function ce(g, e, r, o) {
          if (g) {
            const c = u.N();
            if (!e) {
              const { vecSouth: h, vecEast: z } = pt(r);
              c[0] = z[0], c[1] = z[1], c[4] = h[0], c[5] = h[1];
            }
            return u.Q(c, c, [o, o, 1]), c;
          }
          return r.pixelsToClipSpaceMatrix;
        }
        function pt(g) {
          const e = Math.cos(g.rollInRadians), r = Math.sin(g.rollInRadians), o = Math.cos(g.pitchInRadians), c = Math.cos(g.bearingInRadians), h = Math.sin(g.bearingInRadians), z = u.aB();
          z[0] = -c * o * r - h * e, z[1] = -h * o * r + c * e;
          const d = u.aC(z);
          d < 1e-9 ? u.aD(z) : u.aE(z, z, 1 / d);
          const I = u.aB();
          I[0] = c * o * e - h * r, I[1] = h * o * e + c * r;
          const p = u.aC(I);
          return p < 1e-9 ? u.aD(I) : u.aE(I, I, 1 / p), { vecEast: I, vecSouth: z };
        }
        function Ot(g, e, r, o) {
          let c;
          o ? (c = [g, e, o(g, e), 1], u.aG(c, c, r)) : (c = [g, e, 0, 1], _n(c, c, r));
          const h = c[3];
          return { point: new u.P(c[0] / h, c[1] / h), signedDistanceFromCamera: h, isOccluded: !1 };
        }
        function kt(g, e) {
          return 0.5 + g / e * 0.5;
        }
        function fs(g, e) {
          return g.x >= -e[0] && g.x <= e[0] && g.y >= -e[1] && g.y <= e[1];
        }
        function gr(g, e, r, o, c, h, z, d, I, p, f, _, j) {
          const C = r ? g.textSizeData : g.iconSizeData, v = u.ax(C, e.transform.zoom), F = [256 / e.width * 2 + 1, 256 / e.height * 2 + 1], Y = r ? g.text.dynamicLayoutVertexArray : g.icon.dynamicLayoutVertexArray;
          Y.clear();
          const W = g.lineVertexArray, Z = r ? g.text.placedSymbolArray : g.icon.placedSymbolArray, J = e.transform.width / e.transform.height;
          let R = !1;
          for (let q = 0; q < Z.length; q++) {
            const $ = Z.get(q);
            if ($.hidden || $.writingMode === u.ay.vertical && !R) {
              li($.numGlyphs, Y);
              continue;
            }
            R = !1;
            const G = new u.P($.anchorX, $.anchorY), st = { getElevation: j, pitchedLabelPlaneMatrix: o, lineVertexArray: W, pitchWithMap: h, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: !1 }, transform: e.transform, tileAnchorPoint: G, unwrappedTileID: I, width: p, height: f, translation: _ }, ct = Rr($.anchorX, $.anchorY, st);
            if (!fs(ct.point, F)) {
              li($.numGlyphs, Y);
              continue;
            }
            const nt = kt(e.transform.cameraToCenterDistance, ct.signedDistanceFromCamera), at = u.az(C, v, $), Mt = h ? at * e.transform.getPitchedTextCorrection($.anchorX, $.anchorY, I) / nt : at * nt, xt = wi({ projectionContext: st, pitchedLabelPlaneMatrixInverse: c, symbol: $, fontSize: Mt, flip: !1, keepUpright: z, glyphOffsetArray: g.glyphOffsetArray, dynamicLayoutVertexArray: Y, aspectRatio: J, rotateToLine: d });
            R = xt.useVertical, (xt.notEnoughRoom || R || xt.needsFlipping && wi({ projectionContext: st, pitchedLabelPlaneMatrixInverse: c, symbol: $, fontSize: Mt, flip: !0, keepUpright: z, glyphOffsetArray: g.glyphOffsetArray, dynamicLayoutVertexArray: Y, aspectRatio: J, rotateToLine: d }).notEnoughRoom) && li($.numGlyphs, Y);
          }
          r ? g.text.dynamicLayoutVertexBuffer.updateData(Y) : g.icon.dynamicLayoutVertexBuffer.updateData(Y);
        }
        function Ve(g, e, r, o, c, h, z, d) {
          const I = h.glyphStartIndex + h.numGlyphs, p = h.lineStartIndex, f = h.lineStartIndex + h.lineLength, _ = e.getoffsetX(h.glyphStartIndex), j = e.getoffsetX(I - 1), C = le(g * _, r, o, c, h.segment, p, f, d, z);
          if (!C) return null;
          const v = le(g * j, r, o, c, h.segment, p, f, d, z);
          return v ? d.projectionCache.anyProjectionOccluded ? null : { first: C, last: v } : null;
        }
        function Ft(g, e, r, o) {
          return g === u.ay.horizontal && Math.abs(r.y - e.y) > Math.abs(r.x - e.x) * o ? { useVertical: !0 } : (g === u.ay.vertical ? e.y < r.y : e.x > r.x) ? { needsFlipping: !0 } : null;
        }
        function wi(g) {
          const { projectionContext: e, pitchedLabelPlaneMatrixInverse: r, symbol: o, fontSize: c, flip: h, keepUpright: z, glyphOffsetArray: d, dynamicLayoutVertexArray: I, aspectRatio: p, rotateToLine: f } = g, _ = c / 24, j = o.lineOffsetX * _, C = o.lineOffsetY * _;
          let v;
          if (o.numGlyphs > 1) {
            const F = o.glyphStartIndex + o.numGlyphs, Y = o.lineStartIndex, W = o.lineStartIndex + o.lineLength, Z = Ve(_, d, j, C, h, o, f, e);
            if (!Z) return { notEnoughRoom: !0 };
            const J = hr(Z.first.point.x, Z.first.point.y, e, r), R = hr(Z.last.point.x, Z.last.point.y, e, r);
            if (z && !h) {
              const q = Ft(o.writingMode, J, R, p);
              if (q) return q;
            }
            v = [Z.first];
            for (let q = o.glyphStartIndex + 1; q < F - 1; q++) {
              const $ = le(_ * d.getoffsetX(q), j, C, h, o.segment, Y, W, e, f);
              if (!$) return { notEnoughRoom: !0 };
              v.push($);
            }
            v.push(Z.last);
          } else {
            if (z && !h) {
              const Y = Js(e.tileAnchorPoint.x, e.tileAnchorPoint.y, e).point, W = o.lineStartIndex + o.segment + 1, Z = new u.P(e.lineVertexArray.getx(W), e.lineVertexArray.gety(W)), J = Js(Z.x, Z.y, e), R = J.signedDistanceFromCamera > 0 ? J.point : Wr(e.tileAnchorPoint, Z, Y, 1, e), q = hr(Y.x, Y.y, e, r), $ = hr(R.x, R.y, e, r), G = Ft(o.writingMode, q, $, p);
              if (G) return G;
            }
            const F = le(_ * d.getoffsetX(o.glyphStartIndex), j, C, h, o.segment, o.lineStartIndex, o.lineStartIndex + o.lineLength, e, f);
            if (!F || e.projectionCache.anyProjectionOccluded) return { notEnoughRoom: !0 };
            v = [F];
          }
          for (const F of v) u.aF(I, F.point, F.angle);
          return {};
        }
        function Wr(g, e, r, o, c) {
          const h = g.add(g.sub(e)._unit()), z = Js(h.x, h.y, c).point, d = r.sub(z);
          return r.add(d._mult(o / d.mag()));
        }
        function Pr(g, e, r) {
          const o = e.projectionCache;
          if (o.projections[g]) return o.projections[g];
          const c = new u.P(e.lineVertexArray.getx(g), e.lineVertexArray.gety(g)), h = Js(c.x, c.y, e);
          if (h.signedDistanceFromCamera > 0) return o.projections[g] = h.point, o.anyProjectionOccluded = o.anyProjectionOccluded || h.isOccluded, h.point;
          const z = g - r.direction;
          return Wr(r.distanceFromAnchor === 0 ? e.tileAnchorPoint : new u.P(e.lineVertexArray.getx(z), e.lineVertexArray.gety(z)), c, r.previousVertex, r.absOffsetX - r.distanceFromAnchor + 1, e);
        }
        function Js(g, e, r) {
          const o = g + r.translation[0], c = e + r.translation[1];
          let h;
          return r.pitchWithMap ? (h = Ot(o, c, r.pitchedLabelPlaneMatrix, r.getElevation), h.isOccluded = !1) : (h = r.transform.projectTileCoordinates(o, c, r.unwrappedTileID, r.getElevation), h.point.x = (0.5 * h.point.x + 0.5) * r.width, h.point.y = (0.5 * -h.point.y + 0.5) * r.height), h;
        }
        function hr(g, e, r, o) {
          if (r.pitchWithMap) {
            const c = [g, e, 0, 1];
            return u.aG(c, c, o), r.transform.projectTileCoordinates(c[0] / c[3], c[1] / c[3], r.unwrappedTileID, r.getElevation).point;
          }
          return { x: g / r.width * 2 - 1, y: 1 - e / r.height * 2 };
        }
        function Rr(g, e, r) {
          return r.transform.projectTileCoordinates(g, e, r.unwrappedTileID, r.getElevation);
        }
        function Zr(g, e, r) {
          return g._unit()._perp()._mult(e * r);
        }
        function Es(g, e, r, o, c, h, z, d, I) {
          if (d.projectionCache.offsets[g]) return d.projectionCache.offsets[g];
          const p = r.add(e);
          if (g + I.direction < o || g + I.direction >= c) return d.projectionCache.offsets[g] = p, p;
          const f = Pr(g + I.direction, d, I), _ = Zr(f.sub(r), z, I.direction), j = r.add(_), C = f.add(_);
          return d.projectionCache.offsets[g] = u.aH(h, p, j, C) || p, d.projectionCache.offsets[g];
        }
        function le(g, e, r, o, c, h, z, d, I) {
          const p = o ? g - e : g + e;
          let f = p > 0 ? 1 : -1, _ = 0;
          o && (f *= -1, _ = Math.PI), f < 0 && (_ += Math.PI);
          let j, C = f > 0 ? h + c : h + c + 1;
          d.projectionCache.cachedAnchorPoint ? j = d.projectionCache.cachedAnchorPoint : (j = Js(d.tileAnchorPoint.x, d.tileAnchorPoint.y, d).point, d.projectionCache.cachedAnchorPoint = j);
          let v, F, Y = j, W = j, Z = 0, J = 0;
          const R = Math.abs(p), q = [];
          let $;
          for (; Z + J <= R; ) {
            if (C += f, C < h || C >= z) return null;
            Z += J, W = Y, F = v;
            const ct = { absOffsetX: R, direction: f, distanceFromAnchor: Z, previousVertex: W };
            if (Y = Pr(C, d, ct), r === 0) q.push(W), $ = Y.sub(W);
            else {
              let nt;
              const at = Y.sub(W);
              nt = at.mag() === 0 ? Zr(Pr(C + f, d, ct).sub(Y), r, f) : Zr(at, r, f), F || (F = W.add(nt)), v = Es(C, nt, Y, h, z, F, r, d, ct), q.push(F), $ = v.sub(F);
            }
            J = $.mag();
          }
          const G = $._mult((R - Z) / J)._add(F || W), st = _ + Math.atan2(Y.y - W.y, Y.x - W.x);
          return q.push(G), { point: G, angle: I ? st : 0, path: q };
        }
        const fl = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
        function li(g, e) {
          for (let r = 0; r < g; r++) {
            const o = e.length;
            e.resize(o + 4), e.float32.set(fl, 3 * o);
          }
        }
        function _n(g, e, r) {
          const o = e[0], c = e[1];
          return g[0] = r[0] * o + r[4] * c + r[12], g[1] = r[1] * o + r[5] * c + r[13], g[3] = r[3] * o + r[7] * c + r[15], g;
        }
        const Te = 100;
        class Pi {
          constructor(e, r = new Me(e.width + 200, e.height + 200, 25), o = new Me(e.width + 200, e.height + 200, 25)) {
            this.transform = e, this.grid = r, this.ignoredGrid = o, this.pitchFactor = Math.cos(e.pitch * Math.PI / 180) * e.cameraToCenterDistance, this.screenRightBoundary = e.width + Te, this.screenBottomBoundary = e.height + Te, this.gridRightBoundary = e.width + 200, this.gridBottomBoundary = e.height + 200, this.perspectiveRatioCutoff = 0.6;
          }
          placeCollisionBox(e, r, o, c, h, z, d, I, p, f, _, j) {
            const C = this.projectAndGetPerspectiveRatio(e.anchorPointX + I[0], e.anchorPointY + I[1], h, f, j), v = o * C.perspectiveRatio;
            let F;
            if (z || d) F = this._projectCollisionBox(e, v, c, h, z, d, I, C, f, _, j);
            else {
              const $ = C.x + (_ ? _.x * v : 0), G = C.y + (_ ? _.y * v : 0);
              F = { allPointsOccluded: !1, box: [$ + e.x1 * v, G + e.y1 * v, $ + e.x2 * v, G + e.y2 * v] };
            }
            const [Y, W, Z, J] = F.box, R = z ? F.allPointsOccluded : C.isOccluded;
            let q = R;
            return q || (q = C.perspectiveRatio < this.perspectiveRatioCutoff), q || (q = !this.isInsideGrid(Y, W, Z, J)), q || r !== "always" && this.grid.hitTest(Y, W, Z, J, r, p) ? { box: [Y, W, Z, J], placeable: !1, offscreen: !1, occluded: R } : { box: [Y, W, Z, J], placeable: !0, offscreen: this.isOffscreen(Y, W, Z, J), occluded: R };
          }
          placeCollisionCircles(e, r, o, c, h, z, d, I, p, f, _, j, C, v) {
            const F = [], Y = new u.P(r.anchorX, r.anchorY), W = this.getPerspectiveRatio(Y.x, Y.y, z, v), Z = (p ? h * this.transform.getPitchedTextCorrection(r.anchorX, r.anchorY, z) / W : h * W) / u.aL, J = { getElevation: v, pitchedLabelPlaneMatrix: d, lineVertexArray: o, pitchWithMap: p, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: !1 }, transform: this.transform, tileAnchorPoint: Y, unwrappedTileID: z, width: this.transform.width, height: this.transform.height, translation: C }, R = Ve(Z, c, r.lineOffsetX * Z, r.lineOffsetY * Z, !1, r, !1, J);
            let q = !1, $ = !1, G = !0;
            if (R) {
              const st = 0.5 * _ * W + j, ct = new u.P(-100, -100), nt = new u.P(this.screenRightBoundary, this.screenBottomBoundary), at = new It(), Mt = R.first, xt = R.last;
              let wt = [];
              for (let Ut = Mt.path.length - 1; Ut >= 1; Ut--) wt.push(Mt.path[Ut]);
              for (let Ut = 1; Ut < xt.path.length; Ut++) wt.push(xt.path[Ut]);
              const Nt = 2.5 * st;
              if (p) {
                const Ut = this.projectPathToScreenSpace(wt, J);
                wt = Ut.some(((Yt) => Yt.signedDistanceFromCamera <= 0)) ? [] : Ut.map(((Yt) => Yt.point));
              }
              let Ct = [];
              if (wt.length > 0) {
                const Ut = wt[0].clone(), Yt = wt[0].clone();
                for (let ge = 1; ge < wt.length; ge++) Ut.x = Math.min(Ut.x, wt[ge].x), Ut.y = Math.min(Ut.y, wt[ge].y), Yt.x = Math.max(Yt.x, wt[ge].x), Yt.y = Math.max(Yt.y, wt[ge].y);
                Ct = Ut.x >= ct.x && Yt.x <= nt.x && Ut.y >= ct.y && Yt.y <= nt.y ? [wt] : Yt.x < ct.x || Ut.x > nt.x || Yt.y < ct.y || Ut.y > nt.y ? [] : u.aI([wt], ct.x, ct.y, nt.x, nt.y);
              }
              for (const Ut of Ct) {
                at.reset(Ut, 0.25 * st);
                let Yt = 0;
                Yt = at.length <= 0.5 * st ? 1 : Math.ceil(at.paddedLength / Nt) + 1;
                for (let ge = 0; ge < Yt; ge++) {
                  const he = ge / Math.max(Yt - 1, 1), xe = at.lerp(he), ne = xe.x + Te, Ue = xe.y + Te;
                  F.push(ne, Ue, st, 0);
                  const de = ne - st, ve = Ue - st, be = ne + st, Be = Ue + st;
                  if (G = G && this.isOffscreen(de, ve, be, Be), $ = $ || this.isInsideGrid(de, ve, be, Be), e !== "always" && this.grid.hitTestCircle(ne, Ue, st, e, f) && (q = !0, !I)) return { circles: [], offscreen: !1, collisionDetected: q };
                }
              }
            }
            return { circles: !I && q || !$ || W < this.perspectiveRatioCutoff ? [] : F, offscreen: G, collisionDetected: q };
          }
          projectPathToScreenSpace(e, r) {
            const o = (function(c, h) {
              const z = u.N();
              return u.aA(z, h.pitchedLabelPlaneMatrix), c.map(((d) => {
                const I = Ot(d.x, d.y, z, h.getElevation), p = h.transform.projectTileCoordinates(I.point.x, I.point.y, h.unwrappedTileID, h.getElevation);
                return p.point.x = (0.5 * p.point.x + 0.5) * h.width, p.point.y = (0.5 * -p.point.y + 0.5) * h.height, p;
              }));
            })(e, r);
            return (function(c) {
              let h = 0, z = 0, d = 0, I = 0;
              for (let p = 0; p < c.length; p++) c[p].isOccluded ? (d = p + 1, I = 0) : (I++, I > z && (z = I, h = d));
              return c.slice(h, h + z);
            })(o);
          }
          queryRenderedSymbols(e) {
            if (e.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0) return {};
            const r = [], o = new u.ab();
            for (const _ of e) {
              const j = new u.P(_.x + Te, _.y + Te);
              o.extend(j), r.push(j);
            }
            const { minX: c, minY: h, maxX: z, maxY: d } = o, I = this.grid.query(c, h, z, d).concat(this.ignoredGrid.query(c, h, z, d)), p = {}, f = {};
            for (const _ of I) {
              const j = _.key;
              if (p[j.bucketInstanceId] === void 0 && (p[j.bucketInstanceId] = {}), p[j.bucketInstanceId][j.featureIndex]) continue;
              const C = [new u.P(_.x1, _.y1), new u.P(_.x2, _.y1), new u.P(_.x2, _.y2), new u.P(_.x1, _.y2)];
              u.aJ(r, C) && (p[j.bucketInstanceId][j.featureIndex] = !0, f[j.bucketInstanceId] === void 0 && (f[j.bucketInstanceId] = []), f[j.bucketInstanceId].push(j.featureIndex));
            }
            return f;
          }
          insertCollisionBox(e, r, o, c, h, z) {
            (o ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: c, featureIndex: h, collisionGroupID: z, overlapMode: r }, e[0], e[1], e[2], e[3]);
          }
          insertCollisionCircles(e, r, o, c, h, z) {
            const d = o ? this.ignoredGrid : this.grid, I = { bucketInstanceId: c, featureIndex: h, collisionGroupID: z, overlapMode: r };
            for (let p = 0; p < e.length; p += 4) d.insertCircle(I, e[p], e[p + 1], e[p + 2]);
          }
          projectAndGetPerspectiveRatio(e, r, o, c, h) {
            if (h) {
              let z;
              c ? (z = [e, r, c(e, r), 1], u.aG(z, z, h)) : (z = [e, r, 0, 1], _n(z, z, h));
              const d = z[3];
              return { x: (z[0] / d + 1) / 2 * this.transform.width + Te, y: (-z[1] / d + 1) / 2 * this.transform.height + Te, perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / d * 0.5, isOccluded: !1, signedDistanceFromCamera: d };
            }
            {
              const z = this.transform.projectTileCoordinates(e, r, o, c);
              return { x: (z.point.x + 1) / 2 * this.transform.width + Te, y: (1 - z.point.y) / 2 * this.transform.height + Te, perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / z.signedDistanceFromCamera * 0.5, isOccluded: z.isOccluded, signedDistanceFromCamera: z.signedDistanceFromCamera };
            }
          }
          getPerspectiveRatio(e, r, o, c) {
            const h = this.transform.projectTileCoordinates(e, r, o, c);
            return 0.5 + this.transform.cameraToCenterDistance / h.signedDistanceFromCamera * 0.5;
          }
          isOffscreen(e, r, o, c) {
            return o < Te || e >= this.screenRightBoundary || c < Te || r > this.screenBottomBoundary;
          }
          isInsideGrid(e, r, o, c) {
            return o >= 0 && e < this.gridRightBoundary && c >= 0 && r < this.gridBottomBoundary;
          }
          getViewportMatrix() {
            const e = u.ar([]);
            return u.O(e, e, [-100, -100, 0]), e;
          }
          _projectCollisionBox(e, r, o, c, h, z, d, I, p, f, _) {
            let j = 1, C = 0, v = 0, F = 1;
            const Y = e.anchorPointX + d[0], W = e.anchorPointY + d[1];
            if (z && !h) {
              const wt = this.projectAndGetPerspectiveRatio(Y + 1, W, c, p, _), Nt = wt.x - I.x, Ct = Math.atan((wt.y - I.y) / Nt) + (Nt < 0 ? Math.PI : 0), Ut = Math.sin(Ct), Yt = Math.cos(Ct);
              j = Yt, C = Ut, v = -Ut, F = Yt;
            } else if (!z && h) {
              const wt = pt(this.transform);
              j = wt.vecEast[0], C = wt.vecEast[1], v = wt.vecSouth[0], F = wt.vecSouth[1];
            }
            let Z = I.x, J = I.y, R = r;
            h && (Z = Y, J = W, R = Math.pow(2, -(this.transform.zoom - o.overscaledZ)), R *= this.transform.getPitchedTextCorrection(Y, W, c), f || (R *= u.an(0.5 + I.signedDistanceFromCamera / this.transform.cameraToCenterDistance * 0.5, 0, 4))), f && (Z += j * f.x * R + v * f.y * R, J += C * f.x * R + F * f.y * R);
            const q = e.x1 * R, $ = e.x2 * R, G = (q + $) / 2, st = e.y1 * R, ct = e.y2 * R, nt = (st + ct) / 2, at = [{ offsetX: q, offsetY: st }, { offsetX: G, offsetY: st }, { offsetX: $, offsetY: st }, { offsetX: $, offsetY: nt }, { offsetX: $, offsetY: ct }, { offsetX: G, offsetY: ct }, { offsetX: q, offsetY: ct }, { offsetX: q, offsetY: nt }];
            let Mt = [];
            for (const { offsetX: wt, offsetY: Nt } of at) Mt.push(new u.P(Z + j * wt + v * Nt, J + C * wt + F * Nt));
            let xt = !1;
            if (h) {
              const wt = Mt.map(((Nt) => this.projectAndGetPerspectiveRatio(Nt.x, Nt.y, c, p, _)));
              xt = wt.some(((Nt) => !Nt.isOccluded)), Mt = wt.map(((Nt) => new u.P(Nt.x, Nt.y)));
            } else xt = !0;
            return { box: u.aK(Mt), allPointsOccluded: !xt };
          }
        }
        class fo {
          constructor(e, r, o, c) {
            this.opacity = e ? Math.max(0, Math.min(1, e.opacity + (e.placed ? r : -r))) : c && o ? 1 : 0, this.placed = o;
          }
          isHidden() {
            return this.opacity === 0 && !this.placed;
          }
        }
        class Vr {
          constructor(e, r, o, c, h) {
            this.text = new fo(e ? e.text : null, r, o, h), this.icon = new fo(e ? e.icon : null, r, c, h);
          }
          isHidden() {
            return this.text.isHidden() && this.icon.isHidden();
          }
        }
        class xo {
          constructor(e, r, o) {
            this.text = e, this.icon = r, this.skipFade = o;
          }
        }
        class Gr {
          constructor(e, r, o, c, h) {
            this.bucketInstanceId = e, this.featureIndex = r, this.sourceLayerIndex = o, this.bucketIndex = c, this.tileID = h;
          }
        }
        class WM {
          constructor(e) {
            this.crossSourceCollisions = e, this.maxGroupID = 0, this.collisionGroups = {};
          }
          get(e) {
            if (this.crossSourceCollisions) return { ID: 0, predicate: null };
            if (!this.collisionGroups[e]) {
              const r = ++this.maxGroupID;
              this.collisionGroups[e] = { ID: r, predicate: (o) => o.collisionGroupID === r };
            }
            return this.collisionGroups[e];
          }
        }
        function PM(g, e, r, o, c) {
          const { horizontalAlign: h, verticalAlign: z } = u.aR(g);
          return new u.P(-(h - 0.5) * e + o[0] * c, -(z - 0.5) * r + o[1] * c);
        }
        class xl {
          constructor(e, r, o, c, h) {
            this.transform = e.clone(), this.terrain = r, this.collisionIndex = new Pi(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = o, this.retainedQueryData = {}, this.collisionGroups = new WM(c), this.collisionCircleArrays = {}, this.collisionBoxArrays = /* @__PURE__ */ new Map(), this.prevPlacement = h, h && (h.prevPlacement = void 0), this.placedOrientations = {};
          }
          _getTerrainElevationFunc(e) {
            const r = this.terrain;
            return r ? (o, c) => r.getElevation(e, o, c) : null;
          }
          getBucketParts(e, r, o, c) {
            const h = o.getBucket(r), z = o.latestFeatureIndex;
            if (!h || !z || r.id !== h.layerIds[0]) return;
            const d = o.collisionBoxArray, I = h.layers[0].layout, p = h.layers[0].paint, f = Math.pow(2, this.transform.zoom - o.tileID.overscaledZ), _ = o.tileSize / u.a4, j = o.tileID.toUnwrapped(), C = I.get("text-rotation-alignment") === "map", v = u.aM(o, 1, this.transform.zoom), F = u.aN(this.collisionIndex.transform, o, p.get("text-translate"), p.get("text-translate-anchor")), Y = u.aN(this.collisionIndex.transform, o, p.get("icon-translate"), p.get("icon-translate-anchor")), W = ke(C, this.transform, v);
            this.retainedQueryData[h.bucketInstanceId] = new Gr(h.bucketInstanceId, z, h.sourceLayerIndex, h.index, o.tileID);
            const Z = { bucket: h, layout: I, translationText: F, translationIcon: Y, unwrappedTileID: j, pitchedLabelPlaneMatrix: W, scale: f, textPixelRatio: _, holdingForFade: o.holdingForSymbolFade(), collisionBoxArray: d, partiallyEvaluatedTextSize: u.ax(h.textSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(h.sourceID) };
            if (c) for (const J of h.sortKeyRanges) {
              const { sortKey: R, symbolInstanceStart: q, symbolInstanceEnd: $ } = J;
              e.push({ sortKey: R, symbolInstanceStart: q, symbolInstanceEnd: $, parameters: Z });
            }
            else e.push({ symbolInstanceStart: 0, symbolInstanceEnd: h.symbolInstances.length, parameters: Z });
          }
          attemptAnchorPlacement(e, r, o, c, h, z, d, I, p, f, _, j, C, v, F, Y, W, Z, J, R) {
            const q = u.aO[e.textAnchor], $ = [e.textOffset0, e.textOffset1], G = PM(q, o, c, $, h), st = this.collisionIndex.placeCollisionBox(r, j, I, p, f, d, z, Y, _.predicate, J, G, R);
            if ((!Z || this.collisionIndex.placeCollisionBox(Z, j, I, p, f, d, z, W, _.predicate, J, G, R).placeable) && st.placeable) {
              let ct;
              if (this.prevPlacement && this.prevPlacement.variableOffsets[C.crossTileID] && this.prevPlacement.placements[C.crossTileID] && this.prevPlacement.placements[C.crossTileID].text && (ct = this.prevPlacement.variableOffsets[C.crossTileID].anchor), C.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
              return this.variableOffsets[C.crossTileID] = { textOffset: $, width: o, height: c, anchor: q, textBoxScale: h, prevAnchor: ct }, this.markUsedJustification(v, q, C, F), v.allowVerticalPlacement && (this.markUsedOrientation(v, F, C), this.placedOrientations[C.crossTileID] = F), { shift: G, placedGlyphBoxes: st };
            }
          }
          placeLayerBucketPart(e, r, o) {
            const { bucket: c, layout: h, translationText: z, translationIcon: d, unwrappedTileID: I, pitchedLabelPlaneMatrix: p, textPixelRatio: f, holdingForFade: _, collisionBoxArray: j, partiallyEvaluatedTextSize: C, collisionGroup: v } = e.parameters, F = h.get("text-optional"), Y = h.get("icon-optional"), W = u.aP(h, "text-overlap", "text-allow-overlap"), Z = W === "always", J = u.aP(h, "icon-overlap", "icon-allow-overlap"), R = J === "always", q = h.get("text-rotation-alignment") === "map", $ = h.get("text-pitch-alignment") === "map", G = h.get("icon-text-fit") !== "none", st = h.get("symbol-z-order") === "viewport-y", ct = Z && (R || !c.hasIconData() || Y), nt = R && (Z || !c.hasTextData() || F);
            !c.collisionArrays && j && c.deserializeCollisionBoxes(j);
            const at = this.retainedQueryData[c.bucketInstanceId].tileID, Mt = this._getTerrainElevationFunc(at), xt = this.transform.getFastPathSimpleProjectionMatrix(at), wt = (Nt, Ct, Ut) => {
              var Yt, ge;
              if (r[Nt.crossTileID]) return;
              if (_) return void (this.placements[Nt.crossTileID] = new xo(!1, !1, !1));
              let he = !1, xe = !1, ne = !0, Ue = null, de = { box: null, placeable: !1, offscreen: null, occluded: !1 }, ve = { placeable: !1 }, be = null, Be = null, _s = null, Ai = 0, Ni = 0, $i = 0;
              Ct.textFeatureIndex ? Ai = Ct.textFeatureIndex : Nt.useRuntimeCollisionCircles && (Ai = Nt.featureIndex), Ct.verticalTextFeatureIndex && (Ni = Ct.verticalTextFeatureIndex);
              const Ki = Ct.textBox;
              if (Ki) {
                const bs = (Ce) => {
                  let Ae = u.ay.horizontal;
                  if (c.allowVerticalPlacement && !Ce && this.prevPlacement) {
                    const Xe = this.prevPlacement.placedOrientations[Nt.crossTileID];
                    Xe && (this.placedOrientations[Nt.crossTileID] = Xe, Ae = Xe, this.markUsedOrientation(c, Ae, Nt));
                  }
                  return Ae;
                }, ji = (Ce, Ae) => {
                  if (c.allowVerticalPlacement && Nt.numVerticalGlyphVertices > 0 && Ct.verticalTextBox) {
                    for (const Xe of c.writingModes) if (Xe === u.ay.vertical ? (de = Ae(), ve = de) : de = Ce(), de && de.placeable) break;
                  } else de = Ce();
                }, _r = Nt.textAnchorOffsetStartIndex, Lr = Nt.textAnchorOffsetEndIndex;
                if (Lr === _r) {
                  const Ce = (Ae, Xe) => {
                    const ae = this.collisionIndex.placeCollisionBox(Ae, W, f, at, I, $, q, z, v.predicate, Mt, void 0, xt);
                    return ae && ae.placeable && (this.markUsedOrientation(c, Xe, Nt), this.placedOrientations[Nt.crossTileID] = Xe), ae;
                  };
                  ji((() => Ce(Ki, u.ay.horizontal)), (() => {
                    const Ae = Ct.verticalTextBox;
                    return c.allowVerticalPlacement && Nt.numVerticalGlyphVertices > 0 && Ae ? Ce(Ae, u.ay.vertical) : { box: null, offscreen: null };
                  })), bs(de && de.placeable);
                } else {
                  let Ce = u.aO[(ge = (Yt = this.prevPlacement) === null || Yt === void 0 ? void 0 : Yt.variableOffsets[Nt.crossTileID]) === null || ge === void 0 ? void 0 : ge.anchor];
                  const Ae = (ae, tr, Pc) => {
                    const Rc = ae.x2 - ae.x1, Zc = ae.y2 - ae.y1, Cr = Nt.textBoxScale, Gl = G && J === "never" ? tr : null;
                    let er = null, so = W === "never" ? 1 : 2, IM = "never";
                    Ce && so++;
                    for (let sr = 0; sr < so; sr++) {
                      for (let _i = _r; _i < Lr; _i++) {
                        const wM = c.textAnchorOffsets.get(_i);
                        if (Ce && wM.textAnchor !== Ce) continue;
                        const pM = this.attemptAnchorPlacement(wM, ae, Rc, Zc, Cr, q, $, f, at, I, v, IM, Nt, c, Pc, z, d, Gl, Mt);
                        if (pM && (er = pM.placedGlyphBoxes, er && er.placeable)) return he = !0, Ue = pM.shift, er;
                      }
                      Ce ? Ce = null : IM = W;
                    }
                    return o && !er && (er = { box: this.collisionIndex.placeCollisionBox(Ki, "always", f, at, I, $, q, z, v.predicate, Mt, void 0, xt).box, offscreen: !1, placeable: !1, occluded: !1 }), er;
                  };
                  ji((() => Ae(Ki, Ct.iconBox, u.ay.horizontal)), (() => {
                    const ae = Ct.verticalTextBox;
                    return c.allowVerticalPlacement && (!de || !de.placeable) && Nt.numVerticalGlyphVertices > 0 && ae ? Ae(ae, Ct.verticalIconBox, u.ay.vertical) : { box: null, occluded: !0, offscreen: null };
                  })), de && (he = de.placeable, ne = de.offscreen);
                  const Xe = bs(de && de.placeable);
                  if (!he && this.prevPlacement) {
                    const ae = this.prevPlacement.variableOffsets[Nt.crossTileID];
                    ae && (this.variableOffsets[Nt.crossTileID] = ae, this.markUsedJustification(c, ae.anchor, Nt, Xe));
                  }
                }
              }
              if (be = de, he = be && be.placeable, ne = be && be.offscreen, Nt.useRuntimeCollisionCircles && Nt.centerJustifiedTextSymbolIndex >= 0) {
                const bs = c.text.placedSymbolArray.get(Nt.centerJustifiedTextSymbolIndex), ji = u.az(c.textSizeData, C, bs), _r = h.get("text-padding");
                Be = this.collisionIndex.placeCollisionCircles(W, bs, c.lineVertexArray, c.glyphOffsetArray, ji, I, p, o, $, v.predicate, Nt.collisionCircleDiameter, _r, z, Mt), Be.circles.length && Be.collisionDetected && !o && u.w("Collisions detected, but collision boxes are not shown"), he = Z || Be.circles.length > 0 && !Be.collisionDetected, ne = ne && Be.offscreen;
              }
              if (Ct.iconFeatureIndex && ($i = Ct.iconFeatureIndex), Ct.iconBox) {
                const bs = (ji) => this.collisionIndex.placeCollisionBox(ji, J, f, at, I, $, q, d, v.predicate, Mt, G && Ue ? Ue : void 0, xt);
                ve && ve.placeable && Ct.verticalIconBox ? (_s = bs(Ct.verticalIconBox), xe = _s.placeable) : (_s = bs(Ct.iconBox), xe = _s.placeable), ne = ne && _s.offscreen;
              }
              const jr = F || Nt.numHorizontalGlyphVertices === 0 && Nt.numVerticalGlyphVertices === 0, Ws = Y || Nt.numIconVertices === 0;
              jr || Ws ? Ws ? jr || (xe = xe && he) : he = xe && he : xe = he = xe && he;
              const mi = xe && _s.placeable;
              if (he && be.placeable && this.collisionIndex.insertCollisionBox(be.box, W, h.get("text-ignore-placement"), c.bucketInstanceId, ve && ve.placeable && Ni ? Ni : Ai, v.ID), mi && this.collisionIndex.insertCollisionBox(_s.box, J, h.get("icon-ignore-placement"), c.bucketInstanceId, $i, v.ID), Be && he && this.collisionIndex.insertCollisionCircles(Be.circles, W, h.get("text-ignore-placement"), c.bucketInstanceId, Ai, v.ID), o && this.storeCollisionData(c.bucketInstanceId, Ut, Ct, be, _s, Be), Nt.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
              if (c.bucketInstanceId === 0) throw new Error("bucket.bucketInstanceId can't be 0");
              this.placements[Nt.crossTileID] = new xo((he || ct) && !be?.occluded, (xe || nt) && !_s?.occluded, ne || c.justReloaded), r[Nt.crossTileID] = !0;
            };
            if (st) {
              if (e.symbolInstanceStart !== 0) throw new Error("bucket.bucketInstanceId should be 0");
              const Nt = c.getSortedSymbolIndexes(-this.transform.bearingInRadians);
              for (let Ct = Nt.length - 1; Ct >= 0; --Ct) {
                const Ut = Nt[Ct];
                wt(c.symbolInstances.get(Ut), c.collisionArrays[Ut], Ut);
              }
            } else for (let Nt = e.symbolInstanceStart; Nt < e.symbolInstanceEnd; Nt++) wt(c.symbolInstances.get(Nt), c.collisionArrays[Nt], Nt);
            c.justReloaded = !1;
          }
          storeCollisionData(e, r, o, c, h, z) {
            if (o.textBox || o.iconBox) {
              let d, I;
              this.collisionBoxArrays.has(e) ? d = this.collisionBoxArrays.get(e) : (d = /* @__PURE__ */ new Map(), this.collisionBoxArrays.set(e, d)), d.has(r) ? I = d.get(r) : (I = { text: null, icon: null }, d.set(r, I)), o.textBox && (I.text = c.box), o.iconBox && (I.icon = h.box);
            }
            if (z) {
              let d = this.collisionCircleArrays[e];
              d === void 0 && (d = this.collisionCircleArrays[e] = []);
              for (let I = 0; I < z.circles.length; I += 4) d.push(z.circles[I + 0] - Te), d.push(z.circles[I + 1] - Te), d.push(z.circles[I + 2]), d.push(z.collisionDetected ? 1 : 0);
            }
          }
          markUsedJustification(e, r, o, c) {
            let h;
            h = c === u.ay.vertical ? o.verticalPlacedTextSymbolIndex : { left: o.leftJustifiedTextSymbolIndex, center: o.centerJustifiedTextSymbolIndex, right: o.rightJustifiedTextSymbolIndex }[u.aQ(r)];
            const z = [o.leftJustifiedTextSymbolIndex, o.centerJustifiedTextSymbolIndex, o.rightJustifiedTextSymbolIndex, o.verticalPlacedTextSymbolIndex];
            for (const d of z) d >= 0 && (e.text.placedSymbolArray.get(d).crossTileID = h >= 0 && d !== h ? 0 : o.crossTileID);
          }
          markUsedOrientation(e, r, o) {
            const c = r === u.ay.horizontal || r === u.ay.horizontalOnly ? r : 0, h = r === u.ay.vertical ? r : 0, z = [o.leftJustifiedTextSymbolIndex, o.centerJustifiedTextSymbolIndex, o.rightJustifiedTextSymbolIndex];
            for (const d of z) e.text.placedSymbolArray.get(d).placedOrientation = c;
            o.verticalPlacedTextSymbolIndex && (e.text.placedSymbolArray.get(o.verticalPlacedTextSymbolIndex).placedOrientation = h);
          }
          commit(e) {
            this.commitTime = e, this.zoomAtLastRecencyCheck = this.transform.zoom;
            const r = this.prevPlacement;
            let o = !1;
            this.prevZoomAdjustment = r ? r.zoomAdjustment(this.transform.zoom) : 0;
            const c = r ? r.symbolFadeChange(e) : 1, h = r ? r.opacities : {}, z = r ? r.variableOffsets : {}, d = r ? r.placedOrientations : {};
            for (const I in this.placements) {
              const p = this.placements[I], f = h[I];
              f ? (this.opacities[I] = new Vr(f, c, p.text, p.icon), o = o || p.text !== f.text.placed || p.icon !== f.icon.placed) : (this.opacities[I] = new Vr(null, c, p.text, p.icon, p.skipFade), o = o || p.text || p.icon);
            }
            for (const I in h) {
              const p = h[I];
              if (!this.opacities[I]) {
                const f = new Vr(p, c, !1, !1);
                f.isHidden() || (this.opacities[I] = f, o = o || p.text.placed || p.icon.placed);
              }
            }
            for (const I in z) this.variableOffsets[I] || !this.opacities[I] || this.opacities[I].isHidden() || (this.variableOffsets[I] = z[I]);
            for (const I in d) this.placedOrientations[I] || !this.opacities[I] || this.opacities[I].isHidden() || (this.placedOrientations[I] = d[I]);
            if (r && r.lastPlacementChangeTime === void 0) throw new Error("Last placement time for previous placement is not defined");
            o ? this.lastPlacementChangeTime = e : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = r ? r.lastPlacementChangeTime : e);
          }
          updateLayerOpacities(e, r) {
            const o = {};
            for (const c of r) {
              const h = c.getBucket(e);
              h && c.latestFeatureIndex && e.id === h.layerIds[0] && this.updateBucketOpacities(h, c.tileID, o, c.collisionBoxArray);
            }
          }
          updateBucketOpacities(e, r, o, c) {
            e.hasTextData() && (e.text.opacityVertexArray.clear(), e.text.hasVisibleVertices = !1), e.hasIconData() && (e.icon.opacityVertexArray.clear(), e.icon.hasVisibleVertices = !1), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexArray.clear(), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexArray.clear();
            const h = e.layers[0], z = h.layout, d = new Vr(null, 0, !1, !1, !0), I = z.get("text-allow-overlap"), p = z.get("icon-allow-overlap"), f = h._unevaluatedLayout.hasValue("text-variable-anchor") || h._unevaluatedLayout.hasValue("text-variable-anchor-offset"), _ = z.get("text-rotation-alignment") === "map", j = z.get("text-pitch-alignment") === "map", C = z.get("icon-text-fit") !== "none", v = new Vr(null, 0, I && (p || !e.hasIconData() || z.get("icon-optional")), p && (I || !e.hasTextData() || z.get("text-optional")), !0);
            !e.collisionArrays && c && (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) && e.deserializeCollisionBoxes(c);
            const F = (W, Z, J) => {
              for (let R = 0; R < Z / 4; R++) W.opacityVertexArray.emplaceBack(J);
              W.hasVisibleVertices = W.hasVisibleVertices || J !== pi;
            }, Y = this.collisionBoxArrays.get(e.bucketInstanceId);
            for (let W = 0; W < e.symbolInstances.length; W++) {
              const Z = e.symbolInstances.get(W), { numHorizontalGlyphVertices: J, numVerticalGlyphVertices: R, crossTileID: q } = Z;
              let $ = this.opacities[q];
              o[q] ? $ = d : $ || ($ = v, this.opacities[q] = $), o[q] = !0;
              const G = Z.numIconVertices > 0, st = this.placedOrientations[Z.crossTileID], ct = st === u.ay.vertical, nt = st === u.ay.horizontal || st === u.ay.horizontalOnly;
              if (J > 0 || R > 0) {
                const Mt = HM($.text);
                F(e.text, J, ct ? pi : Mt), F(e.text, R, nt ? pi : Mt);
                const xt = $.text.isHidden();
                [Z.rightJustifiedTextSymbolIndex, Z.centerJustifiedTextSymbolIndex, Z.leftJustifiedTextSymbolIndex].forEach(((Ct) => {
                  Ct >= 0 && (e.text.placedSymbolArray.get(Ct).hidden = xt || ct ? 1 : 0);
                })), Z.verticalPlacedTextSymbolIndex >= 0 && (e.text.placedSymbolArray.get(Z.verticalPlacedTextSymbolIndex).hidden = xt || nt ? 1 : 0);
                const wt = this.variableOffsets[Z.crossTileID];
                wt && this.markUsedJustification(e, wt.anchor, Z, st);
                const Nt = this.placedOrientations[Z.crossTileID];
                Nt && (this.markUsedJustification(e, "left", Z, Nt), this.markUsedOrientation(e, Nt, Z));
              }
              if (G) {
                const Mt = HM($.icon), xt = !(C && Z.verticalPlacedIconSymbolIndex && ct);
                Z.placedIconSymbolIndex >= 0 && (F(e.icon, Z.numIconVertices, xt ? Mt : pi), e.icon.placedSymbolArray.get(Z.placedIconSymbolIndex).hidden = $.icon.isHidden()), Z.verticalPlacedIconSymbolIndex >= 0 && (F(e.icon, Z.numVerticalIconVertices, xt ? pi : Mt), e.icon.placedSymbolArray.get(Z.verticalPlacedIconSymbolIndex).hidden = $.icon.isHidden());
              }
              const at = Y && Y.has(W) ? Y.get(W) : { text: null, icon: null };
              if (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) {
                const Mt = e.collisionArrays[W];
                if (Mt) {
                  let xt = new u.P(0, 0);
                  if (Mt.textBox || Mt.verticalTextBox) {
                    let wt = !0;
                    if (f) {
                      const Nt = this.variableOffsets[q];
                      Nt ? (xt = PM(Nt.anchor, Nt.width, Nt.height, Nt.textOffset, Nt.textBoxScale), _ && xt._rotate(j ? -this.transform.bearingInRadians : this.transform.bearingInRadians)) : wt = !1;
                    }
                    if (Mt.textBox || Mt.verticalTextBox) {
                      let Nt;
                      Mt.textBox && (Nt = ct), Mt.verticalTextBox && (Nt = nt), RM(e.textCollisionBox.collisionVertexArray, $.text.placed, !wt || Nt, at.text, xt.x, xt.y);
                    }
                  }
                  if (Mt.iconBox || Mt.verticalIconBox) {
                    const wt = !!(!nt && Mt.verticalIconBox);
                    let Nt;
                    Mt.iconBox && (Nt = wt), Mt.verticalIconBox && (Nt = !wt), RM(e.iconCollisionBox.collisionVertexArray, $.icon.placed, Nt, at.icon, C ? xt.x : 0, C ? xt.y : 0);
                  }
                }
              }
            }
            if (e.sortFeatures(-this.transform.bearingInRadians), this.retainedQueryData[e.bucketInstanceId] && (this.retainedQueryData[e.bucketInstanceId].featureSortOrder = e.featureSortOrder), e.hasTextData() && e.text.opacityVertexBuffer && e.text.opacityVertexBuffer.updateData(e.text.opacityVertexArray), e.hasIconData() && e.icon.opacityVertexBuffer && e.icon.opacityVertexBuffer.updateData(e.icon.opacityVertexArray), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexBuffer && e.iconCollisionBox.collisionVertexBuffer.updateData(e.iconCollisionBox.collisionVertexArray), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexBuffer && e.textCollisionBox.collisionVertexBuffer.updateData(e.textCollisionBox.collisionVertexArray), e.text.opacityVertexArray.length !== e.text.layoutVertexArray.length / 4) throw new Error(`bucket.text.opacityVertexArray.length (= ${e.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${e.text.layoutVertexArray.length}) / 4`);
            if (e.icon.opacityVertexArray.length !== e.icon.layoutVertexArray.length / 4) throw new Error(`bucket.icon.opacityVertexArray.length (= ${e.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${e.icon.layoutVertexArray.length}) / 4`);
            e.bucketInstanceId in this.collisionCircleArrays && (e.collisionCircleArray = this.collisionCircleArrays[e.bucketInstanceId], delete this.collisionCircleArrays[e.bucketInstanceId]);
          }
          symbolFadeChange(e) {
            return this.fadeDuration === 0 ? 1 : (e - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
          }
          zoomAdjustment(e) {
            return Math.max(0, (this.transform.zoom - e) / 1.5);
          }
          hasTransitions(e) {
            return this.stale || e - this.lastPlacementChangeTime < this.fadeDuration;
          }
          stillRecent(e, r) {
            const o = this.zoomAtLastRecencyCheck === r ? 1 - this.zoomAdjustment(r) : 1;
            return this.zoomAtLastRecencyCheck = r, this.commitTime + this.fadeDuration * o > e;
          }
          setStale() {
            this.stale = !0;
          }
        }
        function RM(g, e, r, o, c, h) {
          o && o.length !== 0 || (o = [0, 0, 0, 0]);
          const z = o[0] - Te, d = o[1] - Te, I = o[2] - Te, p = o[3] - Te;
          g.emplaceBack(e ? 1 : 0, r ? 1 : 0, c || 0, h || 0, z, d), g.emplaceBack(e ? 1 : 0, r ? 1 : 0, c || 0, h || 0, I, d), g.emplaceBack(e ? 1 : 0, r ? 1 : 0, c || 0, h || 0, I, p), g.emplaceBack(e ? 1 : 0, r ? 1 : 0, c || 0, h || 0, z, p);
        }
        const ZM = Math.pow(2, 25), VM = Math.pow(2, 24), Ao = Math.pow(2, 17), mo = Math.pow(2, 16), GM = Math.pow(2, 9), jo = Math.pow(2, 8), _o = Math.pow(2, 1);
        function HM(g) {
          if (g.opacity === 0 && !g.placed) return 0;
          if (g.opacity === 1 && g.placed) return 4294967295;
          const e = g.placed ? 1 : 0, r = Math.floor(127 * g.opacity);
          return r * ZM + e * VM + r * Ao + e * mo + r * GM + e * jo + r * _o + e;
        }
        const pi = 0;
        class wa {
          constructor(e) {
            this._sortAcrossTiles = e.layout.get("symbol-z-order") !== "viewport-y" && !e.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
          }
          continuePlacement(e, r, o, c, h) {
            const z = this._bucketParts;
            for (; this._currentTileIndex < e.length; ) if (r.getBucketParts(z, c, e[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, h()) return !0;
            for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, z.sort(((d, I) => d.sortKey - I.sortKey))); this._currentPartIndex < z.length; ) if (r.placeLayerBucketPart(z[this._currentPartIndex], this._seenCrossTileIDs, o), this._currentPartIndex++, h()) return !0;
            return !1;
          }
        }
        class JM {
          constructor(e, r, o, c, h, z, d, I) {
            this.placement = new xl(e, r, z, d, I), this._currentPlacementIndex = o.length - 1, this._forceFullPlacement = c, this._showCollisionBoxes = h, this._done = !1;
          }
          isDone() {
            return this._done;
          }
          continuePlacement(e, r, o) {
            const c = $t(), h = () => !this._forceFullPlacement && $t() - c > 2;
            for (; this._currentPlacementIndex >= 0; ) {
              const z = r[e[this._currentPlacementIndex]], d = this.placement.collisionIndex.transform.zoom;
              if (z.type === "symbol" && (!z.minzoom || z.minzoom <= d) && (!z.maxzoom || z.maxzoom > d)) {
                if (this._inProgressLayer || (this._inProgressLayer = new wa(z)), this._inProgressLayer.continuePlacement(o[z.source], this.placement, this._showCollisionBoxes, z, h)) return;
                delete this._inProgressLayer;
              }
              this._currentPlacementIndex--;
            }
            this._done = !0;
          }
          commit(e) {
            return this.placement.commit(e), this.placement;
          }
        }
        const ui = 512 / u.a4 / 2;
        class qM {
          constructor(e, r, o) {
            this.tileID = e, this.bucketInstanceId = o, this._symbolsByKey = {};
            const c = /* @__PURE__ */ new Map();
            for (let h = 0; h < r.length; h++) {
              const z = r.get(h), d = z.key, I = c.get(d);
              I ? I.push(z) : c.set(d, [z]);
            }
            for (const [h, z] of c) {
              const d = { positions: z.map(((I) => ({ x: Math.floor(I.anchorX * ui), y: Math.floor(I.anchorY * ui) }))), crossTileIDs: z.map(((I) => I.crossTileID)) };
              if (d.positions.length > 128) {
                const I = new u.aS(d.positions.length, 16, Uint16Array);
                for (const { x: p, y: f } of d.positions) I.add(p, f);
                I.finish(), delete d.positions, d.index = I;
              }
              this._symbolsByKey[h] = d;
            }
          }
          getScaledCoordinates(e, r) {
            const { x: o, y: c, z: h } = this.tileID.canonical, { x: z, y: d, z: I } = r.canonical, p = ui / Math.pow(2, I - h), f = (d * u.a4 + e.anchorY) * p, _ = c * u.a4 * ui;
            return { x: Math.floor((z * u.a4 + e.anchorX) * p - o * u.a4 * ui), y: Math.floor(f - _) };
          }
          findMatches(e, r, o) {
            const c = this.tileID.canonical.z < r.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - r.canonical.z);
            for (let h = 0; h < e.length; h++) {
              const z = e.get(h);
              if (z.crossTileID) continue;
              const d = this._symbolsByKey[z.key];
              if (!d) continue;
              const I = this.getScaledCoordinates(z, r);
              if (d.index) {
                const p = d.index.range(I.x - c, I.y - c, I.x + c, I.y + c).sort();
                for (const f of p) {
                  const _ = d.crossTileIDs[f];
                  if (!o[_]) {
                    o[_] = !0, z.crossTileID = _;
                    break;
                  }
                }
              } else if (d.positions) for (let p = 0; p < d.positions.length; p++) {
                const f = d.positions[p], _ = d.crossTileIDs[p];
                if (Math.abs(f.x - I.x) <= c && Math.abs(f.y - I.y) <= c && !o[_]) {
                  o[_] = !0, z.crossTileID = _;
                  break;
                }
              }
            }
          }
          getCrossTileIDsLists() {
            return Object.values(this._symbolsByKey).map((({ crossTileIDs: e }) => e));
          }
        }
        class Al {
          constructor() {
            this.maxCrossTileID = 0;
          }
          generate() {
            return ++this.maxCrossTileID;
          }
        }
        class Ri {
          constructor() {
            this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
          }
          handleWrapJump(e) {
            const r = Math.round((e - this.lng) / 360);
            if (r !== 0) for (const o in this.indexes) {
              const c = this.indexes[o], h = {};
              for (const z in c) {
                const d = c[z];
                d.tileID = d.tileID.unwrapTo(d.tileID.wrap + r), h[d.tileID.key] = d;
              }
              this.indexes[o] = h;
            }
            this.lng = e;
          }
          addBucket(e, r, o) {
            if (this.indexes[e.overscaledZ] && this.indexes[e.overscaledZ][e.key]) {
              if (this.indexes[e.overscaledZ][e.key].bucketInstanceId === r.bucketInstanceId) return !1;
              this.removeBucketCrossTileIDs(e.overscaledZ, this.indexes[e.overscaledZ][e.key]);
            }
            for (let h = 0; h < r.symbolInstances.length; h++) r.symbolInstances.get(h).crossTileID = 0;
            this.usedCrossTileIDs[e.overscaledZ] || (this.usedCrossTileIDs[e.overscaledZ] = {});
            const c = this.usedCrossTileIDs[e.overscaledZ];
            for (const h in this.indexes) {
              const z = this.indexes[h];
              if (Number(h) > e.overscaledZ) for (const d in z) {
                const I = z[d];
                I.tileID.isChildOf(e) && I.findMatches(r.symbolInstances, e, c);
              }
              else {
                const d = z[e.scaledTo(Number(h)).key];
                d && d.findMatches(r.symbolInstances, e, c);
              }
            }
            for (let h = 0; h < r.symbolInstances.length; h++) {
              const z = r.symbolInstances.get(h);
              z.crossTileID || (z.crossTileID = o.generate(), c[z.crossTileID] = !0);
            }
            return this.indexes[e.overscaledZ] === void 0 && (this.indexes[e.overscaledZ] = {}), this.indexes[e.overscaledZ][e.key] = new qM(e, r.symbolInstances, r.bucketInstanceId), !0;
          }
          removeBucketCrossTileIDs(e, r) {
            for (const o of r.getCrossTileIDsLists()) for (const c of o) delete this.usedCrossTileIDs[e][c];
          }
          removeStaleBuckets(e) {
            let r = !1;
            for (const o in this.indexes) {
              const c = this.indexes[o];
              for (const h in c) e[c[h].bucketInstanceId] || (this.removeBucketCrossTileIDs(o, c[h]), delete c[h], r = !0);
            }
            return r;
          }
        }
        class Dr {
          constructor() {
            this.layerIndexes = {}, this.crossTileIDs = new Al(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
          }
          addLayer(e, r, o) {
            let c = this.layerIndexes[e.id];
            c === void 0 && (c = this.layerIndexes[e.id] = new Ri());
            let h = !1;
            const z = {};
            c.handleWrapJump(o);
            for (const d of r) {
              const I = d.getBucket(e);
              I && e.id === I.layerIds[0] && (I.bucketInstanceId || (I.bucketInstanceId = ++this.maxBucketInstanceId), c.addBucket(d.tileID, I, this.crossTileIDs) && (h = !0), z[I.bucketInstanceId] = !0);
            }
            return c.removeStaleBuckets(z) && (h = !0), h;
          }
          pruneUnusedLayers(e) {
            const r = {};
            e.forEach(((o) => {
              r[o] = !0;
            }));
            for (const o in this.layerIndexes) r[o] || delete this.layerIndexes[o];
          }
        }
        var Vt = "void main() {fragColor=vec4(1.0);}";
        const Fs = { prelude: Jt(`#ifdef GL_ES
precision mediump float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
out highp vec4 fragColor;`, `#ifdef GL_ES
precision highp float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}mat3 rotationMatrixFromAxisAngle(vec3 u,float angle) {float c=cos(angle);float s=sin(angle);float c2=1.0-c;return mat3(u.x*u.x*c2+      c,u.x*u.y*c2-u.z*s,u.x*u.z*c2+u.y*s,u.y*u.x*c2+u.z*s,u.y*u.y*c2+    c,u.y*u.z*c2-u.x*s,u.z*u.x*c2-u.y*s,u.z*u.y*c2+u.x*s,u.z*u.z*c2+    c
);}
#ifdef TERRAIN3D
uniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;
#endif
const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {
#ifdef TERRAIN3D
highp float d=unpack(texture(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));
#else
return 1.0;
#endif
}float calculate_visibility(vec4 pos) {
#ifdef TERRAIN3D
vec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;
#else
return 1.0;
#endif
}float ele(vec2 pos) {
#ifdef TERRAIN3D
vec4 rgb=(texture(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;
#else
return 0.0;
#endif
}float get_elevation(vec2 pos) {
#ifdef TERRAIN3D
#ifdef GLOBE
if ((pos.y <-32767.5) || (pos.y > 32766.5)) {return 0.0;}
#endif
vec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;
#else
return 0.0;
#endif
}const float PI=3.141592653589793;uniform mat4 u_projection_matrix;`), projectionMercator: Jt("", "float projectLineThickness(float tileY) {return 1.0;}float projectCircleRadius(float tileY) {return 1.0;}vec4 projectTile(vec2 p) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);return result;}vec4 projectTile(vec2 p,vec2 rawPos) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);if (rawPos.y <-32767.5 || rawPos.y > 32766.5) {result.z=-10000000.0;}return result;}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_projection_matrix*vec4(posInTile,elevation,1.0);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {return projectTileWithElevation(posInTile,elevation);}"), projectionGlobe: Jt("", `#define GLOBE_RADIUS 6371008.8
uniform highp vec4 u_projection_tile_mercator_coords;uniform highp vec4 u_projection_clipping_plane;uniform highp float u_projection_transition;uniform mat4 u_projection_fallback_matrix;vec3 globeRotateVector(vec3 vec,vec2 angles) {vec3 axisRight=vec3(vec.z,0.0,-vec.x);vec3 axisUp=cross(axisRight,vec);axisRight=normalize(axisRight);axisUp=normalize(axisUp);vec2 t=tan(angles);return normalize(vec+axisRight*t.x+axisUp*t.y);}mat3 globeGetRotationMatrix(vec3 spherePos) {vec3 axisRight=vec3(spherePos.z,0.0,-spherePos.x);vec3 axisDown=cross(axisRight,spherePos);axisRight=normalize(axisRight);axisDown=normalize(axisDown);return mat3(axisRight,axisDown,spherePos
);}float circumferenceRatioAtTileY(float tileY) {float mercator_pos_y=u_projection_tile_mercator_coords.y+u_projection_tile_mercator_coords.w*tileY;float spherical_y=2.0*atan(exp(PI-(mercator_pos_y*PI*2.0)))-PI*0.5;return cos(spherical_y);}float projectLineThickness(float tileY) {float thickness=1.0/circumferenceRatioAtTileY(tileY); 
if (u_projection_transition < 0.999) {return mix(1.0,thickness,u_projection_transition);} else {return thickness;}}vec3 projectToSphere(vec2 translatedPos,vec2 rawPos) {vec2 mercator_pos=u_projection_tile_mercator_coords.xy+u_projection_tile_mercator_coords.zw*translatedPos;vec2 spherical;spherical.x=mercator_pos.x*PI*2.0+PI;spherical.y=2.0*atan(exp(PI-(mercator_pos.y*PI*2.0)))-PI*0.5;float len=cos(spherical.y);vec3 pos=vec3(sin(spherical.x)*len,sin(spherical.y),cos(spherical.x)*len
);if (rawPos.y <-32767.5) {pos=vec3(0.0,1.0,0.0);}if (rawPos.y > 32766.5) {pos=vec3(0.0,-1.0,0.0);}return pos;}vec3 projectToSphere(vec2 posInTile) {return projectToSphere(posInTile,vec2(0.0,0.0));}float globeComputeClippingZ(vec3 spherePos) {return (1.0-(dot(spherePos,u_projection_clipping_plane.xyz)+u_projection_clipping_plane.w));}vec4 interpolateProjection(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);globePosition.z=globeComputeClippingZ(elevatedPos)*globePosition.w;if (u_projection_transition > 0.999) {return globePosition;}vec4 flatPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);const float z_globeness_threshold=0.2;vec4 result=globePosition;result.z=mix(0.0,globePosition.z,clamp((u_projection_transition-z_globeness_threshold)/(1.0-z_globeness_threshold),0.0,1.0));result.xyw=mix(flatPosition.xyw,globePosition.xyw,u_projection_transition);if ((posInTile.y <-32767.5) || (posInTile.y > 32766.5)) {result=globePosition;const float poles_hidden_anim_percentage=0.02;result.z=mix(globePosition.z,100.0,pow(max((1.0-u_projection_transition)/poles_hidden_anim_percentage,0.0),8.0));}return result;}vec4 interpolateProjectionFor3D(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);if (u_projection_transition > 0.999) {return globePosition;}vec4 fallbackPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);return mix(fallbackPosition,globePosition,u_projection_transition);}vec4 projectTile(vec2 posInTile) {return interpolateProjection(posInTile,projectToSphere(posInTile),0.0);}vec4 projectTile(vec2 posInTile,vec2 rawPos) {return interpolateProjection(posInTile,projectToSphere(posInTile,rawPos),0.0);}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return interpolateProjection(posInTile,projectToSphere(posInTile),elevation);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {vec3 spherePos=projectToSphere(posInTile,posInTile);return interpolateProjectionFor3D(posInTile,spherePos,elevation);}`), background: Jt(`uniform vec4 u_color;uniform float u_opacity;void main() {fragColor=u_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"), backgroundPattern: Jt(`uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_mix)*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;void main() {gl_Position=projectTile(a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"), circle: Jt(`in vec3 v_data;in float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float extrude_length=length(extrude);float antialiased_blur=v_data.z;float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));fragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);const float epsilon=0.5/255.0;if (fragColor.r < epsilon && fragColor.g < epsilon && fragColor.b < epsilon && fragColor.a < epsilon) {discard;}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform highp float u_globe_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;uniform vec2 u_translate;in vec2 a_pos;out vec3 v_data;out float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 pos_raw=a_pos+32768.0;vec2 extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);vec2 circle_center=floor(pos_raw/8.0)+u_translate;float ele=get_elevation(circle_center);v_visibility=calculate_visibility(projectTileWithElevation(circle_center,ele));if (u_pitch_with_map) {
#ifdef GLOBE
vec3 center_vector=projectToSphere(circle_center);
#endif
float angle_scale=u_globe_extrude_scale;vec2 corner_position=circle_center;if (u_scale_with_map) {angle_scale*=(radius+stroke_width);corner_position+=extrude*u_extrude_scale*(radius+stroke_width);} else {
#ifdef GLOBE
vec4 projected_center=interpolateProjection(circle_center,center_vector,ele);
#else
vec4 projected_center=projectTileWithElevation(circle_center,ele);
#endif
corner_position+=extrude*u_extrude_scale*(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);angle_scale*=(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);}
#ifdef GLOBE
vec2 angles=extrude*angle_scale;vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(corner_position,corner_vector,ele);
#else
gl_Position=projectTileWithElevation(corner_position,ele);
#endif
} else {gl_Position=projectTileWithElevation(circle_center,ele);if (gl_Position.z/gl_Position.w > 1.0) {gl_Position.xy=vec2(10000.0);}if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}float antialiasblur=-max(1.0/u_device_pixel_ratio/(radius+stroke_width),blur);v_data=vec3(extrude.x,extrude.y,antialiasblur);}`), clippingMask: Jt(Vt, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"), heatmap: Jt(`uniform highp float u_intensity;in vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);fragColor=vec4(val,1.0,1.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;uniform highp float u_globe_extrude_scale;in vec2 a_pos;out vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 pos_raw=a_pos+32768.0;vec2 unscaled_extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 circle_center=floor(pos_raw/8.0);
#ifdef GLOBE
vec2 angles=v_extrude*radius*u_globe_extrude_scale;vec3 center_vector=projectToSphere(circle_center);vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(circle_center+extrude,corner_vector,0.0);
#else
gl_Position=projectTileFor3D(circle_center+extrude,get_elevation(circle_center));
#endif
}`), heatmapTexture: Jt(`uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));fragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(0.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_world;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"), collisionBox: Jt("in float v_placed;in float v_notUsed;void main() {float alpha=0.5;fragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {fragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {fragColor*=.1;}}", "in vec2 a_anchor_pos;in vec2 a_placed;in vec2 a_box_real;uniform vec2 u_pixel_extrude_scale;out float v_placed;out float v_notUsed;void main() {gl_Position=projectTileWithElevation(a_anchor_pos,get_elevation(a_anchor_pos));gl_Position.xy=((a_box_real+0.5)*u_pixel_extrude_scale*2.0-1.0)*vec2(1.0,-1.0)*gl_Position.w;if (gl_Position.z/gl_Position.w < 1.1) {gl_Position.z=0.5;}v_placed=a_placed.x;v_notUsed=a_placed.y;}"), collisionCircle: Jt("in float v_radius;in vec2 v_extrude;in float v_collision;void main() {float alpha=0.5;float stroke_radius=0.9;float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);fragColor=color*alpha*opacity_t;}", "in vec2 a_pos;in float a_radius;in vec2 a_flags;uniform vec2 u_viewport_size;out float v_radius;out vec2 v_extrude;out float v_collision;void main() {float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_collision=collision;gl_Position=vec4((a_pos/u_viewport_size*2.0-1.0)*vec2(1.0,-1.0),0.0,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), colorRelief: Jt(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;uniform vec4 u_unpack;uniform sampler2D u_elevation_stops;uniform sampler2D u_color_stops;uniform int u_color_ramp_size;uniform float u_opacity;in vec2 v_pos;float getElevation(vec2 coord) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}float getElevationStop(int stop) {float x=(float(stop)+0.5)/float(u_color_ramp_size);vec4 data=texture(u_elevation_stops,vec2(x,0))*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {float el=getElevation(v_pos);int r=(u_color_ramp_size-1);int l=0;float el_l=getElevationStop(l);float el_r=getElevationStop(r);while(r-l > 1){int m=(r+l)/2;float el_m=getElevationStop(m);if(el < el_m){r=m;el_r=el_m;}else
{l=m;el_l=el_m;}}float x=(float(l)+(el-el_l)/(el_r-el_l)+0.5)/float(u_color_ramp_size);fragColor=u_opacity*texture(u_color_stops,vec2(x,0));
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform vec2 u_dimension;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_pos/8192.0)*scale+epsilon;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"), debug: Jt("uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);fragColor=mix(u_color,overlay_color,overlay_color.a);}", "in vec2 a_pos;out vec2 v_uv;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=projectTileWithElevation(a_pos*u_overlay_scale,get_elevation(a_pos));}"), depth: Jt(Vt, `in vec2 a_pos;void main() {
#ifdef GLOBE
gl_Position=projectTileFor3D(a_pos,0.0);
#else
gl_Position=u_projection_matrix*vec4(a_pos,0.0,1.0);
#endif
}`), fill: Jt(`#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
fragColor=color*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_fill_translate;in vec2 a_pos;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);}`), fillOutline: Jt(`in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=outline_color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`), fillOutlinePattern: Jt(`uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;in vec2 v_pos_a;in vec2 v_pos_b;in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=mix(color1,color2,u_fade)*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`), fillPattern: Jt(`#ifdef GL_ES
precision highp float;
#endif
uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_fade)*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}`), fillExtrusion: Jt(`in vec4 v_color;void main() {fragColor=v_color;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
out vec4 v_color;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
vec3 normal=a_normal_ed.xyz;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;vec3 normalForLighting=normal/16384.0;float directional=clamp(dot(normalForLighting,u_lightpos),0.0,1.0);
#ifdef GLOBE
mat3 rotMatrix=globeGetRotationMatrix(spherePos);normalForLighting=rotMatrix*normalForLighting;directional=mix(directional,clamp(dot(normalForLighting,u_lightpos_globe),0.0,1.0),u_projection_transition);
#endif
directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}`), fillExtrusionPattern: Jt(`uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;in vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);fragColor=mixedColor*v_lighting;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
#ifdef GLOBE
out vec3 v_sphere_pos;
#endif
out vec2 v_pos_a;out vec2 v_pos_b;out vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);v_sphere_pos=elevatedPos;gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0
? a_pos
: vec2(edgedistance,elevation*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}`), hillshadePrepare: Jt(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {vec2 epsilon=1.0/u_dimension;float tileSize=u_dimension.x-2.0;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))*tileSize/pow(2.0,exaggeration+(28.2562-u_zoom));fragColor=clamp(vec4(deriv.x/8.0+0.5,deriv.y/8.0+0.5,1.0,1.0),0.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: Jt(`uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform float u_exaggeration;uniform vec4 u_accent;uniform int u_method;uniform float u_altitudes[NUM_ILLUMINATION_SOURCES];uniform float u_azimuths[NUM_ILLUMINATION_SOURCES];uniform vec4 u_shadows[NUM_ILLUMINATION_SOURCES];uniform vec4 u_highlights[NUM_ILLUMINATION_SOURCES];
#define PI 3.141592653589793
#define STANDARD 0
#define COMBINED 1
#define IGOR 2
#define MULTIDIRECTIONAL 3
#define BASIC 4
float get_aspect(vec2 deriv){return deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);}void igor_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float aspect=get_aspect(deriv);float azimuth=u_azimuths[0]+PI;float slope_stength=atan(length(deriv))*2.0/PI;float aspect_strength=1.0-abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);float shadow_strength=slope_stength*aspect_strength;float highlight_strength=slope_stength*(1.0-aspect_strength);fragColor=u_shadows[0]*shadow_strength+u_highlights[0]*highlight_strength;}void standard_hillshade(vec2 deriv){float azimuth=u_azimuths[0]+PI;float slope=atan(0.625*length(deriv));float aspect=get_aspect(deriv);float intensity=u_exaggeration;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadows[0],u_highlights[0],shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);fragColor=accent_color*(1.0-shade_color.a)+shade_color;}void basic_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor=u_highlights[0]*(2.0*shade-1.0);}else
{fragColor=u_shadows[0]*(1.0-2.0*shade);}}void multidirectional_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;fragColor=vec4(0,0,0,0);for(int i=0; i < NUM_ILLUMINATION_SOURCES; i++){float cos_alt=cos(u_altitudes[i]);float sin_alt=sin(u_altitudes[i]);float cos_az=-cos(u_azimuths[i]);float sin_az=-sin(u_azimuths[i]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor+=u_highlights[i]*(2.0*shade-1.0)/float(NUM_ILLUMINATION_SOURCES);}else
{fragColor+=u_shadows[i]*(1.0-2.0*shade)/float(NUM_ILLUMINATION_SOURCES);}}}void combined_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=acos((sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv)));cang=clamp(cang,0.0,PI/2.0);float shade=cang*atan(length(deriv))*4.0/PI/PI;float highlight=(PI/2.0-cang)*atan(length(deriv))*4.0/PI/PI;fragColor=u_shadows[0]*shade+u_highlights[0]*highlight;}void main() {vec4 pixel=texture(u_image,v_pos);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));vec2 deriv=((pixel.rg*8.0)-4.0)/scaleFactor;if (u_method==BASIC) {basic_hillshade(deriv);} else if (u_method==COMBINED) {combined_hillshade(deriv);} else if (u_method==IGOR) {igor_hillshade(deriv);} else if (u_method==MULTIDIRECTIONAL) {multidirectional_hillshade(deriv);} else if (u_method==STANDARD) {standard_hillshade(deriv);} else {standard_hillshade(deriv);}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);v_pos=a_pos/8192.0;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"), line: Jt(`uniform lowp float u_device_pixel_ratio;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp float v_linesofar;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`), lineGradient: Jt(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec2 v_uv;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`), linePattern: Jt(`#ifdef GL_ES
precision highp float;
#endif
uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in float v_linesofar;in float v_gamma_scale;in float v_width;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture(u_image,pos_a),texture(u_image,pos_b),u_fade);fragColor=color*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_linesofar;out float v_gamma_scale;out float v_width;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}`), lineSDF: Jt(`uniform lowp float u_device_pixel_ratio;uniform lowp float u_lineatlas_width;uniform sampler2D u_image;uniform float u_mix;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define mediump vec4 dasharray_from
#pragma mapbox: define mediump vec4 dasharray_to
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 dasharray_from
#pragma mapbox: initialize mediump vec4 dasharray_to
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture(u_image,v_tex_a).a;float sdfdist_b=texture(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);float sdfgamma=(u_lineatlas_width/256.0/u_device_pixel_ratio)/min(dasharray_from.w,dasharray_to.w);alpha*=smoothstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_tileratio;uniform float u_crossfade_from;uniform float u_crossfade_to;uniform float u_lineatlas_height;out vec2 v_normal;out vec2 v_width2;out vec2 v_tex_a;out vec2 v_tex_b;out float v_gamma_scale;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define mediump vec4 dasharray_from
#pragma mapbox: define mediump vec4 dasharray_to
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 dasharray_from
#pragma mapbox: initialize mediump vec4 dasharray_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
float u_patternscale_a_x=u_tileratio/dasharray_from.w/u_crossfade_from;float u_patternscale_a_y=-dasharray_from.z/2.0/u_lineatlas_height;float u_patternscale_b_x=u_tileratio/dasharray_to.w/u_crossfade_to;float u_patternscale_b_y=-dasharray_to.z/2.0/u_lineatlas_height;v_tex_a=vec2(a_linesofar*u_patternscale_a_x/floorwidth,normal.y*u_patternscale_a_y+(float(dasharray_from.y)+0.5)/u_lineatlas_height);v_tex_b=vec2(a_linesofar*u_patternscale_b_x/floorwidth,normal.y*u_patternscale_b_y+(float(dasharray_to.y)+0.5)/u_lineatlas_height);v_width2=vec2(outset,inset);}`), lineGradientSDF: Jt(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform sampler2D u_image_dash;uniform float u_mix;uniform lowp float u_lineatlas_width;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;in highp vec2 v_uv;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define mediump vec4 dasharray_from
#pragma mapbox: define mediump vec4 dasharray_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 dasharray_from
#pragma mapbox: initialize mediump vec4 dasharray_to
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);float sdfdist_a=texture(u_image_dash,v_tex_a).a;float sdfdist_b=texture(u_image_dash,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);float sdfgamma=(u_lineatlas_width/256.0)/min(dasharray_from.w,dasharray_to.w);float dash_alpha=smoothstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*dash_alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;uniform float u_tileratio;uniform float u_crossfade_from;uniform float u_crossfade_to;uniform float u_lineatlas_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;out vec2 v_tex_a;out vec2 v_tex_b;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define mediump vec4 dasharray_from
#pragma mapbox: define mediump vec4 dasharray_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 dasharray_from
#pragma mapbox: initialize mediump vec4 dasharray_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;float texel_height=1.0/u_image_height;float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
float u_patternscale_a_x=u_tileratio/dasharray_from.w/u_crossfade_from;float u_patternscale_a_y=-dasharray_from.z/2.0/u_lineatlas_height;float u_patternscale_b_x=u_tileratio/dasharray_to.w/u_crossfade_to;float u_patternscale_b_y=-dasharray_to.z/2.0/u_lineatlas_height;v_tex_a=vec2(a_linesofar*u_patternscale_a_x/floorwidth,normal.y*u_patternscale_a_y+(float(dasharray_from.y)+0.5)/u_lineatlas_height);v_tex_b=vec2(a_linesofar*u_patternscale_b_x/floorwidth,normal.y*u_patternscale_b_y+(float(dasharray_to.y)+0.5)/u_lineatlas_height);v_width2=vec2(outset,inset);}`), raster: Jt(`uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;in vec2 v_pos0;in vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture(u_image0,v_pos0);vec4 color1=texture(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);fragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;uniform vec4 u_coords_top;uniform vec4 u_coords_bottom;in vec2 a_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {vec2 fractionalPos=a_pos/8192.0;vec2 position=mix(mix(u_coords_top.xy,u_coords_top.zw,fractionalPos.x),mix(u_coords_bottom.xy,u_coords_bottom.zw,fractionalPos.x),fractionalPos.y);gl_Position=projectTile(position,position);v_pos0=((fractionalPos-0.5)/u_buffer_scale)+0.5;
#ifdef GLOBE
if (a_pos.y <-32767.5) {v_pos0.y=0.0;}if (a_pos.y > 32766.5) {v_pos0.y=1.0;}
#endif
v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}`), symbolIcon: Jt(`uniform sampler2D u_texture;in vec2 v_tex;in float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
lowp float alpha=opacity*v_fade_opacity;fragColor=texture(u_texture,v_tex)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_tex;out float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}gl_Position=finalPos;v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}`), symbolSDF: Jt(`#define SDF_PX 8.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;in vec2 v_data0;in vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_data0;out vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}`), symbolTextAndIcon: Jt(`#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;in vec4 v_data0;in vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;fragColor=texture(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
return;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec4 v_data0;out vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map && !u_is_along_line) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}`), terrain: Jt("uniform sampler2D u_texture;uniform vec4 u_fog_color;uniform vec4 u_horizon_color;uniform float u_fog_ground_blend;uniform float u_fog_ground_blend_opacity;uniform float u_horizon_fog_blend;uniform bool u_is_globe_mode;in vec2 v_texture_pos;in float v_fog_depth;const float gamma=2.2;vec4 gammaToLinear(vec4 color) {return pow(color,vec4(gamma));}vec4 linearToGamma(vec4 color) {return pow(color,vec4(1.0/gamma));}void main() {vec4 surface_color=texture(u_texture,vec2(v_texture_pos.x,1.0-v_texture_pos.y));if (!u_is_globe_mode && v_fog_depth > u_fog_ground_blend) {vec4 surface_color_linear=gammaToLinear(surface_color);float blend_color=smoothstep(0.0,1.0,max((v_fog_depth-u_horizon_fog_blend)/(1.0-u_horizon_fog_blend),0.0));vec4 fog_horizon_color_linear=mix(gammaToLinear(u_fog_color),gammaToLinear(u_horizon_color),blend_color);float factor_fog=max(v_fog_depth-u_fog_ground_blend,0.0)/(1.0-u_fog_ground_blend);fragColor=linearToGamma(mix(surface_color_linear,fog_horizon_color_linear,pow(factor_fog,2.0)*u_fog_ground_blend_opacity));} else {fragColor=surface_color;}}", "in vec3 a_pos3d;uniform mat4 u_fog_matrix;uniform float u_ele_delta;out vec2 v_texture_pos;out float v_fog_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,get_elevation(a_pos3d.xy)-ele_delta);vec4 pos=u_fog_matrix*vec4(a_pos3d.xy,ele,1.0);v_fog_depth=pos.z/pos.w*0.5+0.5;}"), terrainDepth: Jt("in float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {fragColor=pack(v_depth);}", "in vec3 a_pos3d;uniform float u_ele_delta;out float v_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);v_depth=gl_Position.z/gl_Position.w;}"), terrainCoords: Jt("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;in vec2 v_texture_pos;void main() {vec4 rgba=texture(u_texture,v_texture_pos);fragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", "in vec3 a_pos3d;uniform float u_ele_delta;out vec2 v_texture_pos;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);}"), projectionErrorMeasurement: Jt("in vec4 v_output_error_encoded;void main() {fragColor=v_output_error_encoded;}", "in vec2 a_pos;uniform highp float u_input;uniform highp float u_output_expected;out vec4 v_output_error_encoded;void main() {float real_output=2.0*atan(exp(PI-(u_input*PI*2.0)))-PI*0.5;float error=real_output-u_output_expected;float abs_error=abs(error)*128.0;v_output_error_encoded.x=min(floor(abs_error*256.0),255.0)/255.0;abs_error-=v_output_error_encoded.x;v_output_error_encoded.y=min(floor(abs_error*65536.0),255.0)/255.0;abs_error-=v_output_error_encoded.x/255.0;v_output_error_encoded.z=min(floor(abs_error*16777216.0),255.0)/255.0;v_output_error_encoded.w=error >=0.0 ? 1.0 : 0.0;gl_Position=vec4(a_pos,0.0,1.0);}"), atmosphere: Jt(`in vec3 view_direction;uniform vec3 u_sun_pos;uniform vec3 u_globe_position;uniform float u_globe_radius;uniform float u_atmosphere_blend;/**Shader use from https:*Made some change to adapt to MapLibre Globe geometry*/const float PI=3.141592653589793;const int iSteps=5;const int jSteps=3;/*radius of the planet*/const float EARTH_RADIUS=6371e3;/*radius of the atmosphere*/const float ATMOS_RADIUS=6471e3;vec2 rsi(vec3 r0,vec3 rd,float sr) {float a=dot(rd,rd);float b=2.0*dot(rd,r0);float c=dot(r0,r0)-(sr*sr);float d=(b*b)-4.0*a*c;if (d < 0.0) return vec2(1e5,-1e5);return vec2((-b-sqrt(d))/(2.0*a),(-b+sqrt(d))/(2.0*a));}vec4 atmosphere(vec3 r,vec3 r0,vec3 pSun,float iSun,float rPlanet,float rAtmos,vec3 kRlh,float kMie,float shRlh,float shMie,float g) {pSun=normalize(pSun);r=normalize(r);vec2 p=rsi(r0,r,rAtmos);if (p.x > p.y) {return vec4(0.0,0.0,0.0,1.0);}if (p.x < 0.0) {p.x=0.0;}vec3 pos=r0+r*p.x;vec2 p2=rsi(r0,r,rPlanet);if (p2.x <=p2.y && p2.x > 0.0) {p.y=min(p.y,p2.x);}float iStepSize=(p.y-p.x)/float(iSteps);float iTime=p.x+iStepSize*0.5;vec3 totalRlh=vec3(0,0,0);vec3 totalMie=vec3(0,0,0);float iOdRlh=0.0;float iOdMie=0.0;float mu=dot(r,pSun);float mumu=mu*mu;float gg=g*g;float pRlh=3.0/(16.0*PI)*(1.0+mumu);float pMie=3.0/(8.0*PI)*((1.0-gg)*(mumu+1.0))/(pow(1.0+gg-2.0*mu*g,1.5)*(2.0+gg));for (int i=0; i < iSteps; i++) {vec3 iPos=r0+r*iTime;float iHeight=length(iPos)-rPlanet;float odStepRlh=exp(-iHeight/shRlh)*iStepSize;float odStepMie=exp(-iHeight/shMie)*iStepSize;iOdRlh+=odStepRlh;iOdMie+=odStepMie;float jStepSize=rsi(iPos,pSun,rAtmos).y/float(jSteps);float jTime=jStepSize*0.5;float jOdRlh=0.0;float jOdMie=0.0;for (int j=0; j < jSteps; j++) {vec3 jPos=iPos+pSun*jTime;float jHeight=length(jPos)-rPlanet;jOdRlh+=exp(-jHeight/shRlh)*jStepSize;jOdMie+=exp(-jHeight/shMie)*jStepSize;jTime+=jStepSize;}vec3 attn=exp(-(kMie*(iOdMie+jOdMie)+kRlh*(iOdRlh+jOdRlh)));totalRlh+=odStepRlh*attn;totalMie+=odStepMie*attn;iTime+=iStepSize;}float opacity=exp(-(length(kRlh)*length(totalRlh)+kMie*length(totalMie)));vec3 color=iSun*(pRlh*kRlh*totalRlh+pMie*kMie*totalMie);return vec4(color,opacity);}void main() {vec3 scale_camera_pos=-u_globe_position*EARTH_RADIUS/u_globe_radius;vec4 color=atmosphere(normalize(view_direction),scale_camera_pos,u_sun_pos,22.0,EARTH_RADIUS,ATMOS_RADIUS,vec3(5.5e-6,13.0e-6,22.4e-6),21e-6,8e3,1.2e3,0.758
);color.rgb=1.0-exp(-1.0*color.rgb);color=pow(color,vec4(1.0/2.2));fragColor=vec4(color.rgb,1.0-color.a)*u_atmosphere_blend;}`, "in vec2 a_pos;uniform mat4 u_inv_proj_matrix;out vec3 view_direction;void main() {view_direction=(u_inv_proj_matrix*vec4(a_pos,0.0,1.0)).xyz;gl_Position=vec4(a_pos,0.0,1.0);}"), sky: Jt("uniform vec4 u_sky_color;uniform vec4 u_horizon_color;uniform vec2 u_horizon;uniform vec2 u_horizon_normal;uniform float u_sky_horizon_blend;uniform float u_sky_blend;void main() {float x=gl_FragCoord.x;float y=gl_FragCoord.y;float blend=(y-u_horizon.y)*u_horizon_normal.y+(x-u_horizon.x)*u_horizon_normal.x;if (blend > 0.0) {if (blend < u_sky_horizon_blend) {fragColor=mix(u_sky_color,u_horizon_color,pow(1.0-blend/u_sky_horizon_blend,2.0));} else {fragColor=u_sky_color;}}fragColor=mix(fragColor,vec4(vec3(0.0),0.0),u_sky_blend);}", "in vec2 a_pos;void main() {gl_Position=vec4(a_pos,1.0,1.0);}") };
        function Jt(g, e) {
          const r = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, o = e.match(/in ([\w]+) ([\w]+)/g), c = g.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), h = e.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), z = h ? h.concat(c) : c, d = {};
          return { fragmentSource: g = g.replace(r, ((I, p, f, _, j) => (d[j] = !0, p === "define" ? `
#ifndef HAS_UNIFORM_u_${j}
in ${f} ${_} ${j};
#else
uniform ${f} ${_} u_${j};
#endif
` : `
#ifdef HAS_UNIFORM_u_${j}
    ${f} ${_} ${j} = u_${j};
#endif
`))), vertexSource: e = e.replace(r, ((I, p, f, _, j) => {
            const C = _ === "float" ? "vec2" : "vec4", v = j.match(/color/) ? "color" : C;
            return d[j] ? p === "define" ? `
#ifndef HAS_UNIFORM_u_${j}
uniform lowp float u_${j}_t;
in ${f} ${C} a_${j};
out ${f} ${_} ${j};
#else
uniform ${f} ${_} u_${j};
#endif
` : v === "vec4" ? `
#ifndef HAS_UNIFORM_u_${j}
    ${j} = a_${j};
#else
    ${f} ${_} ${j} = u_${j};
#endif
` : `
#ifndef HAS_UNIFORM_u_${j}
    ${j} = unpack_mix_${v}(a_${j}, u_${j}_t);
#else
    ${f} ${_} ${j} = u_${j};
#endif
` : p === "define" ? `
#ifndef HAS_UNIFORM_u_${j}
uniform lowp float u_${j}_t;
in ${f} ${C} a_${j};
#else
uniform ${f} ${_} u_${j};
#endif
` : v === "vec4" ? `
#ifndef HAS_UNIFORM_u_${j}
    ${f} ${_} ${j} = a_${j};
#else
    ${f} ${_} ${j} = u_${j};
#endif
` : `
#ifndef HAS_UNIFORM_u_${j}
    ${f} ${_} ${j} = unpack_mix_${v}(a_${j}, u_${j}_t);
#else
    ${f} ${_} ${j} = u_${j};
#endif
`;
          })), staticAttributes: o, staticUniforms: z };
        }
        class Zi {
          constructor(e, r, o) {
            this.vertexBuffer = e, this.indexBuffer = r, this.segments = o;
          }
          destroy() {
            this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.vertexBuffer = null, this.indexBuffer = null, this.segments = null;
          }
        }
        var Fe = u.aT([{ name: "a_pos", type: "Int16", components: 2 }]);
        const ns = "#define PROJECTION_MERCATOR", as = "mercator";
        class Re {
          constructor() {
            this._cachedMesh = null;
          }
          get name() {
            return "mercator";
          }
          get useSubdivision() {
            return !1;
          }
          get shaderVariantName() {
            return as;
          }
          get shaderDefine() {
            return ns;
          }
          get shaderPreludeCode() {
            return Fs.projectionMercator;
          }
          get vertexShaderPreludeCode() {
            return Fs.projectionMercator.vertexSource;
          }
          get subdivisionGranularity() {
            return u.aU.noSubdivision;
          }
          get useGlobeControls() {
            return !1;
          }
          get transitionState() {
            return 0;
          }
          get latitudeErrorCorrectionRadians() {
            return 0;
          }
          destroy() {
          }
          updateGPUdependent(e) {
          }
          getMeshFromTileID(e, r, o, c, h) {
            if (this._cachedMesh) return this._cachedMesh;
            const z = new u.aV();
            z.emplaceBack(0, 0), z.emplaceBack(u.a4, 0), z.emplaceBack(0, u.a4), z.emplaceBack(u.a4, u.a4);
            const d = e.createVertexBuffer(z, Fe.members), I = u.aW.simpleSegment(0, 0, 4, 2), p = new u.aX();
            p.emplaceBack(1, 0, 2), p.emplaceBack(1, 2, 3);
            const f = e.createIndexBuffer(p);
            return this._cachedMesh = new Zi(d, f, I), this._cachedMesh;
          }
          recalculate() {
          }
          hasTransition() {
            return !1;
          }
          setErrorQueryLatitudeDegrees(e) {
          }
        }
        class ue {
          constructor(e = 0, r = 0, o = 0, c = 0) {
            if (isNaN(e) || e < 0 || isNaN(r) || r < 0 || isNaN(o) || o < 0 || isNaN(c) || c < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
            this.top = e, this.bottom = r, this.left = o, this.right = c;
          }
          interpolate(e, r, o) {
            return r.top != null && e.top != null && (this.top = u.G.number(e.top, r.top, o)), r.bottom != null && e.bottom != null && (this.bottom = u.G.number(e.bottom, r.bottom, o)), r.left != null && e.left != null && (this.left = u.G.number(e.left, r.left, o)), r.right != null && e.right != null && (this.right = u.G.number(e.right, r.right, o)), this;
          }
          getCenter(e, r) {
            const o = u.an((this.left + e - this.right) / 2, 0, e), c = u.an((this.top + r - this.bottom) / 2, 0, r);
            return new u.P(o, c);
          }
          equals(e) {
            return this.top === e.top && this.bottom === e.bottom && this.left === e.left && this.right === e.right;
          }
          clone() {
            return new ue(this.top, this.bottom, this.left, this.right);
          }
          toJSON() {
            return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
          }
        }
        function pa(g, e) {
          if (!g.renderWorldCopies || g.lngRange) return;
          const r = e.lng - g.center.lng;
          e.lng += r > 180 ? -360 : r < -180 ? 360 : 0;
        }
        function zs(g) {
          return Math.max(0, Math.floor(g));
        }
        class xs {
          constructor(e, r) {
            var o;
            this.applyConstrain = (c, h) => this._constrainOverride !== null ? this._constrainOverride(c, h) : this._callbacks.defaultConstrain(c, h), this._callbacks = e, this._tileSize = 512, this._renderWorldCopies = r?.renderWorldCopies === void 0 || !!r?.renderWorldCopies, this._minZoom = r?.minZoom || 0, this._maxZoom = r?.maxZoom || 22, this._minPitch = r?.minPitch == null ? 0 : r?.minPitch, this._maxPitch = r?.maxPitch == null ? 60 : r?.maxPitch, this._constrainOverride = (o = r?.constrainOverride) !== null && o !== void 0 ? o : null, this.setMaxBounds(), this._width = 0, this._height = 0, this._center = new u.V(0, 0), this._elevation = 0, this._zoom = 0, this._tileZoom = zs(this._zoom), this._scale = u.aq(this._zoom), this._bearingInRadians = 0, this._fovInRadians = 0.6435011087932844, this._pitchInRadians = 0, this._rollInRadians = 0, this._unmodified = !0, this._edgeInsets = new ue(), this._minElevationForCurrentTile = 0, this._autoCalculateNearFarZ = !0;
          }
          apply(e, r, o) {
            this._constrainOverride = e.constrainOverride, this._latRange = e.latRange, this._lngRange = e.lngRange, this._width = e.width, this._height = e.height, this._center = e.center, this._elevation = e.elevation, this._minElevationForCurrentTile = e.minElevationForCurrentTile, this._zoom = e.zoom, this._tileZoom = zs(this._zoom), this._scale = u.aq(this._zoom), this._bearingInRadians = e.bearingInRadians, this._fovInRadians = e.fovInRadians, this._pitchInRadians = e.pitchInRadians, this._rollInRadians = e.rollInRadians, this._unmodified = e.unmodified, this._edgeInsets = new ue(e.padding.top, e.padding.bottom, e.padding.left, e.padding.right), this._minZoom = e.minZoom, this._maxZoom = e.maxZoom, this._minPitch = e.minPitch, this._maxPitch = e.maxPitch, this._renderWorldCopies = e.renderWorldCopies, this._cameraToCenterDistance = e.cameraToCenterDistance, this._nearZ = e.nearZ, this._farZ = e.farZ, this._autoCalculateNearFarZ = !o && e.autoCalculateNearFarZ, r && this.constrainInternal(), this._calcMatrices();
          }
          get pixelsToClipSpaceMatrix() {
            return this._pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._clipSpaceToPixelsMatrix;
          }
          get minElevationForCurrentTile() {
            return this._minElevationForCurrentTile;
          }
          setMinElevationForCurrentTile(e) {
            this._minElevationForCurrentTile = e;
          }
          get tileSize() {
            return this._tileSize;
          }
          get tileZoom() {
            return this._tileZoom;
          }
          get scale() {
            return this._scale;
          }
          get width() {
            return this._width;
          }
          get height() {
            return this._height;
          }
          get bearingInRadians() {
            return this._bearingInRadians;
          }
          get lngRange() {
            return this._lngRange;
          }
          get latRange() {
            return this._latRange;
          }
          get pixelsToGLUnits() {
            return this._pixelsToGLUnits;
          }
          get minZoom() {
            return this._minZoom;
          }
          setMinZoom(e) {
            this._minZoom !== e && (this._minZoom = e, this.setZoom(this.applyConstrain(this._center, this.zoom).zoom));
          }
          get maxZoom() {
            return this._maxZoom;
          }
          setMaxZoom(e) {
            this._maxZoom !== e && (this._maxZoom = e, this.setZoom(this.applyConstrain(this._center, this.zoom).zoom));
          }
          get minPitch() {
            return this._minPitch;
          }
          setMinPitch(e) {
            this._minPitch !== e && (this._minPitch = e, this.setPitch(Math.max(this.pitch, e)));
          }
          get maxPitch() {
            return this._maxPitch;
          }
          setMaxPitch(e) {
            this._maxPitch !== e && (this._maxPitch = e, this.setPitch(Math.min(this.pitch, e)));
          }
          get renderWorldCopies() {
            return this._renderWorldCopies;
          }
          setRenderWorldCopies(e) {
            e === void 0 ? e = !0 : e === null && (e = !1), this._renderWorldCopies = e;
          }
          get constrainOverride() {
            return this._constrainOverride;
          }
          setConstrainOverride(e) {
            e === void 0 && (e = null), this._constrainOverride !== e && (this._constrainOverride = e, this.constrainInternal(), this._calcMatrices());
          }
          get worldSize() {
            return this._tileSize * this._scale;
          }
          get centerOffset() {
            return this.centerPoint._sub(this.size._div(2));
          }
          get size() {
            return new u.P(this._width, this._height);
          }
          get bearing() {
            return this._bearingInRadians / Math.PI * 180;
          }
          setBearing(e) {
            const r = u.W(e, -180, 180) * Math.PI / 180;
            var o, c, h, z, d, I, p, f, _;
            this._bearingInRadians !== r && (this._unmodified = !1, this._bearingInRadians = r, this._calcMatrices(), this._rotationMatrix = Qi(), o = this._rotationMatrix, h = -this._bearingInRadians, z = (c = this._rotationMatrix)[0], d = c[1], I = c[2], p = c[3], f = Math.sin(h), _ = Math.cos(h), o[0] = z * _ + I * f, o[1] = d * _ + p * f, o[2] = z * -f + I * _, o[3] = d * -f + p * _);
          }
          get rotationMatrix() {
            return this._rotationMatrix;
          }
          get pitchInRadians() {
            return this._pitchInRadians;
          }
          get pitch() {
            return this._pitchInRadians / Math.PI * 180;
          }
          setPitch(e) {
            const r = u.an(e, this.minPitch, this.maxPitch) / 180 * Math.PI;
            this._pitchInRadians !== r && (this._unmodified = !1, this._pitchInRadians = r, this._calcMatrices());
          }
          get rollInRadians() {
            return this._rollInRadians;
          }
          get roll() {
            return this._rollInRadians / Math.PI * 180;
          }
          setRoll(e) {
            const r = e / 180 * Math.PI;
            this._rollInRadians !== r && (this._unmodified = !1, this._rollInRadians = r, this._calcMatrices());
          }
          get fovInRadians() {
            return this._fovInRadians;
          }
          get fov() {
            return u.aY(this._fovInRadians);
          }
          setFov(e) {
            e = u.an(e, 0.1, 150), this.fov !== e && (this._unmodified = !1, this._fovInRadians = u.ap(e), this._calcMatrices());
          }
          get zoom() {
            return this._zoom;
          }
          setZoom(e) {
            const r = this.applyConstrain(this._center, e).zoom;
            this._zoom !== r && (this._unmodified = !1, this._zoom = r, this._tileZoom = Math.max(0, Math.floor(r)), this._scale = u.aq(r), this.constrainInternal(), this._calcMatrices());
          }
          get center() {
            return this._center;
          }
          setCenter(e) {
            e.lat === this._center.lat && e.lng === this._center.lng || (this._unmodified = !1, this._center = e, this.constrainInternal(), this._calcMatrices());
          }
          get elevation() {
            return this._elevation;
          }
          setElevation(e) {
            e !== this._elevation && (this._elevation = e, this.constrainInternal(), this._calcMatrices());
          }
          get padding() {
            return this._edgeInsets.toJSON();
          }
          setPadding(e) {
            this._edgeInsets.equals(e) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, e, 1), this._calcMatrices());
          }
          get centerPoint() {
            return this._edgeInsets.getCenter(this._width, this._height);
          }
          get pixelsPerMeter() {
            return this._pixelPerMeter;
          }
          get unmodified() {
            return this._unmodified;
          }
          get cameraToCenterDistance() {
            return this._cameraToCenterDistance;
          }
          get nearZ() {
            return this._nearZ;
          }
          get farZ() {
            return this._farZ;
          }
          get autoCalculateNearFarZ() {
            return this._autoCalculateNearFarZ;
          }
          overrideNearFarZ(e, r) {
            this._autoCalculateNearFarZ = !1, this._nearZ = e, this._farZ = r, this._calcMatrices();
          }
          clearNearFarZOverride() {
            this._autoCalculateNearFarZ = !0, this._calcMatrices();
          }
          isPaddingEqual(e) {
            return this._edgeInsets.equals(e);
          }
          interpolatePadding(e, r, o) {
            this._unmodified = !1, this._edgeInsets.interpolate(e, r, o), this.constrainInternal(), this._calcMatrices();
          }
          resize(e, r, o = !0) {
            this._width = e, this._height = r, o && this.constrainInternal(), this._calcMatrices();
          }
          getMaxBounds() {
            return this._latRange && this._latRange.length === 2 && this._lngRange && this._lngRange.length === 2 ? new pe([this._lngRange[0], this._latRange[0]], [this._lngRange[1], this._latRange[1]]) : null;
          }
          setMaxBounds(e) {
            e ? (this._lngRange = [e.getWest(), e.getEast()], this._latRange = [e.getSouth(), e.getNorth()], this.constrainInternal()) : (this._lngRange = null, this._latRange = [-u.ao, u.ao]);
          }
          getCameraQueryGeometry(e, r) {
            if (r.length === 1) return [r[0], e];
            {
              const { minX: o, minY: c, maxX: h, maxY: z } = u.ab.fromPoints(r).extend(e);
              return [new u.P(o, c), new u.P(h, c), new u.P(h, z), new u.P(o, z), new u.P(o, c)];
            }
          }
          constrainInternal() {
            if (!this.center || !this._width || !this._height || this._constraining) return;
            this._constraining = !0;
            const e = this._unmodified, { center: r, zoom: o } = this.applyConstrain(this.center, this.zoom);
            this.setCenter(r), this.setZoom(o), this._unmodified = e, this._constraining = !1;
          }
          _calcMatrices() {
            if (this._width && this._height) {
              this._pixelsToGLUnits = [2 / this._width, -2 / this._height];
              let e = u.ar(new Float64Array(16));
              u.Q(e, e, [this._width / 2, -this._height / 2, 1]), u.O(e, e, [1, -1, 0]), this._clipSpaceToPixelsMatrix = e, e = u.ar(new Float64Array(16)), u.Q(e, e, [1, -1, 1]), u.O(e, e, [-1, -1, 0]), u.Q(e, e, [2 / this._width, 2 / this._height, 1]), this._pixelsToClipSpaceMatrix = e, this._cameraToCenterDistance = 0.5 / Math.tan(this.fovInRadians / 2) * this._height;
            }
            this._callbacks.calcMatrices();
          }
          calculateCenterFromCameraLngLatAlt(e, r, o, c) {
            const h = o !== void 0 ? o : this.bearing, z = c = c !== void 0 ? c : this.pitch, d = u.aa.fromLngLat(e, r), I = -Math.cos(u.ap(z)), p = Math.sin(u.ap(z)), f = p * Math.sin(u.ap(h)), _ = -p * Math.cos(u.ap(h));
            let j = this.elevation;
            const C = r - j;
            let v;
            I * C >= 0 || Math.abs(I) < 0.1 ? (v = 1e4, j = r + v * I) : v = -C / I;
            let F, Y, W = u.aZ(1, d.y), Z = 0;
            do {
              if (Z += 1, Z > 10) break;
              Y = v / W, F = new u.aa(d.x + f * Y, d.y + _ * Y), W = 1 / F.meterInMercatorCoordinateUnits();
            } while (Math.abs(v - Y * W) > 1e-12);
            return { center: F.toLngLat(), elevation: j, zoom: u.at(this.height / 2 / Math.tan(this.fovInRadians / 2) / Y / this.tileSize) };
          }
          recalculateZoomAndCenter(e) {
            if (this.elevation - e == 0) return;
            const r = u.as(1, this.center.lat) * this.worldSize, o = this.cameraToCenterDistance / r, c = u.aa.fromLngLat(this.center, this.elevation), h = it(this.center, this.elevation, this.pitch, this.bearing, o);
            this._elevation = e;
            const z = this.calculateCenterFromCameraLngLatAlt(h.toLngLat(), u.aZ(h.z, c.y), this.bearing, this.pitch);
            this._elevation = z.elevation, this._center = z.center, this.setZoom(z.zoom);
          }
          getCameraPoint() {
            const e = Math.tan(this.pitchInRadians) * (this.cameraToCenterDistance || 1);
            return this.centerPoint.add(new u.P(e * Math.sin(this.rollInRadians), e * Math.cos(this.rollInRadians)));
          }
          getCameraAltitude() {
            return Math.cos(this.pitchInRadians) * this._cameraToCenterDistance / this._pixelPerMeter + this.elevation;
          }
          getCameraLngLat() {
            const e = u.as(1, this.center.lat) * this.worldSize;
            return it(this.center, this.elevation, this.pitch, this.bearing, this.cameraToCenterDistance / e).toLngLat();
          }
          getMercatorTileCoordinates(e) {
            if (!e) return [0, 0, 1, 1];
            const r = e.canonical.z >= 0 ? 1 << e.canonical.z : Math.pow(2, e.canonical.z);
            return [e.canonical.x / r, e.canonical.y / r, 1 / r / u.a4, 1 / r / u.a4];
          }
        }
        class os {
          constructor(e, r) {
            this.min = e, this.max = r, this.center = u.a_([], u.a$([], this.min, this.max), 0.5);
          }
          quadrant(e) {
            const r = [e % 2 == 0, e < 2], o = u.b0(this.min), c = u.b0(this.max);
            for (let h = 0; h < r.length; h++) o[h] = r[h] ? this.min[h] : this.center[h], c[h] = r[h] ? this.center[h] : this.max[h];
            return c[2] = this.max[2], new os(o, c);
          }
          distanceX(e) {
            return Math.max(Math.min(this.max[0], e[0]), this.min[0]) - e[0];
          }
          distanceY(e) {
            return Math.max(Math.min(this.max[1], e[1]), this.min[1]) - e[1];
          }
          intersectsFrustum(e) {
            let r = !0;
            for (let o = 0; o < e.planes.length; o++) {
              const c = this.intersectsPlane(e.planes[o]);
              if (c === 0) return 0;
              c === 1 && (r = !1);
            }
            return r ? 2 : e.aabb.min[0] > this.max[0] || e.aabb.min[1] > this.max[1] || e.aabb.min[2] > this.max[2] || e.aabb.max[0] < this.min[0] || e.aabb.max[1] < this.min[1] || e.aabb.max[2] < this.min[2] ? 0 : 1;
          }
          intersectsPlane(e) {
            let r = e[3], o = e[3];
            for (let c = 0; c < 3; c++) e[c] > 0 ? (r += e[c] * this.min[c], o += e[c] * this.max[c]) : (o += e[c] * this.min[c], r += e[c] * this.max[c]);
            return r >= 0 ? 2 : o < 0 ? 0 : 1;
          }
        }
        class $M {
          distanceToTile2d(e, r, o, c) {
            const h = c.distanceX([e, r]), z = c.distanceY([e, r]);
            return Math.hypot(h, z);
          }
          getWrap(e, r, o) {
            return o;
          }
          getTileBoundingVolume(e, r, o, c) {
            var h, z;
            let d = 0, I = 0;
            if (c?.terrain) {
              const f = new u.a1(e.z, r, e.z, e.x, e.y), _ = c.terrain.getMinMaxElevation(f);
              d = (h = _.minElevation) !== null && h !== void 0 ? h : Math.min(0, o), I = (z = _.maxElevation) !== null && z !== void 0 ? z : Math.max(0, o);
            }
            const p = 1 << e.z;
            return new os([r + e.x / p, e.y / p, d], [r + (e.x + 1) / p, (e.y + 1) / p, I]);
          }
          allowVariableZoom(e, r) {
            const o = e.fov * (Math.abs(Math.cos(e.rollInRadians)) * e.height + Math.abs(Math.sin(e.rollInRadians)) * e.width) / e.height, c = u.an(78.5 - o / 2, 0, 60);
            return !!r.terrain || e.pitch > c;
          }
          allowWorldCopies() {
            return !0;
          }
          prepareNextFrame() {
          }
        }
        class Vi {
          constructor(e, r, o) {
            this.points = e, this.planes = r, this.aabb = o;
          }
          static fromInvProjectionMatrix(e, r = 1, o = 0, c, h) {
            const z = h ? [[6, 5, 4], [0, 1, 2], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]] : [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]], d = Math.pow(2, o), I = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map(((j) => (function(C, v, F, Y) {
              const W = u.aG([], C, v), Z = 1 / W[3] / F * Y;
              return u.b5(W, W, [Z, Z, 1 / W[3], Z]);
            })(j, e, r, d)));
            c && (function(j, C, v, F) {
              const Y = F ? 4 : 0, W = F ? 0 : 4;
              let Z = 0;
              const J = [], R = [];
              for (let G = 0; G < 4; G++) {
                const st = u.b1([], j[G + W], j[G + Y]), ct = u.b6(st);
                u.a_(st, st, 1 / ct), J.push(ct), R.push(st);
              }
              for (let G = 0; G < 4; G++) {
                const st = u.b7(j[G + Y], R[G], v);
                Z = st !== null && st >= 0 ? Math.max(Z, st) : Math.max(Z, J[G]);
              }
              const q = (function(G, st) {
                const ct = u.b1([], G[st[0]], G[st[1]]), nt = u.b1([], G[st[2]], G[st[1]]), at = [0, 0, 0, 0];
                return u.b2(at, u.b3([], ct, nt)), at[3] = -u.b4(at, G[st[0]]), at;
              })(j, C), $ = (function(G, st) {
                const ct = u.b8(G), nt = u.b9([], G, 1 / ct), at = u.b1([], st, u.a_([], nt, u.b4(st, nt))), Mt = u.b8(at);
                if (Mt > 0) {
                  const xt = Math.sqrt(1 - nt[3] * nt[3]), wt = u.a_([], nt, -nt[3]), Nt = u.a$([], wt, u.a_([], at, xt / Mt));
                  return u.ba(st, Nt);
                }
                return null;
              })(v, q);
              if ($ !== null) {
                const G = $ / u.b4(R[0], q);
                Z = Math.min(Z, G);
              }
              for (let G = 0; G < 4; G++) {
                const st = Math.min(Z, J[G]);
                j[G + W] = [j[G + Y][0] + R[G][0] * st, j[G + Y][1] + R[G][1] * st, j[G + Y][2] + R[G][2] * st, 1];
              }
            })(I, z[0], c, h);
            const p = z.map(((j) => {
              const C = u.b1([], I[j[0]], I[j[1]]), v = u.b1([], I[j[2]], I[j[1]]), F = u.b2([], u.b3([], C, v)), Y = -u.b4(F, I[j[1]]);
              return F.concat(Y);
            })), f = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY], _ = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];
            for (const j of I) for (let C = 0; C < 3; C++) f[C] = Math.min(f[C], j[C]), _[C] = Math.max(_[C], j[C]);
            return new Vi(I, p, new os(f, _));
          }
        }
        class ze {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix;
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits;
          }
          get centerOffset() {
            return this._helper.centerOffset;
          }
          get size() {
            return this._helper.size;
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix;
          }
          get centerPoint() {
            return this._helper.centerPoint;
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter;
          }
          setMinZoom(e) {
            this._helper.setMinZoom(e);
          }
          setMaxZoom(e) {
            this._helper.setMaxZoom(e);
          }
          setMinPitch(e) {
            this._helper.setMinPitch(e);
          }
          setMaxPitch(e) {
            this._helper.setMaxPitch(e);
          }
          setRenderWorldCopies(e) {
            this._helper.setRenderWorldCopies(e);
          }
          setBearing(e) {
            this._helper.setBearing(e);
          }
          setPitch(e) {
            this._helper.setPitch(e);
          }
          setRoll(e) {
            this._helper.setRoll(e);
          }
          setFov(e) {
            this._helper.setFov(e);
          }
          setZoom(e) {
            this._helper.setZoom(e);
          }
          setCenter(e) {
            this._helper.setCenter(e);
          }
          setElevation(e) {
            this._helper.setElevation(e);
          }
          setMinElevationForCurrentTile(e) {
            this._helper.setMinElevationForCurrentTile(e);
          }
          setPadding(e) {
            this._helper.setPadding(e);
          }
          interpolatePadding(e, r, o) {
            return this._helper.interpolatePadding(e, r, o);
          }
          isPaddingEqual(e) {
            return this._helper.isPaddingEqual(e);
          }
          resize(e, r, o = !0) {
            this._helper.resize(e, r, o);
          }
          getMaxBounds() {
            return this._helper.getMaxBounds();
          }
          setMaxBounds(e) {
            this._helper.setMaxBounds(e);
          }
          setConstrainOverride(e) {
            this._helper.setConstrainOverride(e);
          }
          overrideNearFarZ(e, r) {
            this._helper.overrideNearFarZ(e, r);
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride();
          }
          getCameraQueryGeometry(e) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e);
          }
          get tileSize() {
            return this._helper.tileSize;
          }
          get tileZoom() {
            return this._helper.tileZoom;
          }
          get scale() {
            return this._helper.scale;
          }
          get worldSize() {
            return this._helper.worldSize;
          }
          get width() {
            return this._helper.width;
          }
          get height() {
            return this._helper.height;
          }
          get lngRange() {
            return this._helper.lngRange;
          }
          get latRange() {
            return this._helper.latRange;
          }
          get minZoom() {
            return this._helper.minZoom;
          }
          get maxZoom() {
            return this._helper.maxZoom;
          }
          get zoom() {
            return this._helper.zoom;
          }
          get center() {
            return this._helper.center;
          }
          get minPitch() {
            return this._helper.minPitch;
          }
          get maxPitch() {
            return this._helper.maxPitch;
          }
          get pitch() {
            return this._helper.pitch;
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians;
          }
          get roll() {
            return this._helper.roll;
          }
          get rollInRadians() {
            return this._helper.rollInRadians;
          }
          get bearing() {
            return this._helper.bearing;
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians;
          }
          get fov() {
            return this._helper.fov;
          }
          get fovInRadians() {
            return this._helper.fovInRadians;
          }
          get elevation() {
            return this._helper.elevation;
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile;
          }
          get padding() {
            return this._helper.padding;
          }
          get unmodified() {
            return this._helper.unmodified;
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies;
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance;
          }
          get constrainOverride() {
            return this._helper.constrainOverride;
          }
          get nearZ() {
            return this._helper.nearZ;
          }
          get farZ() {
            return this._helper.farZ;
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ;
          }
          setTransitionState(e, r) {
          }
          constructor(e) {
            this._posMatrixCache = /* @__PURE__ */ new Map(), this._alignedPosMatrixCache = /* @__PURE__ */ new Map(), this._fogMatrixCacheF32 = /* @__PURE__ */ new Map(), this.defaultConstrain = (r, o) => {
              o = u.an(+o, this.minZoom, this.maxZoom);
              const c = { center: new u.V(r.lng, r.lat), zoom: o };
              let h = this._helper._lngRange;
              if (!this._helper._renderWorldCopies && h === null) {
                const R = 179.9999999999;
                h = [-R, R];
              }
              const z = this.tileSize * u.aq(c.zoom);
              let d = 0, I = z, p = 0, f = z, _ = 0, j = 0;
              const { x: C, y: v } = this.size;
              if (this._helper._latRange) {
                const R = this._helper._latRange;
                d = u.X(R[1]) * z, I = u.X(R[0]) * z, I - d < v && (_ = v / (I - d));
              }
              h && (p = u.W(u.Y(h[0]) * z, 0, z), f = u.W(u.Y(h[1]) * z, 0, z), f < p && (f += z), f - p < C && (j = C / (f - p)));
              const { x: F, y: Y } = V(z, r);
              let W, Z;
              const J = Math.max(j || 0, _ || 0);
              if (J) {
                const R = new u.P(j ? (f + p) / 2 : F, _ ? (I + d) / 2 : Y);
                return c.center = H(z, R).wrap(), c.zoom += u.at(J), c;
              }
              if (this._helper._latRange) {
                const R = v / 2;
                Y - R < d && (Z = d + R), Y + R > I && (Z = I - R);
              }
              if (h) {
                const R = (p + f) / 2;
                let q = F;
                this._helper._renderWorldCopies && (q = u.W(F, R - z / 2, R + z / 2));
                const $ = C / 2;
                q - $ < p && (W = p + $), q + $ > f && (W = f - $);
              }
              if (W !== void 0 || Z !== void 0) {
                const R = new u.P(W ?? F, Z ?? Y);
                c.center = H(z, R).wrap();
              }
              return c;
            }, this.applyConstrain = (r, o) => this._helper.applyConstrain(r, o), this._helper = new xs({ calcMatrices: () => {
              this._calcMatrices();
            }, defaultConstrain: (r, o) => this.defaultConstrain(r, o) }, e), this._coveringTilesDetailsProvider = new $M();
          }
          clone() {
            const e = new ze();
            return e.apply(this), e;
          }
          apply(e, r, o) {
            this._helper.apply(e, r, o);
          }
          get cameraPosition() {
            return this._cameraPosition;
          }
          get projectionMatrix() {
            return this._projectionMatrix;
          }
          get modelViewProjectionMatrix() {
            return this._viewProjMatrix;
          }
          get inverseProjectionMatrix() {
            return this._invProjMatrix;
          }
          get mercatorMatrix() {
            return this._mercatorMatrix;
          }
          getVisibleUnwrappedCoordinates(e) {
            const r = [new u.bb(0, e)];
            if (this._helper._renderWorldCopies) {
              const o = this.screenPointToMercatorCoordinate(new u.P(0, 0)), c = this.screenPointToMercatorCoordinate(new u.P(this._helper._width, 0)), h = this.screenPointToMercatorCoordinate(new u.P(this._helper._width, this._helper._height)), z = this.screenPointToMercatorCoordinate(new u.P(0, this._helper._height)), d = Math.floor(Math.min(o.x, c.x, h.x, z.x)), I = Math.floor(Math.max(o.x, c.x, h.x, z.x)), p = 1;
              for (let f = d - p; f <= I + p; f++) f !== 0 && r.push(new u.bb(f, e));
            }
            return r;
          }
          getCameraFrustum() {
            return Vi.fromInvProjectionMatrix(this._invViewProjMatrix, this.worldSize);
          }
          getClippingPlane() {
            return null;
          }
          getCoveringTilesDetailsProvider() {
            return this._coveringTilesDetailsProvider;
          }
          recalculateZoomAndCenter(e) {
            const r = this.screenPointToLocation(this.centerPoint, e), o = e ? e.getElevationForLngLatZoom(r, this._helper._tileZoom) : 0;
            this._helper.recalculateZoomAndCenter(o);
          }
          setLocationAtPoint(e, r) {
            const o = u.as(this.elevation, this.center.lat), c = this.screenPointToMercatorCoordinateAtZ(r, o), h = this.screenPointToMercatorCoordinateAtZ(this.centerPoint, o), z = u.aa.fromLngLat(e), d = new u.aa(z.x - (c.x - h.x), z.y - (c.y - h.y));
            this.setCenter(d?.toLngLat()), this._helper._renderWorldCopies && this.setCenter(this.center.wrap());
          }
          locationToScreenPoint(e, r) {
            return r ? this.coordinatePoint(u.aa.fromLngLat(e), r.getElevationForLngLatZoom(e, this._helper._tileZoom), this._pixelMatrix3D) : this.coordinatePoint(u.aa.fromLngLat(e));
          }
          screenPointToLocation(e, r) {
            var o;
            return (o = this.screenPointToMercatorCoordinate(e, r)) === null || o === void 0 ? void 0 : o.toLngLat();
          }
          screenPointToMercatorCoordinate(e, r) {
            if (r) {
              const o = r.pointCoordinate(e);
              if (o != null) return o;
            }
            return this.screenPointToMercatorCoordinateAtZ(e);
          }
          screenPointToMercatorCoordinateAtZ(e, r) {
            const o = r || 0, c = [e.x, e.y, 0, 1], h = [e.x, e.y, 1, 1];
            u.aG(c, c, this._pixelMatrixInverse), u.aG(h, h, this._pixelMatrixInverse);
            const z = c[3], d = h[3], I = c[1] / z, p = h[1] / d, f = c[2] / z, _ = h[2] / d, j = f === _ ? 0 : (o - f) / (_ - f);
            return new u.aa(u.G.number(c[0] / z, h[0] / d, j) / this.worldSize, u.G.number(I, p, j) / this.worldSize, o);
          }
          coordinatePoint(e, r = 0, o = this._pixelMatrix) {
            const c = [e.x * this.worldSize, e.y * this.worldSize, r, 1];
            return u.aG(c, c, o), new u.P(c[0] / c[3], c[1] / c[3]);
          }
          getBounds() {
            const e = Math.max(0, this._helper._height / 2 - rt(this));
            return new pe().extend(this.screenPointToLocation(new u.P(0, e))).extend(this.screenPointToLocation(new u.P(this._helper._width, e))).extend(this.screenPointToLocation(new u.P(this._helper._width, this._helper._height))).extend(this.screenPointToLocation(new u.P(0, this._helper._height)));
          }
          isPointOnMapSurface(e, r) {
            return r ? r.pointCoordinate(e) != null : e.y > this.height / 2 - rt(this);
          }
          calculatePosMatrix(e, r = !1, o) {
            var c;
            const h = (c = e.key) !== null && c !== void 0 ? c : u.bc(e.wrap, e.canonical.z, e.canonical.z, e.canonical.x, e.canonical.y), z = r ? this._alignedPosMatrixCache : this._posMatrixCache;
            if (z.has(h)) {
              const p = z.get(h);
              return o ? p.f32 : p.f64;
            }
            const d = X(e, this.worldSize);
            u.S(d, r ? this._alignedProjMatrix : this._viewProjMatrix, d);
            const I = { f64: d, f32: new Float32Array(d) };
            return z.set(h, I), o ? I.f32 : I.f64;
          }
          calculateFogMatrix(e) {
            const r = e.key, o = this._fogMatrixCacheF32;
            if (o.has(r)) return o.get(r);
            const c = X(e, this.worldSize);
            return u.S(c, this._fogMatrix, c), o.set(r, new Float32Array(c)), o.get(r);
          }
          calculateCenterFromCameraLngLatAlt(e, r, o, c) {
            return this._helper.calculateCenterFromCameraLngLatAlt(e, r, o, c);
          }
          _calculateNearFarZIfNeeded(e, r, o) {
            if (!this._helper.autoCalculateNearFarZ) return;
            const c = Math.min(this.elevation, this.minElevationForCurrentTile, this.getCameraAltitude() - 100), h = e - c * this._helper._pixelPerMeter / Math.cos(r), z = c < 0 ? h : e, d = Math.PI / 2 + this.pitchInRadians, I = u.ap(this.fov) * (Math.abs(Math.cos(u.ap(this.roll))) * this.height + Math.abs(Math.sin(u.ap(this.roll))) * this.width) / this.height * (0.5 + o.y / this.height), p = Math.sin(I) * z / Math.sin(u.an(Math.PI - d - I, 0.01, Math.PI - 0.01)), f = rt(this), _ = Math.atan(f / this._helper.cameraToCenterDistance), j = u.ap(0.75), C = _ > j ? 2 * _ * (0.5 + o.y / (2 * f)) : j, v = Math.sin(C) * z / Math.sin(u.an(Math.PI - d - C, 0.01, Math.PI - 0.01)), F = Math.min(p, v);
            this._helper._farZ = 1.01 * (Math.cos(Math.PI / 2 - r) * F + z), this._helper._nearZ = this._helper._height / 50;
          }
          _calcMatrices() {
            if (!this._helper._height) return;
            const e = this.centerOffset, r = V(this.worldSize, this.center), o = r.x, c = r.y;
            this._helper._pixelPerMeter = u.as(1, this.center.lat) * this.worldSize;
            const h = u.ap(Math.min(this.pitch, S)), z = Math.max(this._helper.cameraToCenterDistance / 2, this._helper.cameraToCenterDistance + this._helper._elevation * this._helper._pixelPerMeter / Math.cos(h));
            let d;
            this._calculateNearFarZIfNeeded(z, h, e), d = new Float64Array(16), u.bd(d, this.fovInRadians, this._helper._width / this._helper._height, this._helper._nearZ, this._helper._farZ), this._invProjMatrix = new Float64Array(16), u.aA(this._invProjMatrix, d), d[8] = 2 * -e.x / this._helper._width, d[9] = 2 * e.y / this._helper._height, this._projectionMatrix = u.be(d), u.Q(d, d, [1, -1, 1]), u.O(d, d, [0, 0, -this._helper.cameraToCenterDistance]), u.bf(d, d, -this.rollInRadians), u.bg(d, d, this.pitchInRadians), u.bf(d, d, -this.bearingInRadians), u.O(d, d, [-o, -c, 0]), this._mercatorMatrix = u.Q([], d, [this.worldSize, this.worldSize, this.worldSize]), u.Q(d, d, [1, 1, this._helper._pixelPerMeter]), this._pixelMatrix = u.S(new Float64Array(16), this.clipSpaceToPixelsMatrix, d), u.O(d, d, [0, 0, -this.elevation]), this._viewProjMatrix = d, this._invViewProjMatrix = u.aA([], d);
            const I = [0, 0, -1, 1];
            u.aG(I, I, this._invViewProjMatrix), this._cameraPosition = [I[0] / I[3], I[1] / I[3], I[2] / I[3]], this._fogMatrix = new Float64Array(16), u.bd(this._fogMatrix, this.fovInRadians, this.width / this.height, z, this._helper._farZ), this._fogMatrix[8] = 2 * -e.x / this.width, this._fogMatrix[9] = 2 * e.y / this.height, u.Q(this._fogMatrix, this._fogMatrix, [1, -1, 1]), u.O(this._fogMatrix, this._fogMatrix, [0, 0, -this.cameraToCenterDistance]), u.bf(this._fogMatrix, this._fogMatrix, -this.rollInRadians), u.bg(this._fogMatrix, this._fogMatrix, this.pitchInRadians), u.bf(this._fogMatrix, this._fogMatrix, -this.bearingInRadians), u.O(this._fogMatrix, this._fogMatrix, [-o, -c, 0]), u.Q(this._fogMatrix, this._fogMatrix, [1, 1, this._helper._pixelPerMeter]), u.O(this._fogMatrix, this._fogMatrix, [0, 0, -this.elevation]), this._pixelMatrix3D = u.S(new Float64Array(16), this.clipSpaceToPixelsMatrix, d);
            const p = this._helper._width % 2 / 2, f = this._helper._height % 2 / 2, _ = Math.cos(this.bearingInRadians), j = Math.sin(-this.bearingInRadians), C = o - Math.round(o) + _ * p + j * f, v = c - Math.round(c) + _ * f + j * p, F = new Float64Array(d);
            if (u.O(F, F, [C > 0.5 ? C - 1 : C, v > 0.5 ? v - 1 : v, 0]), this._alignedProjMatrix = F, d = u.aA(new Float64Array(16), this._pixelMatrix), !d) throw new Error("failed to invert matrix");
            this._pixelMatrixInverse = d, this._clearMatrixCaches();
          }
          _clearMatrixCaches() {
            this._posMatrixCache.clear(), this._alignedPosMatrixCache.clear(), this._fogMatrixCacheF32.clear();
          }
          maxPitchScaleFactor() {
            if (!this._pixelMatrixInverse) return 1;
            const e = this.screenPointToMercatorCoordinate(new u.P(0, 0)), r = [e.x * this.worldSize, e.y * this.worldSize, 0, 1];
            return u.aG(r, r, this._pixelMatrix)[3] / this._helper.cameraToCenterDistance;
          }
          getCameraPoint() {
            return this._helper.getCameraPoint();
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude();
          }
          getCameraLngLat() {
            const e = u.as(1, this.center.lat) * this.worldSize;
            return it(this.center, this.elevation, this.pitch, this.bearing, this._helper.cameraToCenterDistance / e).toLngLat();
          }
          lngLatToCameraDepth(e, r) {
            const o = u.aa.fromLngLat(e), c = [o.x * this.worldSize, o.y * this.worldSize, r, 1];
            return u.aG(c, c, this._viewProjMatrix), c[2] / c[3];
          }
          getProjectionData(e) {
            const { overscaledTileID: r, aligned: o, applyTerrainMatrix: c } = e, h = this._helper.getMercatorTileCoordinates(r), z = r ? this.calculatePosMatrix(r, o, !0) : null;
            let d;
            return d = r && r.terrainRttPosMatrix32f && c ? r.terrainRttPosMatrix32f : z || u.bh(), { mainMatrix: d, tileMercatorCoords: h, clippingPlane: [0, 0, 0, 0], projectionTransition: 0, fallbackMatrix: d };
          }
          isLocationOccluded(e) {
            return !1;
          }
          getPixelScale() {
            return 1;
          }
          getCircleRadiusCorrection() {
            return 1;
          }
          getPitchedTextCorrection(e, r, o) {
            return 1;
          }
          transformLightDirection(e) {
            return u.b0(e);
          }
          getRayDirectionFromPixel(e) {
            throw new Error("Not implemented.");
          }
          projectTileCoordinates(e, r, o, c) {
            const h = this.calculatePosMatrix(o);
            let z;
            c ? (z = [e, r, c(e, r), 1], u.aG(z, z, h)) : (z = [e, r, 0, 1], _n(z, z, h));
            const d = z[3];
            return { point: new u.P(z[0] / d, z[1] / d), signedDistanceFromCamera: d, isOccluded: !1 };
          }
          populateCache(e) {
            for (const r of e) this.calculatePosMatrix(r);
          }
          getMatrixForModel(e, r) {
            const o = u.aa.fromLngLat(e, r), c = o.meterInMercatorCoordinateUnits(), h = u.bi();
            return u.O(h, h, [o.x, o.y, o.z]), u.bf(h, h, Math.PI), u.bg(h, h, Math.PI / 2), u.Q(h, h, [-c, c, c]), h;
          }
          getProjectionDataForCustomLayer(e = !0) {
            const r = new u.a1(0, 0, 0, 0, 0), o = this.getProjectionData({ overscaledTileID: r, applyGlobeMatrix: e }), c = X(r, this.worldSize);
            u.S(c, this._viewProjMatrix, c), o.tileMercatorCoords = [0, 0, 1, 1];
            const h = [u.a4, u.a4, this.worldSize / this._helper.pixelsPerMeter], z = u.bj();
            return u.Q(z, c, h), o.fallbackMatrix = z, o.mainMatrix = z, o;
          }
          getFastPathSimpleProjectionMatrix(e) {
            return this.calculatePosMatrix(e);
          }
        }
        function Hr() {
          u.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
        }
        function Gi(g) {
          if (g.useSlerp) if (g.k < 1) {
            const e = u.bk(g.startEulerAngles.roll, g.startEulerAngles.pitch, g.startEulerAngles.bearing), r = u.bk(g.endEulerAngles.roll, g.endEulerAngles.pitch, g.endEulerAngles.bearing), o = new Float64Array(4);
            u.bl(o, e, r, g.k);
            const c = u.bm(o);
            g.tr.setRoll(c.roll), g.tr.setPitch(c.pitch), g.tr.setBearing(c.bearing);
          } else g.tr.setRoll(g.endEulerAngles.roll), g.tr.setPitch(g.endEulerAngles.pitch), g.tr.setBearing(g.endEulerAngles.bearing);
          else g.tr.setRoll(u.G.number(g.startEulerAngles.roll, g.endEulerAngles.roll, g.k)), g.tr.setPitch(u.G.number(g.startEulerAngles.pitch, g.endEulerAngles.pitch, g.k)), g.tr.setBearing(u.G.number(g.startEulerAngles.bearing, g.endEulerAngles.bearing, g.k));
        }
        function Ln(g, e, r, o, c) {
          const h = c.padding, z = V(c.worldSize, r.getNorthWest()), d = V(c.worldSize, r.getNorthEast()), I = V(c.worldSize, r.getSouthEast()), p = V(c.worldSize, r.getSouthWest()), f = u.ap(-o), _ = z.rotate(f), j = d.rotate(f), C = I.rotate(f), v = p.rotate(f), F = new u.P(Math.max(_.x, j.x, v.x, C.x), Math.max(_.y, j.y, v.y, C.y)), Y = new u.P(Math.min(_.x, j.x, v.x, C.x), Math.min(_.y, j.y, v.y, C.y)), W = F.sub(Y), Z = (c.width - (h.left + h.right + e.left + e.right)) / W.x, J = (c.height - (h.top + h.bottom + e.top + e.bottom)) / W.y;
          if (J < 0 || Z < 0) return void Hr();
          const R = Math.min(u.at(c.scale * Math.min(Z, J)), g.maxZoom), q = u.P.convert(g.offset), $ = new u.P((e.left - e.right) / 2, (e.top - e.bottom) / 2).rotate(u.ap(o)), G = q.add($).mult(c.scale / u.aq(R));
          return { center: H(c.worldSize, z.add(I).div(2).sub(G)), zoom: R, bearing: o };
        }
        class As {
          get useGlobeControls() {
            return !1;
          }
          handlePanInertia(e, r) {
            const o = e.mag(), c = Math.abs(rt(r));
            return { easingOffset: e.mult(Math.min(0.75 * c / o, 1)), easingCenter: r.center };
          }
          handleMapControlsRollPitchBearingZoom(e, r) {
            e.bearingDelta && r.setBearing(r.bearing + e.bearingDelta), e.pitchDelta && r.setPitch(r.pitch + e.pitchDelta), e.rollDelta && r.setRoll(r.roll + e.rollDelta), e.zoomDelta && r.setZoom(r.zoom + e.zoomDelta);
          }
          handleMapControlsPan(e, r, o) {
            e.around.distSqr(r.centerPoint) < 0.01 || r.setLocationAtPoint(o, e.around);
          }
          cameraForBoxAndBearing(e, r, o, c, h) {
            return Ln(e, r, o, c, h);
          }
          handleJumpToCenterZoom(e, r) {
            e.zoom !== (r.zoom !== void 0 ? +r.zoom : e.zoom) && e.setZoom(+r.zoom), r.center !== void 0 && e.setCenter(u.V.convert(r.center));
          }
          handleEaseTo(e, r) {
            const o = e.zoom, c = e.padding, h = { roll: e.roll, pitch: e.pitch, bearing: e.bearing }, z = { roll: r.roll === void 0 ? e.roll : r.roll, pitch: r.pitch === void 0 ? e.pitch : r.pitch, bearing: r.bearing === void 0 ? e.bearing : r.bearing }, d = r.zoom !== void 0, I = !e.isPaddingEqual(r.padding);
            let p = !1;
            const f = d ? +r.zoom : e.zoom;
            let _ = e.centerPoint.add(r.offsetAsPoint);
            const j = e.screenPointToLocation(_), { center: C, zoom: v } = e.applyConstrain(u.V.convert(r.center || j), f ?? o);
            pa(e, C);
            const F = V(e.worldSize, j), Y = V(e.worldSize, C).sub(F), W = u.aq(v - o);
            return p = v !== o, { easeFunc: (Z) => {
              if (p && e.setZoom(u.G.number(o, v, Z)), u.bn(h, z) || Gi({ startEulerAngles: h, endEulerAngles: z, tr: e, k: Z, useSlerp: h.roll != z.roll }), I && (e.interpolatePadding(c, r.padding, Z), _ = e.centerPoint.add(r.offsetAsPoint)), r.around) e.setLocationAtPoint(r.around, r.aroundPoint);
              else {
                const J = u.aq(e.zoom - o), R = v > o ? Math.min(2, W) : Math.max(0.5, W), q = Math.pow(R, 1 - Z), $ = H(e.worldSize, F.add(Y.mult(Z * q)).mult(J));
                e.setLocationAtPoint(e.renderWorldCopies ? $.wrap() : $, _);
              }
            }, isZooming: p, elevationCenter: C };
          }
          handleFlyTo(e, r) {
            const o = r.zoom !== void 0, c = e.zoom, h = e.applyConstrain(u.V.convert(r.center || r.locationAtOffset), o ? +r.zoom : c), z = h.center, d = h.zoom;
            pa(e, z);
            const I = V(e.worldSize, r.locationAtOffset), p = V(e.worldSize, z).sub(I), f = p.mag(), _ = u.aq(d - c);
            let j;
            if (r.minZoom !== void 0) {
              const C = Math.min(+r.minZoom, c, d), v = e.applyConstrain(z, C).zoom;
              j = u.aq(v - c);
            }
            return { easeFunc: (C, v, F, Y) => {
              e.setZoom(C === 1 ? d : c + u.at(v));
              const W = C === 1 ? z : H(e.worldSize, I.add(p.mult(F)).mult(v));
              e.setLocationAtPoint(e.renderWorldCopies ? W.wrap() : W, Y);
            }, scaleOfZoom: _, targetCenter: z, scaleOfMinZoom: j, pixelPathLength: f };
          }
        }
        class Ne {
          constructor(e, r, o) {
            this.blendFunction = e, this.blendColor = r, this.mask = o;
          }
        }
        Ne.Replace = [1, 0], Ne.disabled = new Ne(Ne.Replace, u.bo.transparent, [!1, !1, !1, !1]), Ne.unblended = new Ne(Ne.Replace, u.bo.transparent, [!0, !0, !0, !0]), Ne.alphaBlended = new Ne([1, 771], u.bo.transparent, [!0, !0, !0, !0]);
        const gi = 2305;
        class Kt {
          constructor(e, r, o) {
            this.enable = e, this.mode = r, this.frontFace = o;
          }
        }
        Kt.disabled = new Kt(!1, 1029, gi), Kt.backCCW = new Kt(!0, 1029, gi), Kt.frontCCW = new Kt(!0, 1028, gi);
        class Pt {
          constructor(e, r, o) {
            this.func = e, this.mask = r, this.range = o;
          }
        }
        Pt.ReadOnly = !1, Pt.ReadWrite = !0, Pt.disabled = new Pt(519, Pt.ReadOnly, [0, 1]);
        const Jr = 7680;
        class qt {
          constructor(e, r, o, c, h, z) {
            this.test = e, this.ref = r, this.mask = o, this.fail = c, this.depthFail = h, this.pass = z;
          }
        }
        qt.disabled = new qt({ func: 519, mask: 0 }, 0, 0, Jr, Jr, Jr);
        const qr = /* @__PURE__ */ new WeakMap();
        function qs(g) {
          var e;
          if (qr.has(g)) return qr.get(g);
          {
            const r = (e = g.getParameter(g.VERSION)) === null || e === void 0 ? void 0 : e.startsWith("WebGL 2.0");
            return qr.set(g, r), r;
          }
        }
        class Cn {
          get awaitingQuery() {
            return !!this._readbackQueue;
          }
          constructor(e) {
            this._readbackWaitFrames = 4, this._measureWaitFrames = 6, this._texWidth = 1, this._texHeight = 1, this._measuredError = 0, this._updateCount = 0, this._lastReadbackFrame = -1e3, this._readbackQueue = null, this._cachedRenderContext = e;
            const r = e.context, o = r.gl;
            this._texFormat = o.RGBA, this._texType = o.UNSIGNED_BYTE;
            const c = new u.aV();
            c.emplaceBack(-1, -1), c.emplaceBack(2, -1), c.emplaceBack(-1, 2);
            const h = new u.aX();
            h.emplaceBack(0, 1, 2), this._fullscreenTriangle = new Zi(r.createVertexBuffer(c, Fe.members), r.createIndexBuffer(h), u.aW.simpleSegment(0, 0, c.length, h.length)), this._resultBuffer = new Uint8Array(4), r.activeTexture.set(o.TEXTURE1);
            const z = o.createTexture();
            o.bindTexture(o.TEXTURE_2D, z), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_WRAP_S, o.CLAMP_TO_EDGE), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_WRAP_T, o.CLAMP_TO_EDGE), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MIN_FILTER, o.NEAREST), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MAG_FILTER, o.NEAREST), o.texImage2D(o.TEXTURE_2D, 0, this._texFormat, this._texWidth, this._texHeight, 0, this._texFormat, this._texType, null), this._fbo = r.createFramebuffer(this._texWidth, this._texHeight, !1, !1), this._fbo.colorAttachment.set(z), qs(o) && (this._pbo = o.createBuffer(), o.bindBuffer(o.PIXEL_PACK_BUFFER, this._pbo), o.bufferData(o.PIXEL_PACK_BUFFER, 4, o.STREAM_READ), o.bindBuffer(o.PIXEL_PACK_BUFFER, null));
          }
          destroy() {
            const e = this._cachedRenderContext.context.gl;
            this._fullscreenTriangle.destroy(), this._fbo.destroy(), e.deleteBuffer(this._pbo), this._fullscreenTriangle = null, this._fbo = null, this._pbo = null, this._resultBuffer = null;
          }
          updateErrorLoop(e, r) {
            const o = this._updateCount;
            return this._readbackQueue ? o >= this._readbackQueue.frameNumberIssued + this._readbackWaitFrames && this._tryReadback() : o >= this._lastReadbackFrame + this._measureWaitFrames && this._renderErrorTexture(e, r), this._updateCount++, this._measuredError;
          }
          _bindFramebuffer() {
            const e = this._cachedRenderContext.context, r = e.gl;
            e.activeTexture.set(r.TEXTURE1), r.bindTexture(r.TEXTURE_2D, this._fbo.colorAttachment.get()), e.bindFramebuffer.set(this._fbo.framebuffer);
          }
          _renderErrorTexture(e, r) {
            const o = this._cachedRenderContext.context, c = o.gl;
            if (this._bindFramebuffer(), o.viewport.set([0, 0, this._texWidth, this._texHeight]), o.clear({ color: u.bo.transparent }), this._cachedRenderContext.useProgram("projectionErrorMeasurement").draw(o, c.TRIANGLES, Pt.disabled, qt.disabled, Ne.unblended, Kt.disabled, /* @__PURE__ */ ((h, z) => ({ u_input: h, u_output_expected: z }))(e, r), null, null, "$clipping", this._fullscreenTriangle.vertexBuffer, this._fullscreenTriangle.indexBuffer, this._fullscreenTriangle.segments), this._pbo && qs(c)) {
              c.bindBuffer(c.PIXEL_PACK_BUFFER, this._pbo), c.readBuffer(c.COLOR_ATTACHMENT0), c.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, 0), c.bindBuffer(c.PIXEL_PACK_BUFFER, null);
              const h = c.fenceSync(c.SYNC_GPU_COMMANDS_COMPLETE, 0);
              c.flush(), this._readbackQueue = { frameNumberIssued: this._updateCount, sync: h };
            } else this._readbackQueue = { frameNumberIssued: this._updateCount, sync: null };
          }
          _tryReadback() {
            const e = this._cachedRenderContext.context.gl;
            if (this._pbo && this._readbackQueue && qs(e)) {
              const r = e.clientWaitSync(this._readbackQueue.sync, 0, 0);
              if (r === e.WAIT_FAILED) return u.w("WebGL2 clientWaitSync failed."), this._readbackQueue = null, void (this._lastReadbackFrame = this._updateCount);
              if (r === e.TIMEOUT_EXPIRED) return;
              e.bindBuffer(e.PIXEL_PACK_BUFFER, this._pbo), e.getBufferSubData(e.PIXEL_PACK_BUFFER, 0, this._resultBuffer, 0, 4), e.bindBuffer(e.PIXEL_PACK_BUFFER, null);
            } else this._bindFramebuffer(), e.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, this._resultBuffer);
            this._readbackQueue = null, this._measuredError = Cn._parseRGBA8float(this._resultBuffer), this._lastReadbackFrame = this._updateCount;
          }
          static _parseRGBA8float(e) {
            let r = 0;
            return r += e[0] / 256, r += e[1] / 65536, r += e[2] / 16777216, e[3] < 127 && (r = -r), r / 128;
          }
        }
        const zr = u.a4 / 128;
        function Ta(g, e) {
          const r = g.granularity !== void 0 ? Math.max(g.granularity, 1) : 1, o = r + (g.generateBorders ? 2 : 0), c = r + (g.extendToNorthPole || g.generateBorders ? 1 : 0) + (g.extendToSouthPole || g.generateBorders ? 1 : 0), h = o + 1, z = c + 1, d = g.generateBorders ? -1 : 0, I = g.generateBorders || g.extendToNorthPole ? -1 : 0, p = r + (g.generateBorders ? 1 : 0), f = r + (g.generateBorders || g.extendToSouthPole ? 1 : 0), _ = h * z, j = o * c * 6, C = h * z > 65536;
          if (C && e === "16bit") throw new Error("Granularity is too large and meshes would not fit inside 16 bit vertex indices.");
          const v = C || e === "32bit", F = new Int16Array(2 * _);
          let Y = 0;
          for (let J = I; J <= f; J++) for (let R = d; R <= p; R++) {
            let q = R / r * u.a4;
            R === -1 && (q = -zr), R === r + 1 && (q = u.a4 + zr);
            let $ = J / r * u.a4;
            J === -1 && ($ = g.extendToNorthPole ? u.bq : -zr), J === r + 1 && ($ = g.extendToSouthPole ? u.br : u.a4 + zr), F[Y++] = q, F[Y++] = $;
          }
          const W = v ? new Uint32Array(j) : new Uint16Array(j);
          let Z = 0;
          for (let J = 0; J < c; J++) for (let R = 0; R < o; R++) {
            const q = R + 1 + J * h, $ = R + (J + 1) * h, G = R + 1 + (J + 1) * h;
            W[Z++] = R + J * h, W[Z++] = $, W[Z++] = q, W[Z++] = q, W[Z++] = $, W[Z++] = G;
          }
          return { vertices: F.buffer.slice(0), indices: W.buffer.slice(0), uses32bitIndices: v };
        }
        const On = new u.aU({ fill: new u.bs(128, 2), line: new u.bs(512, 0), tile: new u.bs(128, 32), stencil: new u.bs(128, 1), circle: 3 });
        class En {
          constructor() {
            this._tileMeshCache = {}, this._errorCorrectionUsable = 0, this._errorMeasurementLastValue = 0, this._errorCorrectionPreviousValue = 0, this._errorMeasurementLastChangeTime = -1e3;
          }
          get name() {
            return "vertical-perspective";
          }
          get transitionState() {
            return 1;
          }
          get useSubdivision() {
            return !0;
          }
          get shaderVariantName() {
            return "globe";
          }
          get shaderDefine() {
            return "#define GLOBE";
          }
          get shaderPreludeCode() {
            return Fs.projectionGlobe;
          }
          get vertexShaderPreludeCode() {
            return Fs.projectionMercator.vertexSource;
          }
          get subdivisionGranularity() {
            return On;
          }
          get useGlobeControls() {
            return !0;
          }
          get latitudeErrorCorrectionRadians() {
            return this._errorCorrectionUsable;
          }
          destroy() {
            this._errorMeasurement && this._errorMeasurement.destroy();
          }
          updateGPUdependent(e) {
            this._errorMeasurement || (this._errorMeasurement = new Cn(e));
            const r = u.X(this._errorQueryLatitudeDegrees), o = 2 * Math.atan(Math.exp(Math.PI - r * Math.PI * 2)) - 0.5 * Math.PI, c = this._errorMeasurement.updateErrorLoop(r, o), h = $t();
            c !== this._errorMeasurementLastValue && (this._errorCorrectionPreviousValue = this._errorCorrectionUsable, this._errorMeasurementLastValue = c, this._errorMeasurementLastChangeTime = h);
            const z = Math.min(Math.max((h - this._errorMeasurementLastChangeTime) / 1e3 / 0.5, 0), 1);
            this._errorCorrectionUsable = u.bt(this._errorCorrectionPreviousValue, -this._errorMeasurementLastValue, u.bu(z));
          }
          _getMeshKey(e) {
            return `${e.granularity.toString(36)}_${e.generateBorders ? "b" : ""}${e.extendToNorthPole ? "n" : ""}${e.extendToSouthPole ? "s" : ""}`;
          }
          getMeshFromTileID(e, r, o, c, h) {
            const z = (h === "stencil" ? On.stencil : On.tile).getGranularityForZoomLevel(r.z);
            return this._getMesh(e, { granularity: z, generateBorders: o, extendToNorthPole: r.y === 0 && c, extendToSouthPole: r.y === (1 << r.z) - 1 && c });
          }
          _getMesh(e, r) {
            const o = this._getMeshKey(r);
            if (o in this._tileMeshCache) return this._tileMeshCache[o];
            const c = (function(h, z) {
              const d = Ta(z, "16bit"), I = u.aV.deserialize({ arrayBuffer: d.vertices, length: d.vertices.byteLength / 2 / 2 }), p = u.aX.deserialize({ arrayBuffer: d.indices, length: d.indices.byteLength / 2 / 3 });
              return new Zi(h.createVertexBuffer(I, Fe.members), h.createIndexBuffer(p), u.aW.simpleSegment(0, 0, I.length, p.length));
            })(e, r);
            return this._tileMeshCache[o] = c, c;
          }
          recalculate(e) {
          }
          hasTransition() {
            const e = $t();
            let r = !1;
            return r = r || (e - this._errorMeasurementLastChangeTime) / 1e3 < 0.7, r = r || this._errorMeasurement && this._errorMeasurement.awaitingQuery, r;
          }
          setErrorQueryLatitudeDegrees(e) {
            this._errorQueryLatitudeDegrees = e;
          }
        }
        const fa = new u.t({ type: new u.D(u.u.projection.type) });
        class $r extends u.E {
          constructor(e) {
            super(), this._transitionable = new u.x(fa, void 0), this.setProjection(e), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new u.H(0)), this._mercatorProjection = new Re(), this._verticalPerspectiveProjection = new En();
          }
          get transitionState() {
            const e = this.properties.get("type");
            if (typeof e == "string" && e === "mercator") return 0;
            if (typeof e == "string" && e === "vertical-perspective") return 1;
            if (e instanceof u.bv) {
              if (e.from === "vertical-perspective" && e.to === "mercator") return 1 - e.transition;
              if (e.from === "mercator" && e.to === "vertical-perspective") return e.transition;
            }
            return 1;
          }
          get useGlobeRendering() {
            return this.transitionState > 0;
          }
          get latitudeErrorCorrectionRadians() {
            return this._verticalPerspectiveProjection.latitudeErrorCorrectionRadians;
          }
          get currentProjection() {
            return this.useGlobeRendering ? this._verticalPerspectiveProjection : this._mercatorProjection;
          }
          get name() {
            return "globe";
          }
          get useSubdivision() {
            return this.currentProjection.useSubdivision;
          }
          get shaderVariantName() {
            return this.currentProjection.shaderVariantName;
          }
          get shaderDefine() {
            return this.currentProjection.shaderDefine;
          }
          get shaderPreludeCode() {
            return this.currentProjection.shaderPreludeCode;
          }
          get vertexShaderPreludeCode() {
            return this.currentProjection.vertexShaderPreludeCode;
          }
          get subdivisionGranularity() {
            return this.currentProjection.subdivisionGranularity;
          }
          get useGlobeControls() {
            return this.transitionState > 0;
          }
          destroy() {
            this._mercatorProjection.destroy(), this._verticalPerspectiveProjection.destroy();
          }
          updateGPUdependent(e) {
            this._mercatorProjection.updateGPUdependent(e), this._verticalPerspectiveProjection.updateGPUdependent(e);
          }
          getMeshFromTileID(e, r, o, c, h) {
            return this.currentProjection.getMeshFromTileID(e, r, o, c, h);
          }
          setProjection(e) {
            this._transitionable.setValue("type", e?.type || "mercator");
          }
          updateTransitions(e) {
            this._transitioning = this._transitionable.transitioned(e, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition() || this.currentProjection.hasTransition();
          }
          recalculate(e) {
            this.properties = this._transitioning.possiblyEvaluate(e);
          }
          setErrorQueryLatitudeDegrees(e) {
            this._verticalPerspectiveProjection.setErrorQueryLatitudeDegrees(e), this._mercatorProjection.setErrorQueryLatitudeDegrees(e);
          }
        }
        function KM(g) {
          const e = xa(g.worldSize, g.center.lat);
          return 2 * Math.PI * e;
        }
        function hi(g, e, r, o, c) {
          const h = 1 / (1 << c), z = e / u.a4 * h + o * h, d = u.bx((g / u.a4 * h + r * h) * Math.PI * 2 + Math.PI, 2 * Math.PI), I = 2 * Math.atan(Math.exp(Math.PI - z * Math.PI * 2)) - 0.5 * Math.PI, p = Math.cos(I), f = new Float64Array(3);
          return f[0] = Math.sin(d) * p, f[1] = Math.sin(I), f[2] = Math.cos(d) * p, f;
        }
        function ts(g) {
          return (function(e, r) {
            const o = Math.cos(r), c = new Float64Array(3);
            return c[0] = Math.sin(e) * o, c[1] = Math.sin(r), c[2] = Math.cos(e) * o, c;
          })(g.lng * Math.PI / 180, g.lat * Math.PI / 180);
        }
        function xa(g, e) {
          return g / (2 * Math.PI) / Math.cos(e * Math.PI / 180);
        }
        function tc(g) {
          const e = Math.asin(g[1]) / Math.PI * 180, r = Math.sqrt(g[0] * g[0] + g[2] * g[2]);
          if (r > 1e-6) {
            const o = g[0] / r, c = Math.acos(g[2] / r), h = (o > 0 ? c : -c) / Math.PI * 180;
            return new u.V(u.W(h, -180, 180), e);
          }
          return new u.V(0, e);
        }
        function es(g) {
          return Math.cos(g * Math.PI / 180);
        }
        function Ye(g, e) {
          const r = es(g), o = es(e);
          return u.at(o / r);
        }
        function $s(g, e) {
          const r = g.rotate(e.bearingInRadians), o = e.zoom + Ye(e.center.lat, 0), c = u.bt(1 / es(e.center.lat), 1 / es(Math.min(Math.abs(e.center.lat), 60)), u.bw(o, 7, 3, 0, 1)), h = 360 / KM({ worldSize: e.worldSize, center: { lat: e.center.lat } });
          return new u.V(e.center.lng - r.x * h * c, u.an(e.center.lat + r.y * h, -u.ao, u.ao));
        }
        function Kr(g) {
          const e = 0.5 * g, r = Math.sin(e), o = Math.cos(e);
          return Math.log(r + o) - Math.log(o - r);
        }
        function Lo(g, e, r, o) {
          const c = g.lat + r * o;
          if (Math.abs(r) > 1) {
            const h = (Math.sign(g.lat + r) !== Math.sign(g.lat) ? -Math.abs(g.lat) : Math.abs(g.lat)) * Math.PI / 180, z = Math.abs(g.lat + r) * Math.PI / 180, d = Kr(h + o * (z - h)), I = Kr(h), p = Kr(z);
            return new u.V(g.lng + e * ((d - I) / (p - I)), c);
          }
          return new u.V(g.lng + e * o, c);
        }
        class ec {
          constructor(e) {
            this._cachePrevious = /* @__PURE__ */ new Map(), this._cache = /* @__PURE__ */ new Map(), this._hadAnyChanges = !1, this._boundingVolumeFactory = e;
          }
          swapBuffers() {
            if (!this._hadAnyChanges) return;
            const e = this._cachePrevious;
            this._cachePrevious = this._cache, this._cache = e, this._cache.clear(), this._hadAnyChanges = !1;
          }
          getTileBoundingVolume(e, r, o, c) {
            const h = `${e.z}_${e.x}_${e.y}_${c?.terrain ? "t" : ""}`, z = this._cache.get(h);
            if (z) return z;
            const d = this._cachePrevious.get(h);
            if (d) return this._cache.set(h, d), d;
            const I = this._boundingVolumeFactory(e, r, o, c);
            return this._cache.set(h, I), this._hadAnyChanges = !0, I;
          }
        }
        class Ks {
          constructor(e, r, o, c) {
            this.min = o, this.max = c, this.points = e, this.planes = r;
          }
          static fromAabb(e, r) {
            const o = [];
            for (let c = 0; c < 8; c++) o.push([1 & ~c ? e[0] : r[0], (c >> 1 & 1) == 1 ? r[1] : e[1], (c >> 2 & 1) == 1 ? r[2] : e[2]]);
            return new Ks(o, [[-1, 0, 0, r[0]], [1, 0, 0, -e[0]], [0, -1, 0, r[1]], [0, 1, 0, -e[1]], [0, 0, -1, r[2]], [0, 0, 1, -e[2]]], e, r);
          }
          static fromCenterSizeAngles(e, r, o) {
            const c = u.bA([], o[0], o[1], o[2]), h = u.bB([], [r[0], 0, 0], c), z = u.bB([], [0, r[1], 0], c), d = u.bB([], [0, 0, r[2]], c), I = [...e], p = [...e];
            for (let _ = 0; _ < 8; _++) for (let j = 0; j < 3; j++) {
              const C = e[j] + h[j] * (1 & ~_ ? -1 : 1) + z[j] * ((_ >> 1 & 1) == 1 ? 1 : -1) + d[j] * ((_ >> 2 & 1) == 1 ? 1 : -1);
              I[j] = Math.min(I[j], C), p[j] = Math.max(p[j], C);
            }
            const f = [];
            for (let _ = 0; _ < 8; _++) {
              const j = [...e];
              u.a$(j, j, u.a_([], h, 1 & ~_ ? -1 : 1)), u.a$(j, j, u.a_([], z, (_ >> 1 & 1) == 1 ? 1 : -1)), u.a$(j, j, u.a_([], d, (_ >> 2 & 1) == 1 ? 1 : -1)), f.push(j);
            }
            return new Ks(f, [[...h, -u.b4(h, f[0])], [...z, -u.b4(z, f[0])], [...d, -u.b4(d, f[0])], [-h[0], -h[1], -h[2], -u.b4(h, f[7])], [-z[0], -z[1], -z[2], -u.b4(z, f[7])], [-d[0], -d[1], -d[2], -u.b4(d, f[7])]], I, p);
          }
          intersectsFrustum(e) {
            let r = !0;
            const o = this.points.length, c = this.planes.length, h = e.planes.length, z = e.points.length;
            for (let d = 0; d < h; d++) {
              const I = e.planes[d];
              let p = 0;
              for (let f = 0; f < o; f++) {
                const _ = this.points[f];
                I[0] * _[0] + I[1] * _[1] + I[2] * _[2] + I[3] >= 0 && p++;
              }
              if (p === 0) return 0;
              p < o && (r = !1);
            }
            if (r) return 2;
            for (let d = 0; d < c; d++) {
              const I = this.planes[d];
              let p = 0;
              for (let f = 0; f < z; f++) {
                const _ = e.points[f];
                I[0] * _[0] + I[1] * _[1] + I[2] * _[2] + I[3] >= 0 && p++;
              }
              if (p === 0) return 0;
            }
            return 1;
          }
          intersectsPlane(e) {
            const r = this.points.length;
            let o = 0;
            for (let c = 0; c < r; c++) {
              const h = this.points[c];
              e[0] * h[0] + e[1] * h[1] + e[2] * h[2] + e[3] >= 0 && o++;
            }
            return o === r ? 2 : o === 0 ? 0 : 1;
          }
        }
        function Aa(g, e, r) {
          const o = g - e;
          return o < 0 ? -o : Math.max(0, o - r);
        }
        function Co(g, e, r, o, c) {
          const h = g - r;
          let z;
          return z = h < 0 ? Math.min(-h, 1 + h - c) : h > 1 ? Math.min(Math.max(h - c, 0), 1 - h) : 0, Math.max(z, Aa(e, o, c));
        }
        class ml {
          constructor() {
            this._boundingVolumeCache = new ec(this._computeTileBoundingVolume);
          }
          prepareNextFrame() {
            this._boundingVolumeCache.swapBuffers();
          }
          distanceToTile2d(e, r, o, c) {
            const h = 1 << o.z, z = 1 / h, d = o.x / h, I = o.y / h;
            let p = 2;
            return p = Math.min(p, Co(e, r, d, I, z)), p = Math.min(p, Co(e, r, d + 0.5, -I - z, z)), p = Math.min(p, Co(e, r, d + 0.5, 2 - I - z, z)), p;
          }
          getWrap(e, r, o) {
            const c = 1 << r.z, h = 1 / c, z = r.x / c, d = Aa(e.x, z, h), I = Aa(e.x, z - 1, h), p = Aa(e.x, z + 1, h), f = Math.min(d, I, p);
            return f === p ? 1 : f === I ? -1 : 0;
          }
          allowVariableZoom(e, r) {
            return vt(e, r) > 4;
          }
          allowWorldCopies() {
            return !1;
          }
          getTileBoundingVolume(e, r, o, c) {
            return this._boundingVolumeCache.getTileBoundingVolume(e, r, o, c);
          }
          _computeTileBoundingVolume(e, r, o, c) {
            var h, z;
            let d = 0, I = 0;
            if (c?.terrain) {
              const p = new u.a1(e.z, r, e.z, e.x, e.y), f = c.terrain.getMinMaxElevation(p);
              d = (h = f.minElevation) !== null && h !== void 0 ? h : Math.min(0, o), I = (z = f.maxElevation) !== null && z !== void 0 ? z : Math.max(0, o);
            }
            if (d /= u.bD, I /= u.bD, d += 1, I += 1, e.z <= 0) return Ks.fromAabb([-I, -I, -I], [I, I, I]);
            if (e.z === 1) return Ks.fromAabb([e.x === 0 ? -I : 0, e.y === 0 ? 0 : -I, -I], [e.x === 0 ? 0 : I, e.y === 0 ? I : 0, I]);
            {
              const p = [hi(0, 0, e.x, e.y, e.z), hi(u.a4, 0, e.x, e.y, e.z), hi(u.a4, u.a4, e.x, e.y, e.z), hi(0, u.a4, e.x, e.y, e.z)], f = [];
              for (const at of p) f.push(u.a_([], at, I));
              if (I !== d) for (const at of p) f.push(u.a_([], at, d));
              e.y === 0 && f.push([0, 1, 0]), e.y === (1 << e.z) - 1 && f.push([0, -1, 0]);
              const _ = [1, 1, 1], j = [-1, -1, -1];
              for (const at of f) for (let Mt = 0; Mt < 3; Mt++) _[Mt] = Math.min(_[Mt], at[Mt]), j[Mt] = Math.max(j[Mt], at[Mt]);
              const C = hi(u.a4 / 2, u.a4 / 2, e.x, e.y, e.z), v = u.b3([], [0, 1, 0], C);
              u.b2(v, v);
              const F = u.b3([], C, v);
              u.b2(F, F);
              const Y = u.b3([], p[2], p[1]);
              u.b2(Y, Y);
              const W = u.b3([], p[0], p[3]);
              u.b2(W, W), f.push(u.a_([], C, I)), e.y >= (1 << e.z) / 2 && f.push(u.a_([], hi(u.a4 / 2, 0, e.x, e.y, e.z), I)), e.y < (1 << e.z) / 2 && f.push(u.a_([], hi(u.a4 / 2, u.a4, e.x, e.y, e.z), I));
              const Z = sc(C, f), J = sc(F, f), R = [-C[0], -C[1], -C[2], Z.max], q = [C[0], C[1], C[2], -Z.min], $ = [-F[0], -F[1], -F[2], J.max], G = [F[0], F[1], F[2], -J.min], st = [...Y, 0], ct = [...W, 0], nt = [];
              return e.y === 0 ? nt.push(u.bC(ct, st, R), u.bC(ct, st, q)) : nt.push(u.bC($, st, R), u.bC($, st, q), u.bC($, ct, R), u.bC($, ct, q)), e.y === (1 << e.z) - 1 ? nt.push(u.bC(ct, st, R), u.bC(ct, st, q)) : nt.push(u.bC(G, st, R), u.bC(G, st, q), u.bC(G, ct, R), u.bC(G, ct, q)), new Ks(nt, [R, q, $, G, st, ct], _, j);
            }
          }
        }
        function sc(g, e) {
          let r = 1 / 0, o = -1 / 0;
          for (const c of e) {
            const h = u.b4(g, c);
            r = Math.min(r, h), o = Math.max(o, h);
          }
          return { min: r, max: o };
        }
        class ma {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix;
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits;
          }
          get centerOffset() {
            return this._helper.centerOffset;
          }
          get size() {
            return this._helper.size;
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix;
          }
          get centerPoint() {
            return this._helper.centerPoint;
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter;
          }
          setMinZoom(e) {
            this._helper.setMinZoom(e);
          }
          setMaxZoom(e) {
            this._helper.setMaxZoom(e);
          }
          setMinPitch(e) {
            this._helper.setMinPitch(e);
          }
          setMaxPitch(e) {
            this._helper.setMaxPitch(e);
          }
          setRenderWorldCopies(e) {
            this._helper.setRenderWorldCopies(e);
          }
          setBearing(e) {
            this._helper.setBearing(e);
          }
          setPitch(e) {
            this._helper.setPitch(e);
          }
          setRoll(e) {
            this._helper.setRoll(e);
          }
          setFov(e) {
            this._helper.setFov(e);
          }
          setZoom(e) {
            this._helper.setZoom(e);
          }
          setCenter(e) {
            this._helper.setCenter(e);
          }
          setElevation(e) {
            this._helper.setElevation(e);
          }
          setMinElevationForCurrentTile(e) {
            this._helper.setMinElevationForCurrentTile(e);
          }
          setPadding(e) {
            this._helper.setPadding(e);
          }
          interpolatePadding(e, r, o) {
            return this._helper.interpolatePadding(e, r, o);
          }
          isPaddingEqual(e) {
            return this._helper.isPaddingEqual(e);
          }
          resize(e, r) {
            this._helper.resize(e, r);
          }
          getMaxBounds() {
            return this._helper.getMaxBounds();
          }
          setMaxBounds(e) {
            this._helper.setMaxBounds(e);
          }
          setConstrainOverride(e) {
            this._helper.setConstrainOverride(e);
          }
          overrideNearFarZ(e, r) {
            this._helper.overrideNearFarZ(e, r);
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride();
          }
          getCameraQueryGeometry(e) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e);
          }
          get tileSize() {
            return this._helper.tileSize;
          }
          get tileZoom() {
            return this._helper.tileZoom;
          }
          get scale() {
            return this._helper.scale;
          }
          get worldSize() {
            return this._helper.worldSize;
          }
          get width() {
            return this._helper.width;
          }
          get height() {
            return this._helper.height;
          }
          get lngRange() {
            return this._helper.lngRange;
          }
          get latRange() {
            return this._helper.latRange;
          }
          get minZoom() {
            return this._helper.minZoom;
          }
          get maxZoom() {
            return this._helper.maxZoom;
          }
          get zoom() {
            return this._helper.zoom;
          }
          get center() {
            return this._helper.center;
          }
          get minPitch() {
            return this._helper.minPitch;
          }
          get maxPitch() {
            return this._helper.maxPitch;
          }
          get pitch() {
            return this._helper.pitch;
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians;
          }
          get roll() {
            return this._helper.roll;
          }
          get rollInRadians() {
            return this._helper.rollInRadians;
          }
          get bearing() {
            return this._helper.bearing;
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians;
          }
          get fov() {
            return this._helper.fov;
          }
          get fovInRadians() {
            return this._helper.fovInRadians;
          }
          get elevation() {
            return this._helper.elevation;
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile;
          }
          get padding() {
            return this._helper.padding;
          }
          get unmodified() {
            return this._helper.unmodified;
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies;
          }
          get constrainOverride() {
            return this._helper.constrainOverride;
          }
          get nearZ() {
            return this._helper.nearZ;
          }
          get farZ() {
            return this._helper.farZ;
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ;
          }
          setTransitionState(e) {
          }
          constructor(e) {
            this._cachedClippingPlane = u.bE(), this._projectionMatrix = u.bi(), this._globeViewProjMatrix32f = u.bh(), this._globeViewProjMatrixNoCorrection = u.bi(), this._globeViewProjMatrixNoCorrectionInverted = u.bi(), this._globeProjMatrixInverted = u.bi(), this._cameraPosition = u.by(), this._globeLatitudeErrorCorrectionRadians = 0, this.defaultConstrain = (r, o) => {
              const c = u.an(r.lat, -u.ao, u.ao), h = u.an(+o, this.minZoom + Ye(0, c), this.maxZoom);
              return { center: new u.V(r.lng, c), zoom: h };
            }, this.applyConstrain = (r, o) => this._helper.applyConstrain(r, o), this._helper = new xs({ calcMatrices: () => {
              this._calcMatrices();
            }, defaultConstrain: (r, o) => this.defaultConstrain(r, o) }, e), this._coveringTilesDetailsProvider = new ml();
          }
          clone() {
            const e = new ma();
            return e.apply(this), e;
          }
          apply(e, r) {
            this._globeLatitudeErrorCorrectionRadians = r || 0, this._helper.apply(e);
          }
          get projectionMatrix() {
            return this._projectionMatrix;
          }
          get modelViewProjectionMatrix() {
            return this._globeViewProjMatrixNoCorrection;
          }
          get inverseProjectionMatrix() {
            return this._globeProjMatrixInverted;
          }
          get cameraPosition() {
            const e = u.by();
            return e[0] = this._cameraPosition[0], e[1] = this._cameraPosition[1], e[2] = this._cameraPosition[2], e;
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance;
          }
          getProjectionData(e) {
            const { overscaledTileID: r, applyGlobeMatrix: o } = e, c = this._helper.getMercatorTileCoordinates(r);
            return { mainMatrix: this._globeViewProjMatrix32f, tileMercatorCoords: c, clippingPlane: this._cachedClippingPlane, projectionTransition: o ? 1 : 0, fallbackMatrix: this._globeViewProjMatrix32f };
          }
          _computeClippingPlane(e) {
            const r = this.pitchInRadians, o = this.cameraToCenterDistance / e, c = Math.sin(r) * o, h = Math.cos(r) * o + 1, z = 1 / Math.sqrt(c * c + h * h) * 1;
            let d = -c, I = h;
            const p = Math.sqrt(d * d + I * I);
            d /= p, I /= p;
            const f = [0, d, I];
            u.bF(f, f, [0, 0, 0], -this.bearingInRadians), u.bG(f, f, [0, 0, 0], -1 * this.center.lat * Math.PI / 180), u.bH(f, f, [0, 0, 0], this.center.lng * Math.PI / 180);
            const _ = 1 / u.b6(f);
            return u.a_(f, f, _), [...f, -z * _];
          }
          isLocationOccluded(e) {
            return !this.isSurfacePointVisible(ts(e));
          }
          transformLightDirection(e) {
            const r = this._helper._center.lng * Math.PI / 180, o = this._helper._center.lat * Math.PI / 180, c = Math.cos(o), h = [Math.sin(r) * c, Math.sin(o), Math.cos(r) * c], z = [h[2], 0, -h[0]], d = [0, 0, 0];
            u.b3(d, z, h), u.b2(z, z), u.b2(d, d);
            const I = [0, 0, 0];
            return u.b2(I, [z[0] * e[0] + d[0] * e[1] + h[0] * e[2], z[1] * e[0] + d[1] * e[1] + h[1] * e[2], z[2] * e[0] + d[2] * e[1] + h[2] * e[2]]), I;
          }
          getPixelScale() {
            return 1 / Math.cos(this._helper._center.lat * Math.PI / 180);
          }
          getCircleRadiusCorrection() {
            return Math.cos(this._helper._center.lat * Math.PI / 180);
          }
          getPitchedTextCorrection(e, r, o) {
            const c = (function(d, I, p) {
              const f = 1 / (1 << p.z);
              return new u.aa(d / u.a4 * f + p.x * f, I / u.a4 * f + p.y * f);
            })(e, r, o.canonical), h = (z = c.y, [u.bx(c.x * Math.PI * 2 + Math.PI, 2 * Math.PI), 2 * Math.atan(Math.exp(Math.PI - z * Math.PI * 2)) - 0.5 * Math.PI]);
            var z;
            return this.getCircleRadiusCorrection() / Math.cos(h[1]);
          }
          projectTileCoordinates(e, r, o, c) {
            const h = o.canonical, z = hi(e, r, h.x, h.y, h.z), d = 1 + (c ? c(e, r) : 0) / u.bD, I = [z[0] * d, z[1] * d, z[2] * d, 1];
            u.aG(I, I, this._globeViewProjMatrixNoCorrection);
            const p = this._cachedClippingPlane, f = p[0] * z[0] + p[1] * z[1] + p[2] * z[2] + p[3] < 0;
            return { point: new u.P(I[0] / I[3], I[1] / I[3]), signedDistanceFromCamera: I[3], isOccluded: f };
          }
          _calcMatrices() {
            if (!this._helper._width || !this._helper._height) return;
            const e = xa(this.worldSize, this.center.lat), r = u.bj(), o = u.bj();
            this._helper.autoCalculateNearFarZ && (this._helper._nearZ = 0.5, this._helper._farZ = this.cameraToCenterDistance + 2 * e), u.bd(r, this.fovInRadians, this.width / this.height, this._helper._nearZ, this._helper._farZ);
            const c = this.centerOffset;
            r[8] = 2 * -c.x / this._helper._width, r[9] = 2 * c.y / this._helper._height, this._projectionMatrix = u.be(r), this._globeProjMatrixInverted = u.bj(), u.aA(this._globeProjMatrixInverted, r), u.O(r, r, [0, 0, -this.cameraToCenterDistance]), u.bf(r, r, this.rollInRadians), u.bg(r, r, -this.pitchInRadians), u.bf(r, r, this.bearingInRadians), u.O(r, r, [0, 0, -e]);
            const h = u.by();
            h[0] = e, h[1] = e, h[2] = e, u.bg(o, r, this.center.lat * Math.PI / 180), u.bI(o, o, -this.center.lng * Math.PI / 180), u.Q(o, o, h), this._globeViewProjMatrixNoCorrection = o, u.bg(r, r, this.center.lat * Math.PI / 180 - this._globeLatitudeErrorCorrectionRadians), u.bI(r, r, -this.center.lng * Math.PI / 180), u.Q(r, r, h), this._globeViewProjMatrix32f = new Float32Array(r), this._globeViewProjMatrixNoCorrectionInverted = u.bj(), u.aA(this._globeViewProjMatrixNoCorrectionInverted, o);
            const z = u.by();
            this._cameraPosition = u.by(), this._cameraPosition[2] = this.cameraToCenterDistance / e, u.bF(this._cameraPosition, this._cameraPosition, z, -this.rollInRadians), u.bG(this._cameraPosition, this._cameraPosition, z, this.pitchInRadians), u.bF(this._cameraPosition, this._cameraPosition, z, -this.bearingInRadians), u.a$(this._cameraPosition, this._cameraPosition, [0, 0, 1]), u.bG(this._cameraPosition, this._cameraPosition, z, -this.center.lat * Math.PI / 180), u.bH(this._cameraPosition, this._cameraPosition, z, this.center.lng * Math.PI / 180), this._cachedClippingPlane = this._computeClippingPlane(e);
            const d = u.be(this._globeViewProjMatrixNoCorrectionInverted);
            u.Q(d, d, [1, 1, -1]), this._cachedFrustum = Vi.fromInvProjectionMatrix(d, 1, 0, this._cachedClippingPlane, !0);
          }
          calculateFogMatrix(e) {
            u.w("calculateFogMatrix is not supported on globe projection.");
            const r = u.bj();
            return u.ar(r), r;
          }
          getVisibleUnwrappedCoordinates(e) {
            return [new u.bb(0, e)];
          }
          getCameraFrustum() {
            return this._cachedFrustum;
          }
          getClippingPlane() {
            return this._cachedClippingPlane;
          }
          getCoveringTilesDetailsProvider() {
            return this._coveringTilesDetailsProvider;
          }
          recalculateZoomAndCenter(e) {
            e && u.w("terrain is not fully supported on vertical perspective projection."), this._helper.recalculateZoomAndCenter(0);
          }
          maxPitchScaleFactor() {
            return 1;
          }
          getCameraPoint() {
            return this._helper.getCameraPoint();
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude();
          }
          getCameraLngLat() {
            return this._helper.getCameraLngLat();
          }
          lngLatToCameraDepth(e, r) {
            if (!this._globeViewProjMatrixNoCorrection) return 1;
            const o = ts(e);
            u.a_(o, o, 1 + r / u.bD);
            const c = u.bE();
            return u.aG(c, [o[0], o[1], o[2], 1], this._globeViewProjMatrixNoCorrection), c[2] / c[3];
          }
          populateCache(e) {
          }
          getBounds() {
            const e = 0.5 * this.width, r = 0.5 * this.height, o = [new u.P(0, 0), new u.P(e, 0), new u.P(this.width, 0), new u.P(this.width, r), new u.P(this.width, this.height), new u.P(e, this.height), new u.P(0, this.height), new u.P(0, r)], c = [];
            for (const _ of o) c.push(this.unprojectScreenPoint(_));
            let h = 0, z = 0, d = 0, I = 0;
            const p = this.center;
            for (const _ of c) {
              const j = u.bJ(p.lng, _.lng), C = u.bJ(p.lat, _.lat);
              j < z && (z = j), j > h && (h = j), C < I && (I = C), C > d && (d = C);
            }
            const f = [p.lng + z, p.lat + I, p.lng + h, p.lat + d];
            return this.isSurfacePointOnScreen([0, 1, 0]) && (f[3] = 90, f[0] = -180, f[2] = 180), this.isSurfacePointOnScreen([0, -1, 0]) && (f[1] = -90, f[0] = -180, f[2] = 180), new pe(f);
          }
          calculateCenterFromCameraLngLatAlt(e, r, o, c) {
            return this._helper.calculateCenterFromCameraLngLatAlt(e, r, o, c);
          }
          setLocationAtPoint(e, r) {
            const o = ts(this.unprojectScreenPoint(r)), c = ts(e), h = u.by();
            u.bK(h);
            const z = u.by();
            u.bH(z, o, h, -this.center.lng * Math.PI / 180), u.bG(z, z, h, this.center.lat * Math.PI / 180);
            const d = c[0] * c[0] + c[2] * c[2], I = z[0] * z[0];
            if (d < I) return;
            const p = Math.sqrt(d - I), f = -p, _ = u.bL(c[0], c[2], z[0], p), j = u.bL(c[0], c[2], z[0], f), C = u.by();
            u.bH(C, c, h, -_);
            const v = u.bL(C[1], C[2], z[1], z[2]), F = u.by();
            u.bH(F, c, h, -j);
            const Y = u.bL(F[1], F[2], z[1], z[2]), W = 0.5 * Math.PI, Z = v >= -W && v <= W, J = Y >= -W && Y <= W;
            let R, q;
            if (Z && J) {
              const ct = this.center.lng * Math.PI / 180, nt = this.center.lat * Math.PI / 180;
              u.bM(_, ct) + u.bM(v, nt) < u.bM(j, ct) + u.bM(Y, nt) ? (R = _, q = v) : (R = j, q = Y);
            } else if (Z) R = _, q = v;
            else {
              if (!J) return;
              R = j, q = Y;
            }
            const $ = R / Math.PI * 180, G = q / Math.PI * 180, st = this.center.lat;
            this.setCenter(new u.V($, u.an(G, -90, 90))), this.setZoom(this.zoom + Ye(st, this.center.lat));
          }
          locationToScreenPoint(e, r) {
            const o = ts(e);
            if (r) {
              const c = r.getElevationForLngLatZoom(e, this._helper._tileZoom);
              u.a_(o, o, 1 + c / u.bD);
            }
            return this._projectSurfacePointToScreen(o);
          }
          _projectSurfacePointToScreen(e) {
            const r = u.bE();
            return u.aG(r, [...e, 1], this._globeViewProjMatrixNoCorrection), r[0] /= r[3], r[1] /= r[3], new u.P((0.5 * r[0] + 0.5) * this.width, (0.5 * -r[1] + 0.5) * this.height);
          }
          screenPointToMercatorCoordinate(e, r) {
            if (r) {
              const o = r.pointCoordinate(e);
              if (o) return o;
            }
            return u.aa.fromLngLat(this.unprojectScreenPoint(e));
          }
          screenPointToLocation(e, r) {
            var o;
            return (o = this.screenPointToMercatorCoordinate(e, r)) === null || o === void 0 ? void 0 : o.toLngLat();
          }
          isPointOnMapSurface(e, r) {
            const o = this._cameraPosition, c = this.getRayDirectionFromPixel(e);
            return !!this.rayPlanetIntersection(o, c);
          }
          getRayDirectionFromPixel(e) {
            const r = u.bE();
            r[0] = e.x / this.width * 2 - 1, r[1] = -1 * (e.y / this.height * 2 - 1), r[2] = 1, r[3] = 1, u.aG(r, r, this._globeViewProjMatrixNoCorrectionInverted), r[0] /= r[3], r[1] /= r[3], r[2] /= r[3];
            const o = u.by();
            o[0] = r[0] - this._cameraPosition[0], o[1] = r[1] - this._cameraPosition[1], o[2] = r[2] - this._cameraPosition[2];
            const c = u.by();
            return u.b2(c, o), c;
          }
          isSurfacePointVisible(e) {
            const r = this._cachedClippingPlane;
            return r[0] * e[0] + r[1] * e[1] + r[2] * e[2] + r[3] >= 0;
          }
          isSurfacePointOnScreen(e) {
            if (!this.isSurfacePointVisible(e)) return !1;
            const r = u.bE();
            return u.aG(r, [...e, 1], this._globeViewProjMatrixNoCorrection), r[0] /= r[3], r[1] /= r[3], r[2] /= r[3], r[0] > -1 && r[0] < 1 && r[1] > -1 && r[1] < 1 && r[2] > -1 && r[2] < 1;
          }
          rayPlanetIntersection(e, r) {
            const o = u.b4(e, r), c = u.by(), h = u.by();
            u.a_(h, r, o), u.b1(c, e, h);
            const z = 1 - u.b4(c, c);
            if (z < 0) return null;
            const d = u.b4(e, e) - 1, I = -o + (o < 0 ? 1 : -1) * Math.sqrt(z), p = d / I, f = I;
            return { tMin: Math.min(p, f), tMax: Math.max(p, f) };
          }
          unprojectScreenPoint(e) {
            const r = this._cameraPosition, o = this.getRayDirectionFromPixel(e), c = this.rayPlanetIntersection(r, o);
            if (c) {
              const f = u.by();
              u.a$(f, r, [o[0] * c.tMin, o[1] * c.tMin, o[2] * c.tMin]);
              const _ = u.by();
              return u.b2(_, f), tc(_);
            }
            const h = this._cachedClippingPlane, z = h[0] * o[0] + h[1] * o[1] + h[2] * o[2], d = -u.ba(h, r) / z, I = u.by();
            if (d > 0) u.a$(I, r, [o[0] * d, o[1] * d, o[2] * d]);
            else {
              const f = u.by();
              u.a$(f, r, [2 * o[0], 2 * o[1], 2 * o[2]]);
              const _ = u.ba(this._cachedClippingPlane, f);
              u.b1(I, f, [this._cachedClippingPlane[0] * _, this._cachedClippingPlane[1] * _, this._cachedClippingPlane[2] * _]);
            }
            const p = (function(f) {
              const _ = u.by();
              return _[0] = f[0] * -f[3], _[1] = f[1] * -f[3], _[2] = f[2] * -f[3], { center: _, radius: Math.sqrt(1 - f[3] * f[3]) };
            })(h);
            return tc((function(f, _, j) {
              const C = u.by();
              u.b1(C, j, f);
              const v = u.by();
              return u.bz(v, f, C, _ / u.b8(C)), v;
            })(p.center, p.radius, I));
          }
          getMatrixForModel(e, r) {
            const o = u.V.convert(e), c = 1 / u.bD, h = u.bi();
            return u.bI(h, h, o.lng / 180 * Math.PI), u.bg(h, h, -o.lat / 180 * Math.PI), u.O(h, h, [0, 0, 1 + r / u.bD]), u.bg(h, h, 0.5 * Math.PI), u.Q(h, h, [c, c, c]), h;
          }
          getProjectionDataForCustomLayer(e = !0) {
            const r = this.getProjectionData({ overscaledTileID: new u.a1(0, 0, 0, 0, 0), applyGlobeMatrix: e });
            return r.tileMercatorCoords = [0, 0, 1, 1], r;
          }
          getFastPathSimpleProjectionMatrix(e) {
          }
        }
        class ja {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix;
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits;
          }
          get centerOffset() {
            return this._helper.centerOffset;
          }
          get size() {
            return this._helper.size;
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix;
          }
          get centerPoint() {
            return this._helper.centerPoint;
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter;
          }
          setMinZoom(e) {
            this._helper.setMinZoom(e);
          }
          setMaxZoom(e) {
            this._helper.setMaxZoom(e);
          }
          setMinPitch(e) {
            this._helper.setMinPitch(e);
          }
          setMaxPitch(e) {
            this._helper.setMaxPitch(e);
          }
          setRenderWorldCopies(e) {
            this._helper.setRenderWorldCopies(e);
          }
          setBearing(e) {
            this._helper.setBearing(e);
          }
          setPitch(e) {
            this._helper.setPitch(e);
          }
          setRoll(e) {
            this._helper.setRoll(e);
          }
          setFov(e) {
            this._helper.setFov(e);
          }
          setZoom(e) {
            this._helper.setZoom(e);
          }
          setCenter(e) {
            this._helper.setCenter(e);
          }
          setElevation(e) {
            this._helper.setElevation(e);
          }
          setMinElevationForCurrentTile(e) {
            this._helper.setMinElevationForCurrentTile(e);
          }
          setPadding(e) {
            this._helper.setPadding(e);
          }
          interpolatePadding(e, r, o) {
            return this._helper.interpolatePadding(e, r, o);
          }
          isPaddingEqual(e) {
            return this._helper.isPaddingEqual(e);
          }
          resize(e, r, o = !0) {
            this._helper.resize(e, r, o);
          }
          getMaxBounds() {
            return this._helper.getMaxBounds();
          }
          setMaxBounds(e) {
            this._helper.setMaxBounds(e);
          }
          setConstrainOverride(e) {
            this._helper.setConstrainOverride(e);
          }
          overrideNearFarZ(e, r) {
            this._helper.overrideNearFarZ(e, r);
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride();
          }
          getCameraQueryGeometry(e) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e);
          }
          get tileSize() {
            return this._helper.tileSize;
          }
          get tileZoom() {
            return this._helper.tileZoom;
          }
          get scale() {
            return this._helper.scale;
          }
          get worldSize() {
            return this._helper.worldSize;
          }
          get width() {
            return this._helper.width;
          }
          get height() {
            return this._helper.height;
          }
          get lngRange() {
            return this._helper.lngRange;
          }
          get latRange() {
            return this._helper.latRange;
          }
          get minZoom() {
            return this._helper.minZoom;
          }
          get maxZoom() {
            return this._helper.maxZoom;
          }
          get zoom() {
            return this._helper.zoom;
          }
          get center() {
            return this._helper.center;
          }
          get minPitch() {
            return this._helper.minPitch;
          }
          get maxPitch() {
            return this._helper.maxPitch;
          }
          get pitch() {
            return this._helper.pitch;
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians;
          }
          get roll() {
            return this._helper.roll;
          }
          get rollInRadians() {
            return this._helper.rollInRadians;
          }
          get bearing() {
            return this._helper.bearing;
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians;
          }
          get fov() {
            return this._helper.fov;
          }
          get fovInRadians() {
            return this._helper.fovInRadians;
          }
          get elevation() {
            return this._helper.elevation;
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile;
          }
          get padding() {
            return this._helper.padding;
          }
          get unmodified() {
            return this._helper.unmodified;
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies;
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance;
          }
          get constrainOverride() {
            return this._helper.constrainOverride;
          }
          get nearZ() {
            return this._helper.nearZ;
          }
          get farZ() {
            return this._helper.farZ;
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ;
          }
          get isGlobeRendering() {
            return this._globeness > 0;
          }
          setTransitionState(e, r) {
            this._globeness = e, this._globeLatitudeErrorCorrectionRadians = r, this._calcMatrices(), this._verticalPerspectiveTransform.getCoveringTilesDetailsProvider().prepareNextFrame(), this._mercatorTransform.getCoveringTilesDetailsProvider().prepareNextFrame();
          }
          get currentTransform() {
            return this.isGlobeRendering ? this._verticalPerspectiveTransform : this._mercatorTransform;
          }
          constructor(e) {
            this._globeLatitudeErrorCorrectionRadians = 0, this._globeness = 1, this.defaultConstrain = (r, o) => this.currentTransform.defaultConstrain(r, o), this.applyConstrain = (r, o) => this._helper.applyConstrain(r, o), this._helper = new xs({ calcMatrices: () => {
              this._calcMatrices();
            }, defaultConstrain: (r, o) => this.defaultConstrain(r, o) }, e), this._globeness = 1, this._mercatorTransform = new ze(), this._verticalPerspectiveTransform = new ma();
          }
          clone() {
            const e = new ja();
            return e._globeness = this._globeness, e._globeLatitudeErrorCorrectionRadians = this._globeLatitudeErrorCorrectionRadians, e.apply(this), e;
          }
          apply(e) {
            this._helper.apply(e), this._mercatorTransform.apply(this), this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians);
          }
          get projectionMatrix() {
            return this.currentTransform.projectionMatrix;
          }
          get modelViewProjectionMatrix() {
            return this.currentTransform.modelViewProjectionMatrix;
          }
          get inverseProjectionMatrix() {
            return this.currentTransform.inverseProjectionMatrix;
          }
          get cameraPosition() {
            return this.currentTransform.cameraPosition;
          }
          getProjectionData(e) {
            const r = this._mercatorTransform.getProjectionData(e), o = this._verticalPerspectiveTransform.getProjectionData(e);
            return { mainMatrix: this.isGlobeRendering ? o.mainMatrix : r.mainMatrix, clippingPlane: o.clippingPlane, tileMercatorCoords: o.tileMercatorCoords, projectionTransition: e.applyGlobeMatrix ? this._globeness : 0, fallbackMatrix: r.fallbackMatrix };
          }
          isLocationOccluded(e) {
            return this.currentTransform.isLocationOccluded(e);
          }
          transformLightDirection(e) {
            return this.currentTransform.transformLightDirection(e);
          }
          getPixelScale() {
            return u.bt(this._mercatorTransform.getPixelScale(), this._verticalPerspectiveTransform.getPixelScale(), this._globeness);
          }
          getCircleRadiusCorrection() {
            return u.bt(this._mercatorTransform.getCircleRadiusCorrection(), this._verticalPerspectiveTransform.getCircleRadiusCorrection(), this._globeness);
          }
          getPitchedTextCorrection(e, r, o) {
            const c = this._mercatorTransform.getPitchedTextCorrection(e, r, o), h = this._verticalPerspectiveTransform.getPitchedTextCorrection(e, r, o);
            return u.bt(c, h, this._globeness);
          }
          projectTileCoordinates(e, r, o, c) {
            return this.currentTransform.projectTileCoordinates(e, r, o, c);
          }
          _calcMatrices() {
            this._helper._width && this._helper._height && (this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians), this._helper._nearZ = this._verticalPerspectiveTransform.nearZ, this._helper._farZ = this._verticalPerspectiveTransform.farZ, this._mercatorTransform.apply(this, !0, this.isGlobeRendering), this._helper._nearZ = this._mercatorTransform.nearZ, this._helper._farZ = this._mercatorTransform.farZ);
          }
          calculateFogMatrix(e) {
            return this.currentTransform.calculateFogMatrix(e);
          }
          getVisibleUnwrappedCoordinates(e) {
            return this.currentTransform.getVisibleUnwrappedCoordinates(e);
          }
          getCameraFrustum() {
            return this.currentTransform.getCameraFrustum();
          }
          getClippingPlane() {
            return this.currentTransform.getClippingPlane();
          }
          getCoveringTilesDetailsProvider() {
            return this.currentTransform.getCoveringTilesDetailsProvider();
          }
          recalculateZoomAndCenter(e) {
            this._mercatorTransform.recalculateZoomAndCenter(e), this._verticalPerspectiveTransform.recalculateZoomAndCenter(e);
          }
          maxPitchScaleFactor() {
            return this._mercatorTransform.maxPitchScaleFactor();
          }
          getCameraPoint() {
            return this._helper.getCameraPoint();
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude();
          }
          getCameraLngLat() {
            return this._helper.getCameraLngLat();
          }
          lngLatToCameraDepth(e, r) {
            return this.currentTransform.lngLatToCameraDepth(e, r);
          }
          populateCache(e) {
            this._mercatorTransform.populateCache(e), this._verticalPerspectiveTransform.populateCache(e);
          }
          getBounds() {
            return this.currentTransform.getBounds();
          }
          calculateCenterFromCameraLngLatAlt(e, r, o, c) {
            return this._helper.calculateCenterFromCameraLngLatAlt(e, r, o, c);
          }
          setLocationAtPoint(e, r) {
            if (!this.isGlobeRendering) return this._mercatorTransform.setLocationAtPoint(e, r), void this.apply(this._mercatorTransform);
            this._verticalPerspectiveTransform.setLocationAtPoint(e, r), this.apply(this._verticalPerspectiveTransform);
          }
          locationToScreenPoint(e, r) {
            return this.currentTransform.locationToScreenPoint(e, r);
          }
          screenPointToMercatorCoordinate(e, r) {
            return this.currentTransform.screenPointToMercatorCoordinate(e, r);
          }
          screenPointToLocation(e, r) {
            return this.currentTransform.screenPointToLocation(e, r);
          }
          isPointOnMapSurface(e, r) {
            return this.currentTransform.isPointOnMapSurface(e, r);
          }
          getRayDirectionFromPixel(e) {
            return this._verticalPerspectiveTransform.getRayDirectionFromPixel(e);
          }
          getMatrixForModel(e, r) {
            return this.currentTransform.getMatrixForModel(e, r);
          }
          getProjectionDataForCustomLayer(e = !0) {
            const r = this._mercatorTransform.getProjectionDataForCustomLayer(e);
            if (!this.isGlobeRendering) return r;
            const o = this._verticalPerspectiveTransform.getProjectionDataForCustomLayer(e);
            return o.fallbackMatrix = r.mainMatrix, o;
          }
          getFastPathSimpleProjectionMatrix(e) {
            return this.currentTransform.getFastPathSimpleProjectionMatrix(e);
          }
        }
        class ms {
          get useGlobeControls() {
            return !0;
          }
          handlePanInertia(e, r) {
            const o = $s(e, r);
            return Math.abs(o.lng - r.center.lng) > 180 && (o.lng = r.center.lng + 179.5 * Math.sign(o.lng - r.center.lng)), { easingCenter: o, easingOffset: new u.P(0, 0) };
          }
          handleMapControlsRollPitchBearingZoom(e, r) {
            const o = e.around, c = r.screenPointToLocation(o);
            e.bearingDelta && r.setBearing(r.bearing + e.bearingDelta), e.pitchDelta && r.setPitch(r.pitch + e.pitchDelta), e.rollDelta && r.setRoll(r.roll + e.rollDelta);
            const h = r.zoom;
            e.zoomDelta && r.setZoom(r.zoom + e.zoomDelta);
            const z = r.zoom - h;
            if (z === 0) return;
            const d = u.bJ(r.center.lng, c.lng), I = d / (Math.abs(d / 180) + 1), p = u.bJ(r.center.lat, c.lat), f = r.getRayDirectionFromPixel(o), _ = r.cameraPosition, j = -1 * u.b4(_, f), C = u.by();
            u.a$(C, _, [f[0] * j, f[1] * j, f[2] * j]);
            const v = u.b6(C) - 1, F = Math.exp(0.5 * -Math.max(v - 0.3, 0)), Y = xa(r.worldSize, r.center.lat) / Math.min(r.width, r.height), W = u.bw(Y, 0.9, 0.5, 1, 0.25), Z = (1 - u.aq(-z)) * Math.min(F, W), J = r.center.lat, R = r.zoom, q = new u.V(r.center.lng + I * Z, u.an(r.center.lat + p * Z, -u.ao, u.ao));
            r.setLocationAtPoint(c, o);
            const $ = r.center, G = u.bw(Math.abs(d), 45, 85, 0, 1), st = u.bw(Y, 0.75, 0.35, 0, 1), ct = Math.pow(Math.max(G, st), 0.25), nt = u.bJ($.lng, q.lng), at = u.bJ($.lat, q.lat);
            r.setCenter(new u.V($.lng + nt * ct, $.lat + at * ct).wrap()), r.setZoom(R + Ye(J, r.center.lat));
          }
          handleMapControlsPan(e, r, o) {
            if (!e.panDelta) return;
            const c = r.center.lat, h = r.zoom;
            r.setCenter($s(e.panDelta, r).wrap()), r.setZoom(h + Ye(c, r.center.lat));
          }
          cameraForBoxAndBearing(e, r, o, c, h) {
            const z = Ln(e, r, o, c, h), d = r.left / h.width * 2 - 1, I = (h.width - r.right) / h.width * 2 - 1, p = r.top / h.height * -2 + 1, f = (h.height - r.bottom) / h.height * -2 + 1, _ = u.bJ(o.getWest(), o.getEast()) < 0, j = _ ? o.getEast() : o.getWest(), C = _ ? o.getWest() : o.getEast(), v = Math.max(o.getNorth(), o.getSouth()), F = Math.min(o.getNorth(), o.getSouth()), Y = j + 0.5 * u.bJ(j, C), W = v + 0.5 * u.bJ(v, F), Z = h.clone();
            Z.setCenter(z.center), Z.setBearing(z.bearing), Z.setPitch(0), Z.setRoll(0), Z.setZoom(z.zoom);
            const J = Z.modelViewProjectionMatrix, R = [ts(o.getNorthWest()), ts(o.getNorthEast()), ts(o.getSouthWest()), ts(o.getSouthEast()), ts(new u.V(C, W)), ts(new u.V(j, W)), ts(new u.V(Y, v)), ts(new u.V(Y, F))], q = ts(z.center);
            let $ = Number.POSITIVE_INFINITY;
            for (const G of R) d < 0 && ($ = ms.getLesserNonNegativeNonNull($, ms.solveVectorScale(G, q, J, "x", d))), I > 0 && ($ = ms.getLesserNonNegativeNonNull($, ms.solveVectorScale(G, q, J, "x", I))), p > 0 && ($ = ms.getLesserNonNegativeNonNull($, ms.solveVectorScale(G, q, J, "y", p))), f < 0 && ($ = ms.getLesserNonNegativeNonNull($, ms.solveVectorScale(G, q, J, "y", f)));
            if (Number.isFinite($) && $ !== 0) return z.zoom = Z.zoom + u.at($), z;
            Hr();
          }
          handleJumpToCenterZoom(e, r) {
            const o = e.center.lat, c = e.applyConstrain(r.center ? u.V.convert(r.center) : e.center, e.zoom).center;
            e.setCenter(c.wrap());
            const h = r.zoom !== void 0 ? +r.zoom : e.zoom + Ye(o, c.lat);
            e.zoom !== h && e.setZoom(h);
          }
          handleEaseTo(e, r) {
            const o = e.zoom, c = e.center, h = e.padding, z = { roll: e.roll, pitch: e.pitch, bearing: e.bearing }, d = { roll: r.roll === void 0 ? e.roll : r.roll, pitch: r.pitch === void 0 ? e.pitch : r.pitch, bearing: r.bearing === void 0 ? e.bearing : r.bearing }, I = r.zoom !== void 0, p = !e.isPaddingEqual(r.padding);
            let f = !1;
            const _ = r.center ? u.V.convert(r.center) : c, j = e.applyConstrain(_, o).center;
            pa(e, j);
            const C = e.clone();
            C.setCenter(j), C.setZoom(I ? +r.zoom : o + Ye(c.lat, _.lat)), C.setBearing(r.bearing);
            const v = new u.P(u.an(e.centerPoint.x + r.offsetAsPoint.x, 0, e.width), u.an(e.centerPoint.y + r.offsetAsPoint.y, 0, e.height));
            C.setLocationAtPoint(j, v);
            const F = (r.offset && r.offsetAsPoint.mag()) > 0 ? C.center : j, Y = I ? +r.zoom : o + Ye(c.lat, F.lat), W = o + Ye(c.lat, 0), Z = Y + Ye(F.lat, 0), J = u.bJ(c.lng, F.lng), R = u.bJ(c.lat, F.lat), q = u.aq(Z - W);
            return f = Y !== o, { easeFunc: ($) => {
              if (u.bn(z, d) || Gi({ startEulerAngles: z, endEulerAngles: d, tr: e, k: $, useSlerp: z.roll != d.roll }), p && e.interpolatePadding(h, r.padding, $), r.around) u.w("Easing around a point is not supported under globe projection."), e.setLocationAtPoint(r.around, r.aroundPoint);
              else {
                const G = Z > W ? Math.min(2, q) : Math.max(0.5, q), st = Math.pow(G, 1 - $), ct = Lo(c, J, R, $ * st);
                e.setCenter(ct.wrap());
              }
              if (f) {
                const G = u.G.number(W, Z, $) + Ye(0, e.center.lat);
                e.setZoom(G);
              }
            }, isZooming: f, elevationCenter: F };
          }
          handleFlyTo(e, r) {
            const o = r.zoom !== void 0, c = e.center, h = e.zoom, z = e.padding, d = !e.isPaddingEqual(r.padding), I = e.applyConstrain(u.V.convert(r.center || r.locationAtOffset), h).center, p = o ? +r.zoom : e.zoom + Ye(e.center.lat, I.lat), f = e.clone();
            f.setCenter(I), f.setZoom(p), f.setBearing(r.bearing);
            const _ = new u.P(u.an(e.centerPoint.x + r.offsetAsPoint.x, 0, e.width), u.an(e.centerPoint.y + r.offsetAsPoint.y, 0, e.height));
            f.setLocationAtPoint(I, _);
            const j = f.center;
            pa(e, j);
            const C = (function(R, q, $) {
              const G = ts(q), st = ts($), ct = u.b4(G, st), nt = Math.acos(ct), at = KM(R);
              return nt / (2 * Math.PI) * at;
            })(e, c, j), v = h + Ye(c.lat, 0), F = p + Ye(j.lat, 0), Y = u.aq(F - v);
            let W;
            if (typeof r.minZoom == "number") {
              const R = +r.minZoom + Ye(j.lat, 0), q = Math.min(R, v, F) + Ye(0, j.lat), $ = e.applyConstrain(j, q).zoom + Ye(j.lat, 0);
              W = u.aq($ - v);
            }
            const Z = u.bJ(c.lng, j.lng), J = u.bJ(c.lat, j.lat);
            return { easeFunc: (R, q, $, G) => {
              const st = Lo(c, Z, J, $);
              d && e.interpolatePadding(z, r.padding, R);
              const ct = R === 1 ? j : st;
              e.setCenter(ct.wrap());
              const nt = v + u.at(q);
              e.setZoom(R === 1 ? p : nt + Ye(0, ct.lat));
            }, scaleOfZoom: Y, targetCenter: j, scaleOfMinZoom: W, pixelPathLength: C };
          }
          static solveVectorScale(e, r, o, c, h) {
            const z = c === "x" ? [o[0], o[4], o[8], o[12]] : [o[1], o[5], o[9], o[13]], d = [o[3], o[7], o[11], o[15]], I = e[0] * z[0] + e[1] * z[1] + e[2] * z[2], p = e[0] * d[0] + e[1] * d[1] + e[2] * d[2], f = r[0] * z[0] + r[1] * z[1] + r[2] * z[2], _ = r[0] * d[0] + r[1] * d[1] + r[2] * d[2];
            return f + h * p === I + h * _ || d[3] * (I - f) + z[3] * (_ - p) + I * _ == f * p ? null : (f + z[3] - h * _ - h * d[3]) / (f - I - h * _ + h * p);
          }
          static getLesserNonNegativeNonNull(e, r) {
            return r !== null && r >= 0 && r < e ? r : e;
          }
        }
        class _a {
          constructor(e) {
            this._globe = e, this._mercatorCameraHelper = new As(), this._verticalPerspectiveCameraHelper = new ms();
          }
          get useGlobeControls() {
            return this._globe.useGlobeRendering;
          }
          get currentHelper() {
            return this.useGlobeControls ? this._verticalPerspectiveCameraHelper : this._mercatorCameraHelper;
          }
          handlePanInertia(e, r) {
            return this.currentHelper.handlePanInertia(e, r);
          }
          handleMapControlsRollPitchBearingZoom(e, r) {
            return this.currentHelper.handleMapControlsRollPitchBearingZoom(e, r);
          }
          handleMapControlsPan(e, r, o) {
            this.currentHelper.handleMapControlsPan(e, r, o);
          }
          cameraForBoxAndBearing(e, r, o, c, h) {
            return this.currentHelper.cameraForBoxAndBearing(e, r, o, c, h);
          }
          handleJumpToCenterZoom(e, r) {
            this.currentHelper.handleJumpToCenterZoom(e, r);
          }
          handleEaseTo(e, r) {
            return this.currentHelper.handleEaseTo(e, r);
          }
          handleFlyTo(e, r) {
            return this.currentHelper.handleFlyTo(e, r);
          }
        }
        const Nr = (g, e) => u.B(g, e && e.filter(((r) => r.identifier !== "source.canvas"))), Oo = u.bN();
        class bn extends u.E {
          constructor(e, r = {}) {
            var o, c;
            super(), this._rtlPluginLoaded = () => {
              for (const z in this.tileManagers) {
                const d = this.tileManagers[z].getSource().type;
                d !== "vector" && d !== "geojson" || this.tileManagers[z].reload();
              }
            }, this.map = e, this.dispatcher = new Yi(Fr(), e._getMapId()), this.dispatcher.registerMessageHandler("GG", ((z, d) => this.getGlyphs(z, d))), this.dispatcher.registerMessageHandler("GI", ((z, d) => this.getImages(z, d))), this.dispatcher.registerMessageHandler("GDA", ((z, d) => this.getDashes(z, d))), this.imageManager = new Si(), this.imageManager.setEventedParent(this);
            const h = ((o = e._container) === null || o === void 0 ? void 0 : o.lang) || typeof document < "u" && ((c = document.documentElement) === null || c === void 0 ? void 0 : c.lang) || void 0;
            this.glyphManager = new Zs(e._requestManager, r.localIdeographFontFamily, h), this.lineAtlas = new Ia(256, 512), this.crossTileSymbolIndex = new Dr(), this._setInitialValues(), this._resetUpdates(), this.dispatcher.broadcast("SR", u.bO()), Hs().on(Wi, this._rtlPluginLoaded), this.on("data", ((z) => {
              if (z.dataType !== "source" || z.sourceDataType !== "metadata") return;
              const d = this.tileManagers[z.sourceId];
              if (!d) return;
              const I = d.getSource();
              if (I && I.vectorLayerIds) for (const p in this._layers) {
                const f = this._layers[p];
                f.source === I.id && this._validateLayer(f);
              }
            }));
          }
          _setInitialValues() {
            var e;
            this._spritesImagesIds = {}, this._layers = {}, this._order = [], this.tileManagers = {}, this.zoomHistory = new u.bP(), this._availableImages = [], this._globalState = {}, this._serializedLayers = {}, this.stylesheet = null, this.light = null, this.sky = null, this.projection && (this.projection.destroy(), delete this.projection), this._loaded = !1, this._changed = !1, this._updatedLayers = {}, this._updatedSources = {}, this._changedImages = {}, this._glyphsDidChange = !1, this._updatedPaintProps = {}, this._layerOrderChanged = !1, this.crossTileSymbolIndex = new (((e = this.crossTileSymbolIndex) === null || e === void 0 ? void 0 : e.constructor) || Object)(), this.pauseablePlacement = void 0, this.placement = void 0, this.z = 0;
          }
          setGlobalStateProperty(e, r) {
            var o, c, h;
            this._checkLoaded();
            const z = r === null ? (h = (c = (o = this.stylesheet.state) === null || o === void 0 ? void 0 : o[e]) === null || c === void 0 ? void 0 : c.default) !== null && h !== void 0 ? h : null : r;
            if (u.bQ(z, this._globalState[e])) return this;
            this._globalState[e] = z, this._applyGlobalStateChanges([e]);
          }
          getGlobalState() {
            return this._globalState;
          }
          setGlobalState(e) {
            this._checkLoaded();
            const r = [];
            for (const o in e) !u.bQ(this._globalState[o], e[o].default) && (r.push(o), this._globalState[o] = e[o].default);
            this._applyGlobalStateChanges(r);
          }
          _applyGlobalStateChanges(e) {
            if (e.length === 0) return;
            const r = /* @__PURE__ */ new Set(), o = {};
            for (const c of e) {
              o[c] = this._globalState[c];
              for (const h in this._layers) {
                const z = this._layers[h], d = z.getLayoutAffectingGlobalStateRefs(), I = z.getPaintAffectingGlobalStateRefs();
                if (d.has(c) && r.add(z.source), I.has(c)) for (const { name: p, value: f } of I.get(c)) this._updatePaintProperty(z, p, f);
              }
            }
            this.dispatcher.broadcast("UGS", o);
            for (const c in this.tileManagers) r.has(c) && (this._reloadSource(c), this._changed = !0);
          }
          loadURL(e, r = {}, o) {
            this.fire(new u.l("dataloading", { dataType: "style" })), r.validate = typeof r.validate != "boolean" || r.validate;
            const c = this.map._requestManager.transformRequest(e, "Style");
            this._loadStyleRequest = new AbortController();
            const h = this._loadStyleRequest;
            u.j(c, this._loadStyleRequest).then(((z) => {
              this._loadStyleRequest = null, this._load(z.data, r, o);
            })).catch(((z) => {
              this._loadStyleRequest = null, z && !h.signal.aborted && this.fire(new u.k(z));
            }));
          }
          loadJSON(e, r = {}, o) {
            this.fire(new u.l("dataloading", { dataType: "style" })), this._frameRequest = new AbortController(), Ke.frameAsync(this._frameRequest).then((() => {
              this._frameRequest = null, r.validate = r.validate !== !1, this._load(e, r, o);
            })).catch((() => {
            }));
          }
          loadEmpty() {
            this.fire(new u.l("dataloading", { dataType: "style" })), this._load(Oo, { validate: !1 });
          }
          _load(e, r, o) {
            var c, h;
            let z = r.transformStyle ? r.transformStyle(o, e) : e;
            if (!r.validate || !Nr(this, u.C(z))) {
              z = Object.assign({}, z), this._loaded = !0, this.stylesheet = z;
              for (const d in z.sources) this.addSource(d, z.sources[d], { validate: !1 });
              z.sprite ? this._loadSprite(z.sprite) : this.imageManager.setLoaded(!0), this.glyphManager.setURL(z.glyphs), this._createLayers(), this.light = new kr(this.stylesheet.light), this._setProjectionInternal(((c = this.stylesheet.projection) === null || c === void 0 ? void 0 : c.type) || "mercator"), this.sky = new or(this.stylesheet.sky), this.map.setTerrain((h = this.stylesheet.terrain) !== null && h !== void 0 ? h : null), this.fire(new u.l("data", { dataType: "style" })), this.fire(new u.l("style.load"));
            }
          }
          _createLayers() {
            var e, r, o;
            const c = u.bR(this.stylesheet.layers);
            this.setGlobalState((e = this.stylesheet.state) !== null && e !== void 0 ? e : null), this.dispatcher.broadcast("SL", c), this._order = c.map(((h) => h.id)), this._layers = {}, this._serializedLayers = null;
            for (const h of c) {
              const z = u.bS(h, this._globalState);
              if (z.setEventedParent(this, { layer: { id: h.id } }), this._layers[h.id] = z, u.bT(z) && this.tileManagers[z.source]) {
                const d = (o = (r = h.paint) === null || r === void 0 ? void 0 : r["raster-fade-duration"]) !== null && o !== void 0 ? o : z.paint.get("raster-fade-duration");
                this.tileManagers[z.source].setRasterFadeDuration(d);
              }
            }
          }
          _loadSprite(e, r = !1, o = void 0) {
            let c;
            this.imageManager.setLoaded(!1), this._spriteRequest = new AbortController(), (function(h, z, d, I) {
              return u._(this, void 0, void 0, (function* () {
                const p = Ii(h), f = d > 1 ? "@2x" : "", _ = {}, j = {};
                for (const { id: C, url: v } of p) {
                  const F = z.transformRequest(Bi(v, f, ".json"), "SpriteJSON");
                  _[C] = u.j(F, I);
                  const Y = z.transformRequest(Bi(v, f, ".png"), "SpriteImage");
                  j[C] = ps.getImage(Y, I);
                }
                return yield Promise.all([...Object.values(_), ...Object.values(j)]), (function(C, v) {
                  return u._(this, void 0, void 0, (function* () {
                    const F = {};
                    for (const Y in C) {
                      F[Y] = {};
                      const W = Ke.getImageCanvasContext((yield v[Y]).data), Z = (yield C[Y]).data;
                      for (const J in Z) {
                        const { width: R, height: q, x: $, y: G, sdf: st, pixelRatio: ct, stretchX: nt, stretchY: at, content: Mt, textFitWidth: xt, textFitHeight: wt } = Z[J];
                        F[Y][J] = { data: null, pixelRatio: ct, sdf: st, stretchX: nt, stretchY: at, content: Mt, textFitWidth: xt, textFitHeight: wt, spriteData: { width: R, height: q, x: $, y: G, context: W } };
                      }
                    }
                    return F;
                  }));
                })(_, j);
              }));
            })(e, this.map._requestManager, this.map.getPixelRatio(), this._spriteRequest).then(((h) => {
              if (this._spriteRequest = null, h) for (const z in h) {
                this._spritesImagesIds[z] = [];
                const d = this._spritesImagesIds[z] ? this._spritesImagesIds[z].filter(((I) => !(I in h))) : [];
                for (const I of d) this.imageManager.removeImage(I), this._changedImages[I] = !0;
                for (const I in h[z]) {
                  const p = z === "default" ? I : `${z}:${I}`;
                  this._spritesImagesIds[z].push(p), p in this.imageManager.images ? this.imageManager.updateImage(p, h[z][I], !1) : this.imageManager.addImage(p, h[z][I]), r && (this._changedImages[p] = !0);
                }
              }
            })).catch(((h) => {
              this._spriteRequest = null, c = h, this.fire(new u.k(c));
            })).finally((() => {
              this.imageManager.setLoaded(!0), this._availableImages = this.imageManager.listImages(), r && (this._changed = !0), this.dispatcher.broadcast("SI", this._availableImages), this.fire(new u.l("data", { dataType: "style" })), o && o(c);
            }));
          }
          _unloadSprite() {
            for (const e of Object.values(this._spritesImagesIds).flat()) this.imageManager.removeImage(e), this._changedImages[e] = !0;
            this._spritesImagesIds = {}, this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new u.l("data", { dataType: "style" }));
          }
          _validateLayer(e) {
            const r = this.tileManagers[e.source];
            if (!r) return;
            const o = e.sourceLayer;
            if (!o) return;
            const c = r.getSource();
            (c.type === "geojson" || c.vectorLayerIds && c.vectorLayerIds.indexOf(o) === -1) && this.fire(new u.k(new Error(`Source layer "${o}" does not exist on source "${c.id}" as specified by style layer "${e.id}".`)));
          }
          loaded() {
            if (!this._loaded || Object.keys(this._updatedSources).length) return !1;
            for (const e in this.tileManagers) if (!this.tileManagers[e].loaded()) return !1;
            return !!this.imageManager.isLoaded();
          }
          _serializeByIds(e, r = !1) {
            const o = this._serializedAllLayers();
            if (!e || e.length === 0) return Object.values(r ? u.bU(o) : o);
            const c = [];
            for (const h of e) if (o[h]) {
              const z = r ? u.bU(o[h]) : o[h];
              c.push(z);
            }
            return c;
          }
          _serializedAllLayers() {
            let e = this._serializedLayers;
            if (e) return e;
            e = this._serializedLayers = {};
            const r = Object.keys(this._layers);
            for (const o of r) {
              const c = this._layers[o];
              c.type !== "custom" && (e[o] = c.serialize());
            }
            return e;
          }
          hasTransitions() {
            var e, r, o;
            if (!((e = this.light) === null || e === void 0) && e.hasTransition() || !((r = this.sky) === null || r === void 0) && r.hasTransition() || !((o = this.projection) === null || o === void 0) && o.hasTransition()) return !0;
            for (const c in this.tileManagers) if (this.tileManagers[c].hasTransition()) return !0;
            for (const c in this._layers) if (this._layers[c].hasTransition()) return !0;
            return !1;
          }
          _checkLoaded() {
            if (!this._loaded) throw new Error("Style is not done loading.");
          }
          update(e) {
            if (!this._loaded) return;
            const r = this._changed;
            if (r) {
              const c = Object.keys(this._updatedLayers), h = Object.keys(this._removedLayers);
              (c.length || h.length) && this._updateWorkerLayers(c, h);
              for (const z in this._updatedSources) {
                const d = this._updatedSources[z];
                if (d === "reload") this._reloadSource(z);
                else {
                  if (d !== "clear") throw new Error(`Invalid action ${d}`);
                  this._clearSource(z);
                }
              }
              this._updateTilesForChangedImages(), this._updateTilesForChangedGlyphs();
              for (const z in this._updatedPaintProps) this._layers[z].updateTransitions(e);
              this.light.updateTransitions(e), this.sky.updateTransitions(e), this._resetUpdates();
            }
            const o = {};
            for (const c in this.tileManagers) {
              const h = this.tileManagers[c];
              o[c] = h.used, h.used = !1;
            }
            for (const c of this._order) {
              const h = this._layers[c];
              h.recalculate(e, this._availableImages), !h.isHidden(e.zoom) && h.source && (this.tileManagers[h.source].used = !0);
            }
            for (const c in o) {
              const h = this.tileManagers[c];
              !!o[c] != !!h.used && h.fire(new u.l("data", { sourceDataType: "visibility", dataType: "source", sourceId: c }));
            }
            this.light.recalculate(e), this.sky.recalculate(e), this.projection.recalculate(e), this.z = e.zoom, r && this.fire(new u.l("data", { dataType: "style" }));
          }
          _updateTilesForChangedImages() {
            const e = Object.keys(this._changedImages);
            if (e.length) {
              for (const r in this.tileManagers) this.tileManagers[r].reloadTilesForDependencies(["icons", "patterns"], e);
              this._changedImages = {};
            }
          }
          _updateTilesForChangedGlyphs() {
            if (this._glyphsDidChange) {
              for (const e in this.tileManagers) this.tileManagers[e].reloadTilesForDependencies(["glyphs"], [""]);
              this._glyphsDidChange = !1;
            }
          }
          _updateWorkerLayers(e, r) {
            this.dispatcher.broadcast("UL", { layers: this._serializeByIds(e, !1), removedIds: r });
          }
          _resetUpdates() {
            this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}, this._glyphsDidChange = !1;
          }
          setState(e, r = {}) {
            var o;
            this._checkLoaded();
            const c = this.serialize();
            if (e = r.transformStyle ? r.transformStyle(c, e) : e, ((o = r.validate) === null || o === void 0 || o) && Nr(this, u.C(e))) return !1;
            (e = u.bU(e)).layers = u.bR(e.layers);
            const h = u.bV(c, e), z = this._getOperationsToPerform(h);
            if (z.unimplemented.length > 0) throw new Error(`Unimplemented: ${z.unimplemented.join(", ")}.`);
            if (z.operations.length === 0) return !1;
            for (const d of z.operations) d();
            return this.stylesheet = e, this._serializedLayers = null, !0;
          }
          _getOperationsToPerform(e) {
            const r = [], o = [];
            for (const c of e) switch (c.command) {
              case "setCenter":
              case "setZoom":
              case "setBearing":
              case "setPitch":
              case "setRoll":
                continue;
              case "addLayer":
                r.push((() => this.addLayer.apply(this, c.args)));
                break;
              case "removeLayer":
                r.push((() => this.removeLayer.apply(this, c.args)));
                break;
              case "setPaintProperty":
                r.push((() => this.setPaintProperty.apply(this, c.args)));
                break;
              case "setLayoutProperty":
                r.push((() => this.setLayoutProperty.apply(this, c.args)));
                break;
              case "setFilter":
                r.push((() => this.setFilter.apply(this, c.args)));
                break;
              case "addSource":
                r.push((() => this.addSource.apply(this, c.args)));
                break;
              case "removeSource":
                r.push((() => this.removeSource.apply(this, c.args)));
                break;
              case "setLayerZoomRange":
                r.push((() => this.setLayerZoomRange.apply(this, c.args)));
                break;
              case "setLight":
                r.push((() => this.setLight.apply(this, c.args)));
                break;
              case "setGeoJSONSourceData":
                r.push((() => this.setGeoJSONSourceData.apply(this, c.args)));
                break;
              case "setGlyphs":
                r.push((() => this.setGlyphs.apply(this, c.args)));
                break;
              case "setSprite":
                r.push((() => this.setSprite.apply(this, c.args)));
                break;
              case "setTerrain":
                r.push((() => this.map.setTerrain.apply(this, c.args)));
                break;
              case "setSky":
                r.push((() => this.setSky.apply(this, c.args)));
                break;
              case "setProjection":
                this.setProjection.apply(this, c.args);
                break;
              case "setGlobalState":
                r.push((() => this.setGlobalState.apply(this, c.args)));
                break;
              case "setTransition":
                r.push((() => {
                }));
                break;
              default:
                o.push(c.command);
            }
            return { operations: r, unimplemented: o };
          }
          addImage(e, r) {
            if (this.getImage(e)) return this.fire(new u.k(new Error(`An image named "${e}" already exists.`)));
            this.imageManager.addImage(e, r), this._afterImageUpdated(e);
          }
          updateImage(e, r) {
            this.imageManager.updateImage(e, r);
          }
          getImage(e) {
            return this.imageManager.getImage(e);
          }
          removeImage(e) {
            if (!this.getImage(e)) return this.fire(new u.k(new Error(`An image named "${e}" does not exist.`)));
            this.imageManager.removeImage(e), this._afterImageUpdated(e);
          }
          _afterImageUpdated(e) {
            this._availableImages = this.imageManager.listImages(), this._changedImages[e] = !0, this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new u.l("data", { dataType: "style" }));
          }
          listImages() {
            return this._checkLoaded(), this.imageManager.listImages();
          }
          addSource(e, r, o = {}) {
            if (this._checkLoaded(), this.tileManagers[e] !== void 0) throw new Error(`Source "${e}" already exists.`);
            if (!r.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(r).join(", ")}.`);
            if (["vector", "raster", "geojson", "video", "image"].indexOf(r.type) >= 0 && this._validate(u.C.source, `sources.${e}`, r, null, o)) return;
            this.map && this.map._collectResourceTiming && (r.collectResourceTiming = !0);
            const c = this.tileManagers[e] = new Zt(e, r, this.dispatcher);
            c.style = this, c.setEventedParent(this, (() => ({ isSourceLoaded: c.loaded(), source: c.serialize(), sourceId: e }))), c.onAdd(this.map), this._changed = !0;
          }
          removeSource(e) {
            if (this._checkLoaded(), this.tileManagers[e] === void 0) throw new Error("There is no source with this ID");
            for (const o in this._layers) if (this._layers[o].source === e) return this.fire(new u.k(new Error(`Source "${e}" cannot be removed while layer "${o}" is using it.`)));
            const r = this.tileManagers[e];
            delete this.tileManagers[e], delete this._updatedSources[e], r.fire(new u.l("data", { sourceDataType: "metadata", dataType: "source", sourceId: e })), r.setEventedParent(null), r.onRemove(this.map), this._changed = !0;
          }
          setGeoJSONSourceData(e, r) {
            if (this._checkLoaded(), this.tileManagers[e] === void 0) throw new Error(`There is no source with this ID=${e}`);
            const o = this.tileManagers[e].getSource();
            if (o.type !== "geojson") throw new Error(`geojsonSource.type is ${o.type}, which is !== 'geojson`);
            o.setData(r), this._changed = !0;
          }
          getSource(e) {
            return this.tileManagers[e] && this.tileManagers[e].getSource();
          }
          addLayer(e, r, o = {}) {
            this._checkLoaded();
            const c = e.id;
            if (this.getLayer(c)) return void this.fire(new u.k(new Error(`Layer "${c}" already exists on this map.`)));
            let h;
            if (e.type === "custom") {
              if (Nr(this, u.bW(e))) return;
              h = u.bS(e, this._globalState);
            } else {
              if ("source" in e && typeof e.source == "object" && (this.addSource(c, e.source), e = u.bU(e), e = u.e(e, { source: c })), this._validate(u.C.layer, `layers.${c}`, e, { arrayIndex: -1 }, o)) return;
              h = u.bS(e, this._globalState), this._validateLayer(h), h.setEventedParent(this, { layer: { id: c } });
            }
            const z = r ? this._order.indexOf(r) : this._order.length;
            if (r && z === -1) this.fire(new u.k(new Error(`Cannot add layer "${c}" before non-existing layer "${r}".`)));
            else {
              if (this._order.splice(z, 0, c), this._layerOrderChanged = !0, this._layers[c] = h, this._removedLayers[c] && h.source && h.type !== "custom") {
                const d = this._removedLayers[c];
                delete this._removedLayers[c], d.type !== h.type ? this._updatedSources[h.source] = "clear" : (this._updatedSources[h.source] = "reload", this.tileManagers[h.source].pause());
              }
              this._updateLayer(h), h.onAdd && h.onAdd(this.map);
            }
          }
          moveLayer(e, r) {
            if (this._checkLoaded(), this._changed = !0, !this._layers[e]) return void this.fire(new u.k(new Error(`The layer '${e}' does not exist in the map's style and cannot be moved.`)));
            if (e === r) return;
            const o = this._order.indexOf(e);
            this._order.splice(o, 1);
            const c = r ? this._order.indexOf(r) : this._order.length;
            r && c === -1 ? this.fire(new u.k(new Error(`Cannot move layer "${e}" before non-existing layer "${r}".`))) : (this._order.splice(c, 0, e), this._layerOrderChanged = !0);
          }
          removeLayer(e) {
            this._checkLoaded();
            const r = this._layers[e];
            if (!r) return void this.fire(new u.k(new Error(`Cannot remove non-existing layer "${e}".`)));
            r.setEventedParent(null);
            const o = this._order.indexOf(e);
            this._order.splice(o, 1), this._layerOrderChanged = !0, this._changed = !0, this._removedLayers[e] = r, delete this._layers[e], this._serializedLayers && delete this._serializedLayers[e], delete this._updatedLayers[e], delete this._updatedPaintProps[e], r.onRemove && r.onRemove(this.map);
          }
          getLayer(e) {
            return this._layers[e];
          }
          getLayersOrder() {
            return [...this._order];
          }
          hasLayer(e) {
            return e in this._layers;
          }
          setLayerZoomRange(e, r, o) {
            this._checkLoaded();
            const c = this.getLayer(e);
            c ? c.minzoom === r && c.maxzoom === o || (r != null && (c.minzoom = r), o != null && (c.maxzoom = o), this._updateLayer(c)) : this.fire(new u.k(new Error(`Cannot set the zoom range of non-existing layer "${e}".`)));
          }
          setFilter(e, r, o = {}) {
            this._checkLoaded();
            const c = this.getLayer(e);
            if (c) {
              if (!u.bQ(c.filter, r)) return r == null ? (c.setFilter(void 0), void this._updateLayer(c)) : void (this._validate(u.C.filter, `layers.${c.id}.filter`, r, null, o) || (c.setFilter(u.bU(r)), this._updateLayer(c)));
            } else this.fire(new u.k(new Error(`Cannot filter non-existing layer "${e}".`)));
          }
          getFilter(e) {
            return u.bU(this.getLayer(e).filter);
          }
          setLayoutProperty(e, r, o, c = {}) {
            this._checkLoaded();
            const h = this.getLayer(e);
            h ? u.bQ(h.getLayoutProperty(r), o) || (h.setLayoutProperty(r, o, c), this._updateLayer(h)) : this.fire(new u.k(new Error(`Cannot style non-existing layer "${e}".`)));
          }
          getLayoutProperty(e, r) {
            const o = this.getLayer(e);
            if (o) return o.getLayoutProperty(r);
            this.fire(new u.k(new Error(`Cannot get style of non-existing layer "${e}".`)));
          }
          setPaintProperty(e, r, o, c = {}) {
            this._checkLoaded();
            const h = this.getLayer(e);
            h ? u.bQ(h.getPaintProperty(r), o) || this._updatePaintProperty(h, r, o, c) : this.fire(new u.k(new Error(`Cannot style non-existing layer "${e}".`)));
          }
          _updatePaintProperty(e, r, o, c = {}) {
            e.setPaintProperty(r, o, c) && this._updateLayer(e), u.bT(e) && r === "raster-fade-duration" && this.tileManagers[e.source].setRasterFadeDuration(o), this._changed = !0, this._updatedPaintProps[e.id] = !0, this._serializedLayers = null;
          }
          getPaintProperty(e, r) {
            return this.getLayer(e).getPaintProperty(r);
          }
          setFeatureState(e, r) {
            this._checkLoaded();
            const o = e.source, c = e.sourceLayer, h = this.tileManagers[o];
            if (h === void 0) return void this.fire(new u.k(new Error(`The source '${o}' does not exist in the map's style.`)));
            const z = h.getSource().type;
            z === "geojson" && c ? this.fire(new u.k(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : z !== "vector" || c ? (e.id === void 0 && this.fire(new u.k(new Error("The feature id parameter must be provided."))), h.setFeatureState(c, e.id, r)) : this.fire(new u.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
          }
          removeFeatureState(e, r) {
            this._checkLoaded();
            const o = e.source, c = this.tileManagers[o];
            if (c === void 0) return void this.fire(new u.k(new Error(`The source '${o}' does not exist in the map's style.`)));
            const h = c.getSource().type, z = h === "vector" ? e.sourceLayer : void 0;
            h !== "vector" || z ? r && typeof e.id != "string" && typeof e.id != "number" ? this.fire(new u.k(new Error("A feature id is required to remove its specific state property."))) : c.removeFeatureState(z, e.id, r) : this.fire(new u.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
          }
          getFeatureState(e) {
            this._checkLoaded();
            const r = e.source, o = e.sourceLayer, c = this.tileManagers[r];
            if (c !== void 0) return c.getSource().type !== "vector" || o ? (e.id === void 0 && this.fire(new u.k(new Error("The feature id parameter must be provided."))), c.getFeatureState(o, e.id)) : void this.fire(new u.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
            this.fire(new u.k(new Error(`The source '${r}' does not exist in the map's style.`)));
          }
          getTransition() {
            return u.e({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
          }
          serialize() {
            if (!this._loaded) return;
            const e = u.bX(this.tileManagers, ((h) => h.serialize())), r = this._serializeByIds(this._order, !0), o = this.map.getTerrain() || void 0, c = this.stylesheet;
            return u.bY({ version: c.version, name: c.name, metadata: c.metadata, light: c.light, sky: c.sky, center: c.center, zoom: c.zoom, bearing: c.bearing, pitch: c.pitch, sprite: c.sprite, glyphs: c.glyphs, transition: c.transition, projection: c.projection, sources: e, layers: r, terrain: o }, ((h) => h !== void 0));
          }
          _updateLayer(e) {
            this._updatedLayers[e.id] = !0, e.source && !this._updatedSources[e.source] && this.tileManagers[e.source].getSource().type !== "raster" && (this._updatedSources[e.source] = "reload", this.tileManagers[e.source].pause()), this._serializedLayers = null, this._changed = !0;
          }
          _flattenAndSortRenderedFeatures(e) {
            const r = (z) => this._layers[z].type === "fill-extrusion", o = {}, c = [];
            for (let z = this._order.length - 1; z >= 0; z--) {
              const d = this._order[z];
              if (r(d)) {
                o[d] = z;
                for (const I of e) {
                  const p = I[d];
                  if (p) for (const f of p) c.push(f);
                }
              }
            }
            c.sort(((z, d) => d.intersectionZ - z.intersectionZ));
            const h = [];
            for (let z = this._order.length - 1; z >= 0; z--) {
              const d = this._order[z];
              if (r(d)) for (let I = c.length - 1; I >= 0; I--) {
                const p = c[I].feature;
                if (o[p.layer.id] < z) break;
                h.push(p), c.pop();
              }
              else for (const I of e) {
                const p = I[d];
                if (p) for (const f of p) h.push(f.feature);
              }
            }
            return h;
          }
          queryRenderedFeatures(e, r, o) {
            r && r.filter && this._validate(u.C.filter, "queryRenderedFeatures.filter", r.filter, null, r);
            const c = {};
            if (r && r.layers) {
              if (!(Array.isArray(r.layers) || r.layers instanceof Set)) return this.fire(new u.k(new Error("parameters.layers must be an Array or a Set of strings"))), [];
              for (const p of r.layers) {
                const f = this._layers[p];
                if (!f) return this.fire(new u.k(new Error(`The layer '${p}' does not exist in the map's style and cannot be queried for features.`))), [];
                c[f.source] = !0;
              }
            }
            const h = [];
            r.availableImages = this._availableImages;
            const z = this._serializedAllLayers(), d = r.layers instanceof Set ? r.layers : Array.isArray(r.layers) ? new Set(r.layers) : null, I = Object.assign(Object.assign({}, r), { layers: d, globalState: this._globalState });
            for (const p in this.tileManagers) r.layers && !c[p] || h.push(An(this.tileManagers[p], this._layers, z, e, I, o, this.map.terrain ? (f, _, j) => this.map.terrain.getElevation(f, _, j) : void 0));
            return this.placement && h.push((function(p, f, _, j, C, v, F) {
              const Y = {}, W = v.queryRenderedSymbols(j), Z = [];
              for (const J of Object.keys(W).map(Number)) Z.push(F[J]);
              Z.sort(we);
              for (const J of Z) {
                const R = J.featureIndex.lookupSymbolFeatures(W[J.bucketInstanceId], f, J.bucketIndex, J.sourceLayerIndex, { filterSpec: C.filter, globalState: C.globalState }, C.layers, C.availableImages, p);
                for (const q in R) {
                  const $ = Y[q] = Y[q] || [], G = R[q];
                  G.sort(((st, ct) => {
                    const nt = J.featureSortOrder;
                    if (nt) {
                      const at = nt.indexOf(st.featureIndex);
                      return nt.indexOf(ct.featureIndex) - at;
                    }
                    return ct.featureIndex - st.featureIndex;
                  }));
                  for (const st of G) $.push(st);
                }
              }
              return (function(J, R, q) {
                for (const $ in J) for (const G of J[$]) Gs(G, q[R[$].source]);
                return J;
              })(Y, p, _);
            })(this._layers, z, this.tileManagers, e, I, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(h);
          }
          querySourceFeatures(e, r) {
            r?.filter && this._validate(u.C.filter, "querySourceFeatures.filter", r.filter, null, r);
            const o = this.tileManagers[e];
            return o ? (function(c, h) {
              const z = c.getRenderableIds().map(((p) => c.getTileByID(p))), d = [], I = {};
              for (let p = 0; p < z.length; p++) {
                const f = z[p], _ = f.tileID.canonical.key;
                I[_] || (I[_] = !0, f.querySourceFeatures(d, h));
              }
              return d;
            })(o, r ? Object.assign(Object.assign({}, r), { globalState: this._globalState }) : { globalState: this._globalState }) : [];
          }
          getLight() {
            return this.light.getLight();
          }
          setLight(e, r = {}) {
            this._checkLoaded();
            const o = this.light.getLight();
            let c = !1;
            for (const z in e) if (!u.bQ(e[z], o[z])) {
              c = !0;
              break;
            }
            if (!c) return;
            const h = { now: $t(), transition: u.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
            this.light.setLight(e, r), this.light.updateTransitions(h);
          }
          getProjection() {
            var e;
            return (e = this.stylesheet) === null || e === void 0 ? void 0 : e.projection;
          }
          setProjection(e) {
            if (this._checkLoaded(), this.projection) {
              if (this.projection.name === e.type) return;
              this.projection.destroy(), delete this.projection;
            }
            this.stylesheet.projection = e, this._setProjectionInternal(e.type);
          }
          getSky() {
            var e;
            return (e = this.stylesheet) === null || e === void 0 ? void 0 : e.sky;
          }
          setSky(e, r = {}) {
            this._checkLoaded();
            const o = this.getSky();
            let c = !1;
            if (!e && !o) return;
            if (e && !o) c = !0;
            else if (!e && o) c = !0;
            else for (const z in e) if (!u.bQ(e[z], o[z])) {
              c = !0;
              break;
            }
            if (!c) return;
            const h = { now: $t(), transition: u.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
            this.stylesheet.sky = e, this.sky.setSky(e, r), this.sky.updateTransitions(h);
          }
          _setProjectionInternal(e) {
            const r = (function(o, c) {
              const h = { constrainOverride: c };
              if (Array.isArray(o)) {
                const z = new $r({ type: o });
                return { projection: z, transform: new ja(h), cameraHelper: new _a(z) };
              }
              switch (o) {
                case "mercator":
                  return { projection: new Re(), transform: new ze(h), cameraHelper: new As() };
                case "globe": {
                  const z = new $r({ type: ["interpolate", ["linear"], ["zoom"], 11, "vertical-perspective", 12, "mercator"] });
                  return { projection: z, transform: new ja(h), cameraHelper: new _a(z) };
                }
                case "vertical-perspective":
                  return { projection: new En(), transform: new ma(h), cameraHelper: new ms() };
                default:
                  return u.w(`Unknown projection name: ${o}. Falling back to mercator projection.`), { projection: new Re(), transform: new ze(h), cameraHelper: new As() };
              }
            })(e, this.map.transformConstrain);
            this.projection = r.projection, this.map.migrateProjection(r.transform, r.cameraHelper);
            for (const o in this.tileManagers) this.tileManagers[o].reload();
          }
          _validate(e, r, o, c, h = {}) {
            return (!h || h.validate !== !1) && Nr(this, e.call(u.C, u.e({ key: r, style: this.serialize(), value: o, styleSpec: u.u }, c)));
          }
          _remove(e = !0) {
            this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._loadStyleRequest && (this._loadStyleRequest.abort(), this._loadStyleRequest = null), this._spriteRequest && (this._spriteRequest.abort(), this._spriteRequest = null), Hs().off(Wi, this._rtlPluginLoaded);
            for (const r in this._layers) this._layers[r].setEventedParent(null);
            for (const r in this.tileManagers) {
              const o = this.tileManagers[r];
              o.setEventedParent(null), o.onRemove(this.map);
            }
            this.imageManager.setEventedParent(null), this.setEventedParent(null), e && this.dispatcher.broadcast("RM", void 0), this.dispatcher.remove(e);
          }
          _clearSource(e) {
            this.tileManagers[e].clearTiles();
          }
          _reloadSource(e) {
            this.tileManagers[e].resume(), this.tileManagers[e].reload();
          }
          _updateSources(e) {
            for (const r in this.tileManagers) this.tileManagers[r].update(e, this.map.terrain);
          }
          _generateCollisionBoxes() {
            for (const e in this.tileManagers) this._reloadSource(e);
          }
          _updatePlacement(e, r, o, c, h = !1) {
            let z = !1, d = !1;
            const I = {};
            for (const p of this._order) {
              const f = this._layers[p];
              if (f.type !== "symbol") continue;
              if (!I[f.source]) {
                const j = this.tileManagers[f.source];
                I[f.source] = j.getRenderableIds(!0).map(((C) => j.getTileByID(C))).sort(((C, v) => v.tileID.overscaledZ - C.tileID.overscaledZ || (C.tileID.isLessThan(v.tileID) ? -1 : 1)));
              }
              const _ = this.crossTileSymbolIndex.addLayer(f, I[f.source], e.center.lng);
              z = z || _;
            }
            if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((h = h || this._layerOrderChanged || o === 0) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent($t(), e.zoom)) && (this.pauseablePlacement = new JM(e, this.map.terrain, this._order, h, r, o, c, this.placement), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, I), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit($t()), d = !0), z && this.pauseablePlacement.placement.setStale()), d || z) for (const p of this._order) {
              const f = this._layers[p];
              f.type === "symbol" && this.placement.updateLayerOpacities(f, I[f.source]);
            }
            return !this.pauseablePlacement.isDone() || this.placement.hasTransitions($t());
          }
          _releaseSymbolFadeTiles() {
            for (const e in this.tileManagers) this.tileManagers[e].releaseSymbolFadeTiles();
          }
          getImages(e, r) {
            return u._(this, void 0, void 0, (function* () {
              const o = yield this.imageManager.getImages(r.icons);
              this._updateTilesForChangedImages();
              const c = this.tileManagers[r.source];
              return c && c.setDependencies(r.tileID.key, r.type, r.icons), o;
            }));
          }
          getGlyphs(e, r) {
            return u._(this, void 0, void 0, (function* () {
              const o = yield this.glyphManager.getGlyphs(r.stacks), c = this.tileManagers[r.source];
              return c && c.setDependencies(r.tileID.key, r.type, [""]), o;
            }));
          }
          getGlyphsUrl() {
            return this.stylesheet.glyphs || null;
          }
          setGlyphs(e, r = {}) {
            this._checkLoaded(), e && this._validate(u.C.glyphs, "glyphs", e, null, r) || (this._glyphsDidChange = !0, this.stylesheet.glyphs = e, this.glyphManager.entries = {}, this.glyphManager.setURL(e));
          }
          getDashes(e, r) {
            return u._(this, void 0, void 0, (function* () {
              const o = {};
              for (const [c, h] of Object.entries(r.dashes)) o[c] = this.lineAtlas.getDash(h.dasharray, h.round);
              return o;
            }));
          }
          addSprite(e, r, o = {}, c) {
            this._checkLoaded();
            const h = [{ id: e, url: r }], z = [...Ii(this.stylesheet.sprite), ...h];
            this._validate(u.C.sprite, "sprite", z, null, o) || (this.stylesheet.sprite = z, this._loadSprite(h, !0, c));
          }
          removeSprite(e) {
            this._checkLoaded();
            const r = Ii(this.stylesheet.sprite);
            if (r.find(((o) => o.id === e))) {
              if (this._spritesImagesIds[e]) for (const o of this._spritesImagesIds[e]) this.imageManager.removeImage(o), this._changedImages[o] = !0;
              r.splice(r.findIndex(((o) => o.id === e)), 1), this.stylesheet.sprite = r.length > 0 ? r : void 0, delete this._spritesImagesIds[e], this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new u.l("data", { dataType: "style" }));
            } else this.fire(new u.k(new Error(`Sprite "${e}" doesn't exists on this map.`)));
          }
          getSprite() {
            return Ii(this.stylesheet.sprite);
          }
          setSprite(e, r = {}, o) {
            this._checkLoaded(), e && this._validate(u.C.sprite, "sprite", e, null, r) || (this.stylesheet.sprite = e, e ? this._loadSprite(e, !0, o) : (this._unloadSprite(), o && o(null)));
          }
          destroy() {
            this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._loadStyleRequest && (this._loadStyleRequest.abort(), this._loadStyleRequest = null), this._spriteRequest && (this._spriteRequest.abort(), this._spriteRequest = null);
            for (const e in this.tileManagers) {
              const r = this.tileManagers[e];
              if (r.setEventedParent(null), r._tiles) {
                for (const o in r._tiles) r._tiles[o].unloadVectorData();
                r._tiles = {};
              }
              r._cache.reset(), r.onRemove(this.map);
            }
            this.tileManagers = {}, this.imageManager && (this.imageManager.setEventedParent(null), this.imageManager.destroy(), this._availableImages = [], this._spritesImagesIds = {}), this.glyphManager && this.glyphManager.destroy();
            for (const e in this._layers) {
              const r = this._layers[e];
              r.setEventedParent(null), r.onRemove && r.onRemove(this.map);
            }
            this._setInitialValues(), this.setEventedParent(null), this.dispatcher.unregisterMessageHandler("GG"), this.dispatcher.unregisterMessageHandler("GI"), this.dispatcher.unregisterMessageHandler("GDA"), this.dispatcher.remove(!0), this._listeners = {}, this._oneTimeListeners = {};
          }
        }
        var Di = u.aT([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
        class jl {
          constructor() {
            this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
          }
          bind(e, r, o, c, h, z, d, I, p) {
            this.context = e;
            let f = this.boundPaintVertexBuffers.length !== c.length;
            for (let _ = 0; !f && _ < c.length; _++) this.boundPaintVertexBuffers[_] !== c[_] && (f = !0);
            !this.vao || this.boundProgram !== r || this.boundLayoutVertexBuffer !== o || f || this.boundIndexBuffer !== h || this.boundVertexOffset !== z || this.boundDynamicVertexBuffer !== d || this.boundDynamicVertexBuffer2 !== I || this.boundDynamicVertexBuffer3 !== p ? this.freshBind(r, o, c, h, z, d, I, p) : (e.bindVertexArray.set(this.vao), d && d.bind(), h && h.dynamicDraw && h.bind(), I && I.bind(), p && p.bind());
          }
          freshBind(e, r, o, c, h, z, d, I) {
            const p = e.numAttributes, f = this.context, _ = f.gl;
            this.vao && this.destroy(), this.vao = f.createVertexArray(), f.bindVertexArray.set(this.vao), this.boundProgram = e, this.boundLayoutVertexBuffer = r, this.boundPaintVertexBuffers = o, this.boundIndexBuffer = c, this.boundVertexOffset = h, this.boundDynamicVertexBuffer = z, this.boundDynamicVertexBuffer2 = d, this.boundDynamicVertexBuffer3 = I, r.enableAttributes(_, e);
            for (const j of o) j.enableAttributes(_, e);
            z && z.enableAttributes(_, e), d && d.enableAttributes(_, e), I && I.enableAttributes(_, e), r.bind(), r.setVertexAttribPointers(_, e, h);
            for (const j of o) j.bind(), j.setVertexAttribPointers(_, e, h);
            z && (z.bind(), z.setVertexAttribPointers(_, e, h)), c && c.bind(), d && (d.bind(), d.setVertexAttribPointers(_, e, h)), I && (I.bind(), I.setVertexAttribPointers(_, e, h)), f.currentNumAttributes = p;
          }
          destroy() {
            this.vao && (this.context.deleteVertexArray(this.vao), this.vao = null);
          }
        }
        const Eo = (g, e, r, o, c) => ({ u_texture: 0, u_ele_delta: g, u_fog_matrix: e, u_fog_color: r ? r.properties.get("fog-color") : u.bo.white, u_fog_ground_blend: r ? r.properties.get("fog-ground-blend") : 1, u_fog_ground_blend_opacity: c ? 0 : r ? r.calculateFogBlendOpacity(o) : 0, u_horizon_color: r ? r.properties.get("horizon-color") : u.bo.white, u_horizon_fog_blend: r ? r.properties.get("horizon-fog-blend") : 1, u_is_globe_mode: c ? 1 : 0 }), Qn = { mainMatrix: "u_projection_matrix", tileMercatorCoords: "u_projection_tile_mercator_coords", clippingPlane: "u_projection_clipping_plane", projectionTransition: "u_projection_transition", fallbackMatrix: "u_projection_fallback_matrix" };
        function Hi(g) {
          const e = [];
          for (let r = 0; r < g.length; r++) {
            if (g[r] === null) continue;
            const o = g[r].split(" ");
            e.push(o.pop());
          }
          return e;
        }
        class _l {
          constructor(e, r, o, c, h, z, d, I, p = []) {
            const f = e.gl;
            this.program = f.createProgram();
            const _ = Hi(r.staticAttributes), j = o ? o.getBinderAttributes() : [], C = _.concat(j), v = Fs.prelude.staticUniforms ? Hi(Fs.prelude.staticUniforms) : [], F = d.staticUniforms ? Hi(d.staticUniforms) : [], Y = r.staticUniforms ? Hi(r.staticUniforms) : [], W = o ? o.getBinderUniforms() : [], Z = v.concat(F).concat(Y).concat(W), J = [];
            for (const nt of Z) J.indexOf(nt) < 0 && J.push(nt);
            const R = o ? o.defines() : [];
            qs(f) && R.unshift("#version 300 es"), h && R.push("#define OVERDRAW_INSPECTOR;"), z && R.push("#define TERRAIN3D;"), I && R.push(I), p && R.push(...p);
            let q = R.concat(Fs.prelude.fragmentSource, d.fragmentSource, r.fragmentSource).join(`
`), $ = R.concat(Fs.prelude.vertexSource, d.vertexSource, r.vertexSource).join(`
`);
            qs(f) || (q = (function(nt) {
              return nt.replace(/\bin\s/g, "varying ").replace("out highp vec4 fragColor;", "").replace(/fragColor/g, "gl_FragColor").replace(/texture\(/g, "texture2D(");
            })(q), $ = (function(nt) {
              return nt.replace(/\bin\s/g, "attribute ").replace(/\bout\s/g, "varying ").replace(/texture\(/g, "texture2D(");
            })($));
            const G = f.createShader(f.FRAGMENT_SHADER);
            if (f.isContextLost()) return void (this.failedToCreate = !0);
            if (f.shaderSource(G, q), f.compileShader(G), !f.getShaderParameter(G, f.COMPILE_STATUS)) throw new Error(`Could not compile fragment shader: ${f.getShaderInfoLog(G)}`);
            f.attachShader(this.program, G);
            const st = f.createShader(f.VERTEX_SHADER);
            if (f.isContextLost()) return void (this.failedToCreate = !0);
            if (f.shaderSource(st, $), f.compileShader(st), !f.getShaderParameter(st, f.COMPILE_STATUS)) throw new Error(`Could not compile vertex shader: ${f.getShaderInfoLog(st)}`);
            f.attachShader(this.program, st), this.attributes = {};
            const ct = {};
            this.numAttributes = C.length;
            for (let nt = 0; nt < this.numAttributes; nt++) C[nt] && (f.bindAttribLocation(this.program, nt, C[nt]), this.attributes[C[nt]] = nt);
            if (f.linkProgram(this.program), !f.getProgramParameter(this.program, f.LINK_STATUS)) throw new Error(`Program failed to link: ${f.getProgramInfoLog(this.program)}`);
            f.deleteShader(st), f.deleteShader(G);
            for (let nt = 0; nt < J.length; nt++) {
              const at = J[nt];
              if (at && !ct[at]) {
                const Mt = f.getUniformLocation(this.program, at);
                Mt && (ct[at] = Mt);
              }
            }
            this.fixedUniforms = c(e, ct), this.terrainUniforms = ((nt, at) => ({ u_depth: new u.bZ(nt, at.u_depth), u_terrain: new u.bZ(nt, at.u_terrain), u_terrain_dim: new u.bp(nt, at.u_terrain_dim), u_terrain_matrix: new u.b$(nt, at.u_terrain_matrix), u_terrain_unpack: new u.c0(nt, at.u_terrain_unpack), u_terrain_exaggeration: new u.bp(nt, at.u_terrain_exaggeration) }))(e, ct), this.projectionUniforms = ((nt, at) => ({ u_projection_matrix: new u.b$(nt, at.u_projection_matrix), u_projection_tile_mercator_coords: new u.c0(nt, at.u_projection_tile_mercator_coords), u_projection_clipping_plane: new u.c0(nt, at.u_projection_clipping_plane), u_projection_transition: new u.bp(nt, at.u_projection_transition), u_projection_fallback_matrix: new u.b$(nt, at.u_projection_fallback_matrix) }))(e, ct), this.binderUniforms = o ? o.getUniforms(e, ct) : [];
          }
          draw(e, r, o, c, h, z, d, I, p, f, _, j, C, v, F, Y, W, Z, J) {
            const R = e.gl;
            if (this.failedToCreate) return;
            if (e.program.set(this.program), e.setDepthMode(o), e.setStencilMode(c), e.setColorMode(h), e.setCullFace(z), I) {
              e.activeTexture.set(R.TEXTURE2), R.bindTexture(R.TEXTURE_2D, I.depthTexture), e.activeTexture.set(R.TEXTURE3), R.bindTexture(R.TEXTURE_2D, I.texture);
              for (const $ in this.terrainUniforms) this.terrainUniforms[$].set(I[$]);
            }
            if (p) for (const $ in p) this.projectionUniforms[Qn[$]].set(p[$]);
            if (d) for (const $ in this.fixedUniforms) this.fixedUniforms[$].set(d[$]);
            Y && Y.setUniforms(e, this.binderUniforms, v, { zoom: F });
            let q = 0;
            switch (r) {
              case R.LINES:
                q = 2;
                break;
              case R.TRIANGLES:
                q = 3;
                break;
              case R.LINE_STRIP:
                q = 1;
            }
            for (const $ of C.get()) {
              const G = $.vaos || ($.vaos = {});
              (G[f] || (G[f] = new jl())).bind(e, this, _, Y ? Y.getPaintVertexBuffers() : [], j, $.vertexOffset, W, Z, J), R.drawElements(r, $.primitiveLength * q, R.UNSIGNED_SHORT, $.primitiveOffset * q * 2);
            }
          }
        }
        function vn(g, e, r) {
          const o = 1 / u.aM(r, 1, e.transform.tileZoom), c = Math.pow(2, r.tileID.overscaledZ), h = r.tileSize * Math.pow(2, e.transform.tileZoom) / c, z = h * (r.tileID.canonical.x + r.tileID.wrap * c), d = h * r.tileID.canonical.y;
          return { u_image: 0, u_texsize: r.imageAtlasTexture.size, u_scale: [o, g.fromScale, g.toScale], u_fade: g.t, u_pixel_coord_upper: [z >> 16, d >> 16], u_pixel_coord_lower: [65535 & z, 65535 & d] };
        }
        const ic = (g, e, r, o) => {
          const c = g.style.light, h = c.properties.get("position"), z = [h.x, h.y, h.z], d = u.c3();
          c.properties.get("anchor") === "viewport" && u.c4(d, g.transform.bearingInRadians), u.c5(z, z, d);
          const I = g.transform.transformLightDirection(z), p = c.properties.get("color");
          return { u_lightpos: z, u_lightpos_globe: I, u_lightintensity: c.properties.get("intensity"), u_lightcolor: [p.r, p.g, p.b], u_vertical_gradient: +e, u_opacity: r, u_fill_translate: o };
        }, tn = (g, e, r, o, c, h, z) => u.e(ic(g, e, r, o), vn(h, g, z), { u_height_factor: -Math.pow(2, c.overscaledZ) / z.tileSize / 8 }), rc = (g, e, r, o) => u.e(vn(e, g, r), { u_fill_translate: o }), nc = (g, e) => ({ u_world: g, u_fill_translate: e }), Ll = (g, e, r, o, c) => u.e(rc(g, e, r, c), { u_world: o }), ac = (g, e, r, o, c) => {
          const h = g.transform;
          let z, d, I = 0;
          if (r.paint.get("circle-pitch-alignment") === "map") {
            const p = u.aM(e, 1, h.zoom);
            z = !0, d = [p, p], I = p / (u.a4 * Math.pow(2, e.tileID.overscaledZ)) * 2 * Math.PI * c;
          } else z = !1, d = h.pixelsToGLUnits;
          return { u_camera_to_center_distance: h.cameraToCenterDistance, u_scale_with_map: +(r.paint.get("circle-pitch-scale") === "map"), u_pitch_with_map: +z, u_device_pixel_ratio: g.pixelRatio, u_extrude_scale: d, u_globe_extrude_scale: I, u_translate: o };
        }, bo = (g) => ({ u_pixel_extrude_scale: [1 / g.width, 1 / g.height] }), oc = (g) => ({ u_viewport_size: [g.width, g.height] }), Qo = (g, e = 1) => ({ u_color: g, u_overlay: 0, u_overlay_scale: e }), vo = (g, e, r, o) => {
          const c = u.aM(g, 1, e) / (u.a4 * Math.pow(2, g.tileID.overscaledZ)) * 2 * Math.PI * o;
          return { u_extrude_scale: u.aM(g, 1, e), u_intensity: r, u_globe_extrude_scale: c };
        }, Bo = (g, e, r, o) => {
          const c = u.N();
          u.c6(c, 0, g.width, g.height, 0, 0, 1);
          const h = g.context.gl;
          return { u_matrix: c, u_world: [h.drawingBufferWidth, h.drawingBufferHeight], u_image: r, u_color_ramp: o, u_opacity: e.paint.get("heatmap-opacity") };
        }, dr = (g, e, r) => {
          const o = r.paint.get("hillshade-accent-color");
          let c;
          switch (r.paint.get("hillshade-method")) {
            case "basic":
              c = 4;
              break;
            case "combined":
              c = 1;
              break;
            case "igor":
              c = 2;
              break;
            case "multidirectional":
              c = 3;
              break;
            default:
              c = 0;
          }
          const h = r.getIlluminationProperties();
          for (let z = 0; z < h.directionRadians.length; z++) r.paint.get("hillshade-illumination-anchor") === "viewport" && (h.directionRadians[z] += g.transform.bearingInRadians);
          return { u_image: 0, u_latrange: cc(0, e.tileID), u_exaggeration: r.paint.get("hillshade-exaggeration"), u_altitudes: h.altitudeRadians, u_azimuths: h.directionRadians, u_accent: o, u_method: c, u_highlights: h.highlightColor, u_shadows: h.shadowColor };
        }, Mc = (g, e) => {
          const r = e.stride, o = u.N();
          return u.c6(o, 0, u.a4, -u.a4, 0, 0, 1), u.O(o, o, [0, -u.a4, 0]), { u_matrix: o, u_image: 1, u_dimension: [r, r], u_zoom: g.overscaledZ, u_unpack: e.getUnpackVector() };
        };
        function cc(g, e) {
          const r = Math.pow(2, e.canonical.z), o = e.canonical.y;
          return [new u.aa(0, o / r).toLngLat().lat, new u.aa(0, (o + 1) / r).toLngLat().lat];
        }
        const Bn = (g, e, r = 0) => ({ u_image: 0, u_unpack: e.getUnpackVector(), u_dimension: [e.stride, e.stride], u_elevation_stops: 1, u_color_stops: 4, u_color_ramp_size: r, u_opacity: g.paint.get("color-relief-opacity") }), La = (g, e, r, o) => {
          const c = g.transform;
          return { u_translation: So(g, e, r), u_ratio: o / u.aM(e, 1, c.zoom), u_device_pixel_ratio: g.pixelRatio, u_units_to_pixels: [1 / c.pixelsToGLUnits[0], 1 / c.pixelsToGLUnits[1]] };
        }, Sn = (g, e, r, o, c) => u.e(La(g, e, r, o), { u_image: 0, u_image_height: c }), Cl = (g, e, r, o, c) => {
          const h = g.transform, z = Ca(e, h);
          return { u_translation: So(g, e, r), u_texsize: e.imageAtlasTexture.size, u_ratio: o / u.aM(e, 1, h.zoom), u_device_pixel_ratio: g.pixelRatio, u_image: 0, u_scale: [z, c.fromScale, c.toScale], u_fade: c.t, u_units_to_pixels: [1 / h.pixelsToGLUnits[0], 1 / h.pixelsToGLUnits[1]] };
        }, Ol = (g, e, r, o, c) => {
          const h = Ca(e, g.transform);
          return u.e(La(g, e, r, o), { u_tileratio: h, u_crossfade_from: c.fromScale, u_crossfade_to: c.toScale, u_image: 0, u_mix: c.t, u_lineatlas_width: g.lineAtlas.width, u_lineatlas_height: g.lineAtlas.height });
        }, lc = (g, e, r, o, c, h) => {
          const z = Ca(e, g.transform);
          return u.e(La(g, e, r, o), { u_image: 0, u_image_height: h, u_tileratio: z, u_crossfade_from: c.fromScale, u_crossfade_to: c.toScale, u_image_dash: 1, u_mix: c.t, u_lineatlas_width: g.lineAtlas.width, u_lineatlas_height: g.lineAtlas.height });
        };
        function Ca(g, e) {
          return 1 / u.aM(g, 1, e.tileZoom);
        }
        function So(g, e, r) {
          return u.aN(g.transform, e, r.paint.get("line-translate"), r.paint.get("line-translate-anchor"));
        }
        const ko = (g, e, r, o, c) => {
          return { u_tl_parent: g, u_scale_parent: e, u_buffer_scale: 1, u_fade_t: r.mix, u_opacity: r.opacity * o.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: o.paint.get("raster-brightness-min"), u_brightness_high: o.paint.get("raster-brightness-max"), u_saturation_factor: (z = o.paint.get("raster-saturation"), z > 0 ? 1 - 1 / (1.001 - z) : -z), u_contrast_factor: (h = o.paint.get("raster-contrast"), h > 0 ? 1 / (1 - h) : 1 + h), u_spin_weights: uc(o.paint.get("raster-hue-rotate")), u_coords_top: [c[0].x, c[0].y, c[1].x, c[1].y], u_coords_bottom: [c[3].x, c[3].y, c[2].x, c[2].y] };
          var h, z;
        };
        function uc(g) {
          g *= Math.PI / 180;
          const e = Math.sin(g), r = Math.cos(g);
          return [(2 * r + 1) / 3, (-Math.sqrt(3) * e - r + 1) / 3, (Math.sqrt(3) * e - r + 1) / 3];
        }
        const kn = (g, e, r, o, c, h, z, d, I, p, f, _, j) => {
          const C = z.transform;
          return { u_is_size_zoom_constant: +(g === "constant" || g === "source"), u_is_size_feature_constant: +(g === "constant" || g === "camera"), u_size_t: e ? e.uSizeT : 0, u_size: e ? e.uSize : 0, u_camera_to_center_distance: C.cameraToCenterDistance, u_pitch: C.pitch / 360 * 2 * Math.PI, u_rotate_symbol: +r, u_aspect_ratio: C.width / C.height, u_fade_change: z.options.fadeDuration ? z.symbolFadeChange : 1, u_label_plane_matrix: d, u_coord_matrix: I, u_is_text: +f, u_pitch_with_map: +o, u_is_along_line: c, u_is_variable_anchor: h, u_texsize: _, u_texture: 0, u_translation: p, u_pitched_scale: j };
        }, zi = (g, e, r, o, c, h, z, d, I, p, f, _, j, C) => {
          const v = z.transform;
          return u.e(kn(g, e, r, o, c, h, z, d, I, p, f, _, C), { u_gamma_scale: o ? Math.cos(v.pitch * Math.PI / 180) * v.cameraToCenterDistance : 1, u_device_pixel_ratio: z.pixelRatio, u_is_halo: 1 });
        }, Fo = (g, e, r, o, c, h, z, d, I, p, f, _, j) => u.e(zi(g, e, r, o, c, h, z, d, I, p, !0, f, 0, j), { u_texsize_icon: _, u_texture_icon: 1 }), Yo = (g, e) => ({ u_opacity: g, u_color: e }), Uo = (g, e, r, o, c) => u.e((function(h, z, d, I) {
          const p = d.imageManager.getPattern(h.from.toString()), f = d.imageManager.getPattern(h.to.toString()), { width: _, height: j } = d.imageManager.getPixelSize(), C = Math.pow(2, I.tileID.overscaledZ), v = I.tileSize * Math.pow(2, d.transform.tileZoom) / C, F = v * (I.tileID.canonical.x + I.tileID.wrap * C), Y = v * I.tileID.canonical.y;
          return { u_image: 0, u_pattern_tl_a: p.tl, u_pattern_br_a: p.br, u_pattern_tl_b: f.tl, u_pattern_br_b: f.br, u_texsize: [_, j], u_mix: z.t, u_pattern_size_a: p.displaySize, u_pattern_size_b: f.displaySize, u_scale_a: z.fromScale, u_scale_b: z.toScale, u_tile_units_to_pixels: 1 / u.aM(I, 1, d.transform.tileZoom), u_pixel_coord_upper: [F >> 16, Y >> 16], u_pixel_coord_lower: [65535 & F, 65535 & Y] };
        })(r, c, e, o), { u_opacity: g }), Xo = (g, e) => {
        }, Wo = { fillExtrusion: (g, e) => ({ u_lightpos: new u.c1(g, e.u_lightpos), u_lightpos_globe: new u.c1(g, e.u_lightpos_globe), u_lightintensity: new u.bp(g, e.u_lightintensity), u_lightcolor: new u.c1(g, e.u_lightcolor), u_vertical_gradient: new u.bp(g, e.u_vertical_gradient), u_opacity: new u.bp(g, e.u_opacity), u_fill_translate: new u.c2(g, e.u_fill_translate) }), fillExtrusionPattern: (g, e) => ({ u_lightpos: new u.c1(g, e.u_lightpos), u_lightpos_globe: new u.c1(g, e.u_lightpos_globe), u_lightintensity: new u.bp(g, e.u_lightintensity), u_lightcolor: new u.c1(g, e.u_lightcolor), u_vertical_gradient: new u.bp(g, e.u_vertical_gradient), u_height_factor: new u.bp(g, e.u_height_factor), u_opacity: new u.bp(g, e.u_opacity), u_fill_translate: new u.c2(g, e.u_fill_translate), u_image: new u.bZ(g, e.u_image), u_texsize: new u.c2(g, e.u_texsize), u_pixel_coord_upper: new u.c2(g, e.u_pixel_coord_upper), u_pixel_coord_lower: new u.c2(g, e.u_pixel_coord_lower), u_scale: new u.c1(g, e.u_scale), u_fade: new u.bp(g, e.u_fade) }), fill: (g, e) => ({ u_fill_translate: new u.c2(g, e.u_fill_translate) }), fillPattern: (g, e) => ({ u_image: new u.bZ(g, e.u_image), u_texsize: new u.c2(g, e.u_texsize), u_pixel_coord_upper: new u.c2(g, e.u_pixel_coord_upper), u_pixel_coord_lower: new u.c2(g, e.u_pixel_coord_lower), u_scale: new u.c1(g, e.u_scale), u_fade: new u.bp(g, e.u_fade), u_fill_translate: new u.c2(g, e.u_fill_translate) }), fillOutline: (g, e) => ({ u_world: new u.c2(g, e.u_world), u_fill_translate: new u.c2(g, e.u_fill_translate) }), fillOutlinePattern: (g, e) => ({ u_world: new u.c2(g, e.u_world), u_image: new u.bZ(g, e.u_image), u_texsize: new u.c2(g, e.u_texsize), u_pixel_coord_upper: new u.c2(g, e.u_pixel_coord_upper), u_pixel_coord_lower: new u.c2(g, e.u_pixel_coord_lower), u_scale: new u.c1(g, e.u_scale), u_fade: new u.bp(g, e.u_fade), u_fill_translate: new u.c2(g, e.u_fill_translate) }), circle: (g, e) => ({ u_camera_to_center_distance: new u.bp(g, e.u_camera_to_center_distance), u_scale_with_map: new u.bZ(g, e.u_scale_with_map), u_pitch_with_map: new u.bZ(g, e.u_pitch_with_map), u_extrude_scale: new u.c2(g, e.u_extrude_scale), u_device_pixel_ratio: new u.bp(g, e.u_device_pixel_ratio), u_globe_extrude_scale: new u.bp(g, e.u_globe_extrude_scale), u_translate: new u.c2(g, e.u_translate) }), collisionBox: (g, e) => ({ u_pixel_extrude_scale: new u.c2(g, e.u_pixel_extrude_scale) }), collisionCircle: (g, e) => ({ u_viewport_size: new u.c2(g, e.u_viewport_size) }), debug: (g, e) => ({ u_color: new u.b_(g, e.u_color), u_overlay: new u.bZ(g, e.u_overlay), u_overlay_scale: new u.bp(g, e.u_overlay_scale) }), depth: Xo, clippingMask: Xo, heatmap: (g, e) => ({ u_extrude_scale: new u.bp(g, e.u_extrude_scale), u_intensity: new u.bp(g, e.u_intensity), u_globe_extrude_scale: new u.bp(g, e.u_globe_extrude_scale) }), heatmapTexture: (g, e) => ({ u_matrix: new u.b$(g, e.u_matrix), u_world: new u.c2(g, e.u_world), u_image: new u.bZ(g, e.u_image), u_color_ramp: new u.bZ(g, e.u_color_ramp), u_opacity: new u.bp(g, e.u_opacity) }), hillshade: (g, e) => ({ u_image: new u.bZ(g, e.u_image), u_latrange: new u.c2(g, e.u_latrange), u_exaggeration: new u.bp(g, e.u_exaggeration), u_altitudes: new u.c8(g, e.u_altitudes), u_azimuths: new u.c8(g, e.u_azimuths), u_accent: new u.b_(g, e.u_accent), u_method: new u.bZ(g, e.u_method), u_shadows: new u.c7(g, e.u_shadows), u_highlights: new u.c7(g, e.u_highlights) }), hillshadePrepare: (g, e) => ({ u_matrix: new u.b$(g, e.u_matrix), u_image: new u.bZ(g, e.u_image), u_dimension: new u.c2(g, e.u_dimension), u_zoom: new u.bp(g, e.u_zoom), u_unpack: new u.c0(g, e.u_unpack) }), colorRelief: (g, e) => ({ u_image: new u.bZ(g, e.u_image), u_unpack: new u.c0(g, e.u_unpack), u_dimension: new u.c2(g, e.u_dimension), u_elevation_stops: new u.bZ(g, e.u_elevation_stops), u_color_stops: new u.bZ(g, e.u_color_stops), u_color_ramp_size: new u.bZ(g, e.u_color_ramp_size), u_opacity: new u.bp(g, e.u_opacity) }), line: (g, e) => ({ u_translation: new u.c2(g, e.u_translation), u_ratio: new u.bp(g, e.u_ratio), u_device_pixel_ratio: new u.bp(g, e.u_device_pixel_ratio), u_units_to_pixels: new u.c2(g, e.u_units_to_pixels) }), lineGradient: (g, e) => ({ u_translation: new u.c2(g, e.u_translation), u_ratio: new u.bp(g, e.u_ratio), u_device_pixel_ratio: new u.bp(g, e.u_device_pixel_ratio), u_units_to_pixels: new u.c2(g, e.u_units_to_pixels), u_image: new u.bZ(g, e.u_image), u_image_height: new u.bp(g, e.u_image_height) }), linePattern: (g, e) => ({ u_translation: new u.c2(g, e.u_translation), u_texsize: new u.c2(g, e.u_texsize), u_ratio: new u.bp(g, e.u_ratio), u_device_pixel_ratio: new u.bp(g, e.u_device_pixel_ratio), u_image: new u.bZ(g, e.u_image), u_units_to_pixels: new u.c2(g, e.u_units_to_pixels), u_scale: new u.c1(g, e.u_scale), u_fade: new u.bp(g, e.u_fade) }), lineSDF: (g, e) => ({ u_translation: new u.c2(g, e.u_translation), u_ratio: new u.bp(g, e.u_ratio), u_device_pixel_ratio: new u.bp(g, e.u_device_pixel_ratio), u_units_to_pixels: new u.c2(g, e.u_units_to_pixels), u_image: new u.bZ(g, e.u_image), u_mix: new u.bp(g, e.u_mix), u_tileratio: new u.bp(g, e.u_tileratio), u_crossfade_from: new u.bp(g, e.u_crossfade_from), u_crossfade_to: new u.bp(g, e.u_crossfade_to), u_lineatlas_width: new u.bp(g, e.u_lineatlas_width), u_lineatlas_height: new u.bp(g, e.u_lineatlas_height) }), lineGradientSDF: (g, e) => ({ u_translation: new u.c2(g, e.u_translation), u_ratio: new u.bp(g, e.u_ratio), u_device_pixel_ratio: new u.bp(g, e.u_device_pixel_ratio), u_units_to_pixels: new u.c2(g, e.u_units_to_pixels), u_image: new u.bZ(g, e.u_image), u_image_height: new u.bp(g, e.u_image_height), u_tileratio: new u.bp(g, e.u_tileratio), u_crossfade_from: new u.bp(g, e.u_crossfade_from), u_crossfade_to: new u.bp(g, e.u_crossfade_to), u_image_dash: new u.bZ(g, e.u_image_dash), u_mix: new u.bp(g, e.u_mix), u_lineatlas_width: new u.bp(g, e.u_lineatlas_width), u_lineatlas_height: new u.bp(g, e.u_lineatlas_height) }), raster: (g, e) => ({ u_tl_parent: new u.c2(g, e.u_tl_parent), u_scale_parent: new u.bp(g, e.u_scale_parent), u_buffer_scale: new u.bp(g, e.u_buffer_scale), u_fade_t: new u.bp(g, e.u_fade_t), u_opacity: new u.bp(g, e.u_opacity), u_image0: new u.bZ(g, e.u_image0), u_image1: new u.bZ(g, e.u_image1), u_brightness_low: new u.bp(g, e.u_brightness_low), u_brightness_high: new u.bp(g, e.u_brightness_high), u_saturation_factor: new u.bp(g, e.u_saturation_factor), u_contrast_factor: new u.bp(g, e.u_contrast_factor), u_spin_weights: new u.c1(g, e.u_spin_weights), u_coords_top: new u.c0(g, e.u_coords_top), u_coords_bottom: new u.c0(g, e.u_coords_bottom) }), symbolIcon: (g, e) => ({ u_is_size_zoom_constant: new u.bZ(g, e.u_is_size_zoom_constant), u_is_size_feature_constant: new u.bZ(g, e.u_is_size_feature_constant), u_size_t: new u.bp(g, e.u_size_t), u_size: new u.bp(g, e.u_size), u_camera_to_center_distance: new u.bp(g, e.u_camera_to_center_distance), u_pitch: new u.bp(g, e.u_pitch), u_rotate_symbol: new u.bZ(g, e.u_rotate_symbol), u_aspect_ratio: new u.bp(g, e.u_aspect_ratio), u_fade_change: new u.bp(g, e.u_fade_change), u_label_plane_matrix: new u.b$(g, e.u_label_plane_matrix), u_coord_matrix: new u.b$(g, e.u_coord_matrix), u_is_text: new u.bZ(g, e.u_is_text), u_pitch_with_map: new u.bZ(g, e.u_pitch_with_map), u_is_along_line: new u.bZ(g, e.u_is_along_line), u_is_variable_anchor: new u.bZ(g, e.u_is_variable_anchor), u_texsize: new u.c2(g, e.u_texsize), u_texture: new u.bZ(g, e.u_texture), u_translation: new u.c2(g, e.u_translation), u_pitched_scale: new u.bp(g, e.u_pitched_scale) }), symbolSDF: (g, e) => ({ u_is_size_zoom_constant: new u.bZ(g, e.u_is_size_zoom_constant), u_is_size_feature_constant: new u.bZ(g, e.u_is_size_feature_constant), u_size_t: new u.bp(g, e.u_size_t), u_size: new u.bp(g, e.u_size), u_camera_to_center_distance: new u.bp(g, e.u_camera_to_center_distance), u_pitch: new u.bp(g, e.u_pitch), u_rotate_symbol: new u.bZ(g, e.u_rotate_symbol), u_aspect_ratio: new u.bp(g, e.u_aspect_ratio), u_fade_change: new u.bp(g, e.u_fade_change), u_label_plane_matrix: new u.b$(g, e.u_label_plane_matrix), u_coord_matrix: new u.b$(g, e.u_coord_matrix), u_is_text: new u.bZ(g, e.u_is_text), u_pitch_with_map: new u.bZ(g, e.u_pitch_with_map), u_is_along_line: new u.bZ(g, e.u_is_along_line), u_is_variable_anchor: new u.bZ(g, e.u_is_variable_anchor), u_texsize: new u.c2(g, e.u_texsize), u_texture: new u.bZ(g, e.u_texture), u_gamma_scale: new u.bp(g, e.u_gamma_scale), u_device_pixel_ratio: new u.bp(g, e.u_device_pixel_ratio), u_is_halo: new u.bZ(g, e.u_is_halo), u_translation: new u.c2(g, e.u_translation), u_pitched_scale: new u.bp(g, e.u_pitched_scale) }), symbolTextAndIcon: (g, e) => ({ u_is_size_zoom_constant: new u.bZ(g, e.u_is_size_zoom_constant), u_is_size_feature_constant: new u.bZ(g, e.u_is_size_feature_constant), u_size_t: new u.bp(g, e.u_size_t), u_size: new u.bp(g, e.u_size), u_camera_to_center_distance: new u.bp(g, e.u_camera_to_center_distance), u_pitch: new u.bp(g, e.u_pitch), u_rotate_symbol: new u.bZ(g, e.u_rotate_symbol), u_aspect_ratio: new u.bp(g, e.u_aspect_ratio), u_fade_change: new u.bp(g, e.u_fade_change), u_label_plane_matrix: new u.b$(g, e.u_label_plane_matrix), u_coord_matrix: new u.b$(g, e.u_coord_matrix), u_is_text: new u.bZ(g, e.u_is_text), u_pitch_with_map: new u.bZ(g, e.u_pitch_with_map), u_is_along_line: new u.bZ(g, e.u_is_along_line), u_is_variable_anchor: new u.bZ(g, e.u_is_variable_anchor), u_texsize: new u.c2(g, e.u_texsize), u_texsize_icon: new u.c2(g, e.u_texsize_icon), u_texture: new u.bZ(g, e.u_texture), u_texture_icon: new u.bZ(g, e.u_texture_icon), u_gamma_scale: new u.bp(g, e.u_gamma_scale), u_device_pixel_ratio: new u.bp(g, e.u_device_pixel_ratio), u_is_halo: new u.bZ(g, e.u_is_halo), u_translation: new u.c2(g, e.u_translation), u_pitched_scale: new u.bp(g, e.u_pitched_scale) }), background: (g, e) => ({ u_opacity: new u.bp(g, e.u_opacity), u_color: new u.b_(g, e.u_color) }), backgroundPattern: (g, e) => ({ u_opacity: new u.bp(g, e.u_opacity), u_image: new u.bZ(g, e.u_image), u_pattern_tl_a: new u.c2(g, e.u_pattern_tl_a), u_pattern_br_a: new u.c2(g, e.u_pattern_br_a), u_pattern_tl_b: new u.c2(g, e.u_pattern_tl_b), u_pattern_br_b: new u.c2(g, e.u_pattern_br_b), u_texsize: new u.c2(g, e.u_texsize), u_mix: new u.bp(g, e.u_mix), u_pattern_size_a: new u.c2(g, e.u_pattern_size_a), u_pattern_size_b: new u.c2(g, e.u_pattern_size_b), u_scale_a: new u.bp(g, e.u_scale_a), u_scale_b: new u.bp(g, e.u_scale_b), u_pixel_coord_upper: new u.c2(g, e.u_pixel_coord_upper), u_pixel_coord_lower: new u.c2(g, e.u_pixel_coord_lower), u_tile_units_to_pixels: new u.bp(g, e.u_tile_units_to_pixels) }), terrain: (g, e) => ({ u_texture: new u.bZ(g, e.u_texture), u_ele_delta: new u.bp(g, e.u_ele_delta), u_fog_matrix: new u.b$(g, e.u_fog_matrix), u_fog_color: new u.b_(g, e.u_fog_color), u_fog_ground_blend: new u.bp(g, e.u_fog_ground_blend), u_fog_ground_blend_opacity: new u.bp(g, e.u_fog_ground_blend_opacity), u_horizon_color: new u.b_(g, e.u_horizon_color), u_horizon_fog_blend: new u.bp(g, e.u_horizon_fog_blend), u_is_globe_mode: new u.bp(g, e.u_is_globe_mode) }), terrainDepth: (g, e) => ({ u_ele_delta: new u.bp(g, e.u_ele_delta) }), terrainCoords: (g, e) => ({ u_texture: new u.bZ(g, e.u_texture), u_terrain_coords_id: new u.bp(g, e.u_terrain_coords_id), u_ele_delta: new u.bp(g, e.u_ele_delta) }), projectionErrorMeasurement: (g, e) => ({ u_input: new u.bp(g, e.u_input), u_output_expected: new u.bp(g, e.u_output_expected) }), atmosphere: (g, e) => ({ u_sun_pos: new u.c1(g, e.u_sun_pos), u_atmosphere_blend: new u.bp(g, e.u_atmosphere_blend), u_globe_position: new u.c1(g, e.u_globe_position), u_globe_radius: new u.bp(g, e.u_globe_radius), u_inv_proj_matrix: new u.b$(g, e.u_inv_proj_matrix) }), sky: (g, e) => ({ u_sky_color: new u.b_(g, e.u_sky_color), u_horizon_color: new u.b_(g, e.u_horizon_color), u_horizon: new u.c2(g, e.u_horizon), u_horizon_normal: new u.c2(g, e.u_horizon_normal), u_sky_horizon_blend: new u.bp(g, e.u_sky_horizon_blend), u_sky_blend: new u.bp(g, e.u_sky_blend) }) };
        class yr {
          constructor(e, r, o) {
            this.context = e;
            const c = e.gl;
            this.buffer = c.createBuffer(), this.dynamicDraw = !!o, this.context.unbindVAO(), e.bindElementBuffer.set(this.buffer), c.bufferData(c.ELEMENT_ARRAY_BUFFER, r.arrayBuffer, this.dynamicDraw ? c.DYNAMIC_DRAW : c.STATIC_DRAW), this.dynamicDraw || delete r.arrayBuffer;
          }
          bind() {
            this.context.bindElementBuffer.set(this.buffer);
          }
          updateData(e) {
            const r = this.context.gl;
            if (!this.dynamicDraw) throw new Error("Attempted to update data while not in dynamic mode.");
            this.context.unbindVAO(), this.bind(), r.bufferSubData(r.ELEMENT_ARRAY_BUFFER, 0, e.arrayBuffer);
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        const Po = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
        class El {
          constructor(e, r, o, c) {
            this.length = r.length, this.attributes = o, this.itemSize = r.bytesPerElement, this.dynamicDraw = c, this.context = e;
            const h = e.gl;
            this.buffer = h.createBuffer(), e.bindVertexBuffer.set(this.buffer), h.bufferData(h.ARRAY_BUFFER, r.arrayBuffer, this.dynamicDraw ? h.DYNAMIC_DRAW : h.STATIC_DRAW), this.dynamicDraw || delete r.arrayBuffer;
          }
          bind() {
            this.context.bindVertexBuffer.set(this.buffer);
          }
          updateData(e) {
            if (e.length !== this.length) throw new Error(`Length of new data is ${e.length}, which doesn't match current length of ${this.length}`);
            const r = this.context.gl;
            this.bind(), r.bufferSubData(r.ARRAY_BUFFER, 0, e.arrayBuffer);
          }
          enableAttributes(e, r) {
            for (let o = 0; o < this.attributes.length; o++) {
              const c = r.attributes[this.attributes[o].name];
              c !== void 0 && e.enableVertexAttribArray(c);
            }
          }
          setVertexAttribPointers(e, r, o) {
            for (let c = 0; c < this.attributes.length; c++) {
              const h = this.attributes[c], z = r.attributes[h.name];
              z !== void 0 && e.vertexAttribPointer(z, h.components, e[Po[h.type]], !1, this.itemSize, h.offset + this.itemSize * (o || 0));
            }
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        class ee {
          constructor(e) {
            this.gl = e.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1;
          }
          get() {
            return this.current;
          }
          set(e) {
          }
          getDefault() {
            return this.default;
          }
          setDefault() {
            this.set(this.default);
          }
        }
        class bl extends ee {
          getDefault() {
            return u.bo.transparent;
          }
          set(e) {
            const r = this.current;
            (e.r !== r.r || e.g !== r.g || e.b !== r.b || e.a !== r.a || this.dirty) && (this.gl.clearColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1);
          }
        }
        class Ql extends ee {
          getDefault() {
            return 1;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.clearDepth(e), this.current = e, this.dirty = !1);
          }
        }
        class gc extends ee {
          getDefault() {
            return 0;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.clearStencil(e), this.current = e, this.dirty = !1);
          }
        }
        class vl extends ee {
          getDefault() {
            return [!0, !0, !0, !0];
          }
          set(e) {
            const r = this.current;
            (e[0] !== r[0] || e[1] !== r[1] || e[2] !== r[2] || e[3] !== r[3] || this.dirty) && (this.gl.colorMask(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1);
          }
        }
        class hc extends ee {
          getDefault() {
            return !0;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.depthMask(e), this.current = e, this.dirty = !1);
          }
        }
        class Oa extends ee {
          getDefault() {
            return 255;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.stencilMask(e), this.current = e, this.dirty = !1);
          }
        }
        class Ea extends ee {
          getDefault() {
            return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
          }
          set(e) {
            const r = this.current;
            (e.func !== r.func || e.ref !== r.ref || e.mask !== r.mask || this.dirty) && (this.gl.stencilFunc(e.func, e.ref, e.mask), this.current = e, this.dirty = !1);
          }
        }
        class ba extends ee {
          getDefault() {
            const e = this.gl;
            return [e.KEEP, e.KEEP, e.KEEP];
          }
          set(e) {
            const r = this.current;
            (e[0] !== r[0] || e[1] !== r[1] || e[2] !== r[2] || this.dirty) && (this.gl.stencilOp(e[0], e[1], e[2]), this.current = e, this.dirty = !1);
          }
        }
        class Ro extends ee {
          getDefault() {
            return !1;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const r = this.gl;
            e ? r.enable(r.STENCIL_TEST) : r.disable(r.STENCIL_TEST), this.current = e, this.dirty = !1;
          }
        }
        class Ir extends ee {
          getDefault() {
            return [0, 1];
          }
          set(e) {
            const r = this.current;
            (e[0] !== r[0] || e[1] !== r[1] || this.dirty) && (this.gl.depthRange(e[0], e[1]), this.current = e, this.dirty = !1);
          }
        }
        class Fn extends ee {
          getDefault() {
            return !1;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const r = this.gl;
            e ? r.enable(r.DEPTH_TEST) : r.disable(r.DEPTH_TEST), this.current = e, this.dirty = !1;
          }
        }
        class en extends ee {
          getDefault() {
            return this.gl.LESS;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.depthFunc(e), this.current = e, this.dirty = !1);
          }
        }
        class Ys extends ee {
          getDefault() {
            return !1;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const r = this.gl;
            e ? r.enable(r.BLEND) : r.disable(r.BLEND), this.current = e, this.dirty = !1;
          }
        }
        class Dc extends ee {
          getDefault() {
            const e = this.gl;
            return [e.ONE, e.ZERO];
          }
          set(e) {
            const r = this.current;
            (e[0] !== r[0] || e[1] !== r[1] || this.dirty) && (this.gl.blendFunc(e[0], e[1]), this.current = e, this.dirty = !1);
          }
        }
        class zc extends ee {
          getDefault() {
            return u.bo.transparent;
          }
          set(e) {
            const r = this.current;
            (e.r !== r.r || e.g !== r.g || e.b !== r.b || e.a !== r.a || this.dirty) && (this.gl.blendColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1);
          }
        }
        class Zo extends ee {
          getDefault() {
            return this.gl.FUNC_ADD;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.blendEquation(e), this.current = e, this.dirty = !1);
          }
        }
        class wr extends ee {
          getDefault() {
            return !1;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const r = this.gl;
            e ? r.enable(r.CULL_FACE) : r.disable(r.CULL_FACE), this.current = e, this.dirty = !1;
          }
        }
        class Qa extends ee {
          getDefault() {
            return this.gl.BACK;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.cullFace(e), this.current = e, this.dirty = !1);
          }
        }
        class va extends ee {
          getDefault() {
            return this.gl.CCW;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.frontFace(e), this.current = e, this.dirty = !1);
          }
        }
        class Yn extends ee {
          getDefault() {
            return null;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.useProgram(e), this.current = e, this.dirty = !1);
          }
        }
        class Ba extends ee {
          getDefault() {
            return this.gl.TEXTURE0;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.activeTexture(e), this.current = e, this.dirty = !1);
          }
        }
        class Nc extends ee {
          getDefault() {
            const e = this.gl;
            return [0, 0, e.drawingBufferWidth, e.drawingBufferHeight];
          }
          set(e) {
            const r = this.current;
            (e[0] !== r[0] || e[1] !== r[1] || e[2] !== r[2] || e[3] !== r[3] || this.dirty) && (this.gl.viewport(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1);
          }
        }
        class sn extends ee {
          getDefault() {
            return null;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const r = this.gl;
            r.bindFramebuffer(r.FRAMEBUFFER, e), this.current = e, this.dirty = !1;
          }
        }
        class rn extends ee {
          getDefault() {
            return null;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const r = this.gl;
            r.bindRenderbuffer(r.RENDERBUFFER, e), this.current = e, this.dirty = !1;
          }
        }
        class dc extends ee {
          getDefault() {
            return null;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const r = this.gl;
            r.bindTexture(r.TEXTURE_2D, e), this.current = e, this.dirty = !1;
          }
        }
        class Vo extends ee {
          getDefault() {
            return null;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const r = this.gl;
            r.bindBuffer(r.ARRAY_BUFFER, e), this.current = e, this.dirty = !1;
          }
        }
        class Gt extends ee {
          getDefault() {
            return null;
          }
          set(e) {
            const r = this.gl;
            r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, e), this.current = e, this.dirty = !1;
          }
        }
        class Sa extends ee {
          getDefault() {
            return null;
          }
          set(e) {
            var r;
            if (e === this.current && !this.dirty) return;
            const o = this.gl;
            qs(o) ? o.bindVertexArray(e) : (r = o.getExtension("OES_vertex_array_object")) === null || r === void 0 || r.bindVertexArrayOES(e), this.current = e, this.dirty = !1;
          }
        }
        class Bl extends ee {
          getDefault() {
            return 4;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const r = this.gl;
            r.pixelStorei(r.UNPACK_ALIGNMENT, e), this.current = e, this.dirty = !1;
          }
        }
        class yc extends ee {
          getDefault() {
            return !1;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const r = this.gl;
            r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e), this.current = e, this.dirty = !1;
          }
        }
        class Un extends ee {
          getDefault() {
            return !1;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const r = this.gl;
            r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, e), this.current = e, this.dirty = !1;
          }
        }
        class Go extends ee {
          constructor(e, r) {
            super(e), this.context = e, this.parent = r;
          }
          getDefault() {
            return null;
          }
        }
        class Sl extends Go {
          setDirty() {
            this.dirty = !0;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const r = this.gl;
            r.framebufferTexture2D(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, e, 0), this.current = e, this.dirty = !1;
          }
        }
        class Ic extends Go {
          set(e) {
            if (e === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const r = this.gl;
            r.framebufferRenderbuffer(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.RENDERBUFFER, e), this.current = e, this.dirty = !1;
          }
        }
        class kl extends Go {
          set(e) {
            if (e === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const r = this.gl;
            r.framebufferRenderbuffer(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.RENDERBUFFER, e), this.current = e, this.dirty = !1;
          }
        }
        const ka = "Framebuffer is not complete";
        class Fa {
          constructor(e, r, o, c, h) {
            this.context = e, this.width = r, this.height = o;
            const z = e.gl, d = this.framebuffer = z.createFramebuffer();
            if (this.colorAttachment = new Sl(e, d), c) this.depthAttachment = h ? new kl(e, d) : new Ic(e, d);
            else if (h) throw new Error("Stencil cannot be set without depth");
            if (z.checkFramebufferStatus(z.FRAMEBUFFER) !== z.FRAMEBUFFER_COMPLETE) throw new Error(ka);
          }
          destroy() {
            const e = this.context.gl, r = this.colorAttachment.get();
            if (r && e.deleteTexture(r), this.depthAttachment) {
              const o = this.depthAttachment.get();
              o && e.deleteRenderbuffer(o);
            }
            e.deleteFramebuffer(this.framebuffer);
          }
        }
        class Ya {
          constructor(e) {
            var r, o;
            if (this.gl = e, this.clearColor = new bl(this), this.clearDepth = new Ql(this), this.clearStencil = new gc(this), this.colorMask = new vl(this), this.depthMask = new hc(this), this.stencilMask = new Oa(this), this.stencilFunc = new Ea(this), this.stencilOp = new ba(this), this.stencilTest = new Ro(this), this.depthRange = new Ir(this), this.depthTest = new Fn(this), this.depthFunc = new en(this), this.blend = new Ys(this), this.blendFunc = new Dc(this), this.blendColor = new zc(this), this.blendEquation = new Zo(this), this.cullFace = new wr(this), this.cullFaceSide = new Qa(this), this.frontFace = new va(this), this.program = new Yn(this), this.activeTexture = new Ba(this), this.viewport = new Nc(this), this.bindFramebuffer = new sn(this), this.bindRenderbuffer = new rn(this), this.bindTexture = new dc(this), this.bindVertexBuffer = new Vo(this), this.bindElementBuffer = new Gt(this), this.bindVertexArray = new Sa(this), this.pixelStoreUnpack = new Bl(this), this.pixelStoreUnpackPremultiplyAlpha = new yc(this), this.pixelStoreUnpackFlipY = new Un(this), this.extTextureFilterAnisotropic = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.maxTextureSize = e.getParameter(e.MAX_TEXTURE_SIZE), qs(e)) {
              this.HALF_FLOAT = e.HALF_FLOAT;
              const c = e.getExtension("EXT_color_buffer_half_float");
              this.RGBA16F = (r = e.RGBA16F) !== null && r !== void 0 ? r : c?.RGBA16F_EXT, this.RGB16F = (o = e.RGB16F) !== null && o !== void 0 ? o : c?.RGB16F_EXT, e.getExtension("EXT_color_buffer_float");
            } else {
              e.getExtension("EXT_color_buffer_half_float"), e.getExtension("OES_texture_half_float_linear");
              const c = e.getExtension("OES_texture_half_float");
              this.HALF_FLOAT = c?.HALF_FLOAT_OES;
            }
          }
          setDefault() {
            this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
          }
          setDirty() {
            this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.bindVertexArray.dirty = !0, this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0;
          }
          createIndexBuffer(e, r) {
            return new yr(this, e, r);
          }
          createVertexBuffer(e, r, o) {
            return new El(this, e, r, o);
          }
          createRenderbuffer(e, r, o) {
            const c = this.gl, h = c.createRenderbuffer();
            return this.bindRenderbuffer.set(h), c.renderbufferStorage(c.RENDERBUFFER, e, r, o), this.bindRenderbuffer.set(null), h;
          }
          createFramebuffer(e, r, o, c) {
            return new Fa(this, e, r, o, c);
          }
          clear({ color: e, depth: r, stencil: o }) {
            const c = this.gl;
            let h = 0;
            e && (h |= c.COLOR_BUFFER_BIT, this.clearColor.set(e), this.colorMask.set([!0, !0, !0, !0])), r !== void 0 && (h |= c.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(r), this.depthMask.set(!0)), o !== void 0 && (h |= c.STENCIL_BUFFER_BIT, this.clearStencil.set(o), this.stencilMask.set(255)), c.clear(h);
          }
          setCullFace(e) {
            e.enable === !1 ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(e.mode), this.frontFace.set(e.frontFace));
          }
          setDepthMode(e) {
            e.func !== this.gl.ALWAYS || e.mask ? (this.depthTest.set(!0), this.depthFunc.set(e.func), this.depthMask.set(e.mask), this.depthRange.set(e.range)) : this.depthTest.set(!1);
          }
          setStencilMode(e) {
            e.test.func !== this.gl.ALWAYS || e.mask ? (this.stencilTest.set(!0), this.stencilMask.set(e.mask), this.stencilOp.set([e.fail, e.depthFail, e.pass]), this.stencilFunc.set({ func: e.test.func, ref: e.ref, mask: e.test.mask })) : this.stencilTest.set(!1);
          }
          setColorMode(e) {
            u.bQ(e.blendFunction, Ne.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(e.blendFunction), this.blendColor.set(e.blendColor)), this.colorMask.set(e.mask);
          }
          createVertexArray() {
            var e;
            return qs(this.gl) ? this.gl.createVertexArray() : (e = this.gl.getExtension("OES_vertex_array_object")) === null || e === void 0 ? void 0 : e.createVertexArrayOES();
          }
          deleteVertexArray(e) {
            var r;
            return qs(this.gl) ? this.gl.deleteVertexArray(e) : (r = this.gl.getExtension("OES_vertex_array_object")) === null || r === void 0 ? void 0 : r.deleteVertexArrayOES(e);
          }
          unbindVAO() {
            this.bindVertexArray.set(null);
          }
        }
        let pr;
        function Ua(g, e, r, o, c) {
          const h = g.context, z = g.transform, d = h.gl, I = g.useProgram("collisionBox"), p = [];
          let f = 0, _ = 0;
          for (let W = 0; W < o.length; W++) {
            const Z = o[W], J = e.getTile(Z).getBucket(r);
            if (!J) continue;
            const R = c ? J.textCollisionBox : J.iconCollisionBox, q = J.collisionCircleArray;
            q.length > 0 && (p.push({ circleArray: q, circleOffset: _, coord: Z }), f += q.length / 4, _ = f), R && I.draw(h, d.LINES, Pt.disabled, qt.disabled, g.colorModeForRenderPass(), Kt.disabled, bo(g.transform), g.style.map.terrain && g.style.map.terrain.getTerrainData(Z), z.getProjectionData({ overscaledTileID: Z, applyGlobeMatrix: !0, applyTerrainMatrix: !0 }), r.id, R.layoutVertexBuffer, R.indexBuffer, R.segments, null, g.transform.zoom, null, null, R.collisionVertexBuffer);
          }
          if (!c || !p.length) return;
          const j = g.useProgram("collisionCircle"), C = new u.c9();
          C.resize(4 * f), C._trim();
          let v = 0;
          for (const W of p) for (let Z = 0; Z < W.circleArray.length / 4; Z++) {
            const J = 4 * Z, R = W.circleArray[J + 0], q = W.circleArray[J + 1], $ = W.circleArray[J + 2], G = W.circleArray[J + 3];
            C.emplace(v++, R, q, $, G, 0), C.emplace(v++, R, q, $, G, 1), C.emplace(v++, R, q, $, G, 2), C.emplace(v++, R, q, $, G, 3);
          }
          (!pr || pr.length < 2 * f) && (pr = (function(W) {
            const Z = 2 * W, J = new u.cb();
            J.resize(Z), J._trim();
            for (let R = 0; R < Z; R++) {
              const q = 6 * R;
              J.uint16[q + 0] = 4 * R + 0, J.uint16[q + 1] = 4 * R + 1, J.uint16[q + 2] = 4 * R + 2, J.uint16[q + 3] = 4 * R + 2, J.uint16[q + 4] = 4 * R + 3, J.uint16[q + 5] = 4 * R + 0;
            }
            return J;
          })(f));
          const F = h.createIndexBuffer(pr, !0), Y = h.createVertexBuffer(C, u.ca.members, !0);
          for (const W of p) {
            const Z = oc(g.transform);
            j.draw(h, d.TRIANGLES, Pt.disabled, qt.disabled, g.colorModeForRenderPass(), Kt.disabled, Z, g.style.map.terrain && g.style.map.terrain.getTerrainData(W.coord), null, r.id, Y, F, u.aW.simpleSegment(0, 2 * W.circleOffset, W.circleArray.length, W.circleArray.length / 2), null, g.transform.zoom, null, null, null);
          }
          Y.destroy(), F.destroy();
        }
        const wc = u.ar(new Float32Array(16));
        function Xa(g, e, r, o, c, h) {
          const { horizontalAlign: z, verticalAlign: d } = u.aR(g);
          return new u.P((-(z - 0.5) * e / c + o[0]) * h, (-(d - 0.5) * r / c + o[1]) * h);
        }
        function Wa(g, e, r, o, c, h) {
          const z = e.tileAnchorPoint.add(new u.P(e.translation[0], e.translation[1]));
          if (e.pitchWithMap) {
            let d = o.mult(h);
            r || (d = d.rotate(-c));
            const I = z.add(d);
            return Ot(I.x, I.y, e.pitchedLabelPlaneMatrix, e.getElevation).point;
          }
          if (r) {
            const d = Js(e.tileAnchorPoint.x + 1, e.tileAnchorPoint.y, e).point.sub(g), I = Math.atan(d.y / d.x) + (d.x < 0 ? Math.PI : 0);
            return g.add(o.rotate(I));
          }
          return g.add(o);
        }
        function Pa(g, e, r, o, c, h, z, d, I, p, f, _) {
          const j = g.text.placedSymbolArray, C = g.text.dynamicLayoutVertexArray, v = g.icon.dynamicLayoutVertexArray, F = {};
          C.clear();
          for (let Y = 0; Y < j.length; Y++) {
            const W = j.get(Y), Z = W.hidden || !W.crossTileID || g.allowVerticalPlacement && !W.placedOrientation ? null : o[W.crossTileID];
            if (Z) {
              const J = new u.P(W.anchorX, W.anchorY), R = { getElevation: _, width: c.width, height: c.height, pitchedLabelPlaneMatrix: h, pitchWithMap: r, transform: c, tileAnchorPoint: J, translation: p, unwrappedTileID: f }, q = r ? Rr(J.x, J.y, R) : Js(J.x, J.y, R), $ = kt(c.cameraToCenterDistance, q.signedDistanceFromCamera);
              let G = u.az(g.textSizeData, d, W) * $ / u.aL;
              r && (G *= g.tilePixelRatio / z);
              const { width: st, height: ct, anchor: nt, textOffset: at, textBoxScale: Mt } = Z, xt = Xa(nt, st, ct, at, Mt, G), wt = c.getPitchedTextCorrection(J.x + p[0], J.y + p[1], f), Nt = Wa(q.point, R, e, xt, -c.bearingInRadians, wt), Ct = g.allowVerticalPlacement && W.placedOrientation === u.ay.vertical ? Math.PI / 2 : 0;
              for (let Ut = 0; Ut < W.numGlyphs; Ut++) u.aF(C, Nt, Ct);
              I && W.associatedIconIndex >= 0 && (F[W.associatedIconIndex] = { shiftedAnchor: Nt, angle: Ct });
            } else li(W.numGlyphs, C);
          }
          if (I) {
            v.clear();
            const Y = g.icon.placedSymbolArray;
            for (let W = 0; W < Y.length; W++) {
              const Z = Y.get(W);
              if (Z.hidden) li(Z.numGlyphs, v);
              else {
                const J = F[W];
                if (J) for (let R = 0; R < Z.numGlyphs; R++) u.aF(v, J.shiftedAnchor, J.angle);
                else li(Z.numGlyphs, v);
              }
            }
            g.icon.dynamicLayoutVertexBuffer.updateData(v);
          }
          g.text.dynamicLayoutVertexBuffer.updateData(C);
        }
        function nn(g, e, r) {
          return r.iconsInText && e ? "symbolTextAndIcon" : g ? "symbolSDF" : "symbolIcon";
        }
        function Ra(g, e, r, o, c, h, z, d, I, p, f, _, j) {
          const C = g.context, v = C.gl, F = g.transform, Y = d === "map", W = I === "map", Z = d !== "viewport" && r.layout.get("symbol-placement") !== "point", J = Y && !W && !Z, R = !r.layout.get("symbol-sort-key").isConstant();
          let q = !1;
          const $ = g.getDepthModeForSublayer(0, Pt.ReadOnly), G = r._unevaluatedLayout.hasValue("text-variable-anchor") || r._unevaluatedLayout.hasValue("text-variable-anchor-offset"), st = [], ct = F.getCircleRadiusCorrection();
          for (const nt of o) {
            const at = e.getTile(nt), Mt = at.getBucket(r);
            if (!Mt) continue;
            const xt = c ? Mt.text : Mt.icon;
            if (!xt || !xt.segments.get().length || !xt.hasVisibleVertices) continue;
            const wt = xt.programConfigurations.get(r.id), Nt = c || Mt.sdfIcons, Ct = c ? Mt.textSizeData : Mt.iconSizeData, Ut = W || F.pitch !== 0, Yt = g.useProgram(nn(Nt, c, Mt), wt), ge = u.ax(Ct, F.zoom), he = g.style.map.terrain && g.style.map.terrain.getTerrainData(nt);
            let xe, ne, Ue, de, ve = [0, 0], be = null;
            if (c) ne = at.glyphAtlasTexture, Ue = v.LINEAR, xe = at.glyphAtlasTexture.size, Mt.iconsInText && (ve = at.imageAtlasTexture.size, be = at.imageAtlasTexture, de = Ut || g.options.rotating || g.options.zooming || Ct.kind === "composite" || Ct.kind === "camera" ? v.LINEAR : v.NEAREST);
            else {
              const Ce = r.layout.get("icon-size").constantOr(0) !== 1 || Mt.iconsNeedLinear;
              ne = at.imageAtlasTexture, Ue = Nt || g.options.rotating || g.options.zooming || Ce || Ut ? v.LINEAR : v.NEAREST, xe = at.imageAtlasTexture.size;
            }
            const Be = u.aM(at, 1, g.transform.zoom), _s = ke(Y, g.transform, Be), Ai = u.N();
            u.aA(Ai, _s);
            const Ni = ce(W, Y, g.transform, Be), $i = u.aN(F, at, h, z), Ki = F.getProjectionData({ overscaledTileID: nt, applyGlobeMatrix: !j, applyTerrainMatrix: !0 }), jr = G && Mt.hasTextData(), Ws = r.layout.get("icon-text-fit") !== "none" && jr && Mt.hasIconData();
            if (Z) {
              const Ce = g.style.map.terrain ? (Xe, ae) => g.style.map.terrain.getElevation(nt, Xe, ae) : null, Ae = r.layout.get("text-rotation-alignment") === "map";
              gr(Mt, g, c, _s, Ai, W, p, Ae, nt.toUnwrapped(), F.width, F.height, $i, Ce);
            }
            const mi = c && G || Ws, bs = Z || mi ? wc : W ? _s : g.transform.clipSpaceToPixelsMatrix, ji = Nt && r.paint.get(c ? "text-halo-width" : "icon-halo-width").constantOr(1) !== 0;
            let _r;
            _r = Nt ? Mt.iconsInText ? Fo(Ct.kind, ge, J, W, Z, mi, g, bs, Ni, $i, xe, ve, ct) : zi(Ct.kind, ge, J, W, Z, mi, g, bs, Ni, $i, c, xe, 0, ct) : kn(Ct.kind, ge, J, W, Z, mi, g, bs, Ni, $i, c, xe, ct);
            const Lr = { program: Yt, buffers: xt, uniformValues: _r, projectionData: Ki, atlasTexture: ne, atlasTextureIcon: be, atlasInterpolation: Ue, atlasInterpolationIcon: de, isSDF: Nt, hasHalo: ji };
            if (R && Mt.canOverlap) {
              q = !0;
              const Ce = xt.segments.get();
              for (const Ae of Ce) st.push({ segments: new u.aW([Ae]), sortKey: Ae.sortKey, state: Lr, terrainData: he });
            } else st.push({ segments: xt.segments, sortKey: 0, state: Lr, terrainData: he });
          }
          q && st.sort(((nt, at) => nt.sortKey - at.sortKey));
          for (const nt of st) {
            const at = nt.state;
            if (C.activeTexture.set(v.TEXTURE0), at.atlasTexture.bind(at.atlasInterpolation, v.CLAMP_TO_EDGE), at.atlasTextureIcon && (C.activeTexture.set(v.TEXTURE1), at.atlasTextureIcon && at.atlasTextureIcon.bind(at.atlasInterpolationIcon, v.CLAMP_TO_EDGE)), at.isSDF) {
              const Mt = at.uniformValues;
              at.hasHalo && (Mt.u_is_halo = 1, pc(at.buffers, nt.segments, r, g, at.program, $, f, _, Mt, at.projectionData, nt.terrainData)), Mt.u_is_halo = 0;
            }
            pc(at.buffers, nt.segments, r, g, at.program, $, f, _, at.uniformValues, at.projectionData, nt.terrainData);
          }
        }
        function pc(g, e, r, o, c, h, z, d, I, p, f) {
          const _ = o.context;
          c.draw(_, _.gl.TRIANGLES, h, z, d, Kt.backCCW, I, f, p, r.id, g.layoutVertexBuffer, g.indexBuffer, e, r.paint, o.transform.zoom, g.programConfigurations.get(r.id), g.dynamicLayoutVertexBuffer, g.opacityVertexBuffer);
        }
        function Xn(g, e, r, o, c) {
          const h = g.context, z = h.gl, d = qt.disabled, I = new Ne([z.ONE, z.ONE], u.bo.transparent, [!0, !0, !0, !0]), p = e.getBucket(r);
          if (!p) return;
          const f = o.key;
          let _ = r.heatmapFbos.get(f);
          _ || (_ = Ho(h, e.tileSize, e.tileSize), r.heatmapFbos.set(f, _)), h.bindFramebuffer.set(_.framebuffer), h.viewport.set([0, 0, e.tileSize, e.tileSize]), h.clear({ color: u.bo.transparent });
          const j = p.programConfigurations.get(r.id), C = g.useProgram("heatmap", j, !c), v = g.transform.getProjectionData({ overscaledTileID: e.tileID, applyGlobeMatrix: !0, applyTerrainMatrix: !0 }), F = g.style.map.terrain.getTerrainData(o);
          C.draw(h, z.TRIANGLES, Pt.disabled, d, I, Kt.disabled, vo(e, g.transform.zoom, r.paint.get("heatmap-intensity"), 1), F, v, r.id, p.layoutVertexBuffer, p.indexBuffer, p.segments, r.paint, g.transform.zoom, j);
        }
        function Fl(g, e, r, o, c) {
          const h = g.context, z = h.gl, d = g.transform;
          h.setColorMode(g.colorModeForRenderPass());
          const I = Wn(h, e), p = r.key, f = e.heatmapFbos.get(p);
          if (!f) return;
          h.activeTexture.set(z.TEXTURE0), z.bindTexture(z.TEXTURE_2D, f.colorAttachment.get()), h.activeTexture.set(z.TEXTURE1), I.bind(z.LINEAR, z.CLAMP_TO_EDGE);
          const _ = d.getProjectionData({ overscaledTileID: r, applyTerrainMatrix: c, applyGlobeMatrix: !o });
          g.useProgram("heatmapTexture").draw(h, z.TRIANGLES, Pt.disabled, qt.disabled, g.colorModeForRenderPass(), Kt.disabled, Bo(g, e, 0, 1), null, _, e.id, g.rasterBoundsBuffer, g.quadTriangleIndexBuffer, g.rasterBoundsSegments, e.paint, d.zoom), f.destroy(), e.heatmapFbos.delete(p);
        }
        function Ho(g, e, r) {
          var o, c;
          const h = g.gl, z = h.createTexture();
          h.bindTexture(h.TEXTURE_2D, z), h.texParameteri(h.TEXTURE_2D, h.TEXTURE_WRAP_S, h.CLAMP_TO_EDGE), h.texParameteri(h.TEXTURE_2D, h.TEXTURE_WRAP_T, h.CLAMP_TO_EDGE), h.texParameteri(h.TEXTURE_2D, h.TEXTURE_MIN_FILTER, h.LINEAR), h.texParameteri(h.TEXTURE_2D, h.TEXTURE_MAG_FILTER, h.LINEAR);
          const d = (o = g.HALF_FLOAT) !== null && o !== void 0 ? o : h.UNSIGNED_BYTE, I = (c = g.RGBA16F) !== null && c !== void 0 ? c : h.RGBA;
          h.texImage2D(h.TEXTURE_2D, 0, I, e, r, 0, h.RGBA, d, null);
          const p = g.createFramebuffer(e, r, !1, !1);
          return p.colorAttachment.set(z), p;
        }
        function Wn(g, e) {
          return e.colorRampTexture || (e.colorRampTexture = new u.T(g, e.colorRamp, g.gl.RGBA)), e.colorRampTexture;
        }
        function Za(g, e, r, o, c, h, z, d) {
          let I = 256;
          if (c.stepInterpolant) {
            const p = e.getSource().maxzoom, f = z.canonical.z === p ? Math.ceil(1 << g.transform.maxZoom - z.canonical.z) : 1;
            I = u.an(u.cd(h.maxLineLength / u.a4 * 1024 * f), 256, r.maxTextureSize);
          }
          return d.gradient = u.ce({ expression: c.gradientExpression(), evaluationKey: "lineProgress", resolution: I, image: d.gradient || void 0, clips: h.lineClipsArray }), d.texture ? d.texture.update(d.gradient) : d.texture = new u.T(r, d.gradient, o.RGBA), d.version = c.gradientVersion, d.texture;
        }
        function Tc(g, e, r, o, c) {
          g.activeTexture.set(e.TEXTURE0), r.imageAtlasTexture.bind(e.LINEAR, e.CLAMP_TO_EDGE), o.updatePaintBuffers(c);
        }
        function fc(g, e, r, o, c, h) {
          (c || g.lineAtlas.dirty) && (e.activeTexture.set(r.TEXTURE0), g.lineAtlas.bind(e)), o.updatePaintBuffers(h);
        }
        function Va(g, e, r, o, c, h, z) {
          const d = h.gradients[c.id];
          let I = d.texture;
          c.gradientVersion !== d.version && (I = Za(g, e, r, o, c, h, z, d)), r.activeTexture.set(o.TEXTURE0), I.bind(c.stepInterpolant ? o.NEAREST : o.LINEAR, o.CLAMP_TO_EDGE);
        }
        function Jo(g, e, r, o, c, h, z, d, I) {
          const p = h.gradients[c.id];
          let f = p.texture;
          c.gradientVersion !== p.version && (f = Za(g, e, r, o, c, h, z, p)), r.activeTexture.set(o.TEXTURE0), f.bind(c.stepInterpolant ? o.NEAREST : o.LINEAR, o.CLAMP_TO_EDGE), r.activeTexture.set(o.TEXTURE1), g.lineAtlas.bind(r), d.updatePaintBuffers(I);
        }
        function xc(g, e, r, o, c) {
          if (!r || !o || !o.imageAtlas) return;
          const h = o.imageAtlas.patternPositions;
          let z = h[r.to.toString()], d = h[r.from.toString()];
          if (!z && d && (z = d), !d && z && (d = z), !z || !d) {
            const I = c.getPaintProperty(e);
            z = h[I], d = h[I];
          }
          z && d && g.setConstantPatternPositions(z, d);
        }
        function qo(g, e, r, o, c, h, z, d) {
          const I = g.context.gl, p = "fill-pattern", f = r.paint.get(p), _ = f && f.constantOr(1), j = r.getCrossfadeParameters();
          let C, v, F, Y, W;
          const Z = g.transform, J = r.paint.get("fill-translate"), R = r.paint.get("fill-translate-anchor");
          z ? (v = _ && !r.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", C = I.LINES) : (v = _ ? "fillPattern" : "fill", C = I.TRIANGLES);
          const q = f.constantOr(null);
          for (const $ of o) {
            const G = e.getTile($);
            if (_ && !G.patternsLoaded()) continue;
            const st = G.getBucket(r);
            if (!st) continue;
            const ct = st.programConfigurations.get(r.id), nt = g.useProgram(v, ct), at = g.style.map.terrain && g.style.map.terrain.getTerrainData($);
            _ && (g.context.activeTexture.set(I.TEXTURE0), G.imageAtlasTexture.bind(I.LINEAR, I.CLAMP_TO_EDGE), ct.updatePaintBuffers(j)), xc(ct, p, q, G, r);
            const Mt = Z.getProjectionData({ overscaledTileID: $, applyGlobeMatrix: !d, applyTerrainMatrix: !0 }), xt = u.aN(Z, G, J, R);
            if (z) {
              Y = st.indexBuffer2, W = st.segments2;
              const Nt = [I.drawingBufferWidth, I.drawingBufferHeight];
              F = v === "fillOutlinePattern" && _ ? Ll(g, j, G, Nt, xt) : nc(Nt, xt);
            } else Y = st.indexBuffer, W = st.segments, F = _ ? rc(g, j, G, xt) : { u_fill_translate: xt };
            const wt = g.stencilModeForClipping($);
            nt.draw(g.context, C, c, wt, h, Kt.backCCW, F, at, Mt, r.id, st.layoutVertexBuffer, Y, W, r.paint, g.transform.zoom, ct);
          }
        }
        function fe(g, e, r, o, c, h, z, d) {
          const I = g.context, p = I.gl, f = "fill-extrusion-pattern", _ = r.paint.get(f), j = _.constantOr(1), C = r.getCrossfadeParameters(), v = r.paint.get("fill-extrusion-opacity"), F = _.constantOr(null), Y = g.transform;
          for (const W of o) {
            const Z = e.getTile(W), J = Z.getBucket(r);
            if (!J) continue;
            const R = g.style.map.terrain && g.style.map.terrain.getTerrainData(W), q = J.programConfigurations.get(r.id), $ = g.useProgram(j ? "fillExtrusionPattern" : "fillExtrusion", q);
            j && (g.context.activeTexture.set(p.TEXTURE0), Z.imageAtlasTexture.bind(p.LINEAR, p.CLAMP_TO_EDGE), q.updatePaintBuffers(C));
            const G = Y.getProjectionData({ overscaledTileID: W, applyGlobeMatrix: !d, applyTerrainMatrix: !0 });
            xc(q, f, F, Z, r);
            const st = u.aN(Y, Z, r.paint.get("fill-extrusion-translate"), r.paint.get("fill-extrusion-translate-anchor")), ct = r.paint.get("fill-extrusion-vertical-gradient"), nt = j ? tn(g, ct, v, st, W, C, Z) : ic(g, ct, v, st);
            $.draw(I, I.gl.TRIANGLES, c, h, z, Kt.backCCW, nt, R, G, r.id, J.layoutVertexBuffer, J.indexBuffer, J.segments, r.paint, g.transform.zoom, q, g.style.map.terrain && J.centroidVertexBuffer);
          }
        }
        function Ti(g, e, r, o, c, h, z, d, I) {
          var p;
          const f = g.style.projection, _ = g.context, j = g.transform, C = _.gl, v = [`#define NUM_ILLUMINATION_SOURCES ${r.paint.get("hillshade-highlight-color").values.length}`], F = g.useProgram("hillshade", null, !1, v), Y = !g.options.moving;
          for (const W of o) {
            const Z = e.getTile(W), J = Z.fbo;
            if (!J) continue;
            const R = f.getMeshFromTileID(_, W.canonical, d, !0, "raster"), q = (p = g.style.map.terrain) === null || p === void 0 ? void 0 : p.getTerrainData(W);
            _.activeTexture.set(C.TEXTURE0), C.bindTexture(C.TEXTURE_2D, J.colorAttachment.get());
            const $ = j.getProjectionData({ overscaledTileID: W, aligned: Y, applyGlobeMatrix: !I, applyTerrainMatrix: !0 });
            F.draw(_, C.TRIANGLES, h, c[W.overscaledZ], z, Kt.backCCW, dr(g, Z, r), q, $, r.id, R.vertexBuffer, R.indexBuffer, R.segments);
          }
        }
        function js(g, e, r, o, c, h, z, d, I) {
          var p;
          const f = g.style.projection, _ = g.context, j = g.transform, C = _.gl, v = g.useProgram("colorRelief"), F = !g.options.moving;
          let Y = !0, W = 0;
          for (const Z of o) {
            const J = e.getTile(Z), R = J.dem;
            if (Y) {
              const nt = C.getParameter(C.MAX_TEXTURE_SIZE), { elevationTexture: at, colorTexture: Mt } = r.getColorRampTextures(_, nt, R.getUnpackVector());
              _.activeTexture.set(C.TEXTURE1), at.bind(C.NEAREST, C.CLAMP_TO_EDGE), _.activeTexture.set(C.TEXTURE4), Mt.bind(C.LINEAR, C.CLAMP_TO_EDGE), Y = !1, W = at.size[0];
            }
            if (!R || !R.data) continue;
            const q = R.stride, $ = R.getPixels();
            if (_.activeTexture.set(C.TEXTURE0), _.pixelStoreUnpackPremultiplyAlpha.set(!1), J.demTexture = J.demTexture || g.getTileTexture(q), J.demTexture) {
              const nt = J.demTexture;
              nt.update($, { premultiply: !1 }), nt.bind(C.LINEAR, C.CLAMP_TO_EDGE);
            } else J.demTexture = new u.T(_, $, C.RGBA, { premultiply: !1 }), J.demTexture.bind(C.LINEAR, C.CLAMP_TO_EDGE);
            const G = f.getMeshFromTileID(_, Z.canonical, d, !0, "raster"), st = (p = g.style.map.terrain) === null || p === void 0 ? void 0 : p.getTerrainData(Z), ct = j.getProjectionData({ overscaledTileID: Z, aligned: F, applyGlobeMatrix: !I, applyTerrainMatrix: !0 });
            v.draw(_, C.TRIANGLES, h, c[Z.overscaledZ], z, Kt.backCCW, Bn(r, J.dem, W), st, ct, r.id, G.vertexBuffer, G.indexBuffer, G.segments);
          }
        }
        const Pn = [new u.P(0, 0), new u.P(u.a4, 0), new u.P(u.a4, u.a4), new u.P(0, u.a4)];
        function Tr(g, e, r, o, c, h, z, d, I = !1, p = !1) {
          const f = o[o.length - 1].overscaledZ, _ = g.context, j = _.gl, C = g.useProgram("raster"), v = g.transform, F = g.style.projection, Y = g.colorModeForRenderPass(), W = !g.options.moving, Z = r.paint.get("raster-opacity"), J = r.paint.get("raster-resampling"), R = r.paint.get("raster-fade-duration"), q = !!g.style.map.terrain;
          for (const $ of o) {
            const G = g.getDepthModeForSublayer($.overscaledZ - f, Z === 1 ? Pt.ReadWrite : Pt.ReadOnly, j.LESS), st = e.getTile($), ct = J === "nearest" ? j.NEAREST : j.LINEAR;
            _.activeTexture.set(j.TEXTURE0), st.texture.bind(ct, j.CLAMP_TO_EDGE, j.LINEAR_MIPMAP_NEAREST), _.activeTexture.set(j.TEXTURE1);
            const { parentTile: nt, parentScaleBy: at, parentTopLeft: Mt, fadeValues: xt } = Ac(st, e, R, q);
            st.fadeOpacity = xt.tileOpacity, nt ? (nt.fadeOpacity = xt.parentTileOpacity, nt.texture.bind(ct, j.CLAMP_TO_EDGE, j.LINEAR_MIPMAP_NEAREST)) : st.texture.bind(ct, j.CLAMP_TO_EDGE, j.LINEAR_MIPMAP_NEAREST), st.texture.useMipmap && _.extTextureFilterAnisotropic && g.transform.pitch > 20 && j.texParameterf(j.TEXTURE_2D, _.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, _.extTextureFilterAnisotropicMax);
            const wt = g.style.map.terrain && g.style.map.terrain.getTerrainData($), Nt = v.getProjectionData({ overscaledTileID: $, aligned: W, applyGlobeMatrix: !p, applyTerrainMatrix: !0 }), Ct = ko(Mt, at, xt.fadeMix, r, d), Ut = F.getMeshFromTileID(_, $.canonical, h, z, "raster");
            C.draw(_, j.TRIANGLES, G, c ? c[$.overscaledZ] : qt.disabled, Y, I ? Kt.frontCCW : Kt.backCCW, Ct, wt, Nt, r.id, Ut.vertexBuffer, Ut.indexBuffer, Ut.segments);
          }
        }
        function Ac(g, e, r, o) {
          const c = { parentTile: null, parentScaleBy: 1, parentTopLeft: [0, 0], fadeValues: { tileOpacity: 1, parentTileOpacity: 1, fadeMix: { opacity: 1, mix: 0 } } };
          if (r === 0 || o) return c;
          if (g.fadingParentID) {
            const h = e.getLoadedTile(g.fadingParentID);
            if (!h) return c;
            const z = Math.pow(2, h.tileID.overscaledZ - g.tileID.overscaledZ), d = [g.tileID.canonical.x * z % 1, g.tileID.canonical.y * z % 1], I = (function(p, f, _) {
              const j = $t(), C = (j - f.timeAdded) / _, v = p.fadingDirection === tt.Incoming, F = u.an((j - p.timeAdded) / _, 0, 1), Y = u.an(1 - C, 0, 1), W = v ? F : Y;
              return { tileOpacity: W, parentTileOpacity: v ? Y : F, fadeMix: { opacity: 1, mix: 1 - W } };
            })(g, h, r);
            return { parentTile: h, parentScaleBy: z, parentTopLeft: d, fadeValues: I };
          }
          if (g.selfFading) {
            const h = (function(z, d) {
              const I = ($t() - z.timeAdded) / d, p = u.an(I, 0, 1);
              return { tileOpacity: p, fadeMix: { opacity: p, mix: 0 } };
            })(g, r);
            return { parentTile: null, parentScaleBy: 1, parentTopLeft: [0, 0], fadeValues: h };
          }
          return c;
        }
        const an = new u.bo(1, 0, 0, 1), $o = new u.bo(0, 1, 0, 1), Rn = new u.bo(0, 0, 1, 1), Ko = new u.bo(1, 0, 1, 1), mc = new u.bo(0, 1, 1, 1);
        function tM(g, e, r, o) {
          Zn(g, 0, e + r / 2, g.transform.width, r, o);
        }
        function eM(g, e, r, o) {
          Zn(g, e - r / 2, 0, r, g.transform.height, o);
        }
        function Zn(g, e, r, o, c, h) {
          const z = g.context, d = z.gl;
          d.enable(d.SCISSOR_TEST), d.scissor(e * g.pixelRatio, r * g.pixelRatio, o * g.pixelRatio, c * g.pixelRatio), z.clear({ color: h }), d.disable(d.SCISSOR_TEST);
        }
        function jc(g, e, r) {
          const o = g.context, c = o.gl, h = g.useProgram("debug"), z = Pt.disabled, d = qt.disabled, I = g.colorModeForRenderPass(), p = "$debug", f = g.style.map.terrain && g.style.map.terrain.getTerrainData(r);
          o.activeTexture.set(c.TEXTURE0);
          const _ = e.getTileByID(r.key).latestRawTileData, j = Math.floor((_ && _.byteLength || 0) / 1024), C = e.getTile(r).tileSize, v = 512 / Math.min(C, 512) * (r.overscaledZ / g.transform.zoom) * 0.5;
          let F = r.canonical.toString();
          r.overscaledZ !== r.canonical.z && (F += ` => ${r.overscaledZ}`), (function(W, Z) {
            W.initDebugOverlayCanvas();
            const J = W.debugOverlayCanvas, R = W.context.gl, q = W.debugOverlayCanvas.getContext("2d");
            q.clearRect(0, 0, J.width, J.height), q.shadowColor = "white", q.shadowBlur = 2, q.lineWidth = 1.5, q.strokeStyle = "white", q.textBaseline = "top", q.font = "bold 36px Open Sans, sans-serif", q.fillText(Z, 5, 5), q.strokeText(Z, 5, 5), W.debugOverlayTexture.update(J), W.debugOverlayTexture.bind(R.LINEAR, R.CLAMP_TO_EDGE);
          })(g, `${F} ${j}kB`);
          const Y = g.transform.getProjectionData({ overscaledTileID: r, applyGlobeMatrix: !0, applyTerrainMatrix: !0 });
          h.draw(o, c.TRIANGLES, z, d, Ne.alphaBlended, Kt.disabled, Qo(u.bo.transparent, v), null, Y, p, g.debugBuffer, g.quadTriangleIndexBuffer, g.debugSegments), h.draw(o, c.LINE_STRIP, z, d, I, Kt.disabled, Qo(u.bo.red), f, Y, p, g.debugBuffer, g.tileBorderIndexBuffer, g.debugSegments);
        }
        function Ji(g, e, r, o) {
          const { isRenderingGlobe: c } = o, h = g.context, z = h.gl, d = g.transform, I = g.colorModeForRenderPass(), p = g.getDepthModeFor3D(), f = g.useProgram("terrain");
          h.bindFramebuffer.set(null), h.viewport.set([0, 0, g.width, g.height]);
          for (const _ of r) {
            const j = e.getTerrainMesh(_.tileID), C = g.renderToTexture.getTexture(_), v = e.getTerrainData(_.tileID);
            h.activeTexture.set(z.TEXTURE0), z.bindTexture(z.TEXTURE_2D, C.texture);
            const F = e.getMeshFrameDelta(d.zoom), Y = d.calculateFogMatrix(_.tileID.toUnwrapped()), W = Eo(F, Y, g.style.sky, d.pitch, c), Z = d.getProjectionData({ overscaledTileID: _.tileID, applyTerrainMatrix: !1, applyGlobeMatrix: !0 });
            f.draw(h, z.TRIANGLES, p, qt.disabled, I, Kt.backCCW, W, v, Z, "terrain", j.vertexBuffer, j.indexBuffer, j.segments);
          }
        }
        function sM(g, e) {
          if (!e.mesh) {
            const r = new u.aV();
            r.emplaceBack(-1, -1), r.emplaceBack(1, -1), r.emplaceBack(1, 1), r.emplaceBack(-1, 1);
            const o = new u.aX();
            o.emplaceBack(0, 1, 2), o.emplaceBack(0, 2, 3), e.mesh = new Zi(g.createVertexBuffer(r, Fe.members), g.createIndexBuffer(o), u.aW.simpleSegment(0, 0, r.length, o.length));
          }
          return e.mesh;
        }
        class _c {
          constructor(e, r) {
            this.context = new Ya(e), this.transform = r, this._tileTextures = {}, this.terrainFacilitator = { dirty: !0, matrix: u.ar(new Float64Array(16)), renderTime: 0 }, this.setup(), this.numSublayers = Zt.maxOverzooming + Zt.maxUnderzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new Dr();
          }
          resize(e, r, o) {
            if (this.width = Math.floor(e * o), this.height = Math.floor(r * o), this.pixelRatio = o, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (const c of this.style._order) this.style._layers[c].resize();
          }
          setup() {
            const e = this.context, r = new u.aV();
            r.emplaceBack(0, 0), r.emplaceBack(u.a4, 0), r.emplaceBack(0, u.a4), r.emplaceBack(u.a4, u.a4), this.tileExtentBuffer = e.createVertexBuffer(r, Fe.members), this.tileExtentSegments = u.aW.simpleSegment(0, 0, 4, 2);
            const o = new u.aV();
            o.emplaceBack(0, 0), o.emplaceBack(u.a4, 0), o.emplaceBack(0, u.a4), o.emplaceBack(u.a4, u.a4), this.debugBuffer = e.createVertexBuffer(o, Fe.members), this.debugSegments = u.aW.simpleSegment(0, 0, 4, 5);
            const c = new u.cg();
            c.emplaceBack(0, 0, 0, 0), c.emplaceBack(u.a4, 0, u.a4, 0), c.emplaceBack(0, u.a4, 0, u.a4), c.emplaceBack(u.a4, u.a4, u.a4, u.a4), this.rasterBoundsBuffer = e.createVertexBuffer(c, Di.members), this.rasterBoundsSegments = u.aW.simpleSegment(0, 0, 4, 2);
            const h = new u.aV();
            h.emplaceBack(0, 0), h.emplaceBack(u.a4, 0), h.emplaceBack(0, u.a4), h.emplaceBack(u.a4, u.a4), this.rasterBoundsBufferPosOnly = e.createVertexBuffer(h, Fe.members), this.rasterBoundsSegmentsPosOnly = u.aW.simpleSegment(0, 0, 4, 5);
            const z = new u.aV();
            z.emplaceBack(0, 0), z.emplaceBack(1, 0), z.emplaceBack(0, 1), z.emplaceBack(1, 1), this.viewportBuffer = e.createVertexBuffer(z, Fe.members), this.viewportSegments = u.aW.simpleSegment(0, 0, 4, 2);
            const d = new u.ch();
            d.emplaceBack(0), d.emplaceBack(1), d.emplaceBack(3), d.emplaceBack(2), d.emplaceBack(0), this.tileBorderIndexBuffer = e.createIndexBuffer(d);
            const I = new u.aX();
            I.emplaceBack(1, 0, 2), I.emplaceBack(1, 2, 3), this.quadTriangleIndexBuffer = e.createIndexBuffer(I);
            const p = this.context.gl;
            this.stencilClearMode = new qt({ func: p.ALWAYS, mask: 0 }, 0, 255, p.ZERO, p.ZERO, p.ZERO), this.tileExtentMesh = new Zi(this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
          }
          clearStencil() {
            const e = this.context, r = e.gl;
            this.nextStencilID = 1, this.currentStencilSource = void 0;
            const o = u.N();
            u.c6(o, 0, this.width, this.height, 0, 0, 1), u.Q(o, o, [r.drawingBufferWidth, r.drawingBufferHeight, 0]);
            const c = { mainMatrix: o, tileMercatorCoords: [0, 0, 1, 1], clippingPlane: [0, 0, 0, 0], projectionTransition: 0, fallbackMatrix: o };
            this.useProgram("clippingMask", null, !0).draw(e, r.TRIANGLES, Pt.disabled, this.stencilClearMode, Ne.disabled, Kt.disabled, null, null, c, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
          }
          _renderTileClippingMasks(e, r, o) {
            if (this.currentStencilSource === e.source || !e.isTileClipped() || !r || !r.length) return;
            this.currentStencilSource = e.source, this.nextStencilID + r.length > 256 && this.clearStencil();
            const c = this.context;
            c.setColorMode(Ne.disabled), c.setDepthMode(Pt.disabled);
            const h = {};
            for (const z of r) h[z.key] = this.nextStencilID++;
            this._renderTileMasks(h, r, o, !0), this._renderTileMasks(h, r, o, !1), this._tileClippingMaskIDs = h;
          }
          _renderTileMasks(e, r, o, c) {
            const h = this.context, z = h.gl, d = this.style.projection, I = this.transform, p = this.useProgram("clippingMask");
            for (const f of r) {
              const _ = e[f.key], j = this.style.map.terrain && this.style.map.terrain.getTerrainData(f), C = d.getMeshFromTileID(this.context, f.canonical, c, !0, "stencil"), v = I.getProjectionData({ overscaledTileID: f, applyGlobeMatrix: !o, applyTerrainMatrix: !0 });
              p.draw(h, z.TRIANGLES, Pt.disabled, new qt({ func: z.ALWAYS, mask: 0 }, _, 255, z.KEEP, z.KEEP, z.REPLACE), Ne.disabled, o ? Kt.disabled : Kt.backCCW, null, j, v, "$clipping", C.vertexBuffer, C.indexBuffer, C.segments);
            }
          }
          _renderTilesDepthBuffer() {
            const e = this.context, r = e.gl, o = this.style.projection, c = this.transform, h = this.useProgram("depth"), z = this.getDepthModeFor3D(), d = Xt(c, { tileSize: c.tileSize });
            for (const I of d) {
              const p = this.style.map.terrain && this.style.map.terrain.getTerrainData(I), f = o.getMeshFromTileID(this.context, I.canonical, !0, !0, "raster"), _ = c.getProjectionData({ overscaledTileID: I, applyGlobeMatrix: !0, applyTerrainMatrix: !0 });
              h.draw(e, r.TRIANGLES, z, qt.disabled, Ne.disabled, Kt.backCCW, null, p, _, "$clipping", f.vertexBuffer, f.indexBuffer, f.segments);
            }
          }
          stencilModeFor3D() {
            this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
            const e = this.nextStencilID++, r = this.context.gl;
            return new qt({ func: r.NOTEQUAL, mask: 255 }, e, 255, r.KEEP, r.KEEP, r.REPLACE);
          }
          stencilModeForClipping(e) {
            const r = this.context.gl;
            return new qt({ func: r.EQUAL, mask: 255 }, this._tileClippingMaskIDs[e.key], 0, r.KEEP, r.KEEP, r.REPLACE);
          }
          getStencilConfigForOverlapAndUpdateStencilID(e) {
            const r = this.context.gl, o = e.sort(((z, d) => d.overscaledZ - z.overscaledZ)), c = o[o.length - 1].overscaledZ, h = o[0].overscaledZ - c + 1;
            if (h > 1) {
              this.currentStencilSource = void 0, this.nextStencilID + h > 256 && this.clearStencil();
              const z = {};
              for (let d = 0; d < h; d++) z[d + c] = new qt({ func: r.GEQUAL, mask: 255 }, d + this.nextStencilID, 255, r.KEEP, r.KEEP, r.REPLACE);
              return this.nextStencilID += h, [z, o];
            }
            return [{ [c]: qt.disabled }, o];
          }
          stencilConfigForOverlapTwoPass(e) {
            const r = this.context.gl, o = e.sort(((z, d) => d.overscaledZ - z.overscaledZ)), c = o[o.length - 1].overscaledZ, h = o[0].overscaledZ - c + 1;
            if (this.clearStencil(), h > 1) {
              const z = {}, d = {};
              for (let I = 0; I < h; I++) z[I + c] = new qt({ func: r.GREATER, mask: 255 }, h + 1 + I, 255, r.KEEP, r.KEEP, r.REPLACE), d[I + c] = new qt({ func: r.GREATER, mask: 255 }, 1 + I, 255, r.KEEP, r.KEEP, r.REPLACE);
              return this.nextStencilID = 2 * h + 1, [z, d, o];
            }
            return this.nextStencilID = 3, [{ [c]: new qt({ func: r.GREATER, mask: 255 }, 2, 255, r.KEEP, r.KEEP, r.REPLACE) }, { [c]: new qt({ func: r.GREATER, mask: 255 }, 1, 255, r.KEEP, r.KEEP, r.REPLACE) }, o];
          }
          colorModeForRenderPass() {
            const e = this.context.gl;
            return this._showOverdrawInspector ? new Ne([e.CONSTANT_COLOR, e.ONE], new u.bo(0.125, 0.125, 0.125, 0), [!0, !0, !0, !0]) : this.renderPass === "opaque" ? Ne.unblended : Ne.alphaBlended;
          }
          getDepthModeForSublayer(e, r, o) {
            if (!this.opaquePassEnabledForLayer()) return Pt.disabled;
            const c = 1 - ((1 + this.currentLayer) * this.numSublayers + e) * this.depthEpsilon;
            return new Pt(o || this.context.gl.LEQUAL, r, [c, c]);
          }
          getDepthModeFor3D() {
            return new Pt(this.context.gl.LEQUAL, Pt.ReadWrite, this.depthRangeFor3D);
          }
          opaquePassEnabledForLayer() {
            return this.currentLayer < this.opaquePassCutoff;
          }
          render(e, r) {
            var o, c;
            this.style = e, this.options = r, this.lineAtlas = e.lineAtlas, this.imageManager = e.imageManager, this.glyphManager = e.glyphManager, this.symbolFadeChange = e.placement.symbolFadeChange($t()), this.imageManager.beginFrame();
            const h = this.style._order, z = this.style.tileManagers, d = {}, I = {}, p = {}, f = { isRenderingToTexture: !1, isRenderingGlobe: ((o = e.projection) === null || o === void 0 ? void 0 : o.transitionState) > 0 };
            for (const j in z) {
              const C = z[j];
              C.used && C.prepare(this.context), d[j] = C.getVisibleCoordinates(!1), I[j] = d[j].slice().reverse(), p[j] = C.getVisibleCoordinates(!0).reverse();
            }
            this.opaquePassCutoff = 1 / 0;
            for (let j = 0; j < h.length; j++) if (this.style._layers[h[j]].is3D()) {
              this.opaquePassCutoff = j;
              break;
            }
            this.maybeDrawDepthAndCoords(!1), this.renderToTexture && (this.renderToTexture.prepareForRender(this.style, this.transform.zoom), this.opaquePassCutoff = 0), this.renderPass = "offscreen";
            for (const j of h) {
              const C = this.style._layers[j];
              if (!C.hasOffscreenPass() || C.isHidden(this.transform.zoom)) continue;
              const v = I[C.source];
              (C.type === "custom" || v.length) && this.renderLayer(this, z[C.source], C, v, f);
            }
            if ((c = this.style.projection) === null || c === void 0 || c.updateGPUdependent({ context: this.context, useProgram: (j) => this.useProgram(j) }), this.context.viewport.set([0, 0, this.width, this.height]), this.context.bindFramebuffer.set(null), this.context.clear({ color: r.showOverdrawInspector ? u.bo.black : u.bo.transparent, depth: 1 }), this.clearStencil(), this.style.sky && (function(j, C) {
              const v = j.context, F = v.gl, Y = (($, G, st) => {
                const ct = Math.cos(G.rollInRadians), nt = Math.sin(G.rollInRadians), at = rt(G), Mt = G.getProjectionData({ overscaledTileID: null, applyGlobeMatrix: !0, applyTerrainMatrix: !0 }).projectionTransition;
                return { u_sky_color: $.properties.get("sky-color"), u_horizon_color: $.properties.get("horizon-color"), u_horizon: [(G.width / 2 - at * nt) * st, (G.height / 2 + at * ct) * st], u_horizon_normal: [-nt, ct], u_sky_horizon_blend: $.properties.get("sky-horizon-blend") * G.height / 2 * st, u_sky_blend: Mt };
              })(C, j.style.map.transform, j.pixelRatio), W = new Pt(F.LEQUAL, Pt.ReadWrite, [0, 1]), Z = qt.disabled, J = j.colorModeForRenderPass(), R = j.useProgram("sky"), q = sM(v, C);
              R.draw(v, F.TRIANGLES, W, Z, J, Kt.disabled, Y, null, void 0, "sky", q.vertexBuffer, q.indexBuffer, q.segments);
            })(this, this.style.sky), this._showOverdrawInspector = r.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (e._order.length + 2) * this.numSublayers * this.depthEpsilon], !this.renderToTexture) for (this.renderPass = "opaque", this.currentLayer = h.length - 1; this.currentLayer >= 0; this.currentLayer--) {
              const j = this.style._layers[h[this.currentLayer]], C = z[j.source], v = d[j.source];
              this._renderTileClippingMasks(j, v, !1), this.renderLayer(this, C, j, v, f);
            }
            this.renderPass = "translucent";
            let _ = !1;
            for (this.currentLayer = 0; this.currentLayer < h.length; this.currentLayer++) {
              const j = this.style._layers[h[this.currentLayer]], C = z[j.source];
              if (this.renderToTexture && this.renderToTexture.renderLayer(j, f)) continue;
              this.opaquePassEnabledForLayer() || _ || (_ = !0, f.isRenderingGlobe && !this.style.map.terrain && this._renderTilesDepthBuffer());
              const v = (j.type === "symbol" ? p : I)[j.source];
              this._renderTileClippingMasks(j, d[j.source], !!this.renderToTexture), this.renderLayer(this, C, j, v, f);
            }
            if (f.isRenderingGlobe && (function(j, C, v) {
              const F = j.context, Y = F.gl, W = j.useProgram("atmosphere"), Z = new Pt(Y.LEQUAL, Pt.ReadOnly, [0, 1]), J = j.transform, R = (function(Mt, xt) {
                const wt = Mt.properties.get("position"), Nt = [-wt.x, -wt.y, -wt.z], Ct = u.ar(new Float64Array(16));
                return Mt.properties.get("anchor") === "map" && (u.bf(Ct, Ct, xt.rollInRadians), u.bg(Ct, Ct, -xt.pitchInRadians), u.bf(Ct, Ct, xt.bearingInRadians), u.bg(Ct, Ct, xt.center.lat * Math.PI / 180), u.bI(Ct, Ct, -xt.center.lng * Math.PI / 180)), u.cf(Nt, Nt, Ct), Nt;
              })(v, j.transform), q = J.getProjectionData({ overscaledTileID: null, applyGlobeMatrix: !0, applyTerrainMatrix: !0 }), $ = C.properties.get("atmosphere-blend") * q.projectionTransition;
              if ($ === 0) return;
              const G = xa(J.worldSize, J.center.lat), st = J.inverseProjectionMatrix, ct = new Float64Array(4);
              ct[3] = 1, u.aG(ct, ct, J.modelViewProjectionMatrix), ct[0] /= ct[3], ct[1] /= ct[3], ct[2] /= ct[3], ct[3] = 1, u.aG(ct, ct, st), ct[0] /= ct[3], ct[1] /= ct[3], ct[2] /= ct[3], ct[3] = 1;
              const nt = /* @__PURE__ */ ((Mt, xt, wt, Nt, Ct) => ({ u_sun_pos: Mt, u_atmosphere_blend: xt, u_globe_position: wt, u_globe_radius: Nt, u_inv_proj_matrix: Ct }))(R, $, [ct[0], ct[1], ct[2]], G, st), at = sM(F, C);
              W.draw(F, Y.TRIANGLES, Z, qt.disabled, Ne.alphaBlended, Kt.disabled, nt, null, null, "atmosphere", at.vertexBuffer, at.indexBuffer, at.segments);
            })(this, this.style.sky, this.style.light), this.options.showTileBoundaries) {
              const j = (function(C, v) {
                let F = null;
                const Y = Object.values(C._layers).flatMap(((R) => R.source && !R.isHidden(v) ? [C.tileManagers[R.source]] : [])), W = Y.filter(((R) => R.getSource().type === "vector")), Z = Y.filter(((R) => R.getSource().type !== "vector")), J = (R) => {
                  (!F || F.getSource().maxzoom < R.getSource().maxzoom) && (F = R);
                };
                return W.forEach(((R) => J(R))), F || Z.forEach(((R) => J(R))), F;
              })(this.style, this.transform.zoom);
              j && (function(C, v, F) {
                for (let Y = 0; Y < F.length; Y++) jc(C, v, F[Y]);
              })(this, j, j.getVisibleCoordinates());
            }
            this.options.showPadding && (function(j) {
              const C = j.transform.padding;
              tM(j, j.transform.height - (C.top || 0), 3, an), tM(j, C.bottom || 0, 3, $o), eM(j, C.left || 0, 3, Rn), eM(j, j.transform.width - (C.right || 0), 3, Ko);
              const v = j.transform.centerPoint;
              (function(F, Y, W, Z) {
                Zn(F, Y - 1, W - 10, 2, 20, Z), Zn(F, Y - 10, W - 1, 20, 2, Z);
              })(j, v.x, j.transform.height - v.y, mc);
            })(this), this.context.setDefault();
          }
          maybeDrawDepthAndCoords(e) {
            if (!this.style || !this.style.map || !this.style.map.terrain) return;
            const r = this.terrainFacilitator.matrix, o = this.transform.modelViewProjectionMatrix;
            let c = this.terrainFacilitator.dirty;
            c || (c = e ? !u.ci(r, o) : !u.cj(r, o)), c || (c = this.style.map.terrain.tileManager.anyTilesAfterTime(this.terrainFacilitator.renderTime)), c && (u.ck(r, o), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = !1, (function(h, z) {
              const d = h.context, I = d.gl, p = h.transform, f = Ne.unblended, _ = new Pt(I.LEQUAL, Pt.ReadWrite, [0, 1]), j = z.tileManager.getRenderableTiles(), C = h.useProgram("terrainDepth");
              d.bindFramebuffer.set(z.getFramebuffer("depth").framebuffer), d.viewport.set([0, 0, h.width / devicePixelRatio, h.height / devicePixelRatio]), d.clear({ color: u.bo.transparent, depth: 1 });
              for (const v of j) {
                const F = z.getTerrainMesh(v.tileID), Y = z.getTerrainData(v.tileID), W = p.getProjectionData({ overscaledTileID: v.tileID, applyTerrainMatrix: !1, applyGlobeMatrix: !0 }), Z = { u_ele_delta: z.getMeshFrameDelta(p.zoom) };
                C.draw(d, I.TRIANGLES, _, qt.disabled, f, Kt.backCCW, Z, Y, W, "terrain", F.vertexBuffer, F.indexBuffer, F.segments);
              }
              d.bindFramebuffer.set(null), d.viewport.set([0, 0, h.width, h.height]);
            })(this, this.style.map.terrain), (function(h, z) {
              const d = h.context, I = d.gl, p = h.transform, f = Ne.unblended, _ = new Pt(I.LEQUAL, Pt.ReadWrite, [0, 1]), j = z.getCoordsTexture(), C = z.tileManager.getRenderableTiles(), v = h.useProgram("terrainCoords");
              d.bindFramebuffer.set(z.getFramebuffer("coords").framebuffer), d.viewport.set([0, 0, h.width / devicePixelRatio, h.height / devicePixelRatio]), d.clear({ color: u.bo.transparent, depth: 1 }), z.coordsIndex = [];
              for (const F of C) {
                const Y = z.getTerrainMesh(F.tileID), W = z.getTerrainData(F.tileID);
                d.activeTexture.set(I.TEXTURE0), I.bindTexture(I.TEXTURE_2D, j.texture);
                const Z = { u_terrain_coords_id: (255 - z.coordsIndex.length) / 255, u_texture: 0, u_ele_delta: z.getMeshFrameDelta(p.zoom) }, J = p.getProjectionData({ overscaledTileID: F.tileID, applyTerrainMatrix: !1, applyGlobeMatrix: !0 });
                v.draw(d, I.TRIANGLES, _, qt.disabled, f, Kt.backCCW, Z, W, J, "terrain", Y.vertexBuffer, Y.indexBuffer, Y.segments), z.coordsIndex.push(F.tileID.key);
              }
              d.bindFramebuffer.set(null), d.viewport.set([0, 0, h.width, h.height]);
            })(this, this.style.map.terrain));
          }
          renderLayer(e, r, o, c, h) {
            o.isHidden(this.transform.zoom) || (o.type === "background" || o.type === "custom" || (c || []).length) && (this.id = o.id, u.cl(o) ? (function(z, d, I, p, f, _) {
              if (z.renderPass !== "translucent") return;
              const { isRenderingToTexture: j } = _, C = qt.disabled, v = z.colorModeForRenderPass();
              (I._unevaluatedLayout.hasValue("text-variable-anchor") || I._unevaluatedLayout.hasValue("text-variable-anchor-offset")) && (function(F, Y, W, Z, J, R, q, $, G) {
                const st = Y.transform, ct = Y.style.map.terrain, nt = J === "map", at = R === "map";
                for (const Mt of F) {
                  const xt = Z.getTile(Mt), wt = xt.getBucket(W);
                  if (!wt || !wt.text || !wt.text.segments.get().length) continue;
                  const Nt = u.ax(wt.textSizeData, st.zoom), Ct = u.aM(xt, 1, Y.transform.zoom), Ut = ke(nt, Y.transform, Ct), Yt = W.layout.get("icon-text-fit") !== "none" && wt.hasIconData();
                  if (Nt) {
                    const ge = Math.pow(2, st.zoom - xt.tileID.overscaledZ), he = ct ? (xe, ne) => ct.getElevation(Mt, xe, ne) : null;
                    Pa(wt, nt, at, G, st, Ut, ge, Nt, Yt, u.aN(st, xt, q, $), Mt.toUnwrapped(), he);
                  }
                }
              })(p, z, I, d, I.layout.get("text-rotation-alignment"), I.layout.get("text-pitch-alignment"), I.paint.get("text-translate"), I.paint.get("text-translate-anchor"), f), I.paint.get("icon-opacity").constantOr(1) !== 0 && Ra(z, d, I, p, !1, I.paint.get("icon-translate"), I.paint.get("icon-translate-anchor"), I.layout.get("icon-rotation-alignment"), I.layout.get("icon-pitch-alignment"), I.layout.get("icon-keep-upright"), C, v, j), I.paint.get("text-opacity").constantOr(1) !== 0 && Ra(z, d, I, p, !0, I.paint.get("text-translate"), I.paint.get("text-translate-anchor"), I.layout.get("text-rotation-alignment"), I.layout.get("text-pitch-alignment"), I.layout.get("text-keep-upright"), C, v, j), d.map.showCollisionBoxes && (Ua(z, d, I, p, !0), Ua(z, d, I, p, !1));
            })(e, r, o, c, this.style.placement.variableOffsets, h) : u.cm(o) ? (function(z, d, I, p, f) {
              if (z.renderPass !== "translucent") return;
              const { isRenderingToTexture: _ } = f, j = I.paint.get("circle-opacity"), C = I.paint.get("circle-stroke-width"), v = I.paint.get("circle-stroke-opacity"), F = !I.layout.get("circle-sort-key").isConstant();
              if (j.constantOr(1) === 0 && (C.constantOr(1) === 0 || v.constantOr(1) === 0)) return;
              const Y = z.context, W = Y.gl, Z = z.transform, J = z.getDepthModeForSublayer(0, Pt.ReadOnly), R = qt.disabled, q = z.colorModeForRenderPass(), $ = [], G = Z.getCircleRadiusCorrection();
              for (let st = 0; st < p.length; st++) {
                const ct = p[st], nt = d.getTile(ct), at = nt.getBucket(I);
                if (!at) continue;
                const Mt = I.paint.get("circle-translate"), xt = I.paint.get("circle-translate-anchor"), wt = u.aN(Z, nt, Mt, xt), Nt = at.programConfigurations.get(I.id), Ct = z.useProgram("circle", Nt), Ut = at.layoutVertexBuffer, Yt = at.indexBuffer, ge = z.style.map.terrain && z.style.map.terrain.getTerrainData(ct), he = { programConfiguration: Nt, program: Ct, layoutVertexBuffer: Ut, indexBuffer: Yt, uniformValues: ac(z, nt, I, wt, G), terrainData: ge, projectionData: Z.getProjectionData({ overscaledTileID: ct, applyGlobeMatrix: !_, applyTerrainMatrix: !0 }) };
                if (F) {
                  const xe = at.segments.get();
                  for (const ne of xe) $.push({ segments: new u.aW([ne]), sortKey: ne.sortKey, state: he });
                } else $.push({ segments: at.segments, sortKey: 0, state: he });
              }
              F && $.sort(((st, ct) => st.sortKey - ct.sortKey));
              for (const st of $) {
                const { programConfiguration: ct, program: nt, layoutVertexBuffer: at, indexBuffer: Mt, uniformValues: xt, terrainData: wt, projectionData: Nt } = st.state;
                nt.draw(Y, W.TRIANGLES, J, R, q, Kt.backCCW, xt, wt, Nt, I.id, at, Mt, st.segments, I.paint, z.transform.zoom, ct);
              }
            })(e, r, o, c, h) : u.cn(o) ? (function(z, d, I, p, f) {
              if (I.paint.get("heatmap-opacity") === 0) return;
              const _ = z.context, { isRenderingToTexture: j, isRenderingGlobe: C } = f;
              if (z.style.map.terrain) {
                for (const v of p) {
                  const F = d.getTile(v);
                  d.hasRenderableParent(v) || (z.renderPass === "offscreen" ? Xn(z, F, I, v, C) : z.renderPass === "translucent" && Fl(z, I, v, j, C));
                }
                _.viewport.set([0, 0, z.width, z.height]);
              } else z.renderPass === "offscreen" ? (function(v, F, Y, W) {
                const Z = v.context, J = Z.gl, R = v.transform, q = qt.disabled, $ = new Ne([J.ONE, J.ONE], u.bo.transparent, [!0, !0, !0, !0]);
                (function(G, st, ct) {
                  const nt = G.gl;
                  G.activeTexture.set(nt.TEXTURE1), G.viewport.set([0, 0, st.width / 4, st.height / 4]);
                  let at = ct.heatmapFbos.get(u.cc);
                  at ? (nt.bindTexture(nt.TEXTURE_2D, at.colorAttachment.get()), G.bindFramebuffer.set(at.framebuffer)) : (at = Ho(G, st.width / 4, st.height / 4), ct.heatmapFbos.set(u.cc, at));
                })(Z, v, Y), Z.clear({ color: u.bo.transparent });
                for (let G = 0; G < W.length; G++) {
                  const st = W[G];
                  if (F.hasRenderableParent(st)) continue;
                  const ct = F.getTile(st), nt = ct.getBucket(Y);
                  if (!nt) continue;
                  const at = nt.programConfigurations.get(Y.id), Mt = v.useProgram("heatmap", at), xt = R.getProjectionData({ overscaledTileID: st, applyGlobeMatrix: !0, applyTerrainMatrix: !1 }), wt = R.getCircleRadiusCorrection();
                  Mt.draw(Z, J.TRIANGLES, Pt.disabled, q, $, Kt.backCCW, vo(ct, R.zoom, Y.paint.get("heatmap-intensity"), wt), null, xt, Y.id, nt.layoutVertexBuffer, nt.indexBuffer, nt.segments, Y.paint, R.zoom, at);
                }
                Z.viewport.set([0, 0, v.width, v.height]);
              })(z, d, I, p) : z.renderPass === "translucent" && (function(v, F) {
                const Y = v.context, W = Y.gl;
                Y.setColorMode(v.colorModeForRenderPass());
                const Z = F.heatmapFbos.get(u.cc);
                Z && (Y.activeTexture.set(W.TEXTURE0), W.bindTexture(W.TEXTURE_2D, Z.colorAttachment.get()), Y.activeTexture.set(W.TEXTURE1), Wn(Y, F).bind(W.LINEAR, W.CLAMP_TO_EDGE), v.useProgram("heatmapTexture").draw(Y, W.TRIANGLES, Pt.disabled, qt.disabled, v.colorModeForRenderPass(), Kt.disabled, Bo(v, F, 0, 1), null, null, F.id, v.viewportBuffer, v.quadTriangleIndexBuffer, v.viewportSegments, F.paint, v.transform.zoom));
              })(z, I);
            })(e, r, o, c, h) : u.co(o) ? (function(z, d, I, p, f) {
              if (z.renderPass !== "translucent") return;
              const { isRenderingToTexture: _ } = f, j = I.paint.get("line-opacity"), C = I.paint.get("line-width");
              if (j.constantOr(1) === 0 || C.constantOr(1) === 0) return;
              const v = z.getDepthModeForSublayer(0, Pt.ReadOnly), F = z.colorModeForRenderPass(), Y = I.paint.get("line-dasharray"), W = Y.constantOr(1), Z = I.paint.get("line-pattern"), J = Z.constantOr(1), R = I.paint.get("line-gradient"), q = I.getCrossfadeParameters();
              let $;
              $ = J ? "linePattern" : W && R ? "lineGradientSDF" : W ? "lineSDF" : R ? "lineGradient" : "line";
              const G = z.context, st = G.gl, ct = z.transform;
              let nt = !0;
              for (const at of p) {
                const Mt = d.getTile(at);
                if (J && !Mt.patternsLoaded()) continue;
                const xt = Mt.getBucket(I);
                if (!xt) continue;
                const wt = xt.programConfigurations.get(I.id), Nt = z.context.program.get(), Ct = z.useProgram($, wt), Ut = nt || Ct.program !== Nt, Yt = z.style.map.terrain && z.style.map.terrain.getTerrainData(at), ge = Z.constantOr(null), he = Y && Y.constantOr(null);
                if (ge && Mt.imageAtlas) {
                  const ve = Mt.imageAtlas, be = ve.patternPositions[ge.to.toString()], Be = ve.patternPositions[ge.from.toString()];
                  be && Be && wt.setConstantPatternPositions(be, Be);
                } else if (he) {
                  const ve = I.layout.get("line-cap") === "round", be = z.lineAtlas.getDash(he.to, ve), Be = z.lineAtlas.getDash(he.from, ve);
                  wt.setConstantDashPositions(be, Be);
                }
                const xe = ct.getProjectionData({ overscaledTileID: at, applyGlobeMatrix: !_, applyTerrainMatrix: !0 }), ne = ct.getPixelScale();
                let Ue;
                J ? (Ue = Cl(z, Mt, I, ne, q), Tc(G, st, Mt, wt, q)) : W && R ? (Ue = lc(z, Mt, I, ne, q, xt.lineClipsArray.length), Jo(z, d, G, st, I, xt, at, wt, q)) : W ? (Ue = Ol(z, Mt, I, ne, q), fc(z, G, st, wt, Ut, q)) : R ? (Ue = Sn(z, Mt, I, ne, xt.lineClipsArray.length), Va(z, d, G, st, I, xt, at)) : Ue = La(z, Mt, I, ne);
                const de = z.stencilModeForClipping(at);
                Ct.draw(G, st.TRIANGLES, v, de, F, Kt.disabled, Ue, Yt, xe, I.id, xt.layoutVertexBuffer, xt.indexBuffer, xt.segments, I.paint, z.transform.zoom, wt, xt.layoutVertexBuffer2), nt = !1;
              }
            })(e, r, o, c, h) : u.cp(o) ? (function(z, d, I, p, f) {
              const _ = I.paint.get("fill-color"), j = I.paint.get("fill-opacity");
              if (j.constantOr(1) === 0) return;
              const { isRenderingToTexture: C } = f, v = z.colorModeForRenderPass(), F = I.paint.get("fill-pattern"), Y = z.opaquePassEnabledForLayer() && !F.constantOr(1) && _.constantOr(u.bo.transparent).a === 1 && j.constantOr(0) === 1 ? "opaque" : "translucent";
              if (z.renderPass === Y) {
                const W = z.getDepthModeForSublayer(1, z.renderPass === "opaque" ? Pt.ReadWrite : Pt.ReadOnly);
                qo(z, d, I, p, W, v, !1, C);
              }
              if (z.renderPass === "translucent" && I.paint.get("fill-antialias")) {
                const W = z.getDepthModeForSublayer(I.getPaintProperty("fill-outline-color") ? 2 : 0, Pt.ReadOnly);
                qo(z, d, I, p, W, v, !0, C);
              }
            })(e, r, o, c, h) : u.cq(o) ? (function(z, d, I, p, f) {
              const _ = I.paint.get("fill-extrusion-opacity");
              if (_ === 0) return;
              const { isRenderingToTexture: j } = f;
              if (z.renderPass === "translucent") {
                const C = new Pt(z.context.gl.LEQUAL, Pt.ReadWrite, z.depthRangeFor3D);
                if (_ !== 1 || I.paint.get("fill-extrusion-pattern").constantOr(1)) fe(z, d, I, p, C, qt.disabled, Ne.disabled, j), fe(z, d, I, p, C, z.stencilModeFor3D(), z.colorModeForRenderPass(), j);
                else {
                  const v = z.colorModeForRenderPass();
                  fe(z, d, I, p, C, qt.disabled, v, j);
                }
              }
            })(e, r, o, c, h) : u.cr(o) ? (function(z, d, I, p, f) {
              if (z.renderPass !== "offscreen" && z.renderPass !== "translucent") return;
              const { isRenderingToTexture: _ } = f, j = z.context, C = z.style.projection.useSubdivision, v = z.getDepthModeForSublayer(0, Pt.ReadOnly), F = z.colorModeForRenderPass();
              if (z.renderPass === "offscreen") (function(Y, W, Z, J, R, q, $) {
                const G = Y.context, st = G.gl;
                for (const ct of Z) {
                  const nt = W.getTile(ct), at = nt.dem;
                  if (!at || !at.data || !nt.needsHillshadePrepare) continue;
                  const Mt = at.dim, xt = at.stride, wt = at.getPixels();
                  if (G.activeTexture.set(st.TEXTURE1), G.pixelStoreUnpackPremultiplyAlpha.set(!1), nt.demTexture = nt.demTexture || Y.getTileTexture(xt), nt.demTexture) {
                    const Ct = nt.demTexture;
                    Ct.update(wt, { premultiply: !1 }), Ct.bind(st.NEAREST, st.CLAMP_TO_EDGE);
                  } else nt.demTexture = new u.T(G, wt, st.RGBA, { premultiply: !1 }), nt.demTexture.bind(st.NEAREST, st.CLAMP_TO_EDGE);
                  G.activeTexture.set(st.TEXTURE0);
                  let Nt = nt.fbo;
                  if (!Nt) {
                    const Ct = new u.T(G, { width: Mt, height: Mt, data: null }, st.RGBA);
                    Ct.bind(st.LINEAR, st.CLAMP_TO_EDGE), Nt = nt.fbo = G.createFramebuffer(Mt, Mt, !0, !1), Nt.colorAttachment.set(Ct.texture);
                  }
                  G.bindFramebuffer.set(Nt.framebuffer), G.viewport.set([0, 0, Mt, Mt]), Y.useProgram("hillshadePrepare").draw(G, st.TRIANGLES, R, q, $, Kt.disabled, Mc(nt.tileID, at), null, null, J.id, Y.rasterBoundsBuffer, Y.quadTriangleIndexBuffer, Y.rasterBoundsSegments), nt.needsHillshadePrepare = !1;
                }
              })(z, d, p, I, v, qt.disabled, F), j.viewport.set([0, 0, z.width, z.height]);
              else if (z.renderPass === "translucent") if (C) {
                const [Y, W, Z] = z.stencilConfigForOverlapTwoPass(p);
                Ti(z, d, I, Z, Y, v, F, !1, _), Ti(z, d, I, Z, W, v, F, !0, _);
              } else {
                const [Y, W] = z.getStencilConfigForOverlapAndUpdateStencilID(p);
                Ti(z, d, I, W, Y, v, F, !1, _);
              }
            })(e, r, o, c, h) : u.cs(o) ? (function(z, d, I, p, f) {
              if (z.renderPass !== "translucent" || !p.length) return;
              const { isRenderingToTexture: _ } = f, j = z.style.projection.useSubdivision, C = z.getDepthModeForSublayer(0, Pt.ReadOnly), v = z.colorModeForRenderPass();
              if (j) {
                const [F, Y, W] = z.stencilConfigForOverlapTwoPass(p);
                js(z, d, I, W, F, C, v, !1, _), js(z, d, I, W, Y, C, v, !0, _);
              } else {
                const [F, Y] = z.getStencilConfigForOverlapAndUpdateStencilID(p);
                js(z, d, I, Y, F, C, v, !1, _);
              }
            })(e, r, o, c, h) : u.bT(o) ? (function(z, d, I, p, f) {
              if (z.renderPass !== "translucent" || I.paint.get("raster-opacity") === 0 || !p.length) return;
              const { isRenderingToTexture: _ } = f, j = d.getSource(), C = z.style.projection.useSubdivision;
              if (j instanceof Ts) Tr(z, d, I, p, null, !1, !1, j.tileCoords, j.flippedWindingOrder, _);
              else if (C) {
                const [v, F, Y] = z.stencilConfigForOverlapTwoPass(p);
                Tr(z, d, I, Y, v, !1, !0, Pn, !1, _), Tr(z, d, I, Y, F, !0, !0, Pn, !1, _);
              } else {
                const [v, F] = z.getStencilConfigForOverlapAndUpdateStencilID(p);
                Tr(z, d, I, F, v, !1, !0, Pn, !1, _);
              }
            })(e, r, o, c, h) : u.ct(o) ? (function(z, d, I, p, f) {
              const _ = I.paint.get("background-color"), j = I.paint.get("background-opacity");
              if (j === 0) return;
              const { isRenderingToTexture: C } = f, v = z.context, F = v.gl, Y = z.style.projection, W = z.transform, Z = W.tileSize, J = I.paint.get("background-pattern");
              if (z.isPatternMissing(J)) return;
              const R = !J && _.a === 1 && j === 1 && z.opaquePassEnabledForLayer() ? "opaque" : "translucent";
              if (z.renderPass !== R) return;
              const q = qt.disabled, $ = z.getDepthModeForSublayer(0, R === "opaque" ? Pt.ReadWrite : Pt.ReadOnly), G = z.colorModeForRenderPass(), st = z.useProgram(J ? "backgroundPattern" : "background"), ct = p || Xt(W, { tileSize: Z, terrain: z.style.map.terrain });
              J && (v.activeTexture.set(F.TEXTURE0), z.imageManager.bind(z.context));
              const nt = I.getCrossfadeParameters();
              for (const at of ct) {
                const Mt = W.getProjectionData({ overscaledTileID: at, applyGlobeMatrix: !C, applyTerrainMatrix: !0 }), xt = J ? Uo(j, z, J, { tileID: at, tileSize: Z }, nt) : Yo(j, _), wt = z.style.map.terrain && z.style.map.terrain.getTerrainData(at), Nt = Y.getMeshFromTileID(v, at.canonical, !1, !0, "raster");
                st.draw(v, F.TRIANGLES, $, q, G, Kt.backCCW, xt, wt, Mt, I.id, Nt.vertexBuffer, Nt.indexBuffer, Nt.segments);
              }
            })(e, 0, o, c, h) : u.cu(o) && (function(z, d, I, p) {
              const { isRenderingGlobe: f } = p, _ = z.context, j = I.implementation, C = z.style.projection, v = z.transform, F = v.getProjectionDataForCustomLayer(f), Y = { farZ: v.farZ, nearZ: v.nearZ, fov: v.fov * Math.PI / 180, modelViewProjectionMatrix: v.modelViewProjectionMatrix, projectionMatrix: v.projectionMatrix, shaderData: { variantName: C.shaderVariantName, vertexShaderPrelude: `const float PI = 3.141592653589793;
uniform mat4 u_projection_matrix;
${C.shaderPreludeCode.vertexSource}`, define: C.shaderDefine }, defaultProjectionData: F }, W = j.renderingMode ? j.renderingMode : "2d";
              if (z.renderPass === "offscreen") {
                const Z = j.prerender;
                Z && (z.setCustomLayerDefaults(), _.setColorMode(z.colorModeForRenderPass()), Z.call(j, _.gl, Y), _.setDirty(), z.setBaseState());
              } else if (z.renderPass === "translucent") {
                z.setCustomLayerDefaults(), _.setColorMode(z.colorModeForRenderPass()), _.setStencilMode(qt.disabled);
                const Z = W === "3d" ? z.getDepthModeFor3D() : z.getDepthModeForSublayer(0, Pt.ReadOnly);
                _.setDepthMode(Z), j.render(_.gl, Y), _.setDirty(), z.setBaseState(), _.bindFramebuffer.set(null);
              }
            })(e, 0, o, h));
          }
          saveTileTexture(e) {
            const r = this._tileTextures[e.size[0]];
            r ? r.push(e) : this._tileTextures[e.size[0]] = [e];
          }
          getTileTexture(e) {
            const r = this._tileTextures[e];
            return r && r.length > 0 ? r.pop() : null;
          }
          isPatternMissing(e) {
            if (!e) return !1;
            if (!e.from || !e.to) return !0;
            const r = this.imageManager.getPattern(e.from.toString()), o = this.imageManager.getPattern(e.to.toString());
            return !r || !o;
          }
          useProgram(e, r, o = !1, c = []) {
            this.cache = this.cache || {};
            const h = !!this.style.map.terrain, z = this.style.projection, d = o ? Fs.projectionMercator : z.shaderPreludeCode, I = o ? ns : z.shaderDefine, p = e + (r ? r.cacheKey : "") + `/${o ? as : z.shaderVariantName}` + (this._showOverdrawInspector ? "/overdraw" : "") + (h ? "/terrain" : "") + (c ? `/${c.join("/")}` : "");
            return this.cache[p] || (this.cache[p] = new _l(this.context, Fs[e], r, Wo[e], this._showOverdrawInspector, h, d, I, c)), this.cache[p];
          }
          setCustomLayerDefaults() {
            this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
          }
          setBaseState() {
            const e = this.context.gl;
            this.context.cullFace.set(!1), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(e.FUNC_ADD);
          }
          initDebugOverlayCanvas() {
            this.debugOverlayCanvas == null && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new u.T(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
          }
          destroy() {
            var e, r;
            if (this._tileTextures) {
              for (const o in this._tileTextures) {
                const c = this._tileTextures[o];
                if (c) for (const h of c) h.destroy();
              }
              this._tileTextures = {};
            }
            if (this.tileExtentBuffer && this.tileExtentBuffer.destroy(), this.debugBuffer && this.debugBuffer.destroy(), this.rasterBoundsBuffer && this.rasterBoundsBuffer.destroy(), this.rasterBoundsBufferPosOnly && this.rasterBoundsBufferPosOnly.destroy(), this.viewportBuffer && this.viewportBuffer.destroy(), this.tileBorderIndexBuffer && this.tileBorderIndexBuffer.destroy(), this.quadTriangleIndexBuffer && this.quadTriangleIndexBuffer.destroy(), this.tileExtentMesh && ((e = this.tileExtentMesh.vertexBuffer) === null || e === void 0 || e.destroy()), this.tileExtentMesh && ((r = this.tileExtentMesh.indexBuffer) === null || r === void 0 || r.destroy()), this.debugOverlayTexture && this.debugOverlayTexture.destroy(), this.cache) {
              for (const o in this.cache) {
                const c = this.cache[o];
                c && c.program && this.context.gl.deleteProgram(c.program);
              }
              this.cache = {};
            }
            this.context && this.context.setDefault();
          }
          overLimit() {
            const { drawingBufferWidth: e, drawingBufferHeight: r } = this.context.gl;
            return this.width !== e || this.height !== r;
          }
        }
        function iM(g, e) {
          let r, o = !1, c = null, h = null;
          const z = () => {
            c = null, o && (g.apply(h, r), c = setTimeout(z, e), o = !1);
          };
          return (...d) => (o = !0, h = this, r = d, c || z(), c);
        }
        class rM {
          constructor(e) {
            this._getCurrentHash = () => {
              const r = window.location.hash.replace("#", "");
              if (this._hashName) {
                let o;
                return r.split("&").map(((c) => c.split("="))).forEach(((c) => {
                  c[0] === this._hashName && (o = c);
                })), (o && o[1] || "").split("/");
              }
              return r.split("/");
            }, this._onHashChange = () => {
              const r = this._getCurrentHash();
              if (!this._isValidHash(r)) return !1;
              const o = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(r[3] || 0) : this._map.getBearing();
              return this._map.jumpTo({ center: [+r[2], +r[1]], zoom: +r[0], bearing: o, pitch: +(r[4] || 0) }), !0;
            }, this._updateHashUnthrottled = () => {
              const r = window.location.href.replace(/(#.*)?$/, this.getHashString());
              window.history.replaceState(window.history.state, null, r);
            }, this._removeHash = () => {
              const r = this._getCurrentHash();
              if (r.length === 0) return;
              const o = r.join("/");
              let c = o;
              c.split("&").length > 0 && (c = c.split("&")[0]), this._hashName && (c = `${this._hashName}=${o}`);
              let h = window.location.hash.replace(c, "");
              h.startsWith("#&") ? h = h.slice(0, 1) + h.slice(2) : h === "#" && (h = "");
              let z = window.location.href.replace(/(#.+)?$/, h);
              z = z.replace("&&", "&"), window.history.replaceState(window.history.state, null, z);
            }, this._updateHash = iM(this._updateHashUnthrottled, 300), this._hashName = e && encodeURIComponent(e);
          }
          addTo(e) {
            return this._map = e, addEventListener("hashchange", this._onHashChange, !1), this._map.on("moveend", this._updateHash), this;
          }
          remove() {
            return removeEventListener("hashchange", this._onHashChange, !1), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), this._removeHash(), delete this._map, this;
          }
          getHashString(e) {
            const r = this._map.getCenter(), o = Math.round(100 * this._map.getZoom()) / 100, c = Math.ceil((o * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), h = Math.pow(10, c), z = Math.round(r.lng * h) / h, d = Math.round(r.lat * h) / h, I = this._map.getBearing(), p = this._map.getPitch();
            let f = "";
            if (f += e ? `/${z}/${d}/${o}` : `${o}/${d}/${z}`, (I || p) && (f += "/" + Math.round(10 * I) / 10), p && (f += `/${Math.round(p)}`), this._hashName) {
              const _ = this._hashName;
              let j = !1;
              const C = window.location.hash.slice(1).split("&").map(((v) => {
                const F = v.split("=")[0];
                return F === _ ? (j = !0, `${F}=${f}`) : v;
              })).filter(((v) => v));
              return j || C.push(`${_}=${f}`), `#${C.join("&")}`;
            }
            return `#${f}`;
          }
          _isValidHash(e) {
            if (e.length < 3 || e.some(isNaN)) return !1;
            try {
              new u.V(+e[2], +e[1]);
            } catch {
              return !1;
            }
            const r = +e[0], o = +(e[3] || 0), c = +(e[4] || 0);
            return r >= this._map.getMinZoom() && r <= this._map.getMaxZoom() && o >= -180 && o <= 180 && c >= this._map.getMinPitch() && c <= this._map.getMaxPitch();
          }
        }
        const on = { linearity: 0.3, easing: u.cv(0, 0, 0.3, 1) }, Lc = u.e({ deceleration: 2500, maxSpeed: 1400 }, on), Cc = u.e({ deceleration: 20, maxSpeed: 1400 }, on), Oc = u.e({ deceleration: 1e3, maxSpeed: 360 }, on), Ga = u.e({ deceleration: 1e3, maxSpeed: 90 }, on), Ec = u.e({ deceleration: 1e3, maxSpeed: 360 }, on);
        class Us {
          constructor(e) {
            this._map = e, this.clear();
          }
          clear() {
            this._inertiaBuffer = [];
          }
          record(e) {
            this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: $t(), settings: e });
          }
          _drainInertiaBuffer() {
            const e = this._inertiaBuffer, r = $t();
            for (; e.length > 0 && r - e[0].time > 160; ) e.shift();
          }
          _onMoveEnd(e) {
            if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
            const r = { zoom: 0, bearing: 0, pitch: 0, roll: 0, pan: new u.P(0, 0), pinchAround: void 0, around: void 0 };
            for (const { settings: h } of this._inertiaBuffer) r.zoom += h.zoomDelta || 0, r.bearing += h.bearingDelta || 0, r.pitch += h.pitchDelta || 0, r.roll += h.rollDelta || 0, h.panDelta && r.pan._add(h.panDelta), h.around && (r.around = h.around), h.pinchAround && (r.pinchAround = h.pinchAround);
            const o = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, c = {};
            if (r.pan.mag()) {
              const h = Mn(r.pan.mag(), o, u.e({}, Lc, e || {})), z = r.pan.mult(h.amount / r.pan.mag()), d = this._map.cameraHelper.handlePanInertia(z, this._map.transform);
              c.center = d.easingCenter, c.offset = d.easingOffset, Ns(c, h);
            }
            if (r.zoom) {
              const h = Mn(r.zoom, o, Cc);
              c.zoom = this._map.transform.zoom + h.amount, Ns(c, h);
            }
            if (r.bearing) {
              const h = Mn(r.bearing, o, Oc);
              c.bearing = this._map.transform.bearing + u.an(h.amount, -179, 179), Ns(c, h);
            }
            if (r.pitch) {
              const h = Mn(r.pitch, o, Ga);
              c.pitch = this._map.transform.pitch + h.amount, Ns(c, h);
            }
            if (r.roll) {
              const h = Mn(r.roll, o, Ec);
              c.roll = this._map.transform.roll + u.an(h.amount, -179, 179), Ns(c, h);
            }
            if (c.zoom || c.bearing) {
              const h = r.pinchAround === void 0 ? r.around : r.pinchAround;
              c.around = h ? this._map.unproject(h) : this._map.getCenter();
            }
            return this.clear(), u.e(c, { noMoveStart: !0 });
          }
        }
        function Ns(g, e) {
          (!g.duration || g.duration < e.duration) && (g.duration = e.duration, g.easing = e.easing);
        }
        function Mn(g, e, r) {
          const { maxSpeed: o, linearity: c, deceleration: h } = r, z = u.an(g * c / (e / 1e3), -o, o), d = Math.abs(z) / (h * c);
          return { easing: r.easing, duration: 1e3 * d, amount: z * (d / 2) };
        }
        class Le extends u.l {
          preventDefault() {
            this._defaultPrevented = !0;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(e, r, o, c = {}) {
            o = o instanceof MouseEvent ? o : new MouseEvent(e, o);
            const h = gt.mousePos(r.getCanvas(), o), z = r.unproject(h);
            super(e, u.e({ point: h, lngLat: z, originalEvent: o }, c)), this._defaultPrevented = !1, this.target = r;
          }
        }
        class Vn extends u.l {
          preventDefault() {
            this._defaultPrevented = !0;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(e, r, o) {
            const c = e === "touchend" ? o.changedTouches : o.touches, h = gt.touchPos(r.getCanvasContainer(), c), z = h.map(((I) => r.unproject(I))), d = h.reduce(((I, p, f, _) => I.add(p.div(_.length))), new u.P(0, 0));
            super(e, { points: h, point: d, lngLats: z, lngLat: r.unproject(d), originalEvent: o }), this._defaultPrevented = !1;
          }
        }
        class fr extends u.l {
          preventDefault() {
            this._defaultPrevented = !0;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(e, r, o) {
            super(e, { originalEvent: o }), this._defaultPrevented = !1;
          }
        }
        class Yl {
          constructor(e, r) {
            this._map = e, this._clickTolerance = r.clickTolerance;
          }
          reset() {
            delete this._mousedownPos;
          }
          wheel(e) {
            return this._firePreventable(new fr(e.type, this._map, e));
          }
          mousedown(e, r) {
            return this._mousedownPos = r, this._firePreventable(new Le(e.type, this._map, e));
          }
          mouseup(e) {
            this._map.fire(new Le(e.type, this._map, e));
          }
          click(e, r) {
            this._mousedownPos && this._mousedownPos.dist(r) >= this._clickTolerance || this._map.fire(new Le(e.type, this._map, e));
          }
          dblclick(e) {
            return this._firePreventable(new Le(e.type, this._map, e));
          }
          mouseover(e) {
            this._map.fire(new Le(e.type, this._map, e));
          }
          mouseout(e) {
            this._map.fire(new Le(e.type, this._map, e));
          }
          touchstart(e) {
            return this._firePreventable(new Vn(e.type, this._map, e));
          }
          touchmove(e) {
            this._map.fire(new Vn(e.type, this._map, e));
          }
          touchend(e) {
            this._map.fire(new Vn(e.type, this._map, e));
          }
          touchcancel(e) {
            this._map.fire(new Vn(e.type, this._map, e));
          }
          _firePreventable(e) {
            if (this._map.fire(e), e.defaultPrevented) return {};
          }
          isEnabled() {
            return !0;
          }
          isActive() {
            return !1;
          }
          enable() {
          }
          disable() {
          }
        }
        class Ul {
          constructor(e) {
            this._map = e;
          }
          reset() {
            this._delayContextMenu = !1, this._ignoreContextMenu = !0, delete this._contextMenuEvent;
          }
          mousemove(e) {
            this._map.fire(new Le(e.type, this._map, e));
          }
          mousedown() {
            this._delayContextMenu = !0, this._ignoreContextMenu = !1;
          }
          mouseup() {
            this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new Le("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
          }
          contextmenu(e) {
            this._delayContextMenu ? this._contextMenuEvent = e : this._ignoreContextMenu || this._map.fire(new Le(e.type, this._map, e)), this._map.listens("contextmenu") && e.preventDefault();
          }
          isEnabled() {
            return !0;
          }
          isActive() {
            return !1;
          }
          enable() {
          }
          disable() {
          }
        }
        class Gn {
          constructor(e) {
            this._map = e;
          }
          get transform() {
            return this._map._requestedCameraState || this._map.transform;
          }
          get center() {
            return { lng: this.transform.center.lng, lat: this.transform.center.lat };
          }
          get zoom() {
            return this.transform.zoom;
          }
          get pitch() {
            return this.transform.pitch;
          }
          get bearing() {
            return this.transform.bearing;
          }
          unproject(e) {
            return this.transform.screenPointToLocation(u.P.convert(e), this._map.terrain);
          }
        }
        class bc {
          constructor(e, r) {
            this._map = e, this._tr = new Gn(e), this._el = e.getCanvasContainer(), this._container = e.getContainer(), this._clickTolerance = r.clickTolerance || 1;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active;
          }
          enable() {
            this.isEnabled() || (this._enabled = !0);
          }
          disable() {
            this.isEnabled() && (this._enabled = !1);
          }
          mousedown(e, r) {
            this.isEnabled() && e.shiftKey && e.button === 0 && (gt.disableDrag(), this._startPos = this._lastPos = r, this._active = !0);
          }
          mousemoveWindow(e, r) {
            if (!this._active) return;
            const o = r;
            if (this._lastPos.equals(o) || !this._box && o.dist(this._startPos) < this._clickTolerance) return;
            const c = this._startPos;
            this._lastPos = o, this._box || (this._box = gt.create("div", "maplibregl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair"), this._fireEvent("boxzoomstart", e));
            const h = Math.min(c.x, o.x), z = Math.max(c.x, o.x), d = Math.min(c.y, o.y), I = Math.max(c.y, o.y);
            gt.setTransform(this._box, `translate(${h}px,${d}px)`), this._box.style.width = z - h + "px", this._box.style.height = I - d + "px";
          }
          mouseupWindow(e, r) {
            if (!this._active || e.button !== 0) return;
            const o = this._startPos, c = r;
            if (this.reset(), gt.suppressClick(), o.x !== c.x || o.y !== c.y) return this._map.fire(new u.l("boxzoomend", { originalEvent: e })), { cameraAnimation: (h) => h.fitScreenCoordinates(o, c, this._tr.bearing, { linear: !0 }) };
            this._fireEvent("boxzoomcancel", e);
          }
          keydown(e) {
            this._active && e.keyCode === 27 && (this.reset(), this._fireEvent("boxzoomcancel", e));
          }
          reset() {
            this._active = !1, this._container.classList.remove("maplibregl-crosshair"), this._box && (gt.remove(this._box), this._box = null), gt.enableDrag(), delete this._startPos, delete this._lastPos;
          }
          _fireEvent(e, r) {
            return this._map.fire(new u.l(e, { originalEvent: r }));
          }
        }
        function Ha(g, e) {
          if (g.length !== e.length) throw new Error(`The number of touches and points are not equal - touches ${g.length}, points ${e.length}`);
          const r = {};
          for (let o = 0; o < g.length; o++) r[g[o].identifier] = e[o];
          return r;
        }
        class Hn {
          constructor(e) {
            this.reset(), this.numTouches = e.numTouches;
          }
          reset() {
            delete this.centroid, delete this.startTime, delete this.touches, this.aborted = !1;
          }
          touchstart(e, r, o) {
            (this.centroid || o.length > this.numTouches) && (this.aborted = !0), this.aborted || (this.startTime === void 0 && (this.startTime = e.timeStamp), o.length === this.numTouches && (this.centroid = (function(c) {
              const h = new u.P(0, 0);
              for (const z of c) h._add(z);
              return h.div(c.length);
            })(r), this.touches = Ha(o, r)));
          }
          touchmove(e, r, o) {
            if (this.aborted || !this.centroid) return;
            const c = Ha(o, r);
            for (const h in this.touches) {
              const z = c[h];
              (!z || z.dist(this.touches[h]) > 30) && (this.aborted = !0);
            }
          }
          touchend(e, r, o) {
            if ((!this.centroid || e.timeStamp - this.startTime > 500) && (this.aborted = !0), o.length === 0) {
              const c = !this.aborted && this.centroid;
              if (this.reset(), c) return c;
            }
          }
        }
        class ti {
          constructor(e) {
            this.singleTap = new Hn(e), this.numTaps = e.numTaps, this.reset();
          }
          reset() {
            this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset();
          }
          touchstart(e, r, o) {
            this.singleTap.touchstart(e, r, o);
          }
          touchmove(e, r, o) {
            this.singleTap.touchmove(e, r, o);
          }
          touchend(e, r, o) {
            const c = this.singleTap.touchend(e, r, o);
            if (c) {
              const h = e.timeStamp - this.lastTime < 500, z = !this.lastTap || this.lastTap.dist(c) < 30;
              if (h && z || this.reset(), this.count++, this.lastTime = e.timeStamp, this.lastTap = c, this.count === this.numTaps) return this.reset(), c;
            }
          }
        }
        class jt {
          constructor(e) {
            this._tr = new Gn(e), this._zoomIn = new ti({ numTouches: 1, numTaps: 2 }), this._zoomOut = new ti({ numTouches: 2, numTaps: 1 }), this.reset();
          }
          reset() {
            this._active = !1, this._zoomIn.reset(), this._zoomOut.reset();
          }
          touchstart(e, r, o) {
            this._zoomIn.touchstart(e, r, o), this._zoomOut.touchstart(e, r, o);
          }
          touchmove(e, r, o) {
            this._zoomIn.touchmove(e, r, o), this._zoomOut.touchmove(e, r, o);
          }
          touchend(e, r, o) {
            const c = this._zoomIn.touchend(e, r, o), h = this._zoomOut.touchend(e, r, o), z = this._tr;
            return c ? (this._active = !0, e.preventDefault(), setTimeout((() => this.reset()), 0), { cameraAnimation: (d) => d.easeTo({ duration: 300, zoom: z.zoom + 1, around: z.unproject(c) }, { originalEvent: e }) }) : h ? (this._active = !0, e.preventDefault(), setTimeout((() => this.reset()), 0), { cameraAnimation: (d) => d.easeTo({ duration: 300, zoom: z.zoom - 1, around: z.unproject(h) }, { originalEvent: e }) }) : void 0;
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class cn {
          constructor(e) {
            this._enabled = !!e.enable, this._moveStateManager = e.moveStateManager, this._clickTolerance = e.clickTolerance || 1, this._moveFunction = e.move, this._activateOnStart = !!e.activateOnStart, e.assignEvents(this), this.reset();
          }
          reset(e) {
            this._active = !1, this._moved = !1, delete this._lastPoint, this._moveStateManager.endMove(e);
          }
          _move(...e) {
            const r = this._moveFunction(...e);
            if (r.bearingDelta || r.pitchDelta || r.rollDelta || r.around || r.panDelta) return this._active = !0, r;
          }
          dragStart(e, r) {
            this.isEnabled() && !this._lastPoint && this._moveStateManager.isValidStartEvent(e) && (this._moveStateManager.startMove(e), this._lastPoint = Array.isArray(r) ? r[0] : r, this._activateOnStart && this._lastPoint && (this._active = !0));
          }
          dragMove(e, r) {
            if (!this.isEnabled()) return;
            const o = this._lastPoint;
            if (!o) return;
            if (e.preventDefault(), !this._moveStateManager.isValidMoveEvent(e)) return void this.reset(e);
            const c = Array.isArray(r) ? r[0] : r;
            return !this._moved && c.dist(o) < this._clickTolerance ? void 0 : (this._moved = !0, this._lastPoint = c, this._move(o, c));
          }
          dragEnd(e) {
            this.isEnabled() && this._lastPoint && this._moveStateManager.isValidEndEvent(e) && (this._moved && gt.suppressClick(), this.reset(e));
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
          getClickTolerance() {
            return this._clickTolerance;
          }
        }
        const nM = 0, Qc = 2, Jn = { [nM]: 1, [Qc]: 2 };
        class fi {
          constructor(e) {
            this._correctEvent = e.checkCorrectEvent;
          }
          startMove(e) {
            const r = gt.mouseButton(e);
            this._eventButton = r;
          }
          endMove(e) {
            delete this._eventButton;
          }
          isValidStartEvent(e) {
            return this._correctEvent(e);
          }
          isValidMoveEvent(e) {
            return !(function(r, o) {
              const c = Jn[o];
              return r.buttons === void 0 || (r.buttons & c) !== c;
            })(e, this._eventButton);
          }
          isValidEndEvent(e) {
            return gt.mouseButton(e) === this._eventButton;
          }
        }
        class aM {
          constructor() {
            this._firstTouch = void 0;
          }
          _isOneFingerTouch(e) {
            return e.targetTouches.length === 1;
          }
          _isSameTouchEvent(e) {
            return e.targetTouches[0].identifier === this._firstTouch;
          }
          startMove(e) {
            this._firstTouch = e.targetTouches[0].identifier;
          }
          endMove(e) {
            delete this._firstTouch;
          }
          isValidStartEvent(e) {
            return this._isOneFingerTouch(e);
          }
          isValidMoveEvent(e) {
            return this._isOneFingerTouch(e) && this._isSameTouchEvent(e);
          }
          isValidEndEvent(e) {
            return this._isOneFingerTouch(e) && this._isSameTouchEvent(e);
          }
        }
        class Xl {
          constructor(e = new fi({ checkCorrectEvent: () => !0 }), r = new aM()) {
            this.mouseMoveStateManager = e, this.oneFingerTouchMoveStateManager = r;
          }
          _executeRelevantHandler(e, r, o) {
            return e instanceof MouseEvent ? r(e) : typeof TouchEvent < "u" && e instanceof TouchEvent ? o(e) : void 0;
          }
          startMove(e) {
            this._executeRelevantHandler(e, ((r) => this.mouseMoveStateManager.startMove(r)), ((r) => this.oneFingerTouchMoveStateManager.startMove(r)));
          }
          endMove(e) {
            this._executeRelevantHandler(e, ((r) => this.mouseMoveStateManager.endMove(r)), ((r) => this.oneFingerTouchMoveStateManager.endMove(r)));
          }
          isValidStartEvent(e) {
            return this._executeRelevantHandler(e, ((r) => this.mouseMoveStateManager.isValidStartEvent(r)), ((r) => this.oneFingerTouchMoveStateManager.isValidStartEvent(r)));
          }
          isValidMoveEvent(e) {
            return this._executeRelevantHandler(e, ((r) => this.mouseMoveStateManager.isValidMoveEvent(r)), ((r) => this.oneFingerTouchMoveStateManager.isValidMoveEvent(r)));
          }
          isValidEndEvent(e) {
            return this._executeRelevantHandler(e, ((r) => this.mouseMoveStateManager.isValidEndEvent(r)), ((r) => this.oneFingerTouchMoveStateManager.isValidEndEvent(r)));
          }
        }
        const ln = (g) => {
          g.mousedown = g.dragStart, g.mousemoveWindow = g.dragMove, g.mouseup = g.dragEnd, g.contextmenu = (e) => {
            e.preventDefault();
          };
        };
        class vc {
          constructor(e, r) {
            this._clickTolerance = e.clickTolerance || 1, this._map = r, this.reset();
          }
          reset() {
            this._active = !1, this._touches = {}, this._sum = new u.P(0, 0);
          }
          _shouldBePrevented(e) {
            return e < (this._map.cooperativeGestures.isEnabled() ? 2 : 1);
          }
          touchstart(e, r, o) {
            return this._calculateTransform(e, r, o);
          }
          touchmove(e, r, o) {
            if (this._active) {
              if (!this._shouldBePrevented(o.length)) return e.preventDefault(), this._calculateTransform(e, r, o);
              this._map.cooperativeGestures.notifyGestureBlocked("touch_pan", e);
            }
          }
          touchend(e, r, o) {
            this._calculateTransform(e, r, o), this._active && this._shouldBePrevented(o.length) && this.reset();
          }
          touchcancel() {
            this.reset();
          }
          _calculateTransform(e, r, o) {
            o.length > 0 && (this._active = !0);
            const c = Ha(o, r), h = new u.P(0, 0), z = new u.P(0, 0);
            let d = 0;
            for (const p in c) {
              const f = c[p], _ = this._touches[p];
              _ && (h._add(f), z._add(f.sub(_)), d++, c[p] = f);
            }
            if (this._touches = c, this._shouldBePrevented(d) || !z.mag()) return;
            const I = z.div(d);
            return this._sum._add(I), this._sum.mag() < this._clickTolerance ? void 0 : { around: h.div(d), panDelta: I };
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class qn {
          constructor() {
            this.reset();
          }
          reset() {
            this._active = !1, delete this._firstTwoTouches;
          }
          touchstart(e, r, o) {
            this._firstTwoTouches || o.length < 2 || (this._firstTwoTouches = [o[0].identifier, o[1].identifier], this._start([r[0], r[1]]));
          }
          touchmove(e, r, o) {
            if (!this._firstTwoTouches) return;
            e.preventDefault();
            const [c, h] = this._firstTwoTouches, z = Ja(o, r, c), d = Ja(o, r, h);
            if (!z || !d) return;
            const I = this._aroundCenter ? null : z.add(d).div(2);
            return this._move([z, d], I, e);
          }
          touchend(e, r, o) {
            if (!this._firstTwoTouches) return;
            const [c, h] = this._firstTwoTouches, z = Ja(o, r, c), d = Ja(o, r, h);
            z && d || (this._active && gt.suppressClick(), this.reset());
          }
          touchcancel() {
            this.reset();
          }
          enable(e) {
            this._enabled = !0, this._aroundCenter = !!e && e.around === "center";
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active;
          }
        }
        function Ja(g, e, r) {
          for (let o = 0; o < g.length; o++) if (g[o].identifier === r) return e[o];
        }
        function oM(g, e) {
          return Math.log(g / e) / Math.LN2;
        }
        class Bc extends qn {
          reset() {
            super.reset(), delete this._distance, delete this._startDistance;
          }
          _start(e) {
            this._startDistance = this._distance = e[0].dist(e[1]);
          }
          _move(e, r) {
            const o = this._distance;
            if (this._distance = e[0].dist(e[1]), this._active || !(Math.abs(oM(this._distance, this._startDistance)) < 0.1)) return this._active = !0, { zoomDelta: oM(this._distance, o), pinchAround: r };
          }
        }
        function Sc(g, e) {
          return 180 * g.angleWith(e) / Math.PI;
        }
        class MM extends qn {
          reset() {
            super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector;
          }
          _start(e) {
            this._startVector = this._vector = e[0].sub(e[1]), this._minDiameter = e[0].dist(e[1]);
          }
          _move(e, r, o) {
            const c = this._vector;
            if (this._vector = e[0].sub(e[1]), this._active || !this._isBelowThreshold(this._vector)) return this._active = !0, { bearingDelta: Sc(this._vector, c), pinchAround: r };
          }
          _isBelowThreshold(e) {
            this._minDiameter = Math.min(this._minDiameter, e.mag());
            const r = 25 / (Math.PI * this._minDiameter) * 360, o = Sc(e, this._startVector);
            return Math.abs(o) < r;
          }
        }
        function cM(g) {
          return Math.abs(g.y) > Math.abs(g.x);
        }
        class lM extends qn {
          constructor(e) {
            super(), this._currentTouchCount = 0, this._map = e;
          }
          reset() {
            super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints;
          }
          touchstart(e, r, o) {
            super.touchstart(e, r, o), this._currentTouchCount = o.length;
          }
          _start(e) {
            this._lastPoints = e, cM(e[0].sub(e[1])) && (this._valid = !1);
          }
          _move(e, r, o) {
            if (this._map.cooperativeGestures.isEnabled() && this._currentTouchCount < 3) return;
            const c = e[0].sub(this._lastPoints[0]), h = e[1].sub(this._lastPoints[1]);
            return this._valid = this.gestureBeginsVertically(c, h, o.timeStamp), this._valid ? (this._lastPoints = e, this._active = !0, { pitchDelta: (c.y + h.y) / 2 * -0.5 }) : void 0;
          }
          gestureBeginsVertically(e, r, o) {
            if (this._valid !== void 0) return this._valid;
            const c = e.mag() >= 2, h = r.mag() >= 2;
            if (!c && !h) return;
            if (!c || !h) return this._firstMove === void 0 && (this._firstMove = o), o - this._firstMove < 100 && void 0;
            const z = e.y > 0 == r.y > 0;
            return cM(e) && cM(r) && z;
          }
        }
        const Wl = { panStep: 100, bearingStep: 15, pitchStep: 10 };
        class kc {
          constructor(e) {
            this._tr = new Gn(e);
            const r = Wl;
            this._panStep = r.panStep, this._bearingStep = r.bearingStep, this._pitchStep = r.pitchStep, this._rotationDisabled = !1;
          }
          reset() {
            this._active = !1;
          }
          keydown(e) {
            if (e.altKey || e.ctrlKey || e.metaKey) return;
            let r = 0, o = 0, c = 0, h = 0, z = 0;
            switch (e.keyCode) {
              case 61:
              case 107:
              case 171:
              case 187:
                r = 1;
                break;
              case 189:
              case 109:
              case 173:
                r = -1;
                break;
              case 37:
                e.shiftKey ? o = -1 : (e.preventDefault(), h = -1);
                break;
              case 39:
                e.shiftKey ? o = 1 : (e.preventDefault(), h = 1);
                break;
              case 38:
                e.shiftKey ? c = 1 : (e.preventDefault(), z = -1);
                break;
              case 40:
                e.shiftKey ? c = -1 : (e.preventDefault(), z = 1);
                break;
              default:
                return;
            }
            return this._rotationDisabled && (o = 0, c = 0), { cameraAnimation: (d) => {
              const I = this._tr;
              d.easeTo({ duration: 300, easeId: "keyboardHandler", easing: qi, zoom: r ? Math.round(I.zoom) + r * (e.shiftKey ? 2 : 1) : I.zoom, bearing: I.bearing + o * this._bearingStep, pitch: I.pitch + c * this._pitchStep, offset: [-h * this._panStep, -z * this._panStep], center: I.center }, { originalEvent: e });
            } };
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
          disableRotation() {
            this._rotationDisabled = !0;
          }
          enableRotation() {
            this._rotationDisabled = !1;
          }
        }
        function qi(g) {
          return g * (2 - g);
        }
        const ie = 4.000244140625, Pl = 1 / 450;
        class $n {
          constructor(e, r) {
            this._onTimeout = (o) => {
              this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(o);
            }, this._map = e, this._tr = new Gn(e), this._triggerRenderFrame = r, this._delta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = Pl;
          }
          setZoomRate(e) {
            this._defaultZoomRate = e;
          }
          setWheelZoomRate(e) {
            this._wheelZoomRate = e;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active || this._finishTimeout !== void 0;
          }
          isZooming() {
            return !!this._zooming;
          }
          enable(e) {
            this.isEnabled() || (this._enabled = !0, this._aroundCenter = !!e && e.around === "center");
          }
          disable() {
            this.isEnabled() && (this._enabled = !1);
          }
          _shouldBePrevented(e) {
            return !!this._map.cooperativeGestures.isEnabled() && !(e.ctrlKey || this._map.cooperativeGestures.isBypassed(e));
          }
          wheel(e) {
            if (!this.isEnabled()) return;
            if (this._shouldBePrevented(e)) return void this._map.cooperativeGestures.notifyGestureBlocked("wheel_zoom", e);
            let r = e.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * e.deltaY : e.deltaY;
            const o = $t(), c = o - (this._lastWheelEventTime || 0);
            this._lastWheelEventTime = o, r !== 0 && r % ie == 0 ? this._type = "wheel" : r !== 0 && Math.abs(r) < 4 ? this._type = "trackpad" : c > 400 ? (this._type = null, this._lastValue = r, this._timeout = setTimeout(this._onTimeout, 40, e)) : this._type || (this._type = Math.abs(c * r) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, r += this._lastValue)), e.shiftKey && r && (r /= 4), this._type && (this._lastWheelEvent = e, this._delta -= r, this._active || this._start(e)), e.preventDefault();
          }
          _start(e) {
            if (!this._delta) return;
            this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
            const r = gt.mousePos(this._map.getCanvas(), e), o = this._tr;
            this._aroundPoint = this._aroundCenter ? o.transform.locationToScreenPoint(u.V.convert(o.center)) : r, this._frameId || (this._frameId = !0, this._triggerRenderFrame());
          }
          renderFrame() {
            if (!this._frameId || (this._frameId = null, !this.isActive())) return;
            const e = this._tr.transform;
            if (typeof this._lastExpectedZoom == "number") {
              const d = e.zoom - this._lastExpectedZoom;
              typeof this._startZoom == "number" && (this._startZoom += d), typeof this._targetZoom == "number" && (this._targetZoom += d);
            }
            if (this._delta !== 0) {
              const d = this._type === "wheel" && Math.abs(this._delta) > ie ? this._wheelZoomRate : this._defaultZoomRate;
              let I = 2 / (1 + Math.exp(-Math.abs(this._delta * d)));
              this._delta < 0 && I !== 0 && (I = 1 / I);
              const p = typeof this._targetZoom != "number" ? e.scale : u.aq(this._targetZoom);
              this._targetZoom = e.applyConstrain(e.getCameraLngLat(), u.at(p * I)).zoom, this._type === "wheel" && (this._startZoom = e.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;
            }
            const r = typeof this._targetZoom != "number" ? e.zoom : this._targetZoom, o = this._startZoom, c = this._easing;
            let h, z = !1;
            if (this._type === "wheel" && o && c) {
              const d = $t() - this._lastWheelEventTime, I = Math.min((d + 5) / 200, 1), p = c(I);
              h = u.G.number(o, r, p), I < 1 ? this._frameId || (this._frameId = !0) : z = !0;
            } else h = r, z = !0;
            return this._active = !0, z && (this._active = !1, this._finishTimeout = setTimeout((() => {
              this._zooming = !1, this._triggerRenderFrame(), delete this._targetZoom, delete this._lastExpectedZoom, delete this._finishTimeout;
            }), 200)), this._lastExpectedZoom = h, { noInertia: !0, needsRenderFrame: !z, zoomDelta: h - e.zoom, around: this._aroundPoint, originalEvent: this._lastWheelEvent };
          }
          _smoothOutEasing(e) {
            let r = u.cx;
            if (this._prevEase) {
              const o = this._prevEase, c = ($t() - o.start) / o.duration, h = o.easing(c + 0.01) - o.easing(c), z = 0.27 / Math.sqrt(h * h + 1e-4) * 0.01, d = Math.sqrt(0.0729 - z * z);
              r = u.cv(z, d, 0.25, 1);
            }
            return this._prevEase = { start: $t(), duration: e, easing: r }, r;
          }
          reset() {
            this._active = !1, this._zooming = !1, delete this._targetZoom, delete this._lastExpectedZoom, this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
          }
        }
        class Kn {
          constructor(e, r) {
            this._clickZoom = e, this._tapZoom = r;
          }
          enable() {
            this._clickZoom.enable(), this._tapZoom.enable();
          }
          disable() {
            this._clickZoom.disable(), this._tapZoom.disable();
          }
          isEnabled() {
            return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
          }
          isActive() {
            return this._clickZoom.isActive() || this._tapZoom.isActive();
          }
        }
        class uM {
          constructor(e) {
            this._tr = new Gn(e), this.reset();
          }
          reset() {
            this._active = !1;
          }
          dblclick(e, r) {
            return e.preventDefault(), { cameraAnimation: (o) => {
              o.easeTo({ duration: 300, zoom: this._tr.zoom + (e.shiftKey ? -1 : 1), around: this._tr.unproject(r) }, { originalEvent: e });
            } };
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class Fc {
          constructor() {
            this._tap = new ti({ numTouches: 1, numTaps: 1 }), this.reset();
          }
          reset() {
            this._active = !1, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, delete this._tapPoint, this._tap.reset();
          }
          touchstart(e, r, o) {
            if (!this._swipePoint) if (this._tapTime) {
              const c = r[0], h = e.timeStamp - this._tapTime < 500, z = this._tapPoint.dist(c) < 30;
              h && z ? o.length > 0 && (this._swipePoint = c, this._swipeTouch = o[0].identifier) : this.reset();
            } else this._tap.touchstart(e, r, o);
          }
          touchmove(e, r, o) {
            if (this._tapTime) {
              if (this._swipePoint) {
                if (o[0].identifier !== this._swipeTouch) return;
                const c = r[0], h = c.y - this._swipePoint.y;
                return this._swipePoint = c, e.preventDefault(), this._active = !0, { zoomDelta: h / 128 };
              }
            } else this._tap.touchmove(e, r, o);
          }
          touchend(e, r, o) {
            if (this._tapTime) this._swipePoint && o.length === 0 && this.reset();
            else {
              const c = this._tap.touchend(e, r, o);
              c && (this._tapTime = e.timeStamp, this._tapPoint = c);
            }
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class gM {
          constructor(e, r, o) {
            this._el = e, this._mousePan = r, this._touchPan = o;
          }
          enable(e) {
            this._inertiaOptions = e || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan");
          }
          disable() {
            this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan");
          }
          isEnabled() {
            return this._mousePan.isEnabled() && this._touchPan.isEnabled();
          }
          isActive() {
            return this._mousePan.isActive() || this._touchPan.isActive();
          }
        }
        class hM {
          constructor(e, r, o, c) {
            this._pitchWithRotate = e.pitchWithRotate, this._rollEnabled = e.rollEnabled, this._mouseRotate = r, this._mousePitch = o, this._mouseRoll = c;
          }
          enable() {
            this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable(), this._rollEnabled && this._mouseRoll.enable();
          }
          disable() {
            this._mouseRotate.disable(), this._mousePitch.disable(), this._mouseRoll.disable();
          }
          isEnabled() {
            return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled()) && (!this._rollEnabled || this._mouseRoll.isEnabled());
          }
          isActive() {
            return this._mouseRotate.isActive() || this._mousePitch.isActive() || this._mouseRoll.isActive();
          }
        }
        class Yc {
          constructor(e, r, o, c) {
            this._el = e, this._touchZoom = r, this._touchRotate = o, this._tapDragZoom = c, this._rotationDisabled = !1, this._enabled = !0;
          }
          enable(e) {
            this._touchZoom.enable(e), this._rotationDisabled || this._touchRotate.enable(e), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate");
          }
          disable() {
            this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate");
          }
          isEnabled() {
            return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
          }
          isActive() {
            return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
          }
          disableRotation() {
            this._rotationDisabled = !0, this._touchRotate.disable();
          }
          enableRotation() {
            this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable();
          }
        }
        class ei {
          constructor(e, r) {
            this._bypassKey = navigator.userAgent.indexOf("Mac") !== -1 ? "metaKey" : "ctrlKey", this._map = e, this._options = r, this._enabled = !1;
          }
          isActive() {
            return !1;
          }
          reset() {
          }
          _setupUI() {
            if (this._container) return;
            const e = this._map.getCanvasContainer();
            e.classList.add("maplibregl-cooperative-gestures"), this._container = gt.create("div", "maplibregl-cooperative-gesture-screen", e);
            let r = this._map._getUIString("CooperativeGesturesHandler.WindowsHelpText");
            this._bypassKey === "metaKey" && (r = this._map._getUIString("CooperativeGesturesHandler.MacHelpText"));
            const o = this._map._getUIString("CooperativeGesturesHandler.MobileHelpText"), c = document.createElement("div");
            c.className = "maplibregl-desktop-message", c.textContent = r, this._container.appendChild(c);
            const h = document.createElement("div");
            h.className = "maplibregl-mobile-message", h.textContent = o, this._container.appendChild(h), this._container.setAttribute("aria-hidden", "true");
          }
          _destroyUI() {
            this._container && (gt.remove(this._container), this._map.getCanvasContainer().classList.remove("maplibregl-cooperative-gestures")), delete this._container;
          }
          enable() {
            this._setupUI(), this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this._destroyUI();
          }
          isEnabled() {
            return this._enabled;
          }
          isBypassed(e) {
            return e[this._bypassKey];
          }
          notifyGestureBlocked(e, r) {
            this._enabled && (this._map.fire(new u.l("cooperativegestureprevented", { gestureType: e, originalEvent: r })), this._container.classList.add("maplibregl-show"), setTimeout((() => {
              this._container.classList.remove("maplibregl-show");
            }), 100));
          }
        }
        const xr = (g) => g.zoom || g.drag || g.roll || g.pitch || g.rotate;
        class Et extends u.l {
        }
        function Bt(g) {
          return g.panDelta && g.panDelta.mag() || g.zoomDelta || g.bearingDelta || g.pitchDelta || g.rollDelta;
        }
        class ta {
          constructor(e, r) {
            this.handleWindowEvent = (c) => {
              this.handleEvent(c, `${c.type}Window`);
            }, this.handleEvent = (c, h) => {
              if (c.type === "blur") return void this.stop(!0);
              this._updatingCamera = !0;
              const z = c.type === "renderFrame" ? void 0 : c, d = { needsRenderFrame: !1 }, I = {}, p = {};
              for (const { handlerName: j, handler: C, allowed: v } of this._handlers) {
                if (!C.isEnabled()) continue;
                let F;
                if (this._blockedByActive(p, v, j)) C.reset();
                else if (C[h || c.type]) {
                  if (u.cy(c, h || c.type)) {
                    const Y = gt.mousePos(this._map.getCanvas(), c);
                    F = C[h || c.type](c, Y);
                  } else if (u.cz(c, h || c.type)) {
                    const Y = this._getMapTouches(c.touches), W = gt.touchPos(this._map.getCanvas(), Y);
                    F = C[h || c.type](c, W, Y);
                  } else u.cA(h || c.type) || (F = C[h || c.type](c));
                  this.mergeHandlerResult(d, I, F, j, z), F && F.needsRenderFrame && this._triggerRenderFrame();
                }
                (F || C.isActive()) && (p[j] = C);
              }
              const f = {};
              for (const j in this._previousActiveHandlers) p[j] || (f[j] = z);
              this._previousActiveHandlers = p, (Object.keys(f).length || Bt(d)) && (this._changes.push([d, I, f]), this._triggerRenderFrame()), (Object.keys(p).length || Bt(d)) && this._map._stop(!0), this._updatingCamera = !1;
              const { cameraAnimation: _ } = d;
              _ && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], _(this._map));
            }, this._map = e, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new Us(e), this._bearingSnap = r.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(r);
            const o = this._el;
            this._listeners = [[o, "touchstart", { passive: !0 }], [o, "touchmove", { passive: !1 }], [o, "touchend", void 0], [o, "touchcancel", void 0], [o, "mousedown", void 0], [o, "mousemove", void 0], [o, "mouseup", void 0], [document, "mousemove", { capture: !0 }], [document, "mouseup", void 0], [o, "mouseover", void 0], [o, "mouseout", void 0], [o, "dblclick", void 0], [o, "click", void 0], [o, "keydown", { capture: !1 }], [o, "keyup", void 0], [o, "wheel", { passive: !1 }], [o, "contextmenu", void 0], [window, "blur", void 0]];
            for (const [c, h, z] of this._listeners) gt.addEventListener(c, h, c === document ? this.handleWindowEvent : this.handleEvent, z);
          }
          destroy() {
            for (const [e, r, o] of this._listeners) gt.removeEventListener(e, r, e === document ? this.handleWindowEvent : this.handleEvent, o);
          }
          _addDefaultHandlers(e) {
            const r = this._map, o = r.getCanvasContainer();
            this._add("mapEvent", new Yl(r, e));
            const c = r.boxZoom = new bc(r, e);
            this._add("boxZoom", c), e.interactive && e.boxZoom && c.enable();
            const h = r.cooperativeGestures = new ei(r, e.cooperativeGestures);
            this._add("cooperativeGestures", h), e.cooperativeGestures && h.enable();
            const z = new jt(r), d = new uM(r);
            r.doubleClickZoom = new Kn(d, z), this._add("tapZoom", z), this._add("clickZoom", d), e.interactive && e.doubleClickZoom && r.doubleClickZoom.enable();
            const I = new Fc();
            this._add("tapDragZoom", I);
            const p = r.touchPitch = new lM(r);
            this._add("touchPitch", p), e.interactive && e.touchPitch && r.touchPitch.enable(e.touchPitch);
            const f = () => r.project(r.getCenter()), _ = (function({ enable: R, clickTolerance: q, aroundCenter: $ = !0, minPixelCenterThreshold: G = 100, rotateDegreesPerPixelMoved: st = 0.8 }, ct) {
              const nt = new fi({ checkCorrectEvent: (at) => gt.mouseButton(at) === 0 && at.ctrlKey || gt.mouseButton(at) === 2 && !at.ctrlKey });
              return new cn({ clickTolerance: q, move: (at, Mt) => {
                const xt = ct();
                if ($ && Math.abs(xt.y - at.y) > G) return { bearingDelta: u.cw(new u.P(at.x, Mt.y), Mt, xt) };
                let wt = (Mt.x - at.x) * st;
                return $ && Mt.y < xt.y && (wt = -wt), { bearingDelta: wt };
              }, moveStateManager: nt, enable: R, assignEvents: ln });
            })(e, f), j = (function({ enable: R, clickTolerance: q, pitchDegreesPerPixelMoved: $ = -0.5 }) {
              const G = new fi({ checkCorrectEvent: (st) => gt.mouseButton(st) === 0 && st.ctrlKey || gt.mouseButton(st) === 2 });
              return new cn({ clickTolerance: q, move: (st, ct) => ({ pitchDelta: (ct.y - st.y) * $ }), moveStateManager: G, enable: R, assignEvents: ln });
            })(e), C = (function({ enable: R, clickTolerance: q, rollDegreesPerPixelMoved: $ = 0.3 }, G) {
              const st = new fi({ checkCorrectEvent: (ct) => gt.mouseButton(ct) === 2 && ct.ctrlKey });
              return new cn({ clickTolerance: q, move: (ct, nt) => {
                const at = G();
                let Mt = (nt.x - ct.x) * $;
                return nt.y < at.y && (Mt = -Mt), { rollDelta: Mt };
              }, moveStateManager: st, enable: R, assignEvents: ln });
            })(e, f);
            r.dragRotate = new hM(e, _, j, C), this._add("mouseRotate", _, ["mousePitch"]), this._add("mousePitch", j, ["mouseRotate", "mouseRoll"]), this._add("mouseRoll", C, ["mousePitch"]), e.interactive && e.dragRotate && r.dragRotate.enable();
            const v = (function({ enable: R, clickTolerance: q }) {
              const $ = new fi({ checkCorrectEvent: (G) => gt.mouseButton(G) === 0 && !G.ctrlKey });
              return new cn({ clickTolerance: q, move: (G, st) => ({ around: st, panDelta: st.sub(G) }), activateOnStart: !0, moveStateManager: $, enable: R, assignEvents: ln });
            })(e), F = new vc(e, r);
            r.dragPan = new gM(o, v, F), this._add("mousePan", v), this._add("touchPan", F, ["touchZoom", "touchRotate"]), e.interactive && e.dragPan && r.dragPan.enable(e.dragPan);
            const Y = new MM(), W = new Bc();
            r.touchZoomRotate = new Yc(o, W, Y, I), this._add("touchRotate", Y, ["touchPan", "touchZoom"]), this._add("touchZoom", W, ["touchPan", "touchRotate"]), e.interactive && e.touchZoomRotate && r.touchZoomRotate.enable(e.touchZoomRotate), this._add("blockableMapEvent", new Ul(r));
            const Z = r.scrollZoom = new $n(r, (() => this._triggerRenderFrame()));
            this._add("scrollZoom", Z, ["mousePan"]), e.interactive && e.scrollZoom && r.scrollZoom.enable(e.scrollZoom);
            const J = r.keyboard = new kc(r);
            this._add("keyboard", J), e.interactive && e.keyboard && r.keyboard.enable();
          }
          _add(e, r, o) {
            this._handlers.push({ handlerName: e, handler: r, allowed: o }), this._handlersById[e] = r;
          }
          stop(e) {
            if (!this._updatingCamera) {
              for (const { handler: r } of this._handlers) r.reset();
              this._inertia.clear(), this._fireEvents({}, {}, e), this._changes = [];
            }
          }
          isActive() {
            for (const { handler: e } of this._handlers) if (e.isActive()) return !0;
            return !1;
          }
          isZooming() {
            return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
          }
          isRotating() {
            return !!this._eventsInProgress.rotate;
          }
          isMoving() {
            return !!xr(this._eventsInProgress) || this.isZooming();
          }
          _blockedByActive(e, r, o) {
            for (const c in e) if (c !== o && (!r || r.indexOf(c) < 0)) return !0;
            return !1;
          }
          _getMapTouches(e) {
            const r = [];
            for (const o of e) this._el.contains(o.target) && r.push(o);
            return r;
          }
          mergeHandlerResult(e, r, o, c, h) {
            if (!o) return;
            u.e(e, o);
            const z = { handlerName: c, originalEvent: o.originalEvent || h };
            o.zoomDelta !== void 0 && (r.zoom = z), o.panDelta !== void 0 && (r.drag = z), o.rollDelta !== void 0 && (r.roll = z), o.pitchDelta !== void 0 && (r.pitch = z), o.bearingDelta !== void 0 && (r.rotate = z);
          }
          _applyChanges() {
            const e = {}, r = {}, o = {};
            for (const [c, h, z] of this._changes) c.panDelta && (e.panDelta = (e.panDelta || new u.P(0, 0))._add(c.panDelta)), c.zoomDelta && (e.zoomDelta = (e.zoomDelta || 0) + c.zoomDelta), c.bearingDelta && (e.bearingDelta = (e.bearingDelta || 0) + c.bearingDelta), c.pitchDelta && (e.pitchDelta = (e.pitchDelta || 0) + c.pitchDelta), c.rollDelta && (e.rollDelta = (e.rollDelta || 0) + c.rollDelta), c.around !== void 0 && (e.around = c.around), c.pinchAround !== void 0 && (e.pinchAround = c.pinchAround), c.noInertia && (e.noInertia = c.noInertia), u.e(r, h), u.e(o, z);
            this._updateMapTransform(e, r, o), this._changes = [];
          }
          _updateMapTransform(e, r, o) {
            const c = this._map, h = c._getTransformForUpdate(), z = c.terrain;
            if (!(Bt(e) || z && this._terrainMovement)) return this._fireEvents(r, o, !0);
            c._stop(!0);
            let { panDelta: d, zoomDelta: I, bearingDelta: p, pitchDelta: f, rollDelta: _, around: j, pinchAround: C } = e;
            C !== void 0 && (j = C), j = j || c.transform.centerPoint, z && !h.isPointOnMapSurface(j) && (j = h.centerPoint);
            const v = { panDelta: d, zoomDelta: I, rollDelta: _, pitchDelta: f, bearingDelta: p, around: j };
            this._map.cameraHelper.useGlobeControls && !h.isPointOnMapSurface(j) && (j = h.centerPoint);
            const F = j.distSqr(h.centerPoint) < 0.01 ? h.center : h.screenPointToLocation(d ? j.sub(d) : j);
            this._handleMapControls({ terrain: z, tr: h, deltasForHelper: v, preZoomAroundLoc: F, combinedEventsInProgress: r, panDelta: d }), c._applyUpdatedTransform(h), this._map._update(), e.noInertia || this._inertia.record(e), this._fireEvents(r, o, !0);
          }
          _handleMapControls({ terrain: e, tr: r, deltasForHelper: o, preZoomAroundLoc: c, combinedEventsInProgress: h, panDelta: z }) {
            const d = this._map.cameraHelper;
            if (d.handleMapControlsRollPitchBearingZoom(o, r), e) return d.useGlobeControls ? (this._terrainMovement || !h.drag && !h.zoom || (this._terrainMovement = !0, this._map._elevationFreeze = !0), void d.handleMapControlsPan(o, r, c)) : this._terrainMovement || !h.drag && !h.zoom ? void (h.drag && this._terrainMovement && z ? r.setCenter(r.screenPointToLocation(r.centerPoint.sub(z))) : d.handleMapControlsPan(o, r, c)) : (this._terrainMovement = !0, this._map._elevationFreeze = !0, void d.handleMapControlsPan(o, r, c));
            d.handleMapControlsPan(o, r, c);
          }
          _fireEvents(e, r, o) {
            const c = xr(this._eventsInProgress), h = xr(e), z = {};
            for (const _ in e) {
              const { originalEvent: j } = e[_];
              this._eventsInProgress[_] || (z[`${_}start`] = j), this._eventsInProgress[_] = e[_];
            }
            !c && h && this._fireEvent("movestart", h.originalEvent);
            for (const _ in z) this._fireEvent(_, z[_]);
            h && this._fireEvent("move", h.originalEvent);
            for (const _ in e) {
              const { originalEvent: j } = e[_];
              this._fireEvent(_, j);
            }
            const d = {};
            let I;
            for (const _ in this._eventsInProgress) {
              const { handlerName: j, originalEvent: C } = this._eventsInProgress[_];
              this._handlersById[j].isActive() || (delete this._eventsInProgress[_], I = r[j] || C, d[`${_}end`] = I);
            }
            for (const _ in d) this._fireEvent(_, d[_]);
            const p = xr(this._eventsInProgress), f = (c || h) && !p;
            if (f && this._terrainMovement) {
              this._map._elevationFreeze = !1, this._terrainMovement = !1;
              const _ = this._map._getTransformForUpdate();
              this._map.getCenterClampedToGround() && _.recalculateZoomAndCenter(this._map.terrain), this._map._applyUpdatedTransform(_);
            }
            if (o && f) {
              this._updatingCamera = !0;
              const _ = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), j = (C) => C !== 0 && -this._bearingSnap < C && C < this._bearingSnap;
              !_ || !_.essential && Ke.prefersReducedMotion ? (this._map.fire(new u.l("moveend", { originalEvent: I })), j(this._map.getBearing()) && this._map.resetNorth()) : (j(_.bearing || this._map.getBearing()) && (_.bearing = 0), _.freezeElevation = !0, this._map.easeTo(_, { originalEvent: I })), this._updatingCamera = !1;
            }
          }
          _fireEvent(e, r) {
            this._map.fire(new u.l(e, r ? { originalEvent: r } : {}));
          }
          _requestFrame() {
            return this._map.triggerRepaint(), this._map._renderTaskQueue.add(((e) => {
              delete this._frameId, this.handleEvent(new Et("renderFrame", { timeStamp: e })), this._applyChanges();
            }));
          }
          _triggerRenderFrame() {
            this._frameId === void 0 && (this._frameId = this._requestFrame());
          }
        }
        class Uc extends u.E {
          constructor(e, r, o) {
            super(), this._renderFrameCallback = () => {
              const c = Math.min(($t() - this._easeStart) / this._easeOptions.duration, 1);
              this._onEaseFrame(this._easeOptions.easing(c)), c < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
            }, this._moving = !1, this._zooming = !1, this.transform = e, this._bearingSnap = o.bearingSnap, this.cameraHelper = r, this.on("moveend", (() => {
              delete this._requestedCameraState;
            }));
          }
          migrateProjection(e, r) {
            e.apply(this.transform), this.transform = e, this.cameraHelper = r;
          }
          getCenter() {
            return new u.V(this.transform.center.lng, this.transform.center.lat);
          }
          setCenter(e, r) {
            return this.jumpTo({ center: e }, r);
          }
          getCenterElevation() {
            return this.transform.elevation;
          }
          setCenterElevation(e, r) {
            return this.jumpTo({ elevation: e }, r), this;
          }
          getCenterClampedToGround() {
            return this._centerClampedToGround;
          }
          setCenterClampedToGround(e) {
            this._centerClampedToGround = e;
          }
          panBy(e, r, o) {
            return e = u.P.convert(e).mult(-1), this.panTo(this.transform.center, u.e({ offset: e }, r), o);
          }
          panTo(e, r, o) {
            return this.easeTo(u.e({ center: e }, r), o);
          }
          getZoom() {
            return this.transform.zoom;
          }
          setZoom(e, r) {
            return this.jumpTo({ zoom: e }, r), this;
          }
          zoomTo(e, r, o) {
            return this.easeTo(u.e({ zoom: e }, r), o);
          }
          zoomIn(e, r) {
            return this.zoomTo(this.getZoom() + 1, e, r), this;
          }
          zoomOut(e, r) {
            return this.zoomTo(this.getZoom() - 1, e, r), this;
          }
          getVerticalFieldOfView() {
            return this.transform.fov;
          }
          setVerticalFieldOfView(e, r) {
            return e != this.transform.fov && (this.transform.setFov(e), this.fire(new u.l("movestart", r)).fire(new u.l("move", r)).fire(new u.l("moveend", r))), this;
          }
          getBearing() {
            return this.transform.bearing;
          }
          setBearing(e, r) {
            return this.jumpTo({ bearing: e }, r), this;
          }
          getPadding() {
            return this.transform.padding;
          }
          setPadding(e, r) {
            return this.jumpTo({ padding: e }, r), this;
          }
          rotateTo(e, r, o) {
            return this.easeTo(u.e({ bearing: e }, r), o);
          }
          resetNorth(e, r) {
            return this.rotateTo(0, u.e({ duration: 1e3 }, e), r), this;
          }
          resetNorthPitch(e, r) {
            return this.easeTo(u.e({ bearing: 0, pitch: 0, roll: 0, duration: 1e3 }, e), r), this;
          }
          snapToNorth(e, r) {
            return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e, r) : this;
          }
          getPitch() {
            return this.transform.pitch;
          }
          setPitch(e, r) {
            return this.jumpTo({ pitch: e }, r), this;
          }
          getRoll() {
            return this.transform.roll;
          }
          setRoll(e, r) {
            return this.jumpTo({ roll: e }, r), this;
          }
          cameraForBounds(e, r) {
            e = pe.convert(e).adjustAntiMeridian();
            const o = r && r.bearing || 0;
            return this._cameraForBoxAndBearing(e.getNorthWest(), e.getSouthEast(), o, r);
          }
          _cameraForBoxAndBearing(e, r, o, c) {
            const h = { top: 0, bottom: 0, right: 0, left: 0 };
            if (typeof (c = u.e({ padding: h, offset: [0, 0], maxZoom: this.transform.maxZoom }, c)).padding == "number") {
              const p = c.padding;
              c.padding = { top: p, bottom: p, right: p, left: p };
            }
            const z = u.e(h, c.padding);
            c.padding = z;
            const d = this.transform, I = new pe(e, r);
            return this.cameraHelper.cameraForBoxAndBearing(c, z, I, o, d);
          }
          fitBounds(e, r, o) {
            return this._fitInternal(this.cameraForBounds(e, r), r, o);
          }
          fitScreenCoordinates(e, r, o, c, h) {
            return this._fitInternal(this._cameraForBoxAndBearing(this.transform.screenPointToLocation(u.P.convert(e)), this.transform.screenPointToLocation(u.P.convert(r)), o, c), c, h);
          }
          _fitInternal(e, r, o) {
            return e ? (delete (r = u.e(e, r)).padding, r.linear ? this.easeTo(r, o) : this.flyTo(r, o)) : this;
          }
          jumpTo(e, r) {
            this.stop();
            const o = this._getTransformForUpdate();
            let c = !1, h = !1, z = !1;
            const d = o.zoom;
            this.cameraHelper.handleJumpToCenterZoom(o, e);
            const I = o.zoom !== d;
            return "elevation" in e && o.elevation !== +e.elevation && o.setElevation(+e.elevation), "bearing" in e && o.bearing !== +e.bearing && (c = !0, o.setBearing(+e.bearing)), "pitch" in e && o.pitch !== +e.pitch && (h = !0, o.setPitch(+e.pitch)), "roll" in e && o.roll !== +e.roll && (z = !0, o.setRoll(+e.roll)), e.padding == null || o.isPaddingEqual(e.padding) || o.setPadding(e.padding), this._applyUpdatedTransform(o), this.fire(new u.l("movestart", r)).fire(new u.l("move", r)), I && this.fire(new u.l("zoomstart", r)).fire(new u.l("zoom", r)).fire(new u.l("zoomend", r)), c && this.fire(new u.l("rotatestart", r)).fire(new u.l("rotate", r)).fire(new u.l("rotateend", r)), h && this.fire(new u.l("pitchstart", r)).fire(new u.l("pitch", r)).fire(new u.l("pitchend", r)), z && this.fire(new u.l("rollstart", r)).fire(new u.l("roll", r)).fire(new u.l("rollend", r)), this.fire(new u.l("moveend", r));
          }
          calculateCameraOptionsFromTo(e, r, o, c = 0) {
            const h = u.aa.fromLngLat(e, r), z = u.aa.fromLngLat(o, c), d = z.x - h.x, I = z.y - h.y, p = z.z - h.z, f = Math.hypot(d, I, p);
            if (f === 0) throw new Error("Can't calculate camera options with same From and To");
            const _ = Math.hypot(d, I), j = u.at(this.transform.cameraToCenterDistance / f / this.transform.tileSize), C = 180 * Math.atan2(d, -I) / Math.PI;
            let v = 180 * Math.acos(_ / f) / Math.PI;
            return v = p < 0 ? 90 - v : 90 + v, { center: z.toLngLat(), elevation: c, zoom: j, pitch: v, bearing: C };
          }
          calculateCameraOptionsFromCameraLngLatAltRotation(e, r, o, c, h) {
            const z = this.transform.calculateCenterFromCameraLngLatAlt(e, r, o, c);
            return { center: z.center, elevation: z.elevation, zoom: z.zoom, bearing: o, pitch: c, roll: h };
          }
          easeTo(e, r) {
            this._stop(!1, e.easeId), ((e = u.e({ offset: [0, 0], duration: 500, easing: u.cx }, e)).animate === !1 || !e.essential && Ke.prefersReducedMotion) && (e.duration = 0);
            const o = this._getTransformForUpdate(), c = this.getBearing(), h = o.pitch, z = o.roll, d = "bearing" in e ? this._normalizeBearing(e.bearing, c) : c, I = "pitch" in e ? +e.pitch : h, p = "roll" in e ? this._normalizeBearing(e.roll, z) : z, f = "padding" in e ? e.padding : o.padding, _ = u.P.convert(e.offset);
            let j, C;
            e.around && (j = u.V.convert(e.around), C = o.locationToScreenPoint(j));
            const v = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching, rolling: this._rolling }, F = this.cameraHelper.handleEaseTo(o, { bearing: d, pitch: I, roll: p, padding: f, around: j, aroundPoint: C, offsetAsPoint: _, offset: e.offset, zoom: e.zoom, center: e.center });
            return this._rotating = this._rotating || c !== d, this._pitching = this._pitching || I !== h, this._rolling = this._rolling || p !== z, this._padding = !o.isPaddingEqual(f), this._zooming = this._zooming || F.isZooming, this._easeId = e.easeId, this._prepareEase(r, e.noMoveStart, v), this.terrain && this._prepareElevation(F.elevationCenter), this._ease(((Y) => {
              F.easeFunc(Y), this.terrain && !e.freezeElevation && this._updateElevation(Y), this._applyUpdatedTransform(o), this._fireMoveEvents(r);
            }), ((Y) => {
              this.terrain && e.freezeElevation && this._finalizeElevation(), this._afterEase(r, Y);
            }), e), this;
          }
          _prepareEase(e, r, o = {}) {
            this._moving = !0, r || o.moving || this.fire(new u.l("movestart", e)), this._zooming && !o.zooming && this.fire(new u.l("zoomstart", e)), this._rotating && !o.rotating && this.fire(new u.l("rotatestart", e)), this._pitching && !o.pitching && this.fire(new u.l("pitchstart", e)), this._rolling && !o.rolling && this.fire(new u.l("rollstart", e));
          }
          _prepareElevation(e) {
            this._elevationCenter = e, this._elevationStart = this.transform.elevation, this._elevationTarget = this.terrain.getElevationForLngLatZoom(e, this.transform.tileZoom), this._elevationFreeze = !0;
          }
          _updateElevation(e) {
            this._elevationStart !== void 0 && this._elevationCenter !== void 0 || this._prepareElevation(this.transform.center), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom));
            const r = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
            if (e < 1 && r !== this._elevationTarget) {
              const o = this._elevationTarget - this._elevationStart;
              this._elevationStart += e * (o - (r - (o * e + this._elevationStart)) / (1 - e)), this._elevationTarget = r;
            }
            this.transform.setElevation(u.G.number(this._elevationStart, this._elevationTarget, e));
          }
          _finalizeElevation() {
            this._elevationFreeze = !1, this.getCenterClampedToGround() && this.transform.recalculateZoomAndCenter(this.terrain);
          }
          _getTransformForUpdate() {
            return this.transformCameraUpdate || this.terrain ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()), this._requestedCameraState) : this.transform;
          }
          _elevateCameraIfInsideTerrain(e) {
            if (!this.terrain && e.elevation >= 0 && e.pitch <= 90) return {};
            const r = e.getCameraLngLat(), o = e.getCameraAltitude(), c = this.terrain ? this.terrain.getElevationForLngLatZoom(r, e.zoom) : 0;
            if (o < c) {
              const h = this.calculateCameraOptionsFromTo(r, c, e.center, e.elevation);
              return { pitch: h.pitch, zoom: h.zoom };
            }
            return {};
          }
          _applyUpdatedTransform(e) {
            const r = [];
            if (r.push(((c) => this._elevateCameraIfInsideTerrain(c))), this.transformCameraUpdate && r.push(((c) => this.transformCameraUpdate(c))), !r.length) return;
            const o = e.clone();
            for (const c of r) {
              const h = o.clone(), { center: z, zoom: d, roll: I, pitch: p, bearing: f, elevation: _ } = c(h);
              z && h.setCenter(z), _ !== void 0 && h.setElevation(_), d !== void 0 && h.setZoom(d), I !== void 0 && h.setRoll(I), p !== void 0 && h.setPitch(p), f !== void 0 && h.setBearing(f), o.apply(h);
            }
            this.transform.apply(o);
          }
          _fireMoveEvents(e) {
            this.fire(new u.l("move", e)), this._zooming && this.fire(new u.l("zoom", e)), this._rotating && this.fire(new u.l("rotate", e)), this._pitching && this.fire(new u.l("pitch", e)), this._rolling && this.fire(new u.l("roll", e));
          }
          _afterEase(e, r) {
            if (this._easeId && r && this._easeId === r) return;
            delete this._easeId;
            const o = this._zooming, c = this._rotating, h = this._pitching, z = this._rolling;
            this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._rolling = !1, this._padding = !1, o && this.fire(new u.l("zoomend", e)), c && this.fire(new u.l("rotateend", e)), h && this.fire(new u.l("pitchend", e)), z && this.fire(new u.l("rollend", e)), this.fire(new u.l("moveend", e));
          }
          flyTo(e, r) {
            if (!e.essential && Ke.prefersReducedMotion) {
              const Mt = u.U(e, ["center", "zoom", "bearing", "pitch", "roll", "elevation", "padding"]);
              return this.jumpTo(Mt, r);
            }
            this.stop(), e = u.e({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: u.cx }, e);
            const o = this._getTransformForUpdate(), c = o.bearing, h = o.pitch, z = o.roll, d = o.padding, I = "bearing" in e ? this._normalizeBearing(e.bearing, c) : c, p = "pitch" in e ? +e.pitch : h, f = "roll" in e ? this._normalizeBearing(e.roll, z) : z, _ = "padding" in e ? e.padding : o.padding, j = u.P.convert(e.offset);
            let C = o.centerPoint.add(j);
            const v = o.screenPointToLocation(C), F = this.cameraHelper.handleFlyTo(o, { bearing: I, pitch: p, roll: f, padding: _, locationAtOffset: v, offsetAsPoint: j, center: e.center, minZoom: e.minZoom, zoom: e.zoom });
            let Y = e.curve;
            const W = Math.max(o.width, o.height), Z = W / F.scaleOfZoom, J = F.pixelPathLength;
            typeof F.scaleOfMinZoom == "number" && (Y = Math.sqrt(W / F.scaleOfMinZoom / J * 2));
            const R = Y * Y;
            function q(Mt) {
              const xt = (Z * Z - W * W + (Mt ? -1 : 1) * R * R * J * J) / (2 * (Mt ? Z : W) * R * J);
              return Math.log(Math.sqrt(xt * xt + 1) - xt);
            }
            function $(Mt) {
              return (Math.exp(Mt) - Math.exp(-Mt)) / 2;
            }
            function G(Mt) {
              return (Math.exp(Mt) + Math.exp(-Mt)) / 2;
            }
            const st = q(!1);
            let ct = function(Mt) {
              return G(st) / G(st + Y * Mt);
            }, nt = function(Mt) {
              return W * ((G(st) * ($(xt = st + Y * Mt) / G(xt)) - $(st)) / R) / J;
              var xt;
            }, at = (q(!0) - st) / Y;
            if (Math.abs(J) < 2e-6 || !isFinite(at)) {
              if (Math.abs(W - Z) < 1e-6) return this.easeTo(e, r);
              const Mt = Z < W ? -1 : 1;
              at = Math.abs(Math.log(Z / W)) / Y, nt = () => 0, ct = (xt) => Math.exp(Mt * Y * xt);
            }
            return e.duration = "duration" in e ? +e.duration : 1e3 * at / ("screenSpeed" in e ? +e.screenSpeed / Y : +e.speed), e.maxDuration && e.duration > e.maxDuration && (e.duration = 0), this._zooming = !0, this._rotating = c !== I, this._pitching = p !== h, this._rolling = f !== z, this._padding = !o.isPaddingEqual(_), this._prepareEase(r, !1), this.terrain && this._prepareElevation(F.targetCenter), this._ease(((Mt) => {
              const xt = Mt * at, wt = 1 / ct(xt), Nt = nt(xt);
              this._rotating && o.setBearing(u.G.number(c, I, Mt)), this._pitching && o.setPitch(u.G.number(h, p, Mt)), this._rolling && o.setRoll(u.G.number(z, f, Mt)), this._padding && (o.interpolatePadding(d, _, Mt), C = o.centerPoint.add(j)), F.easeFunc(Mt, wt, Nt, C), this.terrain && !e.freezeElevation && this._updateElevation(Mt), this._applyUpdatedTransform(o), this._fireMoveEvents(r);
            }), (() => {
              this.terrain && e.freezeElevation && this._finalizeElevation(), this._afterEase(r);
            }), e), this;
          }
          isEasing() {
            return !!this._easeFrameId;
          }
          stop() {
            return this._stop();
          }
          _stop(e, r) {
            var o;
            if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
              const c = this._onEaseEnd;
              delete this._onEaseEnd, c.call(this, r);
            }
            return e || (o = this.handlers) === null || o === void 0 || o.stop(!1), this;
          }
          _ease(e, r, o) {
            o.animate === !1 || o.duration === 0 ? (e(1), r()) : (this._easeStart = $t(), this._easeOptions = o, this._onEaseFrame = e, this._onEaseEnd = r, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
          }
          _normalizeBearing(e, r) {
            e = u.W(e, -180, 180);
            const o = Math.abs(e - r);
            return Math.abs(e - 360 - r) < o && (e -= 360), Math.abs(e + 360 - r) < o && (e += 360), e;
          }
          queryTerrainElevation(e) {
            return this.terrain ? this.terrain.getElevationForLngLatZoom(u.V.convert(e), this.transform.tileZoom) : null;
          }
        }
        const ea = { compact: !0, customAttribution: '<a href="https://maplibre.org/" target="_blank">MapLibre</a>' };
        class Ms {
          constructor(e = ea) {
            this._toggleAttribution = () => {
              this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"), this._container.removeAttribute("open")));
            }, this._updateData = (r) => {
              !r || r.sourceDataType !== "metadata" && r.sourceDataType !== "visibility" && r.dataType !== "style" && r.type !== "terrain" || this._updateAttributions();
            }, this._updateCompact = () => {
              this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact === !1 ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show"));
            }, this._updateCompactMinimize = () => {
              this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show");
            }, this.options = e;
          }
          getDefaultPosition() {
            return "bottom-right";
          }
          onAdd(e) {
            return this._map = e, this._compact = this.options.compact, this._container = gt.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"), this._compactButton = gt.create("summary", "maplibregl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = gt.create("div", "maplibregl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container;
          }
          onRemove() {
            gt.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._attribHTML = void 0;
          }
          _setElementTitle(e, r) {
            const o = this._map._getUIString(`AttributionControl.${r}`);
            e.title = o, e.setAttribute("aria-label", o);
          }
          _updateAttributions() {
            if (!this._map.style) return;
            let e = [];
            if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e = e.concat(this.options.customAttribution.map(((c) => typeof c != "string" ? "" : c))) : typeof this.options.customAttribution == "string" && e.push(this.options.customAttribution)), this._map.style.stylesheet) {
              const c = this._map.style.stylesheet;
              this.styleOwner = c.owner, this.styleId = c.id;
            }
            const r = this._map.style.tileManagers;
            for (const c in r) {
              const h = r[c];
              if (h.used || h.usedForTerrain) {
                const z = h.getSource();
                z.attribution && e.indexOf(z.attribution) < 0 && e.push(z.attribution);
              }
            }
            e = e.filter(((c) => String(c).trim())), e.sort(((c, h) => c.length - h.length)), e = e.filter(((c, h) => {
              for (let z = h + 1; z < e.length; z++) if (e[z].indexOf(c) >= 0) return !1;
              return !0;
            }));
            const o = e.join(" | ");
            o !== this._attribHTML && (this._attribHTML = o, e.length ? (this._innerContainer.innerHTML = gt.sanitize(o), this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"), this._updateCompact(), this._editLink = null);
          }
        }
        class Xs {
          constructor(e = {}) {
            this._updateCompact = () => {
              const r = this._container.children;
              if (r.length) {
                const o = r[0];
                this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact !== !1 && o.classList.add("maplibregl-compact") : o.classList.remove("maplibregl-compact");
              }
            }, this.options = e;
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          onAdd(e) {
            this._map = e, this._compact = this.options && this.options.compact, this._container = gt.create("div", "maplibregl-ctrl");
            const r = gt.create("a", "maplibregl-ctrl-logo");
            return r.target = "_blank", r.rel = "noopener nofollow", r.href = "https://maplibre.org/", r.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), r.setAttribute("rel", "noopener nofollow"), this._container.appendChild(r), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
          }
          onRemove() {
            gt.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0;
          }
        }
        class Xc {
          constructor() {
            this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1;
          }
          add(e) {
            const r = ++this._id;
            return this._queue.push({ callback: e, id: r, cancelled: !1 }), r;
          }
          remove(e) {
            const r = this._currentlyRunning, o = r ? this._queue.concat(r) : this._queue;
            for (const c of o) if (c.id === e) return void (c.cancelled = !0);
          }
          run(e = 0) {
            if (this._currentlyRunning) throw new Error("Attempting to run(), but is already running.");
            const r = this._currentlyRunning = this._queue;
            this._queue = [];
            for (const o of r) if (!o.cancelled && (o.callback(e), this._cleared)) break;
            this._cleared = !1, this._currentlyRunning = !1;
          }
          clear() {
            this._currentlyRunning && (this._cleared = !0), this._queue = [];
          }
        }
        var Rl = u.aT([{ name: "a_pos3d", type: "Int16", components: 3 }]);
        class Zl extends u.E {
          constructor(e) {
            super(), this._lastTilesetChange = $t(), this.tileManager = e, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.minzoom = 0, this.maxzoom = 22, this.deltaZoom = 1, this.tileSize = e._source.tileSize * 2 ** this.deltaZoom, e.usedForTerrain = !0, e.tileSize = this.tileSize;
          }
          destruct() {
            this.tileManager.usedForTerrain = !1, this.tileManager.tileSize = null;
          }
          getSource() {
            return this.tileManager._source;
          }
          update(e, r) {
            this.tileManager.update(e, r), this._renderableTilesKeys = [];
            const o = {};
            for (const c of Xt(e, { tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, reparseOverscaled: !1, terrain: r, calculateTileZoom: this.tileManager._source.calculateTileZoom })) o[c.key] = !0, this._renderableTilesKeys.push(c.key), this._tiles[c.key] || (c.terrainRttPosMatrix32f = new Float64Array(16), u.c6(c.terrainRttPosMatrix32f, 0, u.a4, u.a4, 0, 0, 1), this._tiles[c.key] = new E(c, this.tileSize), this._lastTilesetChange = $t());
            for (const c in this._tiles) o[c] || delete this._tiles[c];
          }
          freeRtt(e) {
            for (const r in this._tiles) {
              const o = this._tiles[r];
              (!e || o.tileID.equals(e) || o.tileID.isChildOf(e) || e.isChildOf(o.tileID)) && (o.rtt = []);
            }
          }
          getRenderableTiles() {
            return this._renderableTilesKeys.map(((e) => this.getTileByID(e)));
          }
          getTileByID(e) {
            return this._tiles[e];
          }
          getTerrainCoords(e, r) {
            return r ? this._getTerrainCoordsForTileRanges(e, r) : this._getTerrainCoordsForRegularTile(e);
          }
          _getTerrainCoordsForRegularTile(e) {
            const r = {};
            for (const o of this._renderableTilesKeys) {
              const c = this._tiles[o].tileID, h = e.clone(), z = u.bj();
              if (c.canonical.equals(e.canonical)) u.c6(z, 0, u.a4, u.a4, 0, 0, 1);
              else if (c.canonical.isChildOf(e.canonical)) {
                const d = c.canonical.z - e.canonical.z, I = c.canonical.x - (c.canonical.x >> d << d), p = c.canonical.y - (c.canonical.y >> d << d), f = u.a4 >> d;
                u.c6(z, 0, f, f, 0, 0, 1), u.O(z, z, [-I * f, -p * f, 0]);
              } else {
                if (!e.canonical.isChildOf(c.canonical)) continue;
                {
                  const d = e.canonical.z - c.canonical.z, I = e.canonical.x - (e.canonical.x >> d << d), p = e.canonical.y - (e.canonical.y >> d << d), f = u.a4 >> d;
                  u.c6(z, 0, u.a4, u.a4, 0, 0, 1), u.O(z, z, [I * f, p * f, 0]), u.Q(z, z, [1 / 2 ** d, 1 / 2 ** d, 0]);
                }
              }
              h.terrainRttPosMatrix32f = new Float32Array(z), r[o] = h;
            }
            return r;
          }
          _getTerrainCoordsForTileRanges(e, r) {
            const o = {};
            for (const c of this._renderableTilesKeys) {
              const h = this._tiles[c].tileID;
              if (!this._isWithinTileRanges(h, r)) continue;
              const z = e.clone(), d = u.bj();
              if (h.canonical.z === e.canonical.z) {
                const I = e.canonical.x - h.canonical.x, p = e.canonical.y - h.canonical.y;
                u.c6(d, 0, u.a4, u.a4, 0, 0, 1), u.O(d, d, [I * u.a4, p * u.a4, 0]);
              } else if (h.canonical.z > e.canonical.z) {
                const I = h.canonical.z - e.canonical.z, p = h.canonical.x - (h.canonical.x >> I << I), f = h.canonical.y - (h.canonical.y >> I << I), _ = e.canonical.x - (h.canonical.x >> I), j = e.canonical.y - (h.canonical.y >> I), C = u.a4 >> I;
                u.c6(d, 0, C, C, 0, 0, 1), u.O(d, d, [-p * C + _ * u.a4, -f * C + j * u.a4, 0]);
              } else {
                const I = e.canonical.z - h.canonical.z, p = e.canonical.x - (e.canonical.x >> I << I), f = e.canonical.y - (e.canonical.y >> I << I), _ = (e.canonical.x >> I) - h.canonical.x, j = (e.canonical.y >> I) - h.canonical.y, C = u.a4 << I;
                u.c6(d, 0, C, C, 0, 0, 1), u.O(d, d, [p * u.a4 + _ * C, f * u.a4 + j * C, 0]);
              }
              z.terrainRttPosMatrix32f = new Float32Array(d), o[c] = z;
            }
            return o;
          }
          getSourceTile(e, r) {
            const o = this.tileManager._source;
            let c = e.overscaledZ - this.deltaZoom;
            if (c > o.maxzoom && (c = o.maxzoom), c < o.minzoom) return null;
            this._sourceTileCache[e.key] || (this._sourceTileCache[e.key] = e.scaledTo(c).key);
            let h = this.tileManager.getTileByID(this._sourceTileCache[e.key]);
            if ((!h || !h.dem) && r) for (; c >= o.minzoom && (!h || !h.dem); ) h = this.tileManager.getTileByID(e.scaledTo(c--).key);
            return h;
          }
          anyTilesAfterTime(e = Date.now()) {
            return this._lastTilesetChange >= e;
          }
          _isWithinTileRanges(e, r) {
            return r[e.canonical.z] && e.canonical.x >= r[e.canonical.z].minTileX && e.canonical.x <= r[e.canonical.z].maxTileX && e.canonical.y >= r[e.canonical.z].minTileY && e.canonical.y <= r[e.canonical.z].maxTileY;
          }
        }
        class Vl {
          constructor(e, r, o) {
            this._meshCache = {}, this.painter = e, this.tileManager = new Zl(r), this.options = o, this.exaggeration = typeof o.exaggeration == "number" ? o.exaggeration : 1, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024;
          }
          getDEMElevation(e, r, o, c = u.a4) {
            var h;
            if (!(r >= 0 && r < c && o >= 0 && o < c)) return 0;
            const z = this.getTerrainData(e), d = (h = z.tile) === null || h === void 0 ? void 0 : h.dem;
            if (!d) return 0;
            const I = u.cB([], [r / c * u.a4, o / c * u.a4], z.u_terrain_matrix), p = [I[0] * d.dim, I[1] * d.dim], f = Math.floor(p[0]), _ = Math.floor(p[1]), j = p[0] - f, C = p[1] - _;
            return d.get(f, _) * (1 - j) * (1 - C) + d.get(f + 1, _) * j * (1 - C) + d.get(f, _ + 1) * (1 - j) * C + d.get(f + 1, _ + 1) * j * C;
          }
          getElevationForLngLatZoom(e, r) {
            if (!u.cC(r, e.wrap())) return 0;
            const { tileID: o, mercatorX: c, mercatorY: h } = this._getOverscaledTileIDFromLngLatZoom(e, r);
            return this.getElevation(o, c % u.a4, h % u.a4, u.a4);
          }
          getElevation(e, r, o, c = u.a4) {
            return this.getDEMElevation(e, r, o, c) * this.exaggeration;
          }
          getTerrainData(e) {
            if (!this._emptyDemTexture) {
              const c = this.painter.context, h = new u.R({ width: 1, height: 1 }, new Uint8Array(4));
              this._emptyDepthTexture = new u.T(c, h, c.gl.RGBA, { premultiply: !1 }), this._emptyDemUnpack = [0, 0, 0, 0], this._emptyDemTexture = new u.T(c, new u.R({ width: 1, height: 1 }), c.gl.RGBA, { premultiply: !1 }), this._emptyDemTexture.bind(c.gl.NEAREST, c.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = u.ar([]);
            }
            const r = this.tileManager.getSourceTile(e, !0);
            if (r && r.dem && (!r.demTexture || r.needsTerrainPrepare)) {
              const c = this.painter.context;
              r.demTexture = this.painter.getTileTexture(r.dem.stride), r.demTexture ? r.demTexture.update(r.dem.getPixels(), { premultiply: !1 }) : r.demTexture = new u.T(c, r.dem.getPixels(), c.gl.RGBA, { premultiply: !1 }), r.demTexture.bind(c.gl.NEAREST, c.gl.CLAMP_TO_EDGE), r.needsTerrainPrepare = !1;
            }
            const o = r && r + r.tileID.key + e.key;
            if (o && !this._demMatrixCache[o]) {
              const c = this.tileManager.getSource().maxzoom;
              let h = e.canonical.z - r.tileID.canonical.z;
              e.overscaledZ > e.canonical.z && (e.canonical.z >= c ? h = e.canonical.z - c : u.w("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
              const z = e.canonical.x - (e.canonical.x >> h << h), d = e.canonical.y - (e.canonical.y >> h << h), I = u.cD(new Float64Array(16), [1 / (u.a4 << h), 1 / (u.a4 << h), 0]);
              u.O(I, I, [z * u.a4, d * u.a4, 0]), this._demMatrixCache[e.key] = { matrix: I, coord: e };
            }
            return { u_depth: 2, u_terrain: 3, u_terrain_dim: r && r.dem && r.dem.dim || 1, u_terrain_matrix: o ? this._demMatrixCache[e.key].matrix : this._emptyDemMatrix, u_terrain_unpack: r && r.dem && r.dem.getUnpackVector() || this._emptyDemUnpack, u_terrain_exaggeration: this.exaggeration, texture: (r && r.demTexture || this._emptyDemTexture).texture, depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture, tile: r };
          }
          getFramebuffer(e) {
            const r = this.painter, o = r.width / devicePixelRatio, c = r.height / devicePixelRatio;
            return !this._fbo || this._fbo.width === o && this._fbo.height === c || (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new u.T(r.context, { width: o, height: c, data: null }, r.context.gl.RGBA, { premultiply: !1 }), this._fboCoordsTexture.bind(r.context.gl.NEAREST, r.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new u.T(r.context, { width: o, height: c, data: null }, r.context.gl.RGBA, { premultiply: !1 }), this._fboDepthTexture.bind(r.context.gl.NEAREST, r.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = r.context.createFramebuffer(o, c, !0, !1), this._fbo.depthAttachment.set(r.context.createRenderbuffer(r.context.gl.DEPTH_COMPONENT16, o, c))), this._fbo.colorAttachment.set(e === "coords" ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo;
          }
          getCoordsTexture() {
            const e = this.painter.context;
            if (this._coordsTexture) return this._coordsTexture;
            const r = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
            for (let h = 0, z = 0; h < this._coordsTextureSize; h++) for (let d = 0; d < this._coordsTextureSize; d++, z += 4) r[z + 0] = 255 & d, r[z + 1] = 255 & h, r[z + 2] = d >> 8 << 4 | h >> 8, r[z + 3] = 0;
            const o = new u.R({ width: this._coordsTextureSize, height: this._coordsTextureSize }, new Uint8Array(r.buffer)), c = new u.T(e, o, e.gl.RGBA, { premultiply: !1 });
            return c.bind(e.gl.NEAREST, e.gl.CLAMP_TO_EDGE), this._coordsTexture = c, c;
          }
          pointCoordinate(e) {
            this.painter.maybeDrawDepthAndCoords(!0);
            const r = new Uint8Array(4), o = this.painter.context, c = o.gl, h = Math.round(e.x * this.painter.pixelRatio / devicePixelRatio), z = Math.round(e.y * this.painter.pixelRatio / devicePixelRatio), d = Math.round(this.painter.height / devicePixelRatio);
            o.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), c.readPixels(h, d - z - 1, 1, 1, c.RGBA, c.UNSIGNED_BYTE, r), o.bindFramebuffer.set(null);
            const I = r[0] + (r[2] >> 4 << 8), p = r[1] + ((15 & r[2]) << 8), f = this.coordsIndex[255 - r[3]], _ = f && this.tileManager.getTileByID(f);
            if (!_) return null;
            const j = this._coordsTextureSize, C = (1 << _.tileID.canonical.z) * j;
            return new u.aa((_.tileID.canonical.x * j + I) / C + _.tileID.wrap, (_.tileID.canonical.y * j + p) / C, this.getElevation(_.tileID, I, p, j));
          }
          depthAtPoint(e) {
            const r = new Uint8Array(4), o = this.painter.context, c = o.gl;
            return o.bindFramebuffer.set(this.getFramebuffer("depth").framebuffer), c.readPixels(e.x, this.painter.height / devicePixelRatio - e.y - 1, 1, 1, c.RGBA, c.UNSIGNED_BYTE, r), o.bindFramebuffer.set(null), (r[0] / 16777216 + r[1] / 65536 + r[2] / 256 + r[3]) / 256;
          }
          getTerrainMesh(e) {
            var r;
            const o = ((r = this.painter.style.projection) === null || r === void 0 ? void 0 : r.transitionState) > 0, c = o && e.canonical.y === 0, h = o && e.canonical.y === (1 << e.canonical.z) - 1, z = `m_${c ? "n" : ""}_${h ? "s" : ""}`;
            if (this._meshCache[z]) return this._meshCache[z];
            const d = this.painter.context, I = new u.cE(), p = new u.aX(), f = this.meshSize, _ = u.a4 / f, j = f * f;
            for (let G = 0; G <= f; G++) for (let st = 0; st <= f; st++) I.emplaceBack(st * _, G * _, 0);
            for (let G = 0; G < j; G += f + 1) for (let st = 0; st < f; st++) p.emplaceBack(st + G, f + st + G + 1, f + st + G + 2), p.emplaceBack(st + G, f + st + G + 2, st + G + 1);
            const C = I.length, v = C + (f + 1), F = (f + 1) * f, Y = c ? u.bq : 0, W = c ? 0 : 1, Z = h ? u.br : u.a4, J = h ? 0 : 1;
            for (let G = 0; G <= f; G++) I.emplaceBack(G * _, Y, W);
            for (let G = 0; G <= f; G++) I.emplaceBack(G * _, Z, J);
            for (let G = 0; G < f; G++) p.emplaceBack(F + G, v + G, v + G + 1), p.emplaceBack(F + G, v + G + 1, F + G + 1), p.emplaceBack(0 + G, C + G + 1, C + G), p.emplaceBack(0 + G, 0 + G + 1, C + G + 1);
            const R = I.length, q = R + 2 * (f + 1);
            for (const G of [0, 1]) for (let st = 0; st <= f; st++) for (const ct of [0, 1]) I.emplaceBack(G * u.a4, st * _, ct);
            for (let G = 0; G < 2 * f; G += 2) p.emplaceBack(R + G, R + G + 1, R + G + 3), p.emplaceBack(R + G, R + G + 3, R + G + 2), p.emplaceBack(q + G, q + G + 3, q + G + 1), p.emplaceBack(q + G, q + G + 2, q + G + 3);
            const $ = new Zi(d.createVertexBuffer(I, Rl.members), d.createIndexBuffer(p), u.aW.simpleSegment(0, 0, I.length, p.length));
            return this._meshCache[z] = $, $;
          }
          getMeshFrameDelta(e) {
            return 2 * Math.PI * u.bD / Math.pow(2, Math.max(e, 0)) / 5;
          }
          getMinTileElevationForLngLatZoom(e, r) {
            var o;
            const { tileID: c } = this._getOverscaledTileIDFromLngLatZoom(e, r);
            return (o = this.getMinMaxElevation(c).minElevation) !== null && o !== void 0 ? o : 0;
          }
          getMinMaxElevation(e) {
            const r = this.getTerrainData(e).tile, o = { minElevation: null, maxElevation: null };
            return r && r.dem && (o.minElevation = r.dem.min * this.exaggeration, o.maxElevation = r.dem.max * this.exaggeration), o;
          }
          _getOverscaledTileIDFromLngLatZoom(e, r) {
            const o = u.aa.fromLngLat(e.wrap()), c = (1 << r) * u.a4, h = o.x * c, z = o.y * c, d = Math.floor(h / u.a4), I = Math.floor(z / u.a4);
            return { tileID: new u.a1(r, 0, r, d, I), mercatorX: h, mercatorY: z };
          }
        }
        class sa {
          constructor(e, r, o) {
            this._context = e, this._size = r, this._tileSize = o, this._objects = [], this._recentlyUsed = [], this._stamp = 0;
          }
          destruct() {
            for (const e of this._objects) e.texture.destroy(), e.fbo.destroy();
          }
          _createObject(e) {
            const r = this._context.createFramebuffer(this._tileSize, this._tileSize, !0, !0), o = new u.T(this._context, { width: this._tileSize, height: this._tileSize, data: null }, this._context.gl.RGBA);
            return o.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE), this._context.extTextureFilterAnisotropic && this._context.gl.texParameterf(this._context.gl.TEXTURE_2D, this._context.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, this._context.extTextureFilterAnisotropicMax), r.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)), r.colorAttachment.set(o.texture), { id: e, fbo: r, texture: o, stamp: -1, inUse: !1 };
          }
          getObjectForId(e) {
            return this._objects[e];
          }
          useObject(e) {
            e.inUse = !0, this._recentlyUsed = this._recentlyUsed.filter(((r) => e.id !== r)), this._recentlyUsed.push(e.id);
          }
          stampObject(e) {
            e.stamp = ++this._stamp;
          }
          getOrCreateFreeObject() {
            for (const r of this._recentlyUsed) if (!this._objects[r].inUse) return this._objects[r];
            if (this._objects.length >= this._size) throw new Error("No free RenderPool available, call freeAllObjects() required!");
            const e = this._createObject(this._objects.length);
            return this._objects.push(e), e;
          }
          freeObject(e) {
            e.inUse = !1;
          }
          freeAllObjects() {
            for (const e of this._objects) this.freeObject(e);
          }
          isFull() {
            return !(this._objects.length < this._size) && this._objects.some(((e) => !e.inUse)) === !1;
          }
        }
        const re = { background: !0, fill: !0, line: !0, raster: !0, hillshade: !0, "color-relief": !0 };
        class Ee {
          constructor(e, r) {
            this.painter = e, this.terrain = r, this.pool = new sa(e.context, 30, r.tileManager.tileSize * r.qualityFactor);
          }
          destruct() {
            this.pool.destruct();
          }
          getTexture(e) {
            return this.pool.getObjectForId(e.rtt[this._stacks.length - 1].id).texture;
          }
          prepareForRender(e, r) {
            this._stacks = [], this._prevType = null, this._rttTiles = [], this._renderableTiles = this.terrain.tileManager.getRenderableTiles(), this._renderableLayerIds = e._order.filter(((o) => !e._layers[o].isHidden(r))), this._coordsAscending = {};
            for (const o in e.tileManagers) {
              this._coordsAscending[o] = {};
              const c = e.tileManagers[o].getVisibleCoordinates(), h = e.tileManagers[o].getSource(), z = h instanceof Ts ? h.terrainTileRanges : null;
              for (const d of c) {
                const I = this.terrain.tileManager.getTerrainCoords(d, z);
                for (const p in I) this._coordsAscending[o][p] || (this._coordsAscending[o][p] = []), this._coordsAscending[o][p].push(I[p]);
              }
            }
            this._coordsAscendingStr = {};
            for (const o of e._order) {
              const c = e._layers[o], h = c.source;
              if (re[c.type] && !this._coordsAscendingStr[h]) {
                this._coordsAscendingStr[h] = {};
                for (const z in this._coordsAscending[h]) this._coordsAscendingStr[h][z] = this._coordsAscending[h][z].map(((d) => d.key)).sort().join();
              }
            }
            for (const o of this._renderableTiles) for (const c in this._coordsAscendingStr) {
              const h = this._coordsAscendingStr[c][o.tileID.key];
              h && h !== o.rttCoords[c] && (o.rtt = []);
            }
          }
          renderLayer(e, r) {
            if (e.isHidden(this.painter.transform.zoom)) return !1;
            const o = Object.assign(Object.assign({}, r), { isRenderingToTexture: !0 }), c = e.type, h = this.painter, z = this._renderableLayerIds[this._renderableLayerIds.length - 1] === e.id;
            if (re[c] && (this._prevType && re[this._prevType] || this._stacks.push([]), this._prevType = c, this._stacks[this._stacks.length - 1].push(e.id), !z)) return !0;
            if (re[this._prevType] || re[c] && z) {
              this._prevType = c;
              const d = this._stacks.length - 1, I = this._stacks[d] || [];
              for (const p of this._renderableTiles) {
                if (this.pool.isFull() && (Ji(this.painter, this.terrain, this._rttTiles, o), this._rttTiles = [], this.pool.freeAllObjects()), this._rttTiles.push(p), p.rtt[d]) {
                  const _ = this.pool.getObjectForId(p.rtt[d].id);
                  if (_.stamp === p.rtt[d].stamp) {
                    this.pool.useObject(_);
                    continue;
                  }
                }
                const f = this.pool.getOrCreateFreeObject();
                this.pool.useObject(f), this.pool.stampObject(f), p.rtt[d] = { id: f.id, stamp: f.stamp }, h.context.bindFramebuffer.set(f.fbo.framebuffer), h.context.clear({ color: u.bo.transparent, stencil: 0 }), h.currentStencilSource = void 0;
                for (let _ = 0; _ < I.length; _++) {
                  const j = h.style._layers[I[_]], C = j.source ? this._coordsAscending[j.source][p.tileID.key] : [p.tileID];
                  h.context.viewport.set([0, 0, f.fbo.width, f.fbo.height]), h._renderTileClippingMasks(j, C, !0), h.renderLayer(h, h.style.tileManagers[j.source], j, C, o), j.source && (p.rttCoords[j.source] = this._coordsAscendingStr[j.source][p.tileID.key]);
                }
              }
              return Ji(this.painter, this.terrain, this._rttTiles, o), this._rttTiles = [], this.pool.freeAllObjects(), re[c];
            }
            return !1;
          }
        }
        const Wc = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "MapLibre logo", "Map.Title": "Map", "Marker.Title": "Map marker", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "Popup.Close": "Close popup", "ScaleControl.Feet": "ft", "ScaleControl.Meters": "m", "ScaleControl.Kilometers": "km", "ScaleControl.Miles": "mi", "ScaleControl.NauticalMiles": "nm", "GlobeControl.Enable": "Enable globe", "GlobeControl.Disable": "Disable globe", "TerrainControl.Enable": "Enable terrain", "TerrainControl.Disable": "Disable terrain", "CooperativeGesturesHandler.WindowsHelpText": "Use Ctrl + scroll to zoom the map", "CooperativeGesturesHandler.MacHelpText": "Use  + scroll to zoom the map", "CooperativeGesturesHandler.MobileHelpText": "Use two fingers to move the map" }, ia = mt, ra = { hash: !1, interactive: !0, bearingSnap: 7, attributionControl: ea, maplibreLogo: !1, refreshExpiredTiles: !0, canvasContextAttributes: { antialias: !1, preserveDrawingBuffer: !1, powerPreference: "high-performance", failIfMajorPerformanceCaveat: !1, desynchronized: !1, contextType: void 0 }, scrollZoom: !0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 60, boxZoom: !0, dragRotate: !0, dragPan: !0, keyboard: !0, doubleClickZoom: !0, touchZoomRotate: !0, touchPitch: !0, cooperativeGestures: !1, trackResize: !0, center: [0, 0], elevation: 0, zoom: 0, bearing: 0, pitch: 0, roll: 0, renderWorldCopies: !0, maxTileCacheSize: null, maxTileCacheZoomLevels: u.a.MAX_TILE_CACHE_ZOOM_LEVELS, transformRequest: null, transformCameraUpdate: null, transformConstrain: null, fadeDuration: 300, crossSourceCollisions: !0, clickTolerance: 3, localIdeographFontFamily: "sans-serif", pitchWithRotate: !0, rollEnabled: !1, reduceMotion: void 0, validateStyle: !0, maxCanvasSize: [4096, 4096], cancelPendingTileRequestsWhileZooming: !0, centerClampedToGround: !0, experimentalZoomLevelsToOverscale: void 0 }, DM = { showCompass: !0, showZoom: !0, visualizePitch: !1, visualizeRoll: !0 };
        class zM {
          constructor(e, r, o = !1) {
            this.mousedown = (h) => {
              this.startMove(h, gt.mousePos(this.element, h)), gt.addEventListener(window, "mousemove", this.mousemove), gt.addEventListener(window, "mouseup", this.mouseup);
            }, this.mousemove = (h) => {
              this.move(h, gt.mousePos(this.element, h));
            }, this.mouseup = (h) => {
              this._rotatePitchHandler.dragEnd(h), this.offTemp();
            }, this.touchstart = (h) => {
              h.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = gt.touchPos(this.element, h.targetTouches)[0], this.startMove(h, this._startPos), gt.addEventListener(window, "touchmove", this.touchmove, { passive: !1 }), gt.addEventListener(window, "touchend", this.touchend));
            }, this.touchmove = (h) => {
              h.targetTouches.length !== 1 ? this.reset() : (this._lastPos = gt.touchPos(this.element, h.targetTouches)[0], this.move(h, this._lastPos));
            }, this.touchend = (h) => {
              h.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), delete this._startPos, delete this._lastPos, this.offTemp();
            }, this.reset = () => {
              this._rotatePitchHandler.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
            }, this._clickTolerance = 10, this.element = r;
            const c = new Xl();
            this._rotatePitchHandler = new cn({ clickTolerance: 3, move: (h, z) => {
              const d = r.getBoundingClientRect(), I = new u.P((d.bottom - d.top) / 2, (d.right - d.left) / 2);
              return { bearingDelta: u.cw(new u.P(h.x, z.y), z, I), pitchDelta: o ? -0.5 * (z.y - h.y) : void 0 };
            }, moveStateManager: c, enable: !0, assignEvents: () => {
            } }), this.map = e, gt.addEventListener(r, "mousedown", this.mousedown), gt.addEventListener(r, "touchstart", this.touchstart, { passive: !1 }), gt.addEventListener(r, "touchcancel", this.reset);
          }
          startMove(e, r) {
            this._rotatePitchHandler.dragStart(e, r), gt.disableDrag();
          }
          move(e, r) {
            const o = this.map, { bearingDelta: c, pitchDelta: h } = this._rotatePitchHandler.dragMove(e, r) || {};
            c && o.setBearing(o.getBearing() + c), h && o.setPitch(o.getPitch() + h);
          }
          off() {
            const e = this.element;
            gt.removeEventListener(e, "mousedown", this.mousedown), gt.removeEventListener(e, "touchstart", this.touchstart, { passive: !1 }), gt.removeEventListener(window, "touchmove", this.touchmove, { passive: !1 }), gt.removeEventListener(window, "touchend", this.touchend), gt.removeEventListener(e, "touchcancel", this.reset), this.offTemp();
          }
          offTemp() {
            gt.enableDrag(), gt.removeEventListener(window, "mousemove", this.mousemove), gt.removeEventListener(window, "mouseup", this.mouseup), gt.removeEventListener(window, "touchmove", this.touchmove, { passive: !1 }), gt.removeEventListener(window, "touchend", this.touchend);
          }
        }
        let xi;
        function un(g, e, r, o = !1) {
          if (o || !r.getCoveringTilesDetailsProvider().allowWorldCopies()) return g?.wrap();
          const c = new u.V(g.lng, g.lat);
          if (g = new u.V(g.lng, g.lat), e) {
            const h = new u.V(g.lng - 360, g.lat), z = new u.V(g.lng + 360, g.lat), d = r.locationToScreenPoint(g).distSqr(e);
            r.locationToScreenPoint(h).distSqr(e) < d ? g = h : r.locationToScreenPoint(z).distSqr(e) < d && (g = z);
          }
          for (; Math.abs(g.lng - r.center.lng) > 180; ) {
            const h = r.locationToScreenPoint(g);
            if (h.x >= 0 && h.y >= 0 && h.x <= r.width && h.y <= r.height) break;
            g.lng > r.center.lng ? g.lng -= 360 : g.lng += 360;
          }
          return g.lng !== c.lng && r.isPointOnMapSurface(r.locationToScreenPoint(g)) ? g : c;
        }
        const na = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
        function qa(g, e, r) {
          const o = g.classList;
          for (const c in na) o.remove(`maplibregl-${r}-anchor-${c}`);
          o.add(`maplibregl-${r}-anchor-${e}`);
        }
        class aa extends u.E {
          constructor(e) {
            if (super(), this._onKeyPress = (r) => {
              const o = r.code, c = r.charCode || r.keyCode;
              o !== "Space" && o !== "Enter" && c !== 32 && c !== 13 || this.togglePopup();
            }, this._onMapClick = (r) => {
              const o = r.originalEvent.target, c = this._element;
              this._popup && (o === c || c.contains(o)) && this.togglePopup();
            }, this._update = (r) => {
              if (!this._map) return;
              const o = this._map.loaded() && !this._map.isMoving();
              (r?.type === "terrain" || r?.type === "render" && !o) && this._map.once("render", this._update), this._lngLat = un(this._lngLat, this._flatPos, this._map.transform), this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset), this._map.terrain && (this._flatPos = this._map.transform.locationToScreenPoint(this._lngLat)._add(this._offset));
              let c = "";
              this._rotationAlignment === "viewport" || this._rotationAlignment === "auto" ? c = `rotateZ(${this._rotation}deg)` : this._rotationAlignment === "map" && (c = `rotateZ(${this._rotation - this._map.getBearing()}deg)`);
              let h = "";
              this._pitchAlignment === "viewport" || this._pitchAlignment === "auto" ? h = "rotateX(0deg)" : this._pitchAlignment === "map" && (h = `rotateX(${this._map.getPitch()}deg)`), this._subpixelPositioning || r && r.type !== "moveend" || (this._pos = this._pos.round()), gt.setTransform(this._element, `${na[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${h} ${c}`), Ke.frameAsync(new AbortController()).then((() => {
                this._updateOpacity(r && r.type === "moveend");
              })).catch((() => {
              }));
            }, this._onMove = (r) => {
              if (!this._isDragging) {
                const o = this._clickTolerance || this._map._clickTolerance;
                this._isDragging = r.point.dist(this._pointerdownPos) >= o;
              }
              this._isDragging && (this._pos = r.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", this._state === "pending" && (this._state = "active", this.fire(new u.l("dragstart"))), this.fire(new u.l("drag")));
            }, this._onUp = () => {
              this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), this._state === "active" && this.fire(new u.l("dragend")), this._state = "inactive";
            }, this._addDragHandler = (r) => {
              this._element.contains(r.originalEvent.target) && (r.preventDefault(), this._positionDelta = r.point.sub(this._pos).add(this._offset), this._pointerdownPos = r.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
            }, this._anchor = e && e.anchor || "center", this._color = e && e.color || "#3FB1CE", this._scale = e && e.scale || 1, this._draggable = e && e.draggable || !1, this._clickTolerance = e && e.clickTolerance || 0, this._subpixelPositioning = e && e.subpixelPositioning || !1, this._isDragging = !1, this._state = "inactive", this._rotation = e && e.rotation || 0, this._rotationAlignment = e && e.rotationAlignment || "auto", this._pitchAlignment = e && e.pitchAlignment && e.pitchAlignment !== "auto" ? e.pitchAlignment : this._rotationAlignment, this.setOpacity(e?.opacity, e?.opacityWhenCovered), e && e.element) this._element = e.element, this._offset = u.P.convert(e && e.offset || [0, 0]);
            else {
              this._defaultMarker = !0, this._element = gt.create("div");
              const r = gt.createNS("http://www.w3.org/2000/svg", "svg"), o = 41, c = 27;
              r.setAttributeNS(null, "display", "block"), r.setAttributeNS(null, "height", `${o}px`), r.setAttributeNS(null, "width", `${c}px`), r.setAttributeNS(null, "viewBox", `0 0 ${c} ${o}`);
              const h = gt.createNS("http://www.w3.org/2000/svg", "g");
              h.setAttributeNS(null, "stroke", "none"), h.setAttributeNS(null, "stroke-width", "1"), h.setAttributeNS(null, "fill", "none"), h.setAttributeNS(null, "fill-rule", "evenodd");
              const z = gt.createNS("http://www.w3.org/2000/svg", "g");
              z.setAttributeNS(null, "fill-rule", "nonzero");
              const d = gt.createNS("http://www.w3.org/2000/svg", "g");
              d.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), d.setAttributeNS(null, "fill", "#000000");
              const I = [{ rx: "10.5", ry: "5.25002273" }, { rx: "10.5", ry: "5.25002273" }, { rx: "9.5", ry: "4.77275007" }, { rx: "8.5", ry: "4.29549936" }, { rx: "7.5", ry: "3.81822308" }, { rx: "6.5", ry: "3.34094679" }, { rx: "5.5", ry: "2.86367051" }, { rx: "4.5", ry: "2.38636864" }];
              for (const W of I) {
                const Z = gt.createNS("http://www.w3.org/2000/svg", "ellipse");
                Z.setAttributeNS(null, "opacity", "0.04"), Z.setAttributeNS(null, "cx", "10.5"), Z.setAttributeNS(null, "cy", "5.80029008"), Z.setAttributeNS(null, "rx", W.rx), Z.setAttributeNS(null, "ry", W.ry), d.appendChild(Z);
              }
              const p = gt.createNS("http://www.w3.org/2000/svg", "g");
              p.setAttributeNS(null, "fill", this._color);
              const f = gt.createNS("http://www.w3.org/2000/svg", "path");
              f.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), p.appendChild(f);
              const _ = gt.createNS("http://www.w3.org/2000/svg", "g");
              _.setAttributeNS(null, "opacity", "0.25"), _.setAttributeNS(null, "fill", "#000000");
              const j = gt.createNS("http://www.w3.org/2000/svg", "path");
              j.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), _.appendChild(j);
              const C = gt.createNS("http://www.w3.org/2000/svg", "g");
              C.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), C.setAttributeNS(null, "fill", "#FFFFFF");
              const v = gt.createNS("http://www.w3.org/2000/svg", "g");
              v.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
              const F = gt.createNS("http://www.w3.org/2000/svg", "circle");
              F.setAttributeNS(null, "fill", "#000000"), F.setAttributeNS(null, "opacity", "0.25"), F.setAttributeNS(null, "cx", "5.5"), F.setAttributeNS(null, "cy", "5.5"), F.setAttributeNS(null, "r", "5.4999962");
              const Y = gt.createNS("http://www.w3.org/2000/svg", "circle");
              Y.setAttributeNS(null, "fill", "#FFFFFF"), Y.setAttributeNS(null, "cx", "5.5"), Y.setAttributeNS(null, "cy", "5.5"), Y.setAttributeNS(null, "r", "5.4999962"), v.appendChild(F), v.appendChild(Y), z.appendChild(d), z.appendChild(p), z.appendChild(_), z.appendChild(C), z.appendChild(v), r.appendChild(z), r.setAttributeNS(null, "height", o * this._scale + "px"), r.setAttributeNS(null, "width", c * this._scale + "px"), this._element.appendChild(r), this._offset = u.P.convert(e && e.offset || [0, -14]);
            }
            if (this._element.classList.add("maplibregl-marker"), this._element.addEventListener("dragstart", ((r) => {
              r.preventDefault();
            })), this._element.addEventListener("mousedown", ((r) => {
              r.preventDefault();
            })), qa(this._element, this._anchor, "marker"), e && e.className) for (const r of e.className.split(" ")) this._element.classList.add(r);
            this._popup = null;
          }
          addTo(e) {
            return this.remove(), this._map = e, this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", e._getUIString("Marker.Title")), this._element.hasAttribute("role") || this._element.setAttribute("role", "button"), e.getCanvasContainer().appendChild(this._element), e.on("move", this._update), e.on("moveend", this._update), e.on("terrain", this._update), e.on("projectiontransition", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;
          }
          remove() {
            return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("terrain", this._update), this._map.off("projectiontransition", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), gt.remove(this._element), this._popup && this._popup.remove(), this;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(e) {
            return this._lngLat = u.V.convert(e), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
          }
          getElement() {
            return this._element;
          }
          setPopup(e) {
            if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), e) {
              if (!("offset" in e.options)) {
                const c = Math.abs(13.5) / Math.SQRT2;
                e.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -38.1], "bottom-left": [c, -1 * (38.1 - 13.5 + c)], "bottom-right": [-c, -1 * (38.1 - 13.5 + c)], left: [13.5, -1 * (38.1 - 13.5)], right: [-13.5, -1 * (38.1 - 13.5)] } : this._offset;
              }
              this._popup = e, this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);
            }
            return this;
          }
          setSubpixelPositioning(e) {
            return this._subpixelPositioning = e, this;
          }
          getPopup() {
            return this._popup;
          }
          togglePopup() {
            const e = this._popup;
            return this._element.style.opacity === this._opacityWhenCovered ? this : e ? (e.isOpen() ? e.remove() : (e.setLngLat(this._lngLat), e.addTo(this._map)), this) : this;
          }
          _updateOpacity(e = !1) {
            var r, o;
            const c = (r = this._map) === null || r === void 0 ? void 0 : r.terrain, h = this._map.transform.isLocationOccluded(this._lngLat);
            if (!c || h) {
              const C = h ? this._opacityWhenCovered : this._opacity;
              return void (this._element.style.opacity !== C && (this._element.style.opacity = C));
            }
            if (e) this._opacityTimeout = null;
            else {
              if (this._opacityTimeout) return;
              this._opacityTimeout = setTimeout((() => {
                this._opacityTimeout = null;
              }), 100);
            }
            const z = this._map, d = z.terrain.depthAtPoint(this._pos), I = z.terrain.getElevationForLngLatZoom(this._lngLat, z.transform.tileZoom);
            if (z.transform.lngLatToCameraDepth(this._lngLat, I) - d < 6e-3) return void (this._element.style.opacity = this._opacity);
            const p = -this._offset.y / z.transform.pixelsPerMeter, f = Math.sin(z.getPitch() * Math.PI / 180) * p, _ = z.terrain.depthAtPoint(new u.P(this._pos.x, this._pos.y - this._offset.y)), j = z.transform.lngLatToCameraDepth(this._lngLat, I + f) - _ > 6e-3;
            !((o = this._popup) === null || o === void 0) && o.isOpen() && j && this._popup.remove(), this._element.style.opacity = j ? this._opacityWhenCovered : this._opacity;
          }
          getOffset() {
            return this._offset;
          }
          setOffset(e) {
            return this._offset = u.P.convert(e), this._update(), this;
          }
          addClassName(e) {
            this._element.classList.add(e);
          }
          removeClassName(e) {
            this._element.classList.remove(e);
          }
          toggleClassName(e) {
            return this._element.classList.toggle(e);
          }
          setDraggable(e) {
            return this._draggable = !!e, this._map && (e ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
          }
          isDraggable() {
            return this._draggable;
          }
          setRotation(e) {
            return this._rotation = e || 0, this._update(), this;
          }
          getRotation() {
            return this._rotation;
          }
          setRotationAlignment(e) {
            return this._rotationAlignment = e || "auto", this._update(), this;
          }
          getRotationAlignment() {
            return this._rotationAlignment;
          }
          setPitchAlignment(e) {
            return this._pitchAlignment = e && e !== "auto" ? e : this._rotationAlignment, this._update(), this;
          }
          getPitchAlignment() {
            return this._pitchAlignment;
          }
          setOpacity(e, r) {
            return (this._opacity === void 0 || e === void 0 && r === void 0) && (this._opacity = "1", this._opacityWhenCovered = "0.2"), e !== void 0 && (this._opacity = e), r !== void 0 && (this._opacityWhenCovered = r), this._map && this._updateOpacity(!0), this;
          }
        }
        const NM = { positionOptions: { enableHighAccuracy: !1, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: !1, showAccuracyCircle: !0, showUserLocation: !0 };
        let gn = 0, Ar = !1;
        const dM = { maxWidth: 100, unit: "metric" };
        function $a(g, e, r) {
          const o = r && r.maxWidth || 100, c = g._container.clientHeight / 2, h = g._container.clientWidth / 2, z = g.unproject([h - o / 2, c]), d = g.unproject([h + o / 2, c]), I = Math.round(g.project(d).x - g.project(z).x), p = Math.min(o, I, g._container.clientWidth), f = z.distanceTo(d);
          if (r && r.unit === "imperial") {
            const _ = 3.2808 * f;
            _ > 5280 ? mr(e, p, _ / 5280, g._getUIString("ScaleControl.Miles")) : mr(e, p, _, g._getUIString("ScaleControl.Feet"));
          } else r && r.unit === "nautical" ? mr(e, p, f / 1852, g._getUIString("ScaleControl.NauticalMiles")) : f >= 1e3 ? mr(e, p, f / 1e3, g._getUIString("ScaleControl.Kilometers")) : mr(e, p, f, g._getUIString("ScaleControl.Meters"));
        }
        function mr(g, e, r, o) {
          const c = (function(h) {
            const z = Math.pow(10, `${Math.floor(h)}`.length - 1);
            let d = h / z;
            return d = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : d >= 1 ? 1 : (function(I) {
              const p = Math.pow(10, Math.ceil(-Math.log(I) / Math.LN10));
              return Math.round(I * p) / p;
            })(d), z * d;
          })(r);
          g.style.width = e * (c / r) + "px", g.innerHTML = `${c}&nbsp;${o}`;
        }
        const Ka = { closeButton: !0, closeOnClick: !0, focusAfterOpen: !0, className: "", maxWidth: "240px", subpixelPositioning: !1, locationOccludedOpacity: void 0 }, yM = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
        function to(g) {
          if (g) {
            if (typeof g == "number") {
              const e = Math.round(Math.abs(g) / Math.SQRT2);
              return { center: new u.P(0, 0), top: new u.P(0, g), "top-left": new u.P(e, e), "top-right": new u.P(-e, e), bottom: new u.P(0, -g), "bottom-left": new u.P(e, -e), "bottom-right": new u.P(-e, -e), left: new u.P(g, 0), right: new u.P(-g, 0) };
            }
            if (g instanceof u.P || Array.isArray(g)) {
              const e = u.P.convert(g);
              return { center: e, top: e, "top-left": e, "top-right": e, bottom: e, "bottom-left": e, "bottom-right": e, left: e, right: e };
            }
            return { center: u.P.convert(g.center || [0, 0]), top: u.P.convert(g.top || [0, 0]), "top-left": u.P.convert(g["top-left"] || [0, 0]), "top-right": u.P.convert(g["top-right"] || [0, 0]), bottom: u.P.convert(g.bottom || [0, 0]), "bottom-left": u.P.convert(g["bottom-left"] || [0, 0]), "bottom-right": u.P.convert(g["bottom-right"] || [0, 0]), left: u.P.convert(g.left || [0, 0]), right: u.P.convert(g.right || [0, 0]) };
          }
          return to(new u.P(0, 0));
        }
        const eo = mt;
        b.AJAXError = u.cI, b.Event = u.l, b.Evented = u.E, b.LngLat = u.V, b.MercatorCoordinate = u.aa, b.Point = u.P, b.addProtocol = u.cJ, b.config = u.a, b.removeProtocol = u.cK, b.AttributionControl = Ms, b.BoxZoomHandler = bc, b.CanvasSource = jn, b.CooperativeGesturesHandler = ei, b.DoubleClickZoomHandler = Kn, b.DragPanHandler = gM, b.DragRotateHandler = hM, b.EdgeInsets = ue, b.FullscreenControl = class extends u.E {
          constructor(g = {}) {
            super(), this._onFullscreenChange = () => {
              var e;
              let r = window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement;
              for (; !((e = r?.shadowRoot) === null || e === void 0) && e.fullscreenElement; ) r = r.shadowRoot.fullscreenElement;
              r === this._container !== this._fullscreen && this._handleFullscreenChange();
            }, this._onClickFullscreen = () => {
              this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen();
            }, this._fullscreen = !1, g && g.container && (g.container instanceof HTMLElement ? this._container = g.container : u.w("Full screen control 'container' must be a DOM element.")), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange");
          }
          onAdd(g) {
            return this._map = g, this._container || (this._container = this._map.getContainer()), this._controlContainer = gt.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), this._controlContainer;
          }
          onRemove() {
            gt.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange);
          }
          _setupUI() {
            const g = this._fullscreenButton = gt.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer);
            gt.create("span", "maplibregl-ctrl-icon", g).setAttribute("aria-hidden", "true"), g.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange);
          }
          _updateTitle() {
            const g = this._getTitle();
            this._fullscreenButton.setAttribute("aria-label", g), this._fullscreenButton.title = g;
          }
          _getTitle() {
            return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
          }
          _isFullscreen() {
            return this._fullscreen;
          }
          _handleFullscreenChange() {
            this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._updateTitle(), this._fullscreen ? (this.fire(new u.l("fullscreenstart")), this._prevCooperativeGesturesEnabled = this._map.cooperativeGestures.isEnabled(), this._map.cooperativeGestures.disable()) : (this.fire(new u.l("fullscreenend")), this._prevCooperativeGesturesEnabled && this._map.cooperativeGestures.enable());
          }
          _exitFullscreen() {
            window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen();
          }
          _requestFullscreen() {
            this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen();
          }
          _togglePseudoFullScreen() {
            this._container.classList.toggle("maplibregl-pseudo-fullscreen"), this._handleFullscreenChange(), this._map.resize();
          }
        }, b.GeoJSONSource = cr, b.GeolocateControl = class extends u.E {
          constructor(g) {
            super(), this._onSuccess = (e) => {
              if (this._map) {
                if (this._isOutOfMapMaxBounds(e)) return this._setErrorState(), this.fire(new u.l("outofmaxbounds", e)), this._updateMarker(), void this._finish();
                if (this.options.trackUserLocation) switch (this._lastKnownPosition = e, this._watchState) {
                  case "WAITING_ACTIVE":
                  case "ACTIVE_LOCK":
                  case "ACTIVE_ERROR":
                    this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                    break;
                  case "BACKGROUND":
                  case "BACKGROUND_ERROR":
                    this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");
                    break;
                  default:
                    throw new Error(`Unexpected watchState ${this._watchState}`);
                }
                this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(e), this.options.trackUserLocation && this._watchState !== "ACTIVE_LOCK" || this._updateCamera(e), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"), this.fire(new u.l("geolocate", e)), this._finish();
              }
            }, this._updateCamera = (e) => {
              const r = new u.V(e.coords.longitude, e.coords.latitude), o = e.coords.accuracy, c = this._map.getBearing(), h = u.e({ bearing: c }, this.options.fitBoundsOptions), z = pe.fromLngLat(r, o);
              this._map.fitBounds(z, h, { geolocateSource: !0 });
            }, this._updateMarker = (e) => {
              if (e) {
                const r = new u.V(e.coords.longitude, e.coords.latitude);
                this._accuracyCircleMarker.setLngLat(r).addTo(this._map), this._userLocationDotMarker.setLngLat(r).addTo(this._map), this._accuracy = e.coords.accuracy, this._updateCircleRadiusIfNeeded();
              } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
            }, this._onUpdate = () => {
              this._updateCircleRadiusIfNeeded();
            }, this._onError = (e) => {
              if (this._map) {
                if (e.code === 1) {
                  this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0;
                  const r = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.title = r, this._geolocateButton.setAttribute("aria-label", r), this._geolocationWatchID !== void 0 && this._clearWatch();
                } else {
                  if (e.code === 3 && Ar) return;
                  this._setErrorState();
                }
                this._watchState !== "OFF" && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"), this.fire(new u.l("error", e)), this._finish();
              }
            }, this._finish = () => {
              this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
            }, this._setupUI = () => {
              this._map && (this._container.addEventListener("contextmenu", ((e) => e.preventDefault())), this._geolocateButton = gt.create("button", "maplibregl-ctrl-geolocate", this._container), gt.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", this._geolocateButton.disabled = !0);
            }, this._finishSetupUI = (e) => {
              if (this._map) {
                if (e === !1) {
                  u.w("Geolocation support is not available so the GeolocateControl will be disabled.");
                  const r = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.disabled = !0, this._geolocateButton.title = r, this._geolocateButton.setAttribute("aria-label", r);
                } else {
                  const r = this._map._getUIString("GeolocateControl.FindMyLocation");
                  this._geolocateButton.disabled = !1, this._geolocateButton.title = r, this._geolocateButton.setAttribute("aria-label", r);
                }
                this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = gt.create("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new aa({ element: this._dotElement }), this._circleElement = gt.create("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new aa({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onUpdate), this._map.on("move", this._onUpdate), this._map.on("rotate", this._onUpdate), this._map.on("pitch", this._onUpdate)), this._geolocateButton.addEventListener("click", (() => this.trigger())), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", ((r) => {
                  const o = r?.[0] instanceof ResizeObserverEntry;
                  r.geolocateSource || this._watchState !== "ACTIVE_LOCK" || o || this._map.isZooming() || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new u.l("trackuserlocationend")), this.fire(new u.l("userlocationlostfocus")));
                }));
              }
            }, this.options = u.e({}, NM, g);
          }
          onAdd(g) {
            return this._map = g, this._container = gt.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), (function() {
              return u._(this, arguments, void 0, (function* (e = !1) {
                if (xi !== void 0 && !e) return xi;
                if (window.navigator.permissions === void 0) return xi = !!window.navigator.geolocation, xi;
                try {
                  xi = (yield window.navigator.permissions.query({ name: "geolocation" })).state !== "denied";
                } catch {
                  xi = !!window.navigator.geolocation;
                }
                return xi;
              }));
            })().then(((e) => this._finishSetupUI(e))), this._container;
          }
          onRemove() {
            this._geolocationWatchID !== void 0 && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), gt.remove(this._container), this._map.off("zoom", this._onUpdate), this._map.off("move", this._onUpdate), this._map.off("rotate", this._onUpdate), this._map.off("pitch", this._onUpdate), this._map = void 0, gn = 0, Ar = !1;
          }
          _isOutOfMapMaxBounds(g) {
            const e = this._map.getMaxBounds(), r = g.coords;
            return e && (r.longitude < e.getWest() || r.longitude > e.getEast() || r.latitude < e.getSouth() || r.latitude > e.getNorth());
          }
          _setErrorState() {
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
                break;
              case "ACTIVE_LOCK":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                break;
              case "BACKGROUND":
                this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                break;
              case "ACTIVE_ERROR":
              case "BACKGROUND_ERROR":
              case "OFF":
              case void 0:
                break;
              default:
                throw new Error(`Unexpected watchState ${this._watchState}`);
            }
          }
          _updateCircleRadiusIfNeeded() {
            const g = this._userLocationDotMarker.getLngLat();
            if (!(this.options.showUserLocation && this.options.showAccuracyCircle && this._accuracy && g)) return;
            const e = this._map.project(g), r = this._map.unproject([e.x + 100, e.y]), o = g.distanceTo(r) / 100, c = 2 * this._accuracy / o;
            this._circleElement.style.width = `${c.toFixed(2)}px`, this._circleElement.style.height = `${c.toFixed(2)}px`;
          }
          trigger() {
            if (!this._setup) return u.w("Geolocate control triggered before added to a map"), !1;
            if (this.options.trackUserLocation) {
              switch (this._watchState) {
                case "OFF":
                  this._watchState = "WAITING_ACTIVE", this.fire(new u.l("trackuserlocationstart"));
                  break;
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                case "BACKGROUND_ERROR":
                  gn--, Ar = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this.fire(new u.l("trackuserlocationend"));
                  break;
                case "BACKGROUND":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new u.l("trackuserlocationstart")), this.fire(new u.l("userlocationfocus"));
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`);
              }
              switch (this._watchState) {
                case "WAITING_ACTIVE":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "ACTIVE_LOCK":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "OFF":
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`);
              }
              if (this._watchState === "OFF" && this._geolocationWatchID !== void 0) this._clearWatch();
              else if (this._geolocationWatchID === void 0) {
                let g;
                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), gn++, gn > 1 ? (g = { maximumAge: 6e5, timeout: 0 }, Ar = !0) : (g = this.options.positionOptions, Ar = !1), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, g);
              }
            } else window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
            return !0;
          }
          _clearWatch() {
            window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
          }
        }, b.GlobeControl = class {
          constructor() {
            this._toggleProjection = () => {
              var g;
              const e = (g = this._map.getProjection()) === null || g === void 0 ? void 0 : g.type;
              this._map.setProjection(e !== "mercator" && e ? { type: "mercator" } : { type: "globe" }), this._updateGlobeIcon();
            }, this._updateGlobeIcon = () => {
              var g;
              this._globeButton.classList.remove("maplibregl-ctrl-globe"), this._globeButton.classList.remove("maplibregl-ctrl-globe-enabled"), ((g = this._map.getProjection()) === null || g === void 0 ? void 0 : g.type) === "globe" ? (this._globeButton.classList.add("maplibregl-ctrl-globe-enabled"), this._globeButton.title = this._map._getUIString("GlobeControl.Disable")) : (this._globeButton.classList.add("maplibregl-ctrl-globe"), this._globeButton.title = this._map._getUIString("GlobeControl.Enable"));
            };
          }
          onAdd(g) {
            return this._map = g, this._container = gt.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._globeButton = gt.create("button", "maplibregl-ctrl-globe", this._container), gt.create("span", "maplibregl-ctrl-icon", this._globeButton).setAttribute("aria-hidden", "true"), this._globeButton.type = "button", this._globeButton.addEventListener("click", this._toggleProjection), this._updateGlobeIcon(), this._map.on("styledata", this._updateGlobeIcon), this._container;
          }
          onRemove() {
            gt.remove(this._container), this._map.off("styledata", this._updateGlobeIcon), this._globeButton.removeEventListener("click", this._toggleProjection), this._map = void 0;
          }
        }, b.Hash = rM, b.ImageSource = Ts, b.KeyboardHandler = kc, b.LngLatBounds = pe, b.LogoControl = Xs, b.Map = class extends Uc {
          constructor(g) {
            var e, r;
            u.cF.mark(u.cG.create);
            const o = Object.assign(Object.assign(Object.assign({}, ra), g), { canvasContextAttributes: Object.assign(Object.assign({}, ra.canvasContextAttributes), g.canvasContextAttributes) });
            if (o.minZoom != null && o.maxZoom != null && o.minZoom > o.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
            if (o.minPitch != null && o.maxPitch != null && o.minPitch > o.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
            if (o.minPitch != null && o.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (o.maxPitch != null && o.maxPitch > 180) throw new Error("maxPitch must be less than or equal to 180");
            const c = new ze(), h = new As();
            if (o.minZoom !== void 0 && c.setMinZoom(o.minZoom), o.maxZoom !== void 0 && c.setMaxZoom(o.maxZoom), o.minPitch !== void 0 && c.setMinPitch(o.minPitch), o.maxPitch !== void 0 && c.setMaxPitch(o.maxPitch), o.renderWorldCopies !== void 0 && c.setRenderWorldCopies(o.renderWorldCopies), o.transformConstrain !== null && c.setConstrainOverride(o.transformConstrain), super(c, h, { bearingSnap: o.bearingSnap }), this._idleTriggered = !1, this._crossFadingFactor = 1, this._renderTaskQueue = new Xc(), this._controls = [], this._mapId = u.ag(), this._lostContextStyle = { style: null, images: null }, this._contextLost = (d) => {
              d.preventDefault(), this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this.painter.destroy();
              for (const I of Object.values(this.style._layers)) if (I.type === "custom" && console.warn(`Custom layer with id '${I.id}' cannot be restored after WebGL context loss. You will need to re-add it manually after context restoration.`), I._listeners) for (const [p] of Object.entries(I._listeners)) console.warn(`Custom layer with id '${I.id}' had event listeners for event '${p}' which cannot be restored after WebGL context loss. You will need to re-add them manually after context restoration.`);
              this._lostContextStyle = this._getStyleAndImages(), this.style.destroy(), this.style = null, this.fire(new u.l("webglcontextlost", { originalEvent: d }));
            }, this._contextRestored = (d) => {
              this._lostContextStyle.style && this.setStyle(this._lostContextStyle.style, { diff: !1 }), this._lostContextStyle.images && (this.style.imageManager.images = this._lostContextStyle.images), this._setupPainter(), this.resize(), this._update(), this.fire(new u.l("webglcontextrestored", { originalEvent: d }));
            }, this._onMapScroll = (d) => {
              if (d.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1;
            }, this._onWindowOnline = () => {
              this._update();
            }, this._interactive = o.interactive, this._maxTileCacheSize = o.maxTileCacheSize, this._maxTileCacheZoomLevels = o.maxTileCacheZoomLevels, this._canvasContextAttributes = Object.assign({}, o.canvasContextAttributes), this._trackResize = o.trackResize === !0, this._bearingSnap = o.bearingSnap, this._centerClampedToGround = o.centerClampedToGround, this._refreshExpiredTiles = o.refreshExpiredTiles === !0, this._fadeDuration = o.fadeDuration, this._crossSourceCollisions = o.crossSourceCollisions === !0, this._collectResourceTiming = o.collectResourceTiming === !0, this._locale = Object.assign(Object.assign({}, Wc), o.locale), this._clickTolerance = o.clickTolerance, this._overridePixelRatio = o.pixelRatio, this._maxCanvasSize = o.maxCanvasSize, this._zoomLevelsToOverscale = o.experimentalZoomLevelsToOverscale, this.transformCameraUpdate = o.transformCameraUpdate, this.transformConstrain = o.transformConstrain, this.cancelPendingTileRequestsWhileZooming = o.cancelPendingTileRequestsWhileZooming === !0, o.reduceMotion !== void 0 && (Ke.prefersReducedMotion = o.reduceMotion), this._imageQueueHandle = ps.addThrottleControl((() => this.isMoving())), this._requestManager = new da(o.transformRequest), typeof o.container == "string") {
              if (this._container = document.getElementById(o.container), !this._container) throw new Error(`Container '${o.container}' not found.`);
            } else {
              if (!(o.container instanceof HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
              this._container = o.container;
            }
            if (o.maxBounds && this.setMaxBounds(o.maxBounds), this._setupContainer(), this._setupPainter(), this.on("move", (() => this._update(!1))), this.on("moveend", (() => this._update(!1))), this.on("zoom", (() => this._update(!0))), this.on("terrain", (() => {
              this.painter.terrainFacilitator.dirty = !0, this._update(!0);
            })), this.once("idle", (() => {
              this._idleTriggered = !0;
            })), typeof window < "u") {
              addEventListener("online", this._onWindowOnline, !1);
              let d = !1;
              const I = iM(((p) => {
                this._trackResize && !this._removed && (this.resize(p), this.redraw());
              }), 50);
              this._resizeObserver = new ResizeObserver(((p) => {
                d ? I(p) : d = !0;
              })), this._resizeObserver.observe(this._container);
            }
            this.handlers = new ta(this, o), this._hash = o.hash && new rM(typeof o.hash == "string" && o.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: o.center, elevation: o.elevation, zoom: o.zoom, bearing: o.bearing, pitch: o.pitch, roll: o.roll }), o.bounds && (this.resize(), this.fitBounds(o.bounds, u.e({}, o.fitBoundsOptions, { duration: 0 }))));
            const z = typeof o.style == "string" || ((r = (e = o.style) === null || e === void 0 ? void 0 : e.projection) === null || r === void 0 ? void 0 : r.type) !== "globe";
            this.resize(null, z), this._localIdeographFontFamily = o.localIdeographFontFamily, this._validateStyle = o.validateStyle, o.style && this.setStyle(o.style, { localIdeographFontFamily: o.localIdeographFontFamily }), o.attributionControl && this.addControl(new Ms(typeof o.attributionControl == "boolean" ? void 0 : o.attributionControl)), o.maplibreLogo && this.addControl(new Xs(), o.logoPosition), this.on("style.load", (() => {
              if (z || this._resizeTransform(), this.transform.unmodified) {
                const d = u.U(this.style.stylesheet, ["center", "zoom", "bearing", "pitch", "roll"]);
                this.jumpTo(d);
              }
            })), this.on("data", ((d) => {
              this._update(d.dataType === "style"), this.fire(new u.l(`${d.dataType}data`, d));
            })), this.on("dataloading", ((d) => {
              this.fire(new u.l(`${d.dataType}dataloading`, d));
            })), this.on("dataabort", ((d) => {
              this.fire(new u.l("sourcedataabort", d));
            }));
          }
          _getMapId() {
            return this._mapId;
          }
          setGlobalStateProperty(g, e) {
            return this.style.setGlobalStateProperty(g, e), this._update(!0);
          }
          getGlobalState() {
            return this.style.getGlobalState();
          }
          addControl(g, e) {
            if (e === void 0 && (e = g.getDefaultPosition ? g.getDefaultPosition() : "top-right"), !g || !g.onAdd) return this.fire(new u.k(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
            const r = g.onAdd(this);
            this._controls.push(g);
            const o = this._controlPositions[e];
            return e.indexOf("bottom") !== -1 ? o.insertBefore(r, o.firstChild) : o.appendChild(r), this;
          }
          removeControl(g) {
            if (!g || !g.onRemove) return this.fire(new u.k(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
            const e = this._controls.indexOf(g);
            return e > -1 && this._controls.splice(e, 1), g.onRemove(this), this;
          }
          hasControl(g) {
            return this._controls.indexOf(g) > -1;
          }
          coveringTiles(g) {
            return Xt(this.transform, g);
          }
          calculateCameraOptionsFromTo(g, e, r, o) {
            return o == null && this.terrain && (o = this.terrain.getElevationForLngLatZoom(r, this.transform.tileZoom)), super.calculateCameraOptionsFromTo(g, e, r, o);
          }
          resize(g, e = !0) {
            const [r, o] = this._containerDimensions(), c = this._getClampedPixelRatio(r, o);
            if (this._resizeCanvas(r, o, c), this.painter.resize(r, o, c), this.painter.overLimit()) {
              const z = this.painter.context.gl;
              this._maxCanvasSize = [z.drawingBufferWidth, z.drawingBufferHeight];
              const d = this._getClampedPixelRatio(r, o);
              this._resizeCanvas(r, o, d), this.painter.resize(r, o, d);
            }
            this._resizeTransform(e);
            const h = !this._moving;
            return h && (this.stop(), this.fire(new u.l("movestart", g)).fire(new u.l("move", g))), this.fire(new u.l("resize", g)), h && this.fire(new u.l("moveend", g)), this;
          }
          _resizeTransform(g = !0) {
            var e;
            const [r, o] = this._containerDimensions();
            this.transform.resize(r, o, g), (e = this._requestedCameraState) === null || e === void 0 || e.resize(r, o, g);
          }
          _getClampedPixelRatio(g, e) {
            const { 0: r, 1: o } = this._maxCanvasSize, c = this.getPixelRatio(), h = g * c, z = e * c;
            return Math.min(h > r ? r / h : 1, z > o ? o / z : 1) * c;
          }
          getPixelRatio() {
            var g;
            return (g = this._overridePixelRatio) !== null && g !== void 0 ? g : devicePixelRatio;
          }
          setPixelRatio(g) {
            this._overridePixelRatio = g, this.resize();
          }
          getBounds() {
            return this.transform.getBounds();
          }
          getMaxBounds() {
            return this.transform.getMaxBounds();
          }
          setMaxBounds(g) {
            return this.transform.setMaxBounds(pe.convert(g)), this._update();
          }
          setMinZoom(g) {
            if ((g = g ?? -2) >= -2 && g <= this.transform.maxZoom) return this.transform.setMinZoom(g), this._update(), this.getZoom() < g && this.setZoom(g), this;
            throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
          }
          getMinZoom() {
            return this.transform.minZoom;
          }
          setMaxZoom(g) {
            if ((g = g ?? 22) >= this.transform.minZoom) return this.transform.setMaxZoom(g), this._update(), this.getZoom() > g && this.setZoom(g), this;
            throw new Error("maxZoom must be greater than the current minZoom");
          }
          getMaxZoom() {
            return this.transform.maxZoom;
          }
          setMinPitch(g) {
            if ((g = g ?? 0) < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (g >= 0 && g <= this.transform.maxPitch) return this.transform.setMinPitch(g), this._update(), this.getPitch() < g && this.setPitch(g), this;
            throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
          }
          getMinPitch() {
            return this.transform.minPitch;
          }
          setMaxPitch(g) {
            if ((g = g ?? 60) > 180) throw new Error("maxPitch must be less than or equal to 180");
            if (g >= this.transform.minPitch) return this.transform.setMaxPitch(g), this._update(), this.getPitch() > g && this.setPitch(g), this;
            throw new Error("maxPitch must be greater than the current minPitch");
          }
          getMaxPitch() {
            return this.transform.maxPitch;
          }
          getRenderWorldCopies() {
            return this.transform.renderWorldCopies;
          }
          setRenderWorldCopies(g) {
            return this.transform.setRenderWorldCopies(g), this._update();
          }
          setTransformConstrain(g) {
            return this.transform.setConstrainOverride(g), this._update();
          }
          project(g) {
            return this.transform.locationToScreenPoint(u.V.convert(g), this.style && this.terrain);
          }
          unproject(g) {
            return this.transform.screenPointToLocation(u.P.convert(g), this.terrain);
          }
          isMoving() {
            var g;
            return this._moving || ((g = this.handlers) === null || g === void 0 ? void 0 : g.isMoving());
          }
          isZooming() {
            var g;
            return this._zooming || ((g = this.handlers) === null || g === void 0 ? void 0 : g.isZooming());
          }
          isRotating() {
            var g;
            return this._rotating || ((g = this.handlers) === null || g === void 0 ? void 0 : g.isRotating());
          }
          _createDelegatedListener(g, e, r) {
            if (g === "mouseenter" || g === "mouseover") {
              let o = !1;
              return { layers: e, listener: r, delegates: { mousemove: (h) => {
                const z = e.filter(((I) => this.getLayer(I))), d = z.length !== 0 ? this.queryRenderedFeatures(h.point, { layers: z }) : [];
                d.length ? o || (o = !0, r.call(this, new Le(g, this, h.originalEvent, { features: d }))) : o = !1;
              }, mouseout: () => {
                o = !1;
              } } };
            }
            if (g === "mouseleave" || g === "mouseout") {
              let o = !1;
              return { layers: e, listener: r, delegates: { mousemove: (z) => {
                const d = e.filter(((I) => this.getLayer(I)));
                (d.length !== 0 ? this.queryRenderedFeatures(z.point, { layers: d }) : []).length ? o = !0 : o && (o = !1, r.call(this, new Le(g, this, z.originalEvent)));
              }, mouseout: (z) => {
                o && (o = !1, r.call(this, new Le(g, this, z.originalEvent)));
              } } };
            }
            {
              const o = (c) => {
                const h = e.filter(((d) => this.getLayer(d))), z = h.length !== 0 ? this.queryRenderedFeatures(c.point, { layers: h }) : [];
                z.length && (c.features = z, r.call(this, c), delete c.features);
              };
              return { layers: e, listener: r, delegates: { [g]: o } };
            }
          }
          _saveDelegatedListener(g, e) {
            this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[g] = this._delegatedListeners[g] || [], this._delegatedListeners[g].push(e);
          }
          _removeDelegatedListener(g, e, r) {
            if (!this._delegatedListeners || !this._delegatedListeners[g]) return;
            const o = this._delegatedListeners[g];
            for (let c = 0; c < o.length; c++) {
              const h = o[c];
              if (h.listener === r && h.layers.length === e.length && h.layers.every(((z) => e.includes(z)))) {
                for (const z in h.delegates) this.off(z, h.delegates[z]);
                return void o.splice(c, 1);
              }
            }
          }
          on(g, e, r) {
            if (r === void 0) return super.on(g, e);
            const o = typeof e == "string" ? [e] : e, c = this._createDelegatedListener(g, o, r);
            this._saveDelegatedListener(g, c);
            for (const h in c.delegates) this.on(h, c.delegates[h]);
            return { unsubscribe: () => {
              this._removeDelegatedListener(g, o, r);
            } };
          }
          once(g, e, r) {
            if (r === void 0) return super.once(g, e);
            const o = typeof e == "string" ? [e] : e, c = this._createDelegatedListener(g, o, r);
            for (const h in c.delegates) {
              const z = c.delegates[h];
              c.delegates[h] = (...d) => {
                this._removeDelegatedListener(g, o, r), z(...d);
              };
            }
            this._saveDelegatedListener(g, c);
            for (const h in c.delegates) this.once(h, c.delegates[h]);
            return this;
          }
          off(g, e, r) {
            return r === void 0 ? super.off(g, e) : (this._removeDelegatedListener(g, typeof e == "string" ? [e] : e, r), this);
          }
          queryRenderedFeatures(g, e) {
            if (!this.style) return [];
            let r;
            const o = g instanceof u.P || Array.isArray(g), c = o ? g : [[0, 0], [this.transform.width, this.transform.height]];
            if (e = e || (o ? {} : g) || {}, c instanceof u.P || typeof c[0] == "number") r = [u.P.convert(c)];
            else {
              const h = u.P.convert(c[0]), z = u.P.convert(c[1]);
              r = [h, new u.P(z.x, h.y), z, new u.P(h.x, z.y), h];
            }
            return this.style.queryRenderedFeatures(r, e, this.transform);
          }
          querySourceFeatures(g, e) {
            return this.style.querySourceFeatures(g, e);
          }
          setStyle(g, e) {
            return (e = u.e({}, { localIdeographFontFamily: this._localIdeographFontFamily, validate: this._validateStyle }, e)).diff !== !1 && e.localIdeographFontFamily === this._localIdeographFontFamily && this.style && g ? (this._diffStyle(g, e), this) : (this._localIdeographFontFamily = e.localIdeographFontFamily, this._updateStyle(g, e));
          }
          setTransformRequest(g) {
            return this._requestManager.setTransformRequest(g), this;
          }
          _getUIString(g) {
            const e = this._locale[g];
            if (e == null) throw new Error(`Missing UI string '${g}'`);
            return e;
          }
          _updateStyle(g, e) {
            var r, o;
            if (e.transformStyle && this.style && !this.style._loaded) return void this.style.once("style.load", (() => this._updateStyle(g, e)));
            const c = this.style && e.transformStyle ? this.style.serialize() : void 0;
            return this.style && (this.style.setEventedParent(null), this.style._remove(!g)), g ? (this.style = new bn(this, e || {}), this.style.setEventedParent(this, { style: this.style }), typeof g == "string" ? this.style.loadURL(g, e, c) : this.style.loadJSON(g, e, c), this) : ((o = (r = this.style) === null || r === void 0 ? void 0 : r.projection) === null || o === void 0 || o.destroy(), delete this.style, this);
          }
          _lazyInitEmptyStyle() {
            this.style || (this.style = new bn(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
          }
          _diffStyle(g, e) {
            if (typeof g == "string") {
              const r = this._requestManager.transformRequest(g, "Style");
              u.j(r, new AbortController()).then(((o) => {
                this._updateDiff(o.data, e);
              })).catch(((o) => {
                o && this.fire(new u.k(o));
              }));
            } else typeof g == "object" && this._updateDiff(g, e);
          }
          _updateDiff(g, e) {
            try {
              this.style.setState(g, e) && this._update(!0);
            } catch (r) {
              u.w(`Unable to perform style diff: ${r.message || r.error || r}.  Rebuilding the style from scratch.`), this._updateStyle(g, e);
            }
          }
          getStyle() {
            if (this.style) return this.style.serialize();
          }
          _getStyleAndImages() {
            return this.style ? { style: this.style.serialize(), images: this.style.imageManager.cloneImages() } : { style: null, images: {} };
          }
          isStyleLoaded() {
            return this.style ? this.style.loaded() : u.w("There is no style added to the map.");
          }
          addSource(g, e) {
            return this._lazyInitEmptyStyle(), this.style.addSource(g, e), this._update(!0);
          }
          isSourceLoaded(g) {
            const e = this.style && this.style.tileManagers[g];
            if (e !== void 0) return e.loaded();
            this.fire(new u.k(new Error(`There is no tile manager with ID '${g}'`)));
          }
          setTerrain(g) {
            if (this.style._checkLoaded(), this._terrainDataCallback && this.style.off("data", this._terrainDataCallback), g) {
              const e = this.style.tileManagers[g.source];
              if (!e) throw new Error(`cannot load terrain, because there exists no source with ID: ${g.source}`);
              this.terrain === null && e.reload();
              for (const r in this.style._layers) {
                const o = this.style._layers[r];
                o.type === "hillshade" && o.source === g.source && u.w("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality."), o.type === "color-relief" && o.source === g.source && u.w("You are using the same source for a color-relief layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.");
              }
              this.terrain = new Vl(this.painter, e, g), this.painter.renderToTexture = new Ee(this.painter, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._terrainDataCallback = (r) => {
                var o;
                r.dataType === "style" ? this.terrain.tileManager.freeRtt() : r.dataType === "source" && r.tile && (r.sourceId !== g.source || this._elevationFreeze || (this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))), ((o = r.source) === null || o === void 0 ? void 0 : o.type) === "image" ? this.terrain.tileManager.freeRtt() : this.terrain.tileManager.freeRtt(r.tile.tileID));
              }, this.style.on("data", this._terrainDataCallback);
            } else this.terrain && this.terrain.tileManager.destruct(), this.terrain = null, this.painter.renderToTexture && this.painter.renderToTexture.destruct(), this.painter.renderToTexture = null, this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0);
            return this.fire(new u.l("terrain", { terrain: g })), this;
          }
          getTerrain() {
            var g, e;
            return (e = (g = this.terrain) === null || g === void 0 ? void 0 : g.options) !== null && e !== void 0 ? e : null;
          }
          areTilesLoaded() {
            const g = this.style && this.style.tileManagers;
            for (const e in g) {
              const r = g[e]._tiles;
              for (const o in r) {
                const c = r[o];
                if (c.state !== "loaded" && c.state !== "errored") return !1;
              }
            }
            return !0;
          }
          removeSource(g) {
            return this.style.removeSource(g), this._update(!0);
          }
          getSource(g) {
            return this.style.getSource(g);
          }
          setSourceTileLodParams(g, e, r) {
            if (r) {
              const o = this.getSource(r);
              if (!o) throw new Error(`There is no source with ID "${r}", cannot set LOD parameters`);
              o.calculateTileZoom = ht(Math.max(1, g), Math.max(1, e));
            } else for (const o in this.style.tileManagers) this.style.tileManagers[o].getSource().calculateTileZoom = ht(Math.max(1, g), Math.max(1, e));
            return this._update(!0), this;
          }
          refreshTiles(g, e) {
            const r = this.style.tileManagers[g];
            if (!r) throw new Error(`There is no tile manager with ID "${g}", cannot refresh tile`);
            e === void 0 ? r.reload(!0) : r.refreshTiles(e.map(((o) => new u.ad(o.z, o.x, o.y))));
          }
          addImage(g, e, r = {}) {
            const { pixelRatio: o = 1, sdf: c = !1, stretchX: h, stretchY: z, content: d, textFitWidth: I, textFitHeight: p } = r;
            if (this._lazyInitEmptyStyle(), !(e instanceof HTMLImageElement || u.b(e))) {
              if (e.width === void 0 || e.height === void 0) return this.fire(new u.k(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
              {
                const { width: f, height: _, data: j } = e, C = e;
                return this.style.addImage(g, { data: new u.R({ width: f, height: _ }, new Uint8Array(j)), pixelRatio: o, stretchX: h, stretchY: z, content: d, textFitWidth: I, textFitHeight: p, sdf: c, version: 0, userImage: C }), C.onAdd && C.onAdd(this, g), this;
              }
            }
            {
              const { width: f, height: _, data: j } = Ke.getImageData(e);
              this.style.addImage(g, { data: new u.R({ width: f, height: _ }, j), pixelRatio: o, stretchX: h, stretchY: z, content: d, textFitWidth: I, textFitHeight: p, sdf: c, version: 0 });
            }
          }
          updateImage(g, e) {
            const r = this.style.getImage(g);
            if (!r) return this.fire(new u.k(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
            const o = e instanceof HTMLImageElement || u.b(e) ? Ke.getImageData(e) : e, { width: c, height: h, data: z } = o;
            if (c === void 0 || h === void 0) return this.fire(new u.k(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            if (c !== r.data.width || h !== r.data.height) return this.fire(new u.k(new Error("The width and height of the updated image must be that same as the previous version of the image")));
            const d = !(e instanceof HTMLImageElement || u.b(e));
            return r.data.replace(z, d), this.style.updateImage(g, r), this;
          }
          getImage(g) {
            return this.style.getImage(g);
          }
          hasImage(g) {
            return g ? !!this.style.getImage(g) : (this.fire(new u.k(new Error("Missing required image id"))), !1);
          }
          removeImage(g) {
            this.style.removeImage(g);
          }
          loadImage(g) {
            return ps.getImage(this._requestManager.transformRequest(g, "Image"), new AbortController());
          }
          listImages() {
            return this.style.listImages();
          }
          addLayer(g, e) {
            return this._lazyInitEmptyStyle(), this.style.addLayer(g, e), this._update(!0);
          }
          moveLayer(g, e) {
            return this.style.moveLayer(g, e), this._update(!0);
          }
          removeLayer(g) {
            return this.style.removeLayer(g), this._update(!0);
          }
          getLayer(g) {
            return this.style.getLayer(g);
          }
          getLayersOrder() {
            return this.style.getLayersOrder();
          }
          setLayerZoomRange(g, e, r) {
            return this.style.setLayerZoomRange(g, e, r), this._update(!0);
          }
          setFilter(g, e, r = {}) {
            return this.style.setFilter(g, e, r), this._update(!0);
          }
          getFilter(g) {
            return this.style.getFilter(g);
          }
          setPaintProperty(g, e, r, o = {}) {
            return this.style.setPaintProperty(g, e, r, o), this._update(!0);
          }
          getPaintProperty(g, e) {
            return this.style.getPaintProperty(g, e);
          }
          setLayoutProperty(g, e, r, o = {}) {
            return this.style.setLayoutProperty(g, e, r, o), this._update(!0);
          }
          getLayoutProperty(g, e) {
            return this.style.getLayoutProperty(g, e);
          }
          setGlyphs(g, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setGlyphs(g, e), this._update(!0);
          }
          getGlyphs() {
            return this.style.getGlyphsUrl();
          }
          addSprite(g, e, r = {}) {
            return this._lazyInitEmptyStyle(), this.style.addSprite(g, e, r, ((o) => {
              o || this._update(!0);
            })), this;
          }
          removeSprite(g) {
            return this._lazyInitEmptyStyle(), this.style.removeSprite(g), this._update(!0);
          }
          getSprite() {
            return this.style.getSprite();
          }
          setSprite(g, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setSprite(g, e, ((r) => {
              r || this._update(!0);
            })), this;
          }
          setLight(g, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setLight(g, e), this._update(!0);
          }
          getLight() {
            return this.style.getLight();
          }
          setSky(g, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setSky(g, e), this._update(!0);
          }
          getSky() {
            return this.style.getSky();
          }
          setFeatureState(g, e) {
            return this.style.setFeatureState(g, e), this._update();
          }
          removeFeatureState(g, e) {
            return this.style.removeFeatureState(g, e), this._update();
          }
          getFeatureState(g) {
            return this.style.getFeatureState(g);
          }
          getContainer() {
            return this._container;
          }
          getCanvasContainer() {
            return this._canvasContainer;
          }
          getCanvas() {
            return this._canvas;
          }
          _containerDimensions() {
            let g = 0, e = 0;
            return this._container && (g = this._container.clientWidth || 400, e = this._container.clientHeight || 300), [g, e];
          }
          _setupContainer() {
            const g = this._container;
            g.classList.add("maplibregl-map");
            const e = this._canvasContainer = gt.create("div", "maplibregl-canvas-container", g);
            this._interactive && e.classList.add("maplibregl-interactive"), this._canvas = gt.create("canvas", "maplibregl-canvas", e), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("tabindex", this._interactive ? "0" : "-1"), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region");
            const r = this._containerDimensions(), o = this._getClampedPixelRatio(r[0], r[1]);
            this._resizeCanvas(r[0], r[1], o);
            const c = this._controlContainer = gt.create("div", "maplibregl-control-container", g), h = this._controlPositions = {};
            ["top-left", "top-right", "bottom-left", "bottom-right"].forEach(((z) => {
              h[z] = gt.create("div", `maplibregl-ctrl-${z} `, c);
            })), this._container.addEventListener("scroll", this._onMapScroll, !1);
          }
          _resizeCanvas(g, e, r) {
            this._canvas.width = Math.floor(r * g), this._canvas.height = Math.floor(r * e), this._canvas.style.width = `${g}px`, this._canvas.style.height = `${e}px`;
          }
          _setupPainter() {
            const g = Object.assign(Object.assign({}, this._canvasContextAttributes), { alpha: !0, depth: !0, stencil: !0, premultipliedAlpha: !0 });
            let e = null;
            this._canvas.addEventListener("webglcontextcreationerror", ((o) => {
              e = { requestedAttributes: g }, o && (e.statusMessage = o.statusMessage, e.type = o.type);
            }), { once: !0 });
            let r = null;
            if (r = this._canvasContextAttributes.contextType ? this._canvas.getContext(this._canvasContextAttributes.contextType, g) : this._canvas.getContext("webgl2", g) || this._canvas.getContext("webgl", g), !r) {
              const o = "Failed to initialize WebGL";
              throw e ? (e.message = o, new Error(JSON.stringify(e))) : new Error(o);
            }
            this.painter = new _c(r, this.transform), rr.testSupport(r);
          }
          migrateProjection(g, e) {
            super.migrateProjection(g, e), this.painter.transform = g, this.fire(new u.l("projectiontransition", { newProjection: this.style.projection.name }));
          }
          loaded() {
            return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
          }
          _update(g) {
            return this.style && this.style._loaded ? (this._styleDirty = this._styleDirty || g, this._sourcesDirty = !0, this.triggerRepaint(), this) : this;
          }
          _requestRenderFrame(g) {
            return this._update(), this._renderTaskQueue.add(g);
          }
          _cancelRenderFrame(g) {
            this._renderTaskQueue.remove(g);
          }
          _render(g) {
            var e, r, o, c, h;
            const z = this._idleTriggered ? this._fadeDuration : 0, d = ((e = this.style.projection) === null || e === void 0 ? void 0 : e.transitionState) > 0;
            if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(g), this._removed) return;
            let I = !1;
            if (this.style && this._styleDirty) {
              this._styleDirty = !1;
              const _ = this.transform.zoom, j = $t();
              this.style.zoomHistory.update(_, j);
              const C = new u.H(_, { now: j, fadeDuration: z, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition() }), v = C.crossFadingFactor();
              v === 1 && v === this._crossFadingFactor || (I = !0, this._crossFadingFactor = v), this.style.update(C);
            }
            const p = ((r = this.style.projection) === null || r === void 0 ? void 0 : r.transitionState) > 0 !== d;
            (o = this.style.projection) === null || o === void 0 || o.setErrorQueryLatitudeDegrees(this.transform.center.lat), this.transform.setTransitionState((c = this.style.projection) === null || c === void 0 ? void 0 : c.transitionState, (h = this.style.projection) === null || h === void 0 ? void 0 : h.latitudeErrorCorrectionRadians), this.style && (this._sourcesDirty || p) && (this._sourcesDirty = !1, this.style._updateSources(this.transform)), this.terrain ? (this.terrain.tileManager.update(this.transform, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), !this._elevationFreeze && this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))) : (this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0)), this._placementDirty = this.style && this.style._updatePlacement(this.transform, this.showCollisionBoxes, z, this._crossSourceCollisions, p), this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showOverdrawInspector: this._showOverdrawInspector, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: z, showPadding: this.showPadding }), this.fire(new u.l("render")), this.loaded() && !this._loaded && (this._loaded = !0, u.cF.mark(u.cG.load), this.fire(new u.l("load"))), this.style && (this.style.hasTransitions() || I) && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
            const f = this._sourcesDirty || this._styleDirty || this._placementDirty;
            return f || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new u.l("idle")), !this._loaded || this._fullyLoaded || f || (this._fullyLoaded = !0, u.cF.mark(u.cG.fullLoad)), this;
          }
          redraw() {
            return this.style && (this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._render(0)), this;
          }
          remove() {
            var g;
            this._hash && this._hash.remove();
            for (const r of this._controls) r.onRemove(this);
            this._controls = [], this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), typeof window < "u" && removeEventListener("online", this._onWindowOnline, !1), ps.removeThrottleControl(this._imageQueueHandle), (g = this._resizeObserver) === null || g === void 0 || g.disconnect();
            const e = this.painter.context.gl.getExtension("WEBGL_lose_context");
            e?.loseContext && e.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1), gt.remove(this._canvasContainer), gt.remove(this._controlContainer), this._container.removeEventListener("scroll", this._onMapScroll, !1), this._container.classList.remove("maplibregl-map"), u.cF.clearMetrics(), this._removed = !0, this.fire(new u.l("remove"));
          }
          triggerRepaint() {
            this.style && !this._frameRequest && (this._frameRequest = new AbortController(), Ke.frame(this._frameRequest, ((g) => {
              u.cF.frame(g), this._frameRequest = null;
              try {
                this._render(g);
              } catch (e) {
                if (!u.cH(e) && !(function(r) {
                  return r.message === ka;
                })(e)) throw e;
              }
            }), (() => {
            })));
          }
          get showTileBoundaries() {
            return !!this._showTileBoundaries;
          }
          set showTileBoundaries(g) {
            this._showTileBoundaries !== g && (this._showTileBoundaries = g, this._update());
          }
          get showPadding() {
            return !!this._showPadding;
          }
          set showPadding(g) {
            this._showPadding !== g && (this._showPadding = g, this._update());
          }
          get showCollisionBoxes() {
            return !!this._showCollisionBoxes;
          }
          set showCollisionBoxes(g) {
            this._showCollisionBoxes !== g && (this._showCollisionBoxes = g, g ? this.style._generateCollisionBoxes() : this._update());
          }
          get showOverdrawInspector() {
            return !!this._showOverdrawInspector;
          }
          set showOverdrawInspector(g) {
            this._showOverdrawInspector !== g && (this._showOverdrawInspector = g, this._update());
          }
          get repaint() {
            return !!this._repaint;
          }
          set repaint(g) {
            this._repaint !== g && (this._repaint = g, this.triggerRepaint());
          }
          get vertices() {
            return !!this._vertices;
          }
          set vertices(g) {
            this._vertices = g, this._update();
          }
          get version() {
            return ia;
          }
          getCameraTargetElevation() {
            return this.transform.elevation;
          }
          getProjection() {
            return this.style.getProjection();
          }
          setProjection(g) {
            return this._lazyInitEmptyStyle(), this.style.setProjection(g), this._update(!0);
          }
        }, b.MapMouseEvent = Le, b.MapTouchEvent = Vn, b.MapWheelEvent = fr, b.Marker = aa, b.NavigationControl = class {
          constructor(g) {
            this._updateZoomButtons = () => {
              const e = this._map.getZoom(), r = e === this._map.getMaxZoom(), o = e === this._map.getMinZoom();
              this._zoomInButton.disabled = r, this._zoomOutButton.disabled = o, this._zoomInButton.setAttribute("aria-disabled", r.toString()), this._zoomOutButton.setAttribute("aria-disabled", o.toString());
            }, this._rotateCompassArrow = () => {
              this._compassIcon.style.transform = this.options.visualizePitch && this.options.visualizeRoll ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), 0.5)}) rotateZ(${-this._map.transform.roll}deg) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), 0.5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizeRoll ? `rotate(${-this._map.transform.bearing - this._map.transform.roll}deg)` : `rotate(${-this._map.transform.bearing}deg)`;
            }, this._setButtonTitle = (e, r) => {
              const o = this._map._getUIString(`NavigationControl.${r}`);
              e.title = o, e.setAttribute("aria-label", o);
            }, this.options = u.e({}, DM, g), this._container = gt.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._container.addEventListener("contextmenu", ((e) => e.preventDefault())), this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", ((e) => this._map.zoomIn({}, { originalEvent: e }))), gt.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", ((e) => this._map.zoomOut({}, { originalEvent: e }))), gt.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", ((e) => {
              this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: e }) : this._map.resetNorth({}, { originalEvent: e });
            })), this._compassIcon = gt.create("span", "maplibregl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
          }
          onAdd(g) {
            return this._map = g, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.on("roll", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new zM(this._map, this._compass, this.options.visualizePitch)), this._container;
          }
          onRemove() {
            gt.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.off("roll", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
          }
          _createButton(g, e) {
            const r = gt.create("button", g, this._container);
            return r.type = "button", r.addEventListener("click", e), r;
          }
        }, b.Popup = class extends u.E {
          constructor(g) {
            super(), this._updateOpacity = () => {
              this.options.locationOccludedOpacity !== void 0 && (this._container.style.opacity = this._map.transform.isLocationOccluded(this.getLngLat()) ? `${this.options.locationOccludedOpacity}` : "");
            }, this.remove = () => (this._content && gt.remove(this._content), this._container && (gt.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), this._map._canvasContainer.classList.remove("maplibregl-track-pointer"), delete this._map, this.fire(new u.l("close"))), this), this._onMouseUp = (e) => {
              this._update(e.point);
            }, this._onMouseMove = (e) => {
              this._update(e.point);
            }, this._onDrag = (e) => {
              this._update(e.point);
            }, this._update = (e) => {
              if (!this._map || !this._lngLat && !this._trackPointer || !this._content) return;
              if (!this._container) {
                if (this._container = gt.create("div", "maplibregl-popup", this._map.getContainer()), this._tip = gt.create("div", "maplibregl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className) for (const z of this.options.className.split(" ")) this._container.classList.add(z);
                this._closeButton && this._closeButton.setAttribute("aria-label", this._map._getUIString("Popup.Close")), this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer");
              }
              if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._lngLat = un(this._lngLat, this._flatPos, this._map.transform, this._trackPointer), this._trackPointer && !e) return;
              const r = this._flatPos = this._pos = this._trackPointer && e ? e : this._map.project(this._lngLat);
              this._map.terrain && (this._flatPos = this._trackPointer && e ? e : this._map.transform.locationToScreenPoint(this._lngLat));
              let o = this.options.anchor;
              const c = to(this.options.offset);
              if (!o) {
                const z = this._container.offsetWidth, d = this._container.offsetHeight;
                let I;
                I = r.y + c.bottom.y < d ? ["top"] : r.y > this._map.transform.height - d ? ["bottom"] : [], r.x < z / 2 ? I.push("left") : r.x > this._map.transform.width - z / 2 && I.push("right"), o = I.length === 0 ? "bottom" : I.join("-");
              }
              let h = r.add(c[o]);
              this.options.subpixelPositioning || (h = h.round()), gt.setTransform(this._container, `${na[o]} translate(${h.x}px,${h.y}px)`), qa(this._container, o, "popup"), this._updateOpacity();
            }, this._onClose = () => {
              this.remove();
            }, this.options = u.e(Object.create(Ka), g);
          }
          addTo(g) {
            return this._map && this.remove(), this._map = g, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update), this.fire(new u.l("open")), this;
          }
          isOpen() {
            return !!this._map;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(g) {
            return this._lngLat = u.V.convert(g), this._pos = null, this._flatPos = null, this._trackPointer = !1, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer")), this;
          }
          trackPointer() {
            return this._trackPointer = !0, this._pos = null, this._flatPos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")), this;
          }
          getElement() {
            return this._container;
          }
          setText(g) {
            return this.setDOMContent(document.createTextNode(g));
          }
          setHTML(g) {
            const e = document.createDocumentFragment(), r = document.createElement("body");
            let o;
            for (r.innerHTML = g; o = r.firstChild, o; ) e.appendChild(o);
            return this.setDOMContent(e);
          }
          getMaxWidth() {
            var g;
            return (g = this._container) === null || g === void 0 ? void 0 : g.style.maxWidth;
          }
          setMaxWidth(g) {
            return this.options.maxWidth = g, this._update(), this;
          }
          setDOMContent(g) {
            if (this._content) for (; this._content.hasChildNodes(); ) this._content.firstChild && this._content.removeChild(this._content.firstChild);
            else this._content = gt.create("div", "maplibregl-popup-content", this._container);
            return this._content.appendChild(g), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
          }
          addClassName(g) {
            return this._container && this._container.classList.add(g), this;
          }
          removeClassName(g) {
            return this._container && this._container.classList.remove(g), this;
          }
          setOffset(g) {
            return this.options.offset = g, this._update(), this;
          }
          toggleClassName(g) {
            if (this._container) return this._container.classList.toggle(g);
          }
          setSubpixelPositioning(g) {
            this.options.subpixelPositioning = g;
          }
          _createCloseButton() {
            this.options.closeButton && (this._closeButton = gt.create("button", "maplibregl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
          }
          _focusFirstElement() {
            if (!this.options.focusAfterOpen || !this._container) return;
            const g = this._container.querySelector(yM);
            g && g.focus();
          }
        }, b.RasterDEMTileSource = Ui, b.RasterTileSource = Yr, b.ScaleControl = class {
          constructor(g) {
            this._onMove = () => {
              $a(this._map, this._container, this.options);
            }, this.setUnit = (e) => {
              this.options.unit = e, $a(this._map, this._container, this.options);
            }, this.options = Object.assign(Object.assign({}, dM), g);
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          onAdd(g) {
            return this._map = g, this._container = gt.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", g.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
          }
          onRemove() {
            gt.remove(this._container), this._map.off("move", this._onMove), this._map = void 0;
          }
        }, b.ScrollZoomHandler = $n, b.Style = bn, b.TerrainControl = class {
          constructor(g) {
            this._toggleTerrain = () => {
              this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon();
            }, this._updateTerrainIcon = () => {
              this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.Enable"));
            }, this.options = g;
          }
          onAdd(g) {
            return this._map = g, this._container = gt.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = gt.create("button", "maplibregl-ctrl-terrain", this._container), gt.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container;
          }
          onRemove() {
            gt.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0;
          }
        }, b.TwoFingersTouchPitchHandler = lM, b.TwoFingersTouchRotateHandler = MM, b.TwoFingersTouchZoomHandler = Bc, b.TwoFingersTouchZoomRotateHandler = Yc, b.VectorTileSource = Mi, b.VideoSource = mn, b.addSourceType = (g, e) => u._(void 0, void 0, void 0, (function* () {
          if (Ur(g)) throw new Error(`A source type called "${g}" already exists.`);
          ((r, o) => {
            lr[r] = o;
          })(g, e);
        })), b.clearPrewarmedResources = function() {
          const g = Vs;
          g && (g.isPreloaded() && g.numActive() === 1 ? (g.release(ki), Vs = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
        }, b.createTileMesh = Ta, b.getMaxParallelImageRequests = function() {
          return u.a.MAX_PARALLEL_IMAGE_REQUESTS;
        }, b.getRTLTextPluginStatus = function() {
          return Hs().getRTLTextPluginStatus();
        }, b.getVersion = function() {
          return eo;
        }, b.getWorkerCount = function() {
          return Fi.workerCount;
        }, b.getWorkerUrl = function() {
          return u.a.WORKER_URL;
        }, b.importScriptInWorkers = function(g) {
          return Mr().broadcast("IS", g);
        }, b.isTimeFrozen = function() {
          return vi.isFrozen();
        }, b.now = $t, b.prewarm = function() {
          Fr().acquire(ki);
        }, b.restoreNow = function() {
          vi.restoreNow();
        }, b.setMaxParallelImageRequests = function(g) {
          u.a.MAX_PARALLEL_IMAGE_REQUESTS = g;
        }, b.setNow = function(g) {
          vi.setNow(g);
        }, b.setRTLTextPlugin = function(g, e) {
          return Hs().setRTLTextPlugin(g, e);
        }, b.setWorkerCount = function(g) {
          Fi.workerCount = g;
        }, b.setWorkerUrl = function(g) {
          u.a.WORKER_URL = g;
        };
      }));
      var Hh = In;
      return Hh;
    }));
  })(wl)), wl.exports;
}
var Na = gN();
const hN = "data:application/geo+json;base64,ewoidHlwZSI6ICJGZWF0dXJlQ29sbGVjdGlvbiIsCiJuYW1lIjogImJ1aWxkaW5ncyIsCiJjcnMiOiB7ICJ0eXBlIjogIm5hbWUiLCAicHJvcGVydGllcyI6IHsgIm5hbWUiOiAidXJuOm9nYzpkZWY6Y3JzOk9HQzoxLjM6Q1JTODQiIH0gfSwKImZlYXR1cmVzIjogWwp7ICJ0eXBlIjogIkZlYXR1cmUiLCAicHJvcGVydGllcyI6IHsgfSwgImdlb21ldHJ5IjogeyAidHlwZSI6ICJQb2x5Z29uIiwgImNvb3JkaW5hdGVzIjogWyBbIFsgMTM3LjQwNDE3NzY5NCwgMzQuNzAyNTU5NDE3IF0sIFsgMTM3LjQwNDE4Mjk0NDAwMDAxMywgMzQuNzAyNTIwNzIyIF0sIFsgMTM3LjQwNDI0NzY5NCwgMzQuNzAyNTI2NjM5IF0sIFsgMTM3LjQwNDI0MjMzMzAwMDAxMywgMzQuNzAyNTY1Nzc4IF0sIFsgMTM3LjQwNDM3MDMwNiwgMzQuNzAyNTc4MjUgXSwgWyAxMzcuNDA0Mzc0Mzg5LCAzNC43MDI1NTAxMTEgXSwgWyAxMzcuNDA0NDcyNjY3LCAzNC43MDI1NTkxOTQgXSwgWyAxMzcuNDA0NDgxLCAzNC43MDI0OTc3NzggXSwgWyAxMzcuNDA0MzMyMTY3LCAzNC43MDI0ODQxMTEgXSwgWyAxMzcuNDA0MzM0NzIxOTk5OTg3LCAzNC43MDI0NjQ4ODkgXSwgWyAxMzcuNDA0MTEyMTk0LCAzNC43MDI0NDQ0MTcgXSwgWyAxMzcuNDA0MTA5NjM5MDAwMDEyLCAzNC43MDI0NjM1MjggXSwgWyAxMzcuNDAzOTY1ODMzLCAzNC43MDI0NTAzMDYgXSwgWyAxMzcuNDAzOTU3NSwgMzQuNzAyNTExNjExIF0sIFsgMTM3LjQwNDA1MjA1NjAwMDAxMiwgMzQuNzAyNTIwMzYxIF0sIFsgMTM3LjQwNDA0ODMwNiwgMzQuNzAyNTQ2ODYxIF0sIFsgMTM3LjQwNDE3NzY5NCwgMzQuNzAyNTU5NDE3IF0gXSBdIH0gfSwKeyAidHlwZSI6ICJGZWF0dXJlIiwgInByb3BlcnRpZXMiOiB7IH0sICJnZW9tZXRyeSI6IHsgInR5cGUiOiAiUG9seWdvbiIsICJjb29yZGluYXRlcyI6IFsgWyBbIDEzNy40MDQ2MTk3NzgwMDAwMTEsIDM0LjcwMjkyOTMzMyBdLCBbIDEzNy40MDQ2Mjg4NjEsIDM0LjcwMjg2NTIyMiBdLCBbIDEzNy40MDQ0ODQ1MjgwMDAwMTIsIDM0LjcwMjg1MTE2NyBdLCBbIDEzNy40MDQ0ODY2NjY5OTk5ODYsIDM0LjcwMjgzNTY2NyBdLCBbIDEzNy40MDQyNjEwNTYsIDM0LjcwMjgxMzU1NiBdLCBbIDEzNy40MDQyNTg4MDYsIDM0LjcwMjgyOTI1IF0sIFsgMTM3LjQwNDExMjcyMiwgMzQuNzAyODE1MDI4IF0sIFsgMTM3LjQwNDEwMzYzOSwgMzQuNzAyODc5MTM5IF0sIFsgMTM3LjQwNDIwMjIyMiwgMzQuNzAyODg4Nzc4IF0sIFsgMTM3LjQwNDE5ODM4ODk5OTk4NywgMzQuNzAyOTE3NjM5IF0sIFsgMTM3LjQwNDMyOTUyOCwgMzQuNzAyOTI5ODMzIF0sIFsgMTM3LjQwNDMzMzc3OCwgMzQuNzAyODkxNDE3IF0sIFsgMTM3LjQwNDM5NjU1NiwgMzQuNzAyODk2MDU2IF0sIFsgMTM3LjQwNDM5MjMwNiwgMzQuNzAyOTM1NjM5IF0sIFsgMTM3LjQwNDUxNjU1NiwgMzQuNzAyOTQ3MTM5IF0sIFsgMTM3LjQwNDUyMDMwNiwgMzQuNzAyOTE5NzIyIF0sIFsgMTM3LjQwNDYxOTc3ODAwMDAxMSwgMzQuNzAyOTI5MzMzIF0gXSBdIH0gfSwKeyAidHlwZSI6ICJGZWF0dXJlIiwgInByb3BlcnRpZXMiOiB7IH0sICJnZW9tZXRyeSI6IHsgInR5cGUiOiAiUG9seWdvbiIsICJjb29yZGluYXRlcyI6IFsgWyBbIDEzNy40MDQxOTYzMzI5OTk5ODcsIDM0LjcwMjQzMDcyMiBdLCBbIDEzNy40MDQyMTczMDYsIDM0LjcwMjQzMjUgXSwgWyAxMzcuNDA0MjI0OTcyLCAzNC43MDIzNzEgXSwgWyAxMzcuNDA0MjAzOTE3LCAzNC43MDIzNjkyMjIgXSwgWyAxMzcuNDA0MTk2MzMyOTk5OTg3LCAzNC43MDI0MzA3MjIgXSBdIF0gfSB9LAp7ICJ0eXBlIjogIkZlYXR1cmUiLCAicHJvcGVydGllcyI6IHsgfSwgImdlb21ldHJ5IjogeyAidHlwZSI6ICJQb2x5Z29uIiwgImNvb3JkaW5hdGVzIjogWyBbIFsgMTM3LjQwNDU1MjUyODAwMDAxMSwgMzQuNzAyNTg5MjUgXSwgWyAxMzcuNDA0NjMyNDcyLCAzNC43MDI1NjM0NzIgXSwgWyAxMzcuNDA0NjI1NjY3LCAzNC43MDI1NDkxNjcgXSwgWyAxMzcuNDA0NTQxNDcyLCAzNC43MDI1NzYyNzggXSwgWyAxMzcuNDA0NTUyNTI4MDAwMDExLCAzNC43MDI1ODkyNSBdIF0gXSB9IH0sCnsgInR5cGUiOiAiRmVhdHVyZSIsICJwcm9wZXJ0aWVzIjogeyB9LCAiZ2VvbWV0cnkiOiB7ICJ0eXBlIjogIlBvbHlnb24iLCAiY29vcmRpbmF0ZXMiOiBbIFsgWyAxMzcuNDA0NDI5MTY2OTk5OTg5LCAzNC43MDI2MTc4ODkgXSwgWyAxMzcuNDA0NDMxMDgzLCAzNC43MDI2MDI0NzIgXSwgWyAxMzcuNDA0MzQzMzA1OTk5OTg3LCAzNC43MDI1OTQ2OTQgXSwgWyAxMzcuNDA0MzQxMzYxLCAzNC43MDI2MTAxMTEgXSwgWyAxMzcuNDA0NDI5MTY2OTk5OTg5LCAzNC43MDI2MTc4ODkgXSBdIF0gfSB9LAp7ICJ0eXBlIjogIkZlYXR1cmUiLCAicHJvcGVydGllcyI6IHsgfSwgImdlb21ldHJ5IjogeyAidHlwZSI6ICJQb2x5Z29uIiwgImNvb3JkaW5hdGVzIjogWyBbIFsgMTM3LjQwNDMwNjYxMTAwMDAxLCAzNC43MDI5NzY3NSBdLCBbIDEzNy40MDQyOTgwNTU5OTk5ODgsIDM0LjcwMzA0MTg2MSBdLCBbIDEzNy40MDQzMjA0NDQsIDM0LjcwMzA0Mzg4OSBdLCBbIDEzNy40MDQzMjkxMTEwMDAwMSwgMzQuNzAyOTc4Nzc4IF0sIFsgMTM3LjQwNDMwNjYxMTAwMDAxLCAzNC43MDI5NzY3NSBdIF0gXSB9IH0sCnsgInR5cGUiOiAiRmVhdHVyZSIsICJwcm9wZXJ0aWVzIjogeyB9LCAiZ2VvbWV0cnkiOiB7ICJ0eXBlIjogIlBvbHlnb24iLCAiY29vcmRpbmF0ZXMiOiBbIFsgWyAxMzcuNDA0MjMxOTQ0LCAzNC43MDI0MzYwODMgXSwgWyAxMzcuNDA0MjUzNDQ0LCAzNC43MDI0Mzc0NzIgXSwgWyAxMzcuNDA0MjYwMjIyLCAzNC43MDIzNjgxMzkgXSwgWyAxMzcuNDA0MjM4NzIyLCAzNC43MDIzNjY3MjIgXSwgWyAxMzcuNDA0MjMxOTQ0LCAzNC43MDI0MzYwODMgXSBdIF0gfSB9LAp7ICJ0eXBlIjogIkZlYXR1cmUiLCAicHJvcGVydGllcyI6IHsgfSwgImdlb21ldHJ5IjogeyAidHlwZSI6ICJQb2x5Z29uIiwgImNvb3JkaW5hdGVzIjogWyBbIFsgMTM3LjQwNDQ3MjQ3MiwgMzQuNzAyNzk4NTU2IF0sIFsgMTM3LjQwNDU1ODI3OCwgMzQuNzAyODA2NSBdLCBbIDEzNy40MDQ1NjA3NSwgMzQuNzAyNzg4ODMzIF0sIFsgMTM3LjQwNDQ3NDgwNiwgMzQuNzAyNzgwODg5IF0sIFsgMTM3LjQwNDQ3MjQ3MiwgMzQuNzAyNzk4NTU2IF0gXSBdIH0gfSwKeyAidHlwZSI6ICJGZWF0dXJlIiwgInByb3BlcnRpZXMiOiB7IH0sICJnZW9tZXRyeSI6IHsgInR5cGUiOiAiUG9seWdvbiIsICJjb29yZGluYXRlcyI6IFsgWyBbIDEzNy40MDQzNjE3NSwgMzQuNzAyOTc5Njk0IF0sIFsgMTM3LjQwNDMzOTU4MywgMzQuNzAyOTc4MDI4IF0sIFsgMTM3LjQwNDMzMjI1MDAwMDAxLCAzNC43MDMwNDY5MTcgXSwgWyAxMzcuNDA0MzU0NDE3LCAzNC43MDMwNDg1ODMgXSwgWyAxMzcuNDA0MzYxNzUsIDM0LjcwMjk3OTY5NCBdIF0gXSB9IH0sCnsgInR5cGUiOiAiRmVhdHVyZSIsICJwcm9wZXJ0aWVzIjogeyB9LCAiZ2VvbWV0cnkiOiB7ICJ0eXBlIjogIlBvbHlnb24iLCAiY29vcmRpbmF0ZXMiOiBbIFsgWyAxMzcuNDA0NDIyOTE3LCAzNC43MDI2NTE2OTQgXSwgWyAxMzcuNDA0NDI1Mjc4LCAzNC43MDI2MzM2NjcgXSwgWyAxMzcuNDA0MzM5NDQzOTk5OTg3LCAzNC43MDI2MjYwODMgXSwgWyAxMzcuNDA0MzM3MTExLCAzNC43MDI2NDQxMTEgXSwgWyAxMzcuNDA0NDIyOTE3LCAzNC43MDI2NTE2OTQgXSBdIF0gfSB9LAp7ICJ0eXBlIjogIkZlYXR1cmUiLCAicHJvcGVydGllcyI6IHsgfSwgImdlb21ldHJ5IjogeyAidHlwZSI6ICJQb2x5Z29uIiwgImNvb3JkaW5hdGVzIjogWyBbIFsgMTM3LjQwNDQ3ODU4MzAwMDAxNCwgMzQuNzAyNzY1NzIyIF0sIFsgMTM3LjQwNDU2MDUsIDM0LjcwMjc3NDM4OSBdLCBbIDEzNy40MDQ1NjM1LCAzNC43MDI3NTQ0NzIgXSwgWyAxMzcuNDA0NDgyMjUsIDM0LjcwMjc0NTQ0NCBdLCBbIDEzNy40MDQ0Nzg1ODMwMDAwMTQsIDM0LjcwMjc2NTcyMiBdIF0gXSB9IH0sCnsgInR5cGUiOiAiRmVhdHVyZSIsICJwcm9wZXJ0aWVzIjogeyB9LCAiZ2VvbWV0cnkiOiB7ICJ0eXBlIjogIlBvbHlnb24iLCAiY29vcmRpbmF0ZXMiOiBbIFsgWyAxMzcuNDA1NTI2MTk0LCAzNC43MDM0MDI5NDQgXSwgWyAxMzcuNDA1NTMzMTM5LCAzNC43MDMzNTYzMDYgXSwgWyAxMzcuNDA1NDc3ODg5LCAzNC43MDMzNTA2NjcgXSwgWyAxMzcuNDA1NDgzMTM5MDAwMDEyLCAzNC43MDMzMTUwMjggXSwgWyAxMzcuNDA1NDI5MzA2LCAzNC43MDMzMDk1NTYgXSwgWyAxMzcuNDA1NDE3MTExLCAzNC43MDMzOTE4ODkgXSwgWyAxMzcuNDA1NTI2MTk0LCAzNC43MDM0MDI5NDQgXSBdIF0gfSB9LAp7ICJ0eXBlIjogIkZlYXR1cmUiLCAicHJvcGVydGllcyI6IHsgfSwgImdlb21ldHJ5IjogeyAidHlwZSI6ICJQb2x5Z29uIiwgImNvb3JkaW5hdGVzIjogWyBbIFsgMTM3LjQwNTA2MTEzOSwgMzQuNzAzMzU1OTcyIF0sIFsgMTM3LjQwNTE2NDMzMjk5OTk4OCwgMzQuNzAzMzY4MjIyIF0sIFsgMTM3LjQwNTE3Nzc1LCAzNC43MDMyOTExMTEgXSwgWyAxMzcuNDA1MDc0NTU1OTk5OTg4LCAzNC43MDMyNzg4NjEgXSwgWyAxMzcuNDA1MDYxMTM5LCAzNC43MDMzNTU5NzIgXSBdIF0gfSB9LAp7ICJ0eXBlIjogIkZlYXR1cmUiLCAicHJvcGVydGllcyI6IHsgfSwgImdlb21ldHJ5IjogeyAidHlwZSI6ICJQb2x5Z29uIiwgImNvb3JkaW5hdGVzIjogWyBbIFsgMTM3LjQwNTMyNTgzMywgMzQuNzAzMzg0NSBdLCBbIDEzNy40MDUzNDExOTM5OTk5ODgsIDM0LjcwMzMwNjkxNyBdLCBbIDEzNy40MDUyMzY5MTcsIDM0LjcwMzI5Mjg4OSBdLCBbIDEzNy40MDUyMjE2MzksIDM0LjcwMzM3MDQ0NCBdLCBbIDEzNy40MDUzMjU4MzMsIDM0LjcwMzM4NDUgXSBdIF0gfSB9LAp7ICJ0eXBlIjogIkZlYXR1cmUiLCAicHJvcGVydGllcyI6IHsgfSwgImdlb21ldHJ5IjogeyAidHlwZSI6ICJQb2x5Z29uIiwgImNvb3JkaW5hdGVzIjogWyBbIFsgMTM3LjQwNTE2OTMwNiwgMzQuNzAyNjc0MTM5IF0sIFsgMTM3LjQwNTE3NzA4MzAwMDAxMiwgMzQuNzAyNjA3NjY3IF0sIFsgMTM3LjQwNTEzMDU4Mjk5OTk4OCwgMzQuNzAyNjAzODg5IF0sIFsgMTM3LjQwNTEyMjY5NCwgMzQuNzAyNjcwNDQ0IF0sIFsgMTM3LjQwNTE2OTMwNiwgMzQuNzAyNjc0MTM5IF0gXSBdIH0gfSwKeyAidHlwZSI6ICJGZWF0dXJlIiwgInByb3BlcnRpZXMiOiB7IH0sICJnZW9tZXRyeSI6IHsgInR5cGUiOiAiUG9seWdvbiIsICJjb29yZGluYXRlcyI6IFsgWyBbIDEzNy40MDU0NTkxOTQsIDM0LjcwMzE0NzU4MyBdLCBbIDEzNy40MDU0NTUzMzMsIDM0LjcwMzE3MDMwNiBdLCBbIDEzNy40MDU0OTQ1MjgsIDM0LjcwMzIxNDY2NyBdLCBbIDEzNy40MDU1MzY2OTQsIDM0LjcwMzIxOTQ3MiBdLCBbIDEzNy40MDU1NDY3NzgsIDM0LjcwMzE1NzEzOSBdLCBbIDEzNy40MDU0NTkxOTQsIDM0LjcwMzE0NzU4MyBdIF0gXSB9IH0sCnsgInR5cGUiOiAiRmVhdHVyZSIsICJwcm9wZXJ0aWVzIjogeyB9LCAiZ2VvbWV0cnkiOiB7ICJ0eXBlIjogIlBvbHlnb24iLCAiY29vcmRpbmF0ZXMiOiBbIFsgWyAxMzcuNDA1NDIyMjc4LCAzNC43MDI5OTQzMDYgXSwgWyAxMzcuNDA1NDE2NDE3LCAzNC43MDMwMzcxMzkgXSwgWyAxMzcuNDA1NTQyMzA2LCAzNC43MDMwNDg1MjggXSwgWyAxMzcuNDA1NTQ1NjExLCAzNC43MDMwMjQgXSwgWyAxMzcuNDA1NjQ0ODYxMDAwMDEzLCAzNC43MDMwMzQgXSwgWyAxMzcuNDA1NjUzOTcyMDAwMDEsIDM0LjcwMjk3MjY2NyBdLCBbIDEzNy40MDU1MDYzNjEsIDM0LjcwMjk1NzgwNiBdLCBbIDEzNy40MDU1MDkzMzMsIDM0LjcwMjkzNjYxMSBdLCBbIDEzNy40MDUyODY0NzIsIDM0LjcwMjkxNTEzOSBdLCBbIDEzNy40MDUyODM1ODMsIDM0LjcwMjkzNTQ0NCBdLCBbIDEzNy40MDUxMzgyNSwgMzQuNzAyOTIwODYxIF0sIFsgMTM3LjQwNTEyOTE2NzAwMDAxMywgMzQuNzAyOTgyMDgzIF0sIFsgMTM3LjQwNTIyNDM2MSwgMzQuNzAyOTkxNjM5IF0sIFsgMTM3LjQwNTIyMDYzOSwgMzQuNzAzMDE5Mzg5IF0sIFsgMTM3LjQwNTM0ODE2NywgMzQuNzAzMDMwOTcyIF0sIFsgMTM3LjQwNTM1NDE2NzAwMDAxMywgMzQuNzAyOTg3OTQ0IF0sIFsgMTM3LjQwNTQyMjI3OCwgMzQuNzAyOTk0MzA2IF0gXSBdIH0gfSwKeyAidHlwZSI6ICJGZWF0dXJlIiwgInByb3BlcnRpZXMiOiB7IH0sICJnZW9tZXRyeSI6IHsgInR5cGUiOiAiUG9seWdvbiIsICJjb29yZGluYXRlcyI6IFsgWyBbIDEzNy40MDUyNjgyNSwgMzQuNzAzMTM5NDcyIF0sIFsgMTM3LjQwNTI4NTUsIDM0LjcwMzE0MDgwNiBdLCBbIDEzNy40MDUyOTI4MzMsIDM0LjcwMzA3MzYxMSBdLCBbIDEzNy40MDUyNzU1ODMsIDM0LjcwMzA3MjMwNiBdLCBbIDEzNy40MDUyNjgyNSwgMzQuNzAzMTM5NDcyIF0gXSBdIH0gfSwKeyAidHlwZSI6ICJGZWF0dXJlIiwgInByb3BlcnRpZXMiOiB7IH0sICJnZW9tZXRyeSI6IHsgInR5cGUiOiAiUG9seWdvbiIsICJjb29yZGluYXRlcyI6IFsgWyBbIDEzNy40MDQ5Nzk5MTcsIDM0LjcwMjkzMjc3OCBdLCBbIDEzNy40MDQ5Nzc1NTYsIDM0LjcwMjk0NzMwNiBdLCBbIDEzNy40MDUwNjY2MzkwMDAwMTIsIDM0LjcwMjk1Njk0NCBdLCBbIDEzNy40MDUwNjg4ODksIDM0LjcwMjk0MjQ0NCBdLCBbIDEzNy40MDQ5Nzk5MTcsIDM0LjcwMjkzMjc3OCBdIF0gXSB9IH0sCnsgInR5cGUiOiAiRmVhdHVyZSIsICJwcm9wZXJ0aWVzIjogeyB9LCAiZ2VvbWV0cnkiOiB7ICJ0eXBlIjogIlBvbHlnb24iLCAiY29vcmRpbmF0ZXMiOiBbIFsgWyAxMzcuNDA1NDk5ODYxMDAwMDEsIDM0LjcwMjg2ODAyOCBdLCBbIDEzNy40MDU0OTc3MjIsIDM0LjcwMjg4NDI1IF0sIFsgMTM3LjQwNTU4MDYxMSwgMzQuNzAyODkxNSBdLCBbIDEzNy40MDU1ODI2Mzg5OTk5ODgsIDM0LjcwMjg3NTI1IF0sIFsgMTM3LjQwNTQ5OTg2MTAwMDAxLCAzNC43MDI4NjgwMjggXSBdIF0gfSB9LAp7ICJ0eXBlIjogIkZlYXR1cmUiLCAicHJvcGVydGllcyI6IHsgfSwgImdlb21ldHJ5IjogeyAidHlwZSI6ICJQb2x5Z29uIiwgImNvb3JkaW5hdGVzIjogWyBbIFsgMTM3LjQwNTI5ODYxMSwgMzQuNzAzMTQzMTExIF0sIFsgMTM3LjQwNTMyMDU1NiwgMzQuNzAzMTQ0Njk0IF0sIFsgMTM3LjQwNTMyOCwgMzQuNzAzMDc3MjUgXSwgWyAxMzcuNDA1MzA2MDU2LCAzNC43MDMwNzU1ODMgXSwgWyAxMzcuNDA1Mjk4NjExLCAzNC43MDMxNDMxMTEgXSBdIF0gfSB9LAp7ICJ0eXBlIjogIkZlYXR1cmUiLCAicHJvcGVydGllcyI6IHsgfSwgImdlb21ldHJ5IjogeyAidHlwZSI6ICJQb2x5Z29uIiwgImNvb3JkaW5hdGVzIjogWyBbIFsgMTM3LjQwNDk3NDIyMiwgMzQuNzAyOTY2NjExIF0sIFsgMTM3LjQwNDk3MjE5NDAwMDAxLCAzNC43MDI5ODM2MzkgXSwgWyAxMzcuNDA1MDU5MjIyLCAzNC43MDI5OTA3NzggXSwgWyAxMzcuNDA1MDYxMjIyLCAzNC43MDI5NzM3NSBdLCBbIDEzNy40MDQ5NzQyMjIsIDM0LjcwMjk2NjYxMSBdIF0gXSB9IH0sCnsgInR5cGUiOiAiRmVhdHVyZSIsICJwcm9wZXJ0aWVzIjogeyB9LCAiZ2VvbWV0cnkiOiB7ICJ0eXBlIjogIlBvbHlnb24iLCAiY29vcmRpbmF0ZXMiOiBbIFsgWyAxMzcuNDA1MzMxODg5LCAzNC43MDMxNDQwNTYgXSwgWyAxMzcuNDA1MzU1Njk0LCAzNC43MDMxNDYzMzMgXSwgWyAxMzcuNDA1MzY1LCAzNC43MDMwNzk5NzIgXSwgWyAxMzcuNDA1MzQxMTkzOTk5OTg4LCAzNC43MDMwNzc2NjcgXSwgWyAxMzcuNDA1MzMxODg5LCAzNC43MDMxNDQwNTYgXSBdIF0gfSB9LAp7ICJ0eXBlIjogIkZlYXR1cmUiLCAicHJvcGVydGllcyI6IHsgfSwgImdlb21ldHJ5IjogeyAidHlwZSI6ICJQb2x5Z29uIiwgImNvb3JkaW5hdGVzIjogWyBbIFsgMTM3LjQwNTQ5OTA1NiwgMzQuNzAyODU1NDE3IF0sIFsgMTM3LjQwNTU4NzM4OSwgMzQuNzAyODYyMDgzIF0sIFsgMTM3LjQwNTU4OTQxNjk5OTk4NywgMzQuNzAyODQzODg5IF0sIFsgMTM3LjQwNTUwMTA4MywgMzQuNzAyODM3MTk0IF0sIFsgMTM3LjQwNTQ5OTA1NiwgMzQuNzAyODU1NDE3IF0gXSBdIH0gfSwKeyAidHlwZSI6ICJGZWF0dXJlIiwgInByb3BlcnRpZXMiOiB7IH0sICJnZW9tZXRyeSI6IHsgInR5cGUiOiAiUG9seWdvbiIsICJjb29yZGluYXRlcyI6IFsgWyBbIDEzNy40MDUzNjU3NDk5OTk5ODcsIDM0LjcwMzE1MDc1IF0sIFsgMTM3LjQwNTM4OTY2NywgMzQuNzAzMTUyODYxIF0sIFsgMTM3LjQwNTM5ODc0OTk5OTk4OSwgMzQuNzAzMDgyNjk0IF0sIFsgMTM3LjQwNTM3NDcyMiwgMzQuNzAzMDgwNjY3IF0sIFsgMTM3LjQwNTM2NTc0OTk5OTk4NywgMzQuNzAzMTUwNzUgXSBdIF0gfSB9LAp7ICJ0eXBlIjogIkZlYXR1cmUiLCAicHJvcGVydGllcyI6IHsgfSwgImdlb21ldHJ5IjogeyAidHlwZSI6ICJQb2x5Z29uIiwgImNvb3JkaW5hdGVzIjogWyBbIFsgMTM3LjQwNTQ5NjgwNiwgMzQuNzAwODkyOTE3IF0sIFsgMTM3LjQwNTUwMjI1MDAwMDAxMiwgMzQuNzAwODUxNjExIF0sIFsgMTM3LjQwNTQ1OTAyOCwgMzQuNzAwODQ3NzIyIF0sIFsgMTM3LjQwNTQ1MzU4MywgMzQuNzAwODg5MDI4IF0sIFsgMTM3LjQwNTQ5NjgwNiwgMzQuNzAwODkyOTE3IF0gXSBdIH0gfSwKeyAidHlwZSI6ICJGZWF0dXJlIiwgInByb3BlcnRpZXMiOiB7IH0sICJnZW9tZXRyeSI6IHsgInR5cGUiOiAiUG9seWdvbiIsICJjb29yZGluYXRlcyI6IFsgWyBbIDEzNy40MDQ5ODQyNTAwMDAwMTIsIDM0LjcwMDk0NjI3OCBdLCBbIDEzNy40MDUwMDQwNTYsIDM0LjcwMDkyOTgzMyBdLCBbIDEzNy40MDQ5MzUwMjgwMDAwMTEsIDM0LjcwMDg3MyBdLCBbIDEzNy40MDQ5MTUxOTQwMDAwMTIsIDM0LjcwMDg4OTQ0NCBdLCBbIDEzNy40MDQ5ODQyNTAwMDAwMTIsIDM0LjcwMDk0NjI3OCBdIF0gXSB9IH0sCnsgInR5cGUiOiAiRmVhdHVyZSIsICJwcm9wZXJ0aWVzIjogeyB9LCAiZ2VvbWV0cnkiOiB7ICJ0eXBlIjogIlBvbHlnb24iLCAiY29vcmRpbmF0ZXMiOiBbIFsgWyAxMzcuNDA1Mzg3MDI4LCAzNC43MDA5MDM2NjcgXSwgWyAxMzcuNDA1NDM3Mzg5MDAwMDE0LCAzNC43MDA4MzU4NjEgXSwgWyAxMzcuNDA1NDEyNDQ0LCAzNC43MDA4MjMxOTQgXSwgWyAxMzcuNDA1MzYyMTEwOTk5OTg4LCAzNC43MDA4OTEgXSwgWyAxMzcuNDA1Mzg3MDI4LCAzNC43MDA5MDM2NjcgXSBdIF0gfSB9LAp7ICJ0eXBlIjogIkZlYXR1cmUiLCAicHJvcGVydGllcyI6IHsgfSwgImdlb21ldHJ5IjogeyAidHlwZSI6ICJQb2x5Z29uIiwgImNvb3JkaW5hdGVzIjogWyBbIFsgMTM3LjQwNjA4NDgwNiwgMzQuNzAzMTUzNjY3IF0sIFsgMTM3LjQwNjA5MTk3MjAwMDAxMywgMzQuNzAzMTAwNzIyIF0sIFsgMTM3LjQwNjA2NDg4OSwgMzQuNzAzMDk4MjUgXSwgWyAxMzcuNDA2MDU3ODMzLCAzNC43MDMxNTExOTQgXSwgWyAxMzcuNDA2MDg0ODA2LCAzNC43MDMxNTM2NjcgXSBdIF0gfSB9LAp7ICJ0eXBlIjogIkZlYXR1cmUiLCAicHJvcGVydGllcyI6IHsgfSwgImdlb21ldHJ5IjogeyAidHlwZSI6ICJQb2x5Z29uIiwgImNvb3JkaW5hdGVzIjogWyBbIFsgMTM3LjQwNjA0NzIyMjAwMDAxMiwgMzQuNzAzMjIwNjExIF0sIFsgMTM3LjQwNjA3NDc0OTk5OTk4OCwgMzQuNzAzMjIyODMzIF0sIFsgMTM3LjQwNjA4MTU4MywgMzQuNzAzMTY2Mjc4IF0sIFsgMTM3LjQwNjA1NDA1NTk5OTk4OCwgMzQuNzAzMTY0MDgzIF0sIFsgMTM3LjQwNjA0NzIyMjAwMDAxMiwgMzQuNzAzMjIwNjExIF0gXSBdIH0gfSwKeyAidHlwZSI6ICJGZWF0dXJlIiwgInByb3BlcnRpZXMiOiB7IH0sICJnZW9tZXRyeSI6IHsgInR5cGUiOiAiUG9seWdvbiIsICJjb29yZGluYXRlcyI6IFsgWyBbIDEzNy40MDYzNzYzNjEwMDAwMTQsIDM0LjcwMjM1NDA4MyBdLCBbIDEzNy40MDY0OTU0NzE5OTk5ODksIDM0LjcwMjM2MjM4OSBdLCBbIDEzNy40MDY1MDA2OTM5OTk5ODgsIDM0LjcwMjMxMjM2MSBdLCBbIDEzNy40MDYzODE0NzIsIDM0LjcwMjMwNDAyOCBdLCBbIDEzNy40MDYzNzYzNjEwMDAwMTQsIDM0LjcwMjM1NDA4MyBdIF0gXSB9IH0sCnsgInR5cGUiOiAiRmVhdHVyZSIsICJwcm9wZXJ0aWVzIjogeyB9LCAiZ2VvbWV0cnkiOiB7ICJ0eXBlIjogIlBvbHlnb24iLCAiY29vcmRpbmF0ZXMiOiBbIFsgWyAxMzcuNDA3MTA2MzA2LCAzNC43MDI2NTQxOTQgXSwgWyAxMzcuNDA3MTI2NTI4LCAzNC43MDI1MDkgXSwgWyAxMzcuNDA2ODU1ODMzLCAzNC43MDI0ODMyMjIgXSwgWyAxMzcuNDA2ODQyNjk0LCAzNC43MDI1NzcxNjcgXSwgWyAxMzcuNDA2OTE4MzYxMDAwMDEsIDM0LjcwMjU4NDMzMyBdLCBbIDEzNy40MDY5MTQ5NDQsIDM0LjcwMjYwOTEzOSBdLCBbIDEzNy40MDY5OTQ4NjA5OTk5ODcsIDM0LjcwMjYxNjcyMiBdLCBbIDEzNy40MDY5OTExMTEsIDM0LjcwMjY0MzEzOSBdLCBbIDEzNy40MDcxMDYzMDYsIDM0LjcwMjY1NDE5NCBdIF0gXSB9IH0sCnsgInR5cGUiOiAiRmVhdHVyZSIsICJwcm9wZXJ0aWVzIjogeyB9LCAiZ2VvbWV0cnkiOiB7ICJ0eXBlIjogIlBvbHlnb24iLCAiY29vcmRpbmF0ZXMiOiBbIFsgWyAxMzcuNDA2ODE5MzYxLCAzNC43MDIzOTc3MjIgXSwgWyAxMzcuNDA3MTk4MjUsIDM0LjcwMjQzNzgzMyBdLCBbIDEzNy40MDcyMTk2OTQsIDM0LjcwMjI5OTY2NyBdLCBbIDEzNy40MDY4MzAzMDU5OTk5ODksIDM0LjcwMjI1ODUyOCBdLCBbIDEzNy40MDY4MTkxNjcsIDM0LjcwMjMzMDM4OSBdLCBbIDEzNy40MDY4MDg4NjEsIDM0LjcwMjM5NjY2NyBdLCBbIDEzNy40MDY4MTkzNjEsIDM0LjcwMjM5NzcyMiBdIF0gXSB9IH0sCnsgInR5cGUiOiAiRmVhdHVyZSIsICJwcm9wZXJ0aWVzIjogeyB9LCAiZ2VvbWV0cnkiOiB7ICJ0eXBlIjogIlBvbHlnb24iLCAiY29vcmRpbmF0ZXMiOiBbIFsgWyAxMzcuNDA2NjUyNzc4LCAzNC43MDEyMjQzODkgXSwgWyAxMzcuNDA2NzQzOTQ0LCAzNC43MDEyMzMxMTEgXSwgWyAxMzcuNDA2NzU4ODA2LCAzNC43MDExMjgyNSBdLCBbIDEzNy40MDY2Njc2MzksIDM0LjcwMTExOTQxNyBdLCBbIDEzNy40MDY2NTI3NzgsIDM0LjcwMTIyNDM4OSBdIF0gXSB9IH0sCnsgInR5cGUiOiAiRmVhdHVyZSIsICJwcm9wZXJ0aWVzIjogeyB9LCAiZ2VvbWV0cnkiOiB7ICJ0eXBlIjogIlBvbHlnb24iLCAiY29vcmRpbmF0ZXMiOiBbIFsgWyAxMzcuNDA2NTUxOTE3LCAzNC43MDExMTMwNTYgXSwgWyAxMzcuNDA2MzIyMjc4LCAzNC43MDEwOTAyNSBdLCBbIDEzNy40MDYzMDc1MjgwMDAwMTMsIDM0LjcwMTE5MTMzMyBdLCBbIDEzNy40MDY1MzcyNTAwMDAwMTQsIDM0LjcwMTIxNDEzOSBdLCBbIDEzNy40MDY1NTE5MTcsIDM0LjcwMTExMzA1NiBdIF0gXSB9IH0sCnsgInR5cGUiOiAiRmVhdHVyZSIsICJwcm9wZXJ0aWVzIjogeyB9LCAiZ2VvbWV0cnkiOiB7ICJ0eXBlIjogIlBvbHlnb24iLCAiY29vcmRpbmF0ZXMiOiBbIFsgWyAxMzcuNDA3MjM2MTY3LCAzNC43MDE4NDIwMjggXSwgWyAxMzcuNDA2OTE1MTM5LCAzNC43MDE4MDk5NDQgXSwgWyAxMzcuNDA2ODk0ODg5LCAzNC43MDE5NDc3MjIgXSwgWyAxMzcuNDA3MjE1OTE3LCAzNC43MDE5Nzk5MTcgXSwgWyAxMzcuNDA3MjM2MTY3LCAzNC43MDE4NDIwMjggXSBdIF0gfSB9LAp7ICJ0eXBlIjogIkZlYXR1cmUiLCAicHJvcGVydGllcyI6IHsgfSwgImdlb21ldHJ5IjogeyAidHlwZSI6ICJQb2x5Z29uIiwgImNvb3JkaW5hdGVzIjogWyBbIFsgMTM3LjQwNjg3MDI1LCAzNC43MDAyMTcwNTYgXSwgWyAxMzcuNDA2ODY2OTQ0LCAzNC43MDAyNDMxOTQgXSwgWyAxMzcuNDA2OTMxMzYxLCAzNC43MDAyNDg2NjcgXSwgWyAxMzcuNDA2OTM0NjY3LCAzNC43MDAyMjI1IF0sIFsgMTM3LjQwNjg3MDI1LCAzNC43MDAyMTcwNTYgXSBdIF0gfSB9LAp7ICJ0eXBlIjogIkZlYXR1cmUiLCAicHJvcGVydGllcyI6IHsgfSwgImdlb21ldHJ5IjogeyAidHlwZSI6ICJQb2x5Z29uIiwgImNvb3JkaW5hdGVzIjogWyBbIFsgMTM3LjQwNjc4NzQ0NCwgMzQuNzAwNDE5Nzc4IF0sIFsgMTM3LjQwNjgwMDIyMTk5OTk4NywgMzQuNzAwMzUyNDE3IF0sIFsgMTM3LjQwNjc1NTEzOTAwMDAxMiwgMzQuNzAwMzQ2NTU2IF0sIFsgMTM3LjQwNjc0MjMzMzAwMDAxMSwgMzQuNzAwNDEzOTE3IF0sIFsgMTM3LjQwNjc4NzQ0NCwgMzQuNzAwNDE5Nzc4IF0gXSBdIH0gfSwKeyAidHlwZSI6ICJGZWF0dXJlIiwgInByb3BlcnRpZXMiOiB7IH0sICJnZW9tZXRyeSI6IHsgInR5cGUiOiAiUG9seWdvbiIsICJjb29yZGluYXRlcyI6IFsgWyBbIDEzNy40MDY4Mjg1ODMsIDM0LjcwMDA3MzI1IF0sIFsgMTM3LjQwNzAyNTQxNywgMzQuNzAwMDg3NDcyIF0sIFsgMTM3LjQwNzAzMjg2MSwgMzQuNzAwMDE3NSBdLCBbIDEzNy40MDY4MzYsIDM0LjcwMDAwMzI3OCBdLCBbIDEzNy40MDY4Mjg1ODMsIDM0LjcwMDA3MzI1IF0gXSBdIH0gfSwKeyAidHlwZSI6ICJGZWF0dXJlIiwgInByb3BlcnRpZXMiOiB7IH0sICJnZW9tZXRyeSI6IHsgInR5cGUiOiAiUG9seWdvbiIsICJjb29yZGluYXRlcyI6IFsgWyBbIDEzNy40MDY2NTUzMzMsIDM0LjcwMDQxNTE2NyBdLCBbIDEzNy40MDY2ODc0NzE5OTk5ODcsIDM0LjcwMDIwMDU1NiBdLCBbIDEzNy40MDY1NjY5MTcsIDM0LjcwMDE4ODI1IF0sIFsgMTM3LjQwNjUzNDY5Mzk5OTk4NywgMzQuNzAwNDAyNzc4IF0sIFsgMTM3LjQwNjY1NTMzMywgMzQuNzAwNDE1MTY3IF0gXSBdIH0gfSwKeyAidHlwZSI6ICJGZWF0dXJlIiwgInByb3BlcnRpZXMiOiB7IH0sICJnZW9tZXRyeSI6IHsgInR5cGUiOiAiUG9seWdvbiIsICJjb29yZGluYXRlcyI6IFsgWyBbIDEzNy40MDY0Njg4MzMsIDM0LjcwMDg0ODA4MyBdLCBbIDEzNy40MDY0NDIxOTQsIDM0LjcwMDg0NDk3MiBdLCBbIDEzNy40MDY0Mzc5MTcsIDM0LjcwMDg2OTY5NCBdLCBbIDEzNy40MDY0NjQ1NTYsIDM0LjcwMDg3Mjg4OSBdLCBbIDEzNy40MDY0Njg4MzMsIDM0LjcwMDg0ODA4MyBdIF0gXSB9IH0sCnsgInR5cGUiOiAiRmVhdHVyZSIsICJwcm9wZXJ0aWVzIjogeyB9LCAiZ2VvbWV0cnkiOiB7ICJ0eXBlIjogIlBvbHlnb24iLCAiY29vcmRpbmF0ZXMiOiBbIFsgWyAxMzcuNDA2Mzg2ODMzLCAzNC43MDA4NDAzMDYgXSwgWyAxMzcuNDA2MzgzMTk0LCAzNC43MDA4NjM4NjEgXSwgWyAxMzcuNDA2NDE1NDE3LCAzNC43MDA4NjczMDYgXSwgWyAxMzcuNDA2NDE5MTY3LCAzNC43MDA4NDM3NzggXSwgWyAxMzcuNDA2Mzg2ODMzLCAzNC43MDA4NDAzMDYgXSBdIF0gfSB9LAp7ICJ0eXBlIjogIkZlYXR1cmUiLCAicHJvcGVydGllcyI6IHsgfSwgImdlb21ldHJ5IjogeyAidHlwZSI6ICJQb2x5Z29uIiwgImNvb3JkaW5hdGVzIjogWyBbIFsgMTM3LjQwNjc1NzMwNiwgMzQuNzAwNjQ1NzUgXSwgWyAxMzcuNDA2Nzg5OTQ0LCAzNC43MDA2NDc2NjcgXSwgWyAxMzcuNDA2NzkzNzUsIDM0LjcwMDYwMTg4OSBdLCBbIDEzNy40MDY3NjExMTEsIDM0LjcwMDYwMDA1NiBdLCBbIDEzNy40MDY3NTczMDYsIDM0LjcwMDY0NTc1IF0gXSBdIH0gfSwKeyAidHlwZSI6ICJGZWF0dXJlIiwgInByb3BlcnRpZXMiOiB7IH0sICJnZW9tZXRyeSI6IHsgInR5cGUiOiAiUG9seWdvbiIsICJjb29yZGluYXRlcyI6IFsgWyBbIDEzNy40MDY4MTM5NDQsIDM0LjcwMDUyODA4MyBdLCBbIDEzNy40MDY4MTgwMjgsIDM0LjcwMDUwNDcyMiBdLCBbIDEzNy40MDY4MTM4ODksIDM0LjcwMDUwNDE5NCBdLCBbIDEzNy40MDY3ODk1MjgsIDM0LjcwMDUwMTM2MSBdLCBbIDEzNy40MDY3NzM4NjEsIDM0LjcwMDU5MTA4MyBdLCBbIDEzNy40MDY4MDIzNjEsIDM0LjcwMDU5NDU1NiBdLCBbIDEzNy40MDY4MTM5NDQsIDM0LjcwMDUyODA4MyBdIF0gXSB9IH0sCnsgInR5cGUiOiAiRmVhdHVyZSIsICJwcm9wZXJ0aWVzIjogeyB9LCAiZ2VvbWV0cnkiOiB7ICJ0eXBlIjogIlBvbHlnb24iLCAiY29vcmRpbmF0ZXMiOiBbIFsgWyAxMzcuNDA2NzY5MzA2LCAzNC43MDA4MzQxNjcgXSwgWyAxMzcuNDA2Nzg4NDE3LCAzNC43MDA3MTk0NDQgXSwgWyAxMzcuNDA2NzU1LCAzNC43MDA3MTU2MzkgXSwgWyAxMzcuNDA2NzM1OTE3LCAzNC43MDA4MzAzMzMgXSwgWyAxMzcuNDA2NzY5MzA2LCAzNC43MDA4MzQxNjcgXSBdIF0gfSB9LAp7ICJ0eXBlIjogIkZlYXR1cmUiLCAicHJvcGVydGllcyI6IHsgfSwgImdlb21ldHJ5IjogeyAidHlwZSI6ICJQb2x5Z29uIiwgImNvb3JkaW5hdGVzIjogWyBbIFsgMTM3LjQwNzY4MzYzOSwgMzQuNzAyMzQyODMzIF0sIFsgMTM3LjQwNzY3NywgMzQuNzAyMzg1OTQ0IF0sIFsgMTM3LjQwNzY3MTg2MTAwMDAxMSwgMzQuNzAyNDIwMTExIF0sIFsgMTM3LjQwNzY2NzY2NywgMzQuNzAyNDQ3MDgzIF0sIFsgMTM3LjQwNzg5NzYzOSwgMzQuNzAyNDcwOTcyIF0sIFsgMTM3LjQwNzkxMzQ3MiwgMzQuNzAyMzY2ODA2IF0sIFsgMTM3LjQwNzY4MzYzOSwgMzQuNzAyMzQyODMzIF0gXSBdIH0gfSwKeyAidHlwZSI6ICJGZWF0dXJlIiwgInByb3BlcnRpZXMiOiB7IH0sICJnZW9tZXRyeSI6IHsgInR5cGUiOiAiUG9seWdvbiIsICJjb29yZGluYXRlcyI6IFsgWyBbIDEzNy40MDc5OTY5NzIsIDM0LjcwMzE0NiBdLCBbIDEzNy40MDgwMjY1ODMsIDM0LjcwMjk2ODYxMSBdLCBbIDEzNy40MDc5OTkzODksIDM0LjcwMjk2NTUyOCBdLCBbIDEzNy40MDc5Njk3NzgsIDM0LjcwMzE0MyBdLCBbIDEzNy40MDc5OTY5NzIsIDM0LjcwMzE0NiBdIF0gXSB9IH0sCnsgInR5cGUiOiAiRmVhdHVyZSIsICJwcm9wZXJ0aWVzIjogeyB9LCAiZ2VvbWV0cnkiOiB7ICJ0eXBlIjogIlBvbHlnb24iLCAiY29vcmRpbmF0ZXMiOiBbIFsgWyAxMzcuNDA4MDQ4MDU2MDAwMDEzLCAzNC43MDMxNDk0MTcgXSwgWyAxMzcuNDA4MDc2NDcyLCAzNC43MDI5NzIyMjIgXSwgWyAxMzcuNDA4MDQ3MzA1OTk5OTg2LCAzNC43MDI5NjkwMjggXSwgWyAxMzcuNDA4MDE4OTE3LCAzNC43MDMxNDYyMjIgXSwgWyAxMzcuNDA4MDQ4MDU2MDAwMDEzLCAzNC43MDMxNDk0MTcgXSBdIF0gfSB9LAp7ICJ0eXBlIjogIkZlYXR1cmUiLCAicHJvcGVydGllcyI6IHsgfSwgImdlb21ldHJ5IjogeyAidHlwZSI6ICJQb2x5Z29uIiwgImNvb3JkaW5hdGVzIjogWyBbIFsgMTM3LjQwNzY3MTg2MTAwMDAxMSwgMzQuNzAyNDIwMTExIF0sIFsgMTM3LjQwNzY3NywgMzQuNzAyMzg1OTQ0IF0sIFsgMTM3LjQwNzYzNjkxNywgMzQuNzAyMzgyMDU2IF0sIFsgMTM3LjQwNzYzODUsIDM0LjcwMjM2NDExMSBdLCBbIDEzNy40MDc1OTk3NSwgMzQuNzAyMzYxNDcyIF0sIFsgMTM3LjQwNzU5NzUsIDM0LjcwMjM3NjcyMiBdLCBbIDEzNy40MDc1NTY0NDQsIDM0LjcwMjM3MzQ3MiBdLCBbIDEzNy40MDc1NTA1MjgsIDM0LjcwMjQwODE5NCBdLCBbIDEzNy40MDc1OTM1NTYsIDM0LjcwMjQxMjUyOCBdLCBbIDEzNy40MDc1ODY0MTcsIDM0LjcwMjQ3MTA1NiBdLCBbIDEzNy40MDc2MTAzMzMsIDM0LjcwMjQ3MzQ0NCBdLCBbIDEzNy40MDc2MTgyNTAwMDAwMTMsIDM0LjcwMjQxNTYzOSBdLCBbIDEzNy40MDc2NzE4NjEwMDAwMTEsIDM0LjcwMjQyMDExMSBdIF0gXSB9IH0sCnsgInR5cGUiOiAiRmVhdHVyZSIsICJwcm9wZXJ0aWVzIjogeyB9LCAiZ2VvbWV0cnkiOiB7ICJ0eXBlIjogIlBvbHlnb24iLCAiY29vcmRpbmF0ZXMiOiBbIFsgWyAxMzcuNDA3NTc3NTgzLCAzNC43MDIwNjIyMjIgXSwgWyAxMzcuNDA3NTgwMzYwOTk5OTg3LCAzNC43MDIwNDI1NTYgXSwgWyAxMzcuNDA3NzU2Mjc4LCAzNC43MDIwNTkzMzMgXSwgWyAxMzcuNDA3NzUzMTY3MDAwMDEsIDM0LjcwMjA3OTU1NiBdLCBbIDEzNy40MDc1Nzc1ODMsIDM0LjcwMjA2MjIyMiBdIF0gXSB9IH0sCnsgInR5cGUiOiAiRmVhdHVyZSIsICJwcm9wZXJ0aWVzIjogeyB9LCAiZ2VvbWV0cnkiOiB7ICJ0eXBlIjogIlBvbHlnb24iLCAiY29vcmRpbmF0ZXMiOiBbIFsgWyAxMzcuNDA4MDcxNTU2MDAwMDEsIDM0LjcwMTI4Mzc3OCBdLCBbIDEzNy40MDc5OTE4NjEsIDM0LjcwMTI3NTYzOSBdLCBbIDEzNy40MDc5NjUyMjIsIDM0LjcwMTI3MjkxNyBdLCBbIDEzNy40MDc4ODc4MDYsIDM0LjcwMTI2NDk0NCBdLCBbIDEzNy40MDc4NDM1ODI5OTk5ODgsIDM0LjcwMTU1OTI3OCBdLCBbIDEzNy40MDgwMjc0NDQsIDM0LjcwMTU3ODAyOCBdLCBbIDEzNy40MDgwNzE1NTYwMDAwMSwgMzQuNzAxMjgzNzc4IF0gXSBdIH0gfSwKeyAidHlwZSI6ICJGZWF0dXJlIiwgInByb3BlcnRpZXMiOiB7IH0sICJnZW9tZXRyeSI6IHsgInR5cGUiOiAiUG9seWdvbiIsICJjb29yZGluYXRlcyI6IFsgWyBbIDEzNy40MDgwMDQzODkwMDAwMTMsIDM0LjcwMTcxNDU1NiBdLCBbIDEzNy40MDgwMTU4MDYsIDM0LjcwMTYzMDk3MiBdLCBbIDEzNy40MDc5NTIxNjcsIDM0LjcwMTYyNTA1NiBdLCBbIDEzNy40MDc5NTY5NzIsIDM0LjcwMTU4OTgwNiBdLCBbIDEzNy40MDc2OTYxMTEsIDM0LjcwMTU2NTYxMSBdLCBbIDEzNy40MDc2NzQ4MzI5OTk5ODcsIDM0LjcwMTcxNTIyMiBdLCBbIDEzNy40MDc2NjgzODksIDM0LjcwMTc1NCBdLCBbIDEzNy40MDc5OTMyMjE5OTk5ODgsIDM0LjcwMTc3OTk0NCBdLCBbIDEzNy40MDgwMDQzODkwMDAwMTMsIDM0LjcwMTcxNDU1NiBdIF0gXSB9IH0sCnsgInR5cGUiOiAiRmVhdHVyZSIsICJwcm9wZXJ0aWVzIjogeyB9LCAiZ2VvbWV0cnkiOiB7ICJ0eXBlIjogIlBvbHlnb24iLCAiY29vcmRpbmF0ZXMiOiBbIFsgWyAxMzcuNDA4MDk5MzA2LCAzNC43MDExMDIwODMgXSwgWyAxMzcuNDA3ODI3MTk0LCAzNC43MDEwNzMzMDYgXSwgWyAxMzcuNDA3NjM0NTgzLCAzNC43MDEwNTI5NDQgXSwgWyAxMzcuNDA3NjE0Nzc4MDAwMDEsIDM0LjcwMTE4MDYzOSBdLCBbIDEzNy40MDc5NzU0MTY5OTk5ODksIDM0LjcwMTIxODc3OCBdLCBbIDEzNy40MDgwMDIwODMwMDAwMTQsIDM0LjcwMTIyMTUyOCBdLCBbIDEzNy40MDgwNzk1MDAwMDAwMTQsIDM0LjcwMTIyOTc3OCBdLCBbIDEzNy40MDgwOTkzMDYsIDM0LjcwMTEwMjA4MyBdIF0gXSB9IH0sCnsgInR5cGUiOiAiRmVhdHVyZSIsICJwcm9wZXJ0aWVzIjogeyB9LCAiZ2VvbWV0cnkiOiB7ICJ0eXBlIjogIlBvbHlnb24iLCAiY29vcmRpbmF0ZXMiOiBbIFsgWyAxMzcuNDA4MDAyMDgzMDAwMDE0LCAzNC43MDEyMjE1MjggXSwgWyAxMzcuNDA3OTc1NDE2OTk5OTg5LCAzNC43MDEyMTg3NzggXSwgWyAxMzcuNDA3OTY1MjIyLCAzNC43MDEyNzI5MTcgXSwgWyAxMzcuNDA3OTkxODYxLCAzNC43MDEyNzU2MzkgXSwgWyAxMzcuNDA4MDAyMDgzMDAwMDE0LCAzNC43MDEyMjE1MjggXSBdIF0gfSB9LAp7ICJ0eXBlIjogIkZlYXR1cmUiLCAicHJvcGVydGllcyI6IHsgfSwgImdlb21ldHJ5IjogeyAidHlwZSI6ICJQb2x5Z29uIiwgImNvb3JkaW5hdGVzIjogWyBbIFsgMTM3LjQwODMwOTY2NywgMzQuNzAxNTU0MjIyIF0sIFsgMTM3LjQwODI2NjYzOSwgMzQuNzAxNTQ5ODA2IF0sIFsgMTM3LjQwODI1NjQ3MiwgMzQuNzAxNjE1OTcyIF0sIFsgMTM3LjQwODI5OTUsIDM0LjcwMTYyMDIyMiBdLCBbIDEzNy40MDgzMDk2NjcsIDM0LjcwMTU1NDIyMiBdIF0gXSB9IH0sCnsgInR5cGUiOiAiRmVhdHVyZSIsICJwcm9wZXJ0aWVzIjogeyB9LCAiZ2VvbWV0cnkiOiB7ICJ0eXBlIjogIlBvbHlnb24iLCAiY29vcmRpbmF0ZXMiOiBbIFsgWyAxMzcuNDA4NzQyMTY3MDAwMDE0LCAzNC43MDE3MTMxMTEgXSwgWyAxMzcuNDA4NzQ3NSwgMzQuNzAxNjY1Nzc4IF0sIFsgMTM3LjQwODU3NTk3MiwgMzQuNzAxNjUyNjY3IF0sIFsgMTM3LjQwODU3MDMzMywgMzQuNzAxNzAyNDQ0IF0sIFsgMTM3LjQwODU2OTE2NywgMzQuNzAxNzEzNDQ0IF0sIFsgMTM3LjQwODU2MzcyMiwgMzQuNzAxNzYxNjExIF0sIFsgMTM3LjQwODU2MTgzMywgMzQuNzAxNzc5Mjc4IF0sIFsgMTM3LjQwODczMzI1MDAwMDAxMiwgMzQuNzAxNzkyMzYxIF0sIFsgMTM3LjQwODczODY2NywgMzQuNzAxNzQ0MTExIF0sIFsgMTM3LjQwODc0MjE2NzAwMDAxNCwgMzQuNzAxNzEzMTExIF0gXSBdIH0gfSwKeyAidHlwZSI6ICJGZWF0dXJlIiwgInByb3BlcnRpZXMiOiB7IH0sICJnZW9tZXRyeSI6IHsgInR5cGUiOiAiUG9seWdvbiIsICJjb29yZGluYXRlcyI6IFsgWyBbIDEzNy40MDg2OTQ2MTA5OTk5ODcsIDM0LjcwMTI2ODAyOCBdLCBbIDEzNy40MDg2NjQzNjEsIDM0LjcwMTI2NDM4OSBdLCBbIDEzNy40MDg2NTc5MTcsIDM0LjcwMTMwMTExMSBdLCBbIDEzNy40MDg2ODgzNjEsIDM0LjcwMTMwMzY2NyBdLCBbIDEzNy40MDg2OTQ2MTA5OTk5ODcsIDM0LjcwMTI2ODAyOCBdIF0gXSB9IH0sCnsgInR5cGUiOiAiRmVhdHVyZSIsICJwcm9wZXJ0aWVzIjogeyB9LCAiZ2VvbWV0cnkiOiB7ICJ0eXBlIjogIlBvbHlnb24iLCAiY29vcmRpbmF0ZXMiOiBbIFsgWyAxMzcuNDA4NTY5MTY3LCAzNC43MDE3MTM0NDQgXSwgWyAxMzcuNDA4NTcwMzMzLCAzNC43MDE3MDI0NDQgXSwgWyAxMzcuNDA4NTM2Njk0LCAzNC43MDE2OTkxNjcgXSwgWyAxMzcuNDA4NTM0NjY3LCAzNC43MDE3MTM1MjggXSwgWyAxMzcuNDA4NTI4MTM5LCAzNC43MDE3NTg4ODkgXSwgWyAxMzcuNDA4NTYzNzIyLCAzNC43MDE3NjE2MTEgXSwgWyAxMzcuNDA4NTY5MTY3LCAzNC43MDE3MTM0NDQgXSBdIF0gfSB9LAp7ICJ0eXBlIjogIkZlYXR1cmUiLCAicHJvcGVydGllcyI6IHsgfSwgImdlb21ldHJ5IjogeyAidHlwZSI6ICJQb2x5Z29uIiwgImNvb3JkaW5hdGVzIjogWyBbIFsgMTM3LjQwNzYwOTg2MSwgMzQuNjk5OTc2ODYxIF0sIFsgMTM3LjQwNzYxNjgwNiwgMzQuNjk5OTI2NTU2IF0sIFsgMTM3LjQwNzQ5MywgMzQuNjk5OTE0OTcyIF0sIFsgMTM3LjQwNzQ4NjA1NjAwMDAxLCAzNC42OTk5NjUyMjIgXSwgWyAxMzcuNDA3NjA5ODYxLCAzNC42OTk5NzY4NjEgXSBdIF0gfSB9LAp7ICJ0eXBlIjogIkZlYXR1cmUiLCAicHJvcGVydGllcyI6IHsgfSwgImdlb21ldHJ5IjogeyAidHlwZSI6ICJQb2x5Z29uIiwgImNvb3JkaW5hdGVzIjogWyBbIFsgMTM3LjQwNzkwNDA4MywgMzQuNzAwODU1NDQ0IF0sIFsgMTM3LjQwNzkyNDExMSwgMzQuNzAwNzI0MTM5IF0sIFsgMTM3LjQwNzkwNjc1LCAzNC43MDA3MjIyNzggXSwgWyAxMzcuNDA3ODg2NzIyLCAzNC43MDA4NTM1ODMgXSwgWyAxMzcuNDA3OTA0MDgzLCAzNC43MDA4NTU0NDQgXSBdIF0gfSB9LAp7ICJ0eXBlIjogIkZlYXR1cmUiLCAicHJvcGVydGllcyI6IHsgfSwgImdlb21ldHJ5IjogeyAidHlwZSI6ICJQb2x5Z29uIiwgImNvb3JkaW5hdGVzIjogWyBbIFsgMTM3LjQwODMwMDM2MDk5OTk4OCwgMzQuNzAwNzYxMzYxIF0sIFsgMTM3LjQwODI1OTc1MDAwMDAxMywgMzQuNzAwNzU3Mjc4IF0sIFsgMTM3LjQwODI0MDUsIDM0LjcwMDg4OTMwNiBdLCBbIDEzNy40MDgyODEyMjIsIDM0LjcwMDg5MzI3OCBdLCBbIDEzNy40MDgzMDAzNjA5OTk5ODgsIDM0LjcwMDc2MTM2MSBdIF0gXSB9IH0sCnsgInR5cGUiOiAiRmVhdHVyZSIsICJwcm9wZXJ0aWVzIjogeyB9LCAiZ2VvbWV0cnkiOiB7ICJ0eXBlIjogIlBvbHlnb24iLCAiY29vcmRpbmF0ZXMiOiBbIFsgWyAxMzcuNDA4MjMxMDI3OTk5OTg5LCAzNC43MDA3NTIzMDYgXSwgWyAxMzcuNDA4MTkwNDE2OTk5OTg2LCAzNC43MDA3NDgzMDYgXSwgWyAxMzcuNDA4MTcxMTM5LCAzNC43MDA4ODAyNSBdLCBbIDEzNy40MDgyMTE4ODksIDM0LjcwMDg4NDMwNiBdLCBbIDEzNy40MDgyMzEwMjc5OTk5ODksIDM0LjcwMDc1MjMwNiBdIF0gXSB9IH0sCnsgInR5cGUiOiAiRmVhdHVyZSIsICJwcm9wZXJ0aWVzIjogeyB9LCAiZ2VvbWV0cnkiOiB7ICJ0eXBlIjogIlBvbHlnb24iLCAiY29vcmRpbmF0ZXMiOiBbIFsgWyAxMzcuNDA3OTkwMDU1OTk5OTg4LCAzNC43MDA3MzEwNTYgXSwgWyAxMzcuNDA3OTQ5MzMzLCAzNC43MDA3MjY5NzIgXSwgWyAxMzcuNDA3OTMwMTY2OTk5OTg5LCAzNC43MDA4NTkgXSwgWyAxMzcuNDA3OTcwOTE3LCAzNC43MDA4NjI5NzIgXSwgWyAxMzcuNDA3OTkwMDU1OTk5OTg4LCAzNC43MDA3MzEwNTYgXSBdIF0gfSB9LAp7ICJ0eXBlIjogIkZlYXR1cmUiLCAicHJvcGVydGllcyI6IHsgfSwgImdlb21ldHJ5IjogeyAidHlwZSI6ICJQb2x5Z29uIiwgImNvb3JkaW5hdGVzIjogWyBbIFsgMTM3LjQwODEzNDcyMiwgMzQuNzAwNzQzMzg5IF0sIFsgMTM3LjQwODA5NCwgMzQuNzAwNzM5MzA2IF0sIFsgMTM3LjQwODA3NDc1LCAzNC43MDA4NzEzMzMgXSwgWyAxMzcuNDA4MTE1NDcyLCAzNC43MDA4NzUzODkgXSwgWyAxMzcuNDA4MTM0NzIyLCAzNC43MDA3NDMzODkgXSBdIF0gfSB9LAp7ICJ0eXBlIjogIkZlYXR1cmUiLCAicHJvcGVydGllcyI6IHsgfSwgImdlb21ldHJ5IjogeyAidHlwZSI6ICJQb2x5Z29uIiwgImNvb3JkaW5hdGVzIjogWyBbIFsgMTM3LjQwODA2MzYzOSwgMzQuNzAwNzM0NDE3IF0sIFsgMTM3LjQwODAyMjkxNzAwMDAxMSwgMzQuNzAwNzMwMzMzIF0sIFsgMTM3LjQwODAwMzc1LCAzNC43MDA4NjIzNjEgXSwgWyAxMzcuNDA4MDQ0NDcyLCAzNC43MDA4NjY0NDQgXSwgWyAxMzcuNDA4MDYzNjM5LCAzNC43MDA3MzQ0MTcgXSBdIF0gfSB9LAp7ICJ0eXBlIjogIkZlYXR1cmUiLCAicHJvcGVydGllcyI6IHsgfSwgImdlb21ldHJ5IjogeyAidHlwZSI6ICJQb2x5Z29uIiwgImNvb3JkaW5hdGVzIjogWyBbIFsgMTM3LjQwNzY2NjQ0NCwgMzQuNzAwMTQyMzYxIF0sIFsgMTM3LjQwNzY4MDAyNzk5OTk4NywgMzQuNzAwMDQzODA2IF0sIFsgMTM3LjQwNzUyNjA4MywgMzQuNzAwMDI5MzMzIF0sIFsgMTM3LjQwNzUxMjM4OSwgMzQuNzAwMTI3ODA2IF0sIFsgMTM3LjQwNzY2NjQ0NCwgMzQuNzAwMTQyMzYxIF0gXSBdIH0gfSwKeyAidHlwZSI6ICJGZWF0dXJlIiwgInByb3BlcnRpZXMiOiB7IH0sICJnZW9tZXRyeSI6IHsgInR5cGUiOiAiUG9seWdvbiIsICJjb29yZGluYXRlcyI6IFsgWyBbIDEzNy40MDg1NjA4ODksIDM0LjcwMDc4NjgwNiBdLCBbIDEzNy40MDg1Mzg4MzMsIDM0LjcwMDc4NDc3OCBdLCBbIDEzNy40MDg1MjA1NTYwMDAwMTMsIDM0LjcwMDkxODEzOSBdLCBbIDEzNy40MDg1NDI1MDAwMDAwMSwgMzQuNzAwOTIwMTY3IF0sIFsgMTM3LjQwODU2MDg4OSwgMzQuNzAwNzg2ODA2IF0gXSBdIH0gfSwKeyAidHlwZSI6ICJGZWF0dXJlIiwgInByb3BlcnRpZXMiOiB7IH0sICJnZW9tZXRyeSI6IHsgInR5cGUiOiAiUG9seWdvbiIsICJjb29yZGluYXRlcyI6IFsgWyBbIDEzNy40MDg0Mzk5MTcwMDAwMSwgMzQuNzAwNzc1Nzc4IF0sIFsgMTM3LjQwODQwMDgzMywgMzQuNzAwNzcyMjUgXSwgWyAxMzcuNDA4MzgzNDE3MDAwMDEsIDM0LjcwMDkwMjA4MyBdLCBbIDEzNy40MDg0MjIzODksIDM0LjcwMDkwNTcyMiBdLCBbIDEzNy40MDg0Mzk5MTcwMDAwMSwgMzQuNzAwNzc1Nzc4IF0gXSBdIH0gfSwKeyAidHlwZSI6ICJGZWF0dXJlIiwgInByb3BlcnRpZXMiOiB7IH0sICJnZW9tZXRyeSI6IHsgInR5cGUiOiAiUG9seWdvbiIsICJjb29yZGluYXRlcyI6IFsgWyBbIDEzNy40MDg1MTI2MzksIDM0LjcwMDc4MjY2NyBdLCBbIDEzNy40MDg0NzE5MTcwMDAwMTQsIDM0LjcwMDc3ODY2NyBdLCBbIDEzNy40MDg0NTI3NSwgMzQuNzAwOTEwNjExIF0sIFsgMTM3LjQwODQ5MzQ3MiwgMzQuNzAwOTE0NjY3IF0sIFsgMTM3LjQwODUxMjYzOSwgMzQuNzAwNzgyNjY3IF0gXSBdIH0gfSwKeyAidHlwZSI6ICJGZWF0dXJlIiwgInByb3BlcnRpZXMiOiB7IH0sICJnZW9tZXRyeSI6IHsgInR5cGUiOiAiUG9seWdvbiIsICJjb29yZGluYXRlcyI6IFsgWyBbIDEzNy40MDk5MjcwODMwMDAwMTQsIDM0LjcwMzMwOTMwNiBdLCBbIDEzNy40MDk3MzM4MDYsIDM0LjcwMzI5MDUgXSwgWyAxMzcuNDA5NzE5NTgzLCAzNC43MDMzOTAxMzkgXSwgWyAxMzcuNDA5Nzc1MTY3LCAzNC43MDMzOTU1MjggXSwgWyAxMzcuNDA5NzczNTU2LCAzNC43MDM0MDczMzMgXSwgWyAxMzcuNDA5ODUxNjM5MDAwMDEsIDM0LjcwMzQxNDk0NCBdLCBbIDEzNy40MDk4NDgyMjIsIDM0LjcwMzQzOTE5NCBdLCBbIDEzNy40MDk5MDc3MjIwMDAwMTQsIDM0LjcwMzQ0NTAyOCBdLCBbIDEzNy40MDk5MjcwODMwMDAwMTQsIDM0LjcwMzMwOTMwNiBdIF0gXSB9IH0sCnsgInR5cGUiOiAiRmVhdHVyZSIsICJwcm9wZXJ0aWVzIjogeyB9LCAiZ2VvbWV0cnkiOiB7ICJ0eXBlIjogIlBvbHlnb24iLCAiY29vcmRpbmF0ZXMiOiBbIFsgWyAxMzcuNDA5OTE2Mjc4LCAzNC43MDMwMTIyNzggXSwgWyAxMzcuNDA5OTQ4ODA1OTk5OTg5LCAzNC43MDMwMTUyNzggXSwgWyAxMzcuNDA5OTUyMjIxOTk5OTg3LCAzNC43MDI5ODkyMjIgXSwgWyAxMzcuNDA5OTE5Njk0LCAzNC43MDI5ODYzMDYgXSwgWyAxMzcuNDA5OTE2Mjc4LCAzNC43MDMwMTIyNzggXSBdIF0gfSB9LAp7ICJ0eXBlIjogIkZlYXR1cmUiLCAicHJvcGVydGllcyI6IHsgfSwgImdlb21ldHJ5IjogeyAidHlwZSI6ICJQb2x5Z29uIiwgImNvb3JkaW5hdGVzIjogWyBbIFsgMTM3LjQwOTk3MTc1MDAwMDAxMSwgMzQuNzAzMDE3Mzg5IF0sIFsgMTM3LjQxMDAwNDUwMDAwMDAxNCwgMzQuNzAzMDE5MzA2IF0sIFsgMTM3LjQxMDAwNjgzMzAwMDAxMSwgMzQuNzAyOTkyODg5IF0sIFsgMTM3LjQwOTk3Mzk3MTk5OTk4OSwgMzQuNzAyOTkwOTcyIF0sIFsgMTM3LjQwOTk3MTc1MDAwMDAxMSwgMzQuNzAzMDE3Mzg5IF0gXSBdIH0gfSwKeyAidHlwZSI6ICJGZWF0dXJlIiwgInByb3BlcnRpZXMiOiB7IH0sICJnZW9tZXRyeSI6IHsgInR5cGUiOiAiUG9seWdvbiIsICJjb29yZGluYXRlcyI6IFsgWyBbIDEzNy40MDk4Nzk2OTQwMDAwMTEsIDM0LjcwMzAwODY2NyBdLCBbIDEzNy40MDk5MTI1NTYsIDM0LjcwMzAxMTgzMyBdLCBbIDEzNy40MDk5MTY3NSwgMzQuNzAyOTgyODg5IF0sIFsgMTM3LjQwOTg4Mzg2MSwgMzQuNzAyOTc5NzIyIF0sIFsgMTM3LjQwOTg3OTY5NDAwMDAxMSwgMzQuNzAzMDA4NjY3IF0gXSBdIH0gfSwKeyAidHlwZSI6ICJGZWF0dXJlIiwgInByb3BlcnRpZXMiOiB7IH0sICJnZW9tZXRyeSI6IHsgInR5cGUiOiAiUG9seWdvbiIsICJjb29yZGluYXRlcyI6IFsgWyBbIDEzNy40MDk4MjI5NDQwMDAwMTMsIDM0LjcwMjkzNTMwNiBdLCBbIDEzNy40MDk4MTc4MDYsIDM0LjcwMjk2ODIyMiBdLCBbIDEzNy40MDk4NjUxOTQsIDM0LjcwMjk3MzM2MSBdLCBbIDEzNy40MDk4NzAzMzI5OTk5ODYsIDM0LjcwMjk0MDMzMyBdLCBbIDEzNy40MDk4MjI5NDQwMDAwMTMsIDM0LjcwMjkzNTMwNiBdIF0gXSB9IH0sCnsgInR5cGUiOiAiRmVhdHVyZSIsICJwcm9wZXJ0aWVzIjogeyB9LCAiZ2VvbWV0cnkiOiB7ICJ0eXBlIjogIlBvbHlnb24iLCAiY29vcmRpbmF0ZXMiOiBbIFsgWyAxMzcuNDA5NzA2NjM5LCAzNC43MDI4NDEzMzMgXSwgWyAxMzcuNDA5NzE2MTk0LCAzNC43MDI3OTQ2OTQgXSwgWyAxMzcuNDA5NjczODMzLCAzNC43MDI3ODg3NSBdLCBbIDEzNy40MDk2NjQyNSwgMzQuNzAyODM1MzYxIF0sIFsgMTM3LjQwOTcwNjYzOSwgMzQuNzAyODQxMzMzIF0gXSBdIH0gfSwKeyAidHlwZSI6ICJGZWF0dXJlIiwgInByb3BlcnRpZXMiOiB7IH0sICJnZW9tZXRyeSI6IHsgInR5cGUiOiAiUG9seWdvbiIsICJjb29yZGluYXRlcyI6IFsgWyBbIDEzNy40MDYxNDI0MDAzMDAwMTMsIDM0LjcwMzEzMDU3NDI1OTMwNSBdLCBbIDEzNy40MDY0NTM2NDUzODM4MzQsIDM0LjcwMzE2MDUzMDc3NjI0NSBdLCBbIDEzNy40MDY2ODg5NzcwMzI1NTksIDM0LjcwMzAzNDQ2MzcwMTQzNSBdLCBbIDEzNy40MDY2MzI4MDEwOTA2MDksIDM0LjcwMjk2NzA2MTQyNTQxMiBdLCBbIDEzNy40MDY0MzIzODk2MjIwMTIsIDM0LjcwMzA3MzE1NzU3NTgyMiBdLCBbIDEzNy40MDYxNTYwNjQ3MTgzMTcsIDM0LjcwMzA0Njk0NTU5ODM3MyBdLCBbIDEzNy40MDYxNDI0MDAzMDAwMTMsIDM0LjcwMzEzMDU3NDI1OTMwNSBdIF0gXSB9IH0sCnsgInR5cGUiOiAiRmVhdHVyZSIsICJwcm9wZXJ0aWVzIjogeyB9LCAiZ2VvbWV0cnkiOiB7ICJ0eXBlIjogIlBvbHlnb24iLCAiY29vcmRpbmF0ZXMiOiBbIFsgWyAxMzcuNDA5NTgwNDE3LCAzNC43MDI4MzMxOTQgXSwgWyAxMzcuNDA5NDY0NjY3LCAzNC43MDI4MjMxMzkgXSwgWyAxMzcuNDA5NDU2MDI4LCAzNC43MDI4OTA2OTQgXSwgWyAxMzcuNDA5NTcxODg5LCAzNC43MDI5MDA3MjIgXSwgWyAxMzcuNDA5NTgwNDE3LCAzNC43MDI4MzMxOTQgXSBdIF0gfSB9LAp7ICJ0eXBlIjogIkZlYXR1cmUiLCAicHJvcGVydGllcyI6IHsgfSwgImdlb21ldHJ5IjogeyAidHlwZSI6ICJQb2x5Z29uIiwgImNvb3JkaW5hdGVzIjogWyBbIFsgMTM3LjQwODk0MzA4MywgMzQuNzAyODUyNzUgXSwgWyAxMzcuNDA5MjUyMzA2MDAwMDEzLCAzNC43MDI4ODI4ODkgXSwgWyAxMzcuNDA5Mjc1MTk0LCAzNC43MDI3MjIgXSwgWyAxMzcuNDA4OTY1OTcyLCAzNC43MDI2OTE5NzIgXSwgWyAxMzcuNDA4OTQzMDgzLCAzNC43MDI4NTI3NSBdIF0gXSB9IH0sCnsgInR5cGUiOiAiRmVhdHVyZSIsICJwcm9wZXJ0aWVzIjogeyB9LCAiZ2VvbWV0cnkiOiB7ICJ0eXBlIjogIlBvbHlnb24iLCAiY29vcmRpbmF0ZXMiOiBbIFsgWyAxMzcuNDA5MjAzNSwgMzQuNzAyNjg2MTk0IF0sIFsgMTM3LjQwOTIwNjY2NywgMzQuNzAyNjU3MjUgXSwgWyAxMzcuNDA5Mjg0MzA1OTk5OTg5LCAzNC43MDI2NjQxOTQgXSwgWyAxMzcuNDA5MzA1MjQ5OTk5OTg5LCAzNC43MDI1MDQzMzMgXSwgWyAxMzcuNDA4OTk1MTM5MDAwMDEyLCAzNC43MDI0NzY2MzkgXSwgWyAxMzcuNDA4OTc0MjIyMDAwMDEyLCAzNC43MDI2MzY1MjggXSwgWyAxMzcuNDA5MDkwMzg5LCAzNC43MDI2NDY5MTcgXSwgWyAxMzcuNDA5MDg3LCAzNC43MDI2Nzc1ODMgXSwgWyAxMzcuNDA5MjAzNSwgMzQuNzAyNjg2MTk0IF0gXSBdIH0gfSwKeyAidHlwZSI6ICJGZWF0dXJlIiwgInByb3BlcnRpZXMiOiB7IH0sICJnZW9tZXRyeSI6IHsgInR5cGUiOiAiUG9seWdvbiIsICJjb29yZGluYXRlcyI6IFsgWyBbIDEzNy40MDk3NDU4MzI5OTk5ODgsIDM0LjcwMjg1MDUyOCBdLCBbIDEzNy40MDk5ODE0NzIsIDM0LjcwMjg3MjQxNyBdLCBbIDEzNy40MTAwMTY4MzI5OTk5ODYsIDM0LjcwMjYxMjI1IF0sIFsgMTM3LjQwOTcyOTg4OSwgMzQuNzAyNTg1NjExIF0sIFsgMTM3LjQwOTcwOTE2Njk5OTk4OCwgMzQuNzAyNzM4MDgzIF0sIFsgMTM3LjQwOTc2MDQ3MTk5OTk4OCwgMzQuNzAyNzQyODYxIF0sIFsgMTM3LjQwOTc0NTgzMjk5OTk4OCwgMzQuNzAyODUwNTI4IF0gXSBdIH0gfSwKeyAidHlwZSI6ICJGZWF0dXJlIiwgInByb3BlcnRpZXMiOiB7IH0sICJnZW9tZXRyeSI6IHsgInR5cGUiOiAiUG9seWdvbiIsICJjb29yZGluYXRlcyI6IFsgWyBbIDEzNy40MDk2ODU3MjIsIDM0LjcwMjU2NDYxMSBdLCBbIDEzNy40MDk1NjYzODksIDM0LjcwMjU1MjUgXSwgWyAxMzcuNDA5NTYxNzc4MDAwMDExLCAzNC43MDI1ODM2OTQgXSwgWyAxMzcuNDA5NjgxMTM5MDAwMDE0LCAzNC43MDI1OTU4MDYgXSwgWyAxMzcuNDA5Njg1NzIyLCAzNC43MDI1NjQ2MTEgXSBdIF0gfSB9LAp7ICJ0eXBlIjogIkZlYXR1cmUiLCAicHJvcGVydGllcyI6IHsgfSwgImdlb21ldHJ5IjogeyAidHlwZSI6ICJQb2x5Z29uIiwgImNvb3JkaW5hdGVzIjogWyBbIFsgMTM3LjQwOTkyODkxNywgMzQuNzAyMDM0NjY3IF0sIFsgMTM3LjQwOTkzOTg2MSwgMzQuNzAxOTY4NzIyIF0sIFsgMTM3LjQwOTg3NDU1NiwgMzQuNzAxOTYxMjc4IF0sIFsgMTM3LjQwOTg2MzYxMSwgMzQuNzAyMDI3MjIyIF0sIFsgMTM3LjQwOTkyODkxNywgMzQuNzAyMDM0NjY3IF0gXSBdIH0gfSwKeyAidHlwZSI6ICJGZWF0dXJlIiwgInByb3BlcnRpZXMiOiB7IH0sICJnZW9tZXRyeSI6IHsgInR5cGUiOiAiUG9seWdvbiIsICJjb29yZGluYXRlcyI6IFsgWyBbIDEzNy40MDk5OTk5NzIsIDM0LjcwMTkxNzg2MSBdLCBbIDEzNy40MTAwMTMyMjIsIDM0LjcwMTgyNjQxNyBdLCBbIDEzNy40MDk5OTAxOTM5OTk5ODgsIDM0LjcwMTgyNDIyMiBdLCBbIDEzNy40MDk4OTY1LCAzNC43MDE4MTQ5MTcgXSwgWyAxMzcuNDA5ODgzMjUsIDM0LjcwMTkwNjM2MSBdLCBbIDEzNy40MDk5OTk5NzIsIDM0LjcwMTkxNzg2MSBdIF0gXSB9IH0sCnsgInR5cGUiOiAiRmVhdHVyZSIsICJwcm9wZXJ0aWVzIjogeyB9LCAiZ2VvbWV0cnkiOiB7ICJ0eXBlIjogIlBvbHlnb24iLCAiY29vcmRpbmF0ZXMiOiBbIFsgWyAxMzcuNDA5MDc1NjExLCAzNC43MDE2OTQzMzMgXSwgWyAxMzcuNDA5MTE2MTExLCAzNC43MDE0Mzg3NSBdLCBbIDEzNy40MDkwNDAxMTEsIDM0LjcwMTQzMDYxMSBdLCBbIDEzNy40MDg5OTYxMTEsIDM0LjcwMTQyNTgzMyBdLCBbIDEzNy40MDg5NjUsIDM0LjcwMTQyMjQ3MiBdLCBbIDEzNy40MDg5MjQ0NzIsIDM0LjcwMTY3ODAyOCBdLCBbIDEzNy40MDkwMTY0MTcsIDM0LjcwMTY4Nzk0NCBdLCBbIDEzNy40MDkwNzU2MTEsIDM0LjcwMTY5NDMzMyBdIF0gXSB9IH0sCnsgInR5cGUiOiAiRmVhdHVyZSIsICJwcm9wZXJ0aWVzIjogeyB9LCAiZ2VvbWV0cnkiOiB7ICJ0eXBlIjogIlBvbHlnb24iLCAiY29vcmRpbmF0ZXMiOiBbIFsgWyAxMzcuNDA5MjUyODYxLCAzNC43MDE2MTY2MTEgXSwgWyAxMzcuNDA5NDgyNjEwOTk5OTg3LCAzNC43MDE2MzkzMzMgXSwgWyAxMzcuNDA5NTA5ODg5LCAzNC43MDE0NTExMzkgXSwgWyAxMzcuNDA5Mzg2MDgyOTk5OTg3LCAzNC43MDE0Mzg4MzMgXSwgWyAxMzcuNDA5MzU5MTEwOTk5OTg2LCAzNC43MDE0MzYxOTQgXSwgWyAxMzcuNDA5MzQyNSwgMzQuNzAxNDM0NTI4IF0sIFsgMTM3LjQwOTMzODc0OTk5OTk4OSwgMzQuNzAxNDU5Nzc4IF0sIFsgMTM3LjQwOTI3NjUyOCwgMzQuNzAxNDUzNTgzIF0sIFsgMTM3LjQwOTI1Mjg2MSwgMzQuNzAxNjE2NjExIF0gXSBdIH0gfSwKeyAidHlwZSI6ICJGZWF0dXJlIiwgInByb3BlcnRpZXMiOiB7IH0sICJnZW9tZXRyeSI6IHsgInR5cGUiOiAiUG9seWdvbiIsICJjb29yZGluYXRlcyI6IFsgWyBbIDEzNy40MDg5MTA0MTY5OTk5ODcsIDM0LjcwMTc5NjMzMyBdLCBbIDEzNy40MDg5NzQ4NjEsIDM0LjcwMTg1MDIyMiBdLCBbIDEzNy40MDkzMTAwODMsIDM0LjcwMTg4MzUyOCBdLCBbIDEzNy40MDkzMjg4MDYsIDM0LjcwMTc1NDU4MyBdLCBbIDEzNy40MDg5MjIzMDYsIDM0LjcwMTcxNDE5NCBdLCBbIDEzNy40MDg5MTA0MTY5OTk5ODcsIDM0LjcwMTc5NjMzMyBdIF0gXSB9IH0sCnsgInR5cGUiOiAiRmVhdHVyZSIsICJwcm9wZXJ0aWVzIjogeyB9LCAiZ2VvbWV0cnkiOiB7ICJ0eXBlIjogIlBvbHlnb24iLCAiY29vcmRpbmF0ZXMiOiBbIFsgWyAxMzcuNDA5NjA5MTExLCAzNC43MDE3MTEzODkgXSwgWyAxMzcuNDA5NTk0NDcyLCAzNC43MDE4MTM2MzkgXSwgWyAxMzcuNDA5NjIxNDQ0MDAwMDEsIDM0LjcwMTgxNjM4OSBdLCBbIDEzNy40MDk2MTU2NjcsIDM0LjcwMTg1Njg2MSBdLCBbIDEzNy40MDk1ODY2MTEsIDM0LjcwMTg1Mzk0NCBdLCBbIDEzNy40MDk1ODExNjcsIDM0LjcwMTg5MiBdLCBbIDEzNy40MDk2MDM0MTcsIDM0LjcwMTkyNjMwNiBdLCBbIDEzNy40MDk3MjY4MDYsIDM0LjcwMTkzODQxNyBdLCBbIDEzNy40MDk3NTk1MjgsIDM0LjcwMTcxMTA4MyBdLCBbIDEzNy40MDk3Nzk1NTU5OTk5ODksIDM0LjcwMTU3MjAyOCBdLCBbIDEzNy40MDk2MzEyNSwgMzQuNzAxNTU3NTI4IF0sIFsgMTM3LjQwOTYwOTExMSwgMzQuNzAxNzExMzg5IF0gXSBdIH0gfSwKeyAidHlwZSI6ICJGZWF0dXJlIiwgInByb3BlcnRpZXMiOiB7IH0sICJnZW9tZXRyeSI6IHsgInR5cGUiOiAiUG9seWdvbiIsICJjb29yZGluYXRlcyI6IFsgWyBbIDEzNy40MDkwMTI1MjgsIDM0LjcwMTE4MDIyMiBdLCBbIDEzNy40MDg5ODg2MTEwMDAwMTIsIDM0LjcwMTM2MTU1NiBdLCBbIDEzNy40MDkwMDQ0NDQsIDM0LjcwMTM2Mjk3MiBdLCBbIDEzNy40MDkwNDg1NTU5OTk5ODgsIDM0LjcwMTM2Njk0NCBdLCBbIDEzNy40MDkzNjQ0NDQsIDM0LjcwMTM5NTI1IF0sIFsgMTM3LjQwOTQzODI1LCAzNC43MDE0MDE4NjEgXSwgWyAxMzcuNDA5NDQ1NSwgMzQuNzAxMzQ2NTgzIF0sIFsgMTM3LjQwOTQ0OTQ3MiwgMzQuNzAxMzE2NDcyIF0sIFsgMTM3LjQwOTQ1NTIyMiwgMzQuNzAxMjcyNTU2IF0sIFsgMTM3LjQwOTA2ODI3OCwgMzQuNzAxMjM3ODA2IF0sIFsgMTM3LjQwOTA3MjYzODk5OTk4NywgMzQuNzAxMjA0ODA2IF0sIFsgMTM3LjQwOTA1MTc1LCAzNC43MDExODM3NSBdLCBbIDEzNy40MDkwMTI1MjgsIDM0LjcwMTE4MDIyMiBdIF0gXSB9IH0sCnsgInR5cGUiOiAiRmVhdHVyZSIsICJwcm9wZXJ0aWVzIjogeyB9LCAiZ2VvbWV0cnkiOiB7ICJ0eXBlIjogIlBvbHlnb24iLCAiY29vcmRpbmF0ZXMiOiBbIFsgWyAxMzcuNDA5OTk0Njk0LCAzNC43MDE3OTMxMTEgXSwgWyAxMzcuNDA5OTkwMTkzOTk5OTg4LCAzNC43MDE4MjQyMjIgXSwgWyAxMzcuNDEwMDEzMjIyLCAzNC43MDE4MjY0MTcgXSwgWyAxMzcuNDEwMDE2NDE3LCAzNC43MDE3OTQ2NjcgXSwgWyAxMzcuNDA5OTk0Njk0LCAzNC43MDE3OTMxMTEgXSBdIF0gfSB9LAp7ICJ0eXBlIjogIkZlYXR1cmUiLCAicHJvcGVydGllcyI6IHsgfSwgImdlb21ldHJ5IjogeyAidHlwZSI6ICJQb2x5Z29uIiwgImNvb3JkaW5hdGVzIjogWyBbIFsgMTM3LjQwOTM5MTUyNzk5OTk4NiwgMzQuNzAxMzk3NzIyIF0sIFsgMTM3LjQwOTM2NDQ0NCwgMzQuNzAxMzk1MjUgXSwgWyAxMzcuNDA5MzU5MTEwOTk5OTg2LCAzNC43MDE0MzYxOTQgXSwgWyAxMzcuNDA5Mzg2MDgyOTk5OTg3LCAzNC43MDE0Mzg4MzMgXSwgWyAxMzcuNDA5MzkxNTI3OTk5OTg2LCAzNC43MDEzOTc3MjIgXSBdIF0gfSB9LAp7ICJ0eXBlIjogIkZlYXR1cmUiLCAicHJvcGVydGllcyI6IHsgfSwgImdlb21ldHJ5IjogeyAidHlwZSI6ICJQb2x5Z29uIiwgImNvb3JkaW5hdGVzIjogWyBbIFsgMTM3LjQxMDA0OTEzOSwgMzQuNzAxNTYwMzA2IF0sIFsgMTM3LjQxMDA1MzMwNiwgMzQuNzAxNTMwNDcyIF0sIFsgMTM3LjQxMDAxNDk3MiwgMzQuNzAxNTI2NzUgXSwgWyAxMzcuNDEwMDA4MDI4LCAzNC43MDE1NzYwODMgXSwgWyAxMzcuNDEwMDQ2NjY2OTk5OTg5LCAzNC43MDE1Nzk0MTcgXSwgWyAxMzcuNDEwMDQ5MTM5LCAzNC43MDE1NjAzMDYgXSBdIF0gfSB9LAp7ICJ0eXBlIjogIkZlYXR1cmUiLCAicHJvcGVydGllcyI6IHsgfSwgImdlb21ldHJ5IjogeyAidHlwZSI6ICJQb2x5Z29uIiwgImNvb3JkaW5hdGVzIjogWyBbIFsgMTM3LjQwOTA0ODU1NTk5OTk4OCwgMzQuNzAxMzY2OTQ0IF0sIFsgMTM3LjQwOTAwNDQ0NCwgMzQuNzAxMzYyOTcyIF0sIFsgMTM3LjQwODk5NjExMSwgMzQuNzAxNDI1ODMzIF0sIFsgMTM3LjQwOTA0MDExMSwgMzQuNzAxNDMwNjExIF0sIFsgMTM3LjQwOTA0ODU1NTk5OTk4OCwgMzQuNzAxMzY2OTQ0IF0gXSBdIH0gfSwKeyAidHlwZSI6ICJGZWF0dXJlIiwgInByb3BlcnRpZXMiOiB7IH0sICJnZW9tZXRyeSI6IHsgInR5cGUiOiAiUG9seWdvbiIsICJjb29yZGluYXRlcyI6IFsgWyBbIDEzNy40MDk2NzM2MzksIDM0LjcwMTQ5NDE2NyBdLCBbIDEzNy40MDk2NjQxMzksIDM0LjcwMTU2MDcyMiBdLCBbIDEzNy40MDk3MDc2OTQsIDM0LjcwMTU2NDk0NCBdLCBbIDEzNy40MDk3MTcsIDM0LjcwMTQ5ODMwNiBdLCBbIDEzNy40MDk2NzM2MzksIDM0LjcwMTQ5NDE2NyBdIF0gXSB9IH0sCnsgInR5cGUiOiAiRmVhdHVyZSIsICJwcm9wZXJ0aWVzIjogeyB9LCAiZ2VvbWV0cnkiOiB7ICJ0eXBlIjogIlBvbHlnb24iLCAiY29vcmRpbmF0ZXMiOiBbIFsgWyAxMzcuNDA5NjcyMzA2LCAzNC43MDEzNjY5NzIgXSwgWyAxMzcuNDA5Njc2MzYxMDAwMDEsIDM0LjcwMTMzODE5NCBdLCBbIDEzNy40MDk0NDk0NzIsIDM0LjcwMTMxNjQ3MiBdLCBbIDEzNy40MDk0NDU1LCAzNC43MDEzNDY1ODMgXSwgWyAxMzcuNDA5NjcyMzA2LCAzNC43MDEzNjY5NzIgXSBdIF0gfSB9LAp7ICJ0eXBlIjogIkZlYXR1cmUiLCAicHJvcGVydGllcyI6IHsgfSwgImdlb21ldHJ5IjogeyAidHlwZSI6ICJQb2x5Z29uIiwgImNvb3JkaW5hdGVzIjogWyBbIFsgMTM3LjQwOTQ3NDgzMywgMzQuNzAwOTE2OTcyIF0sIFsgMTM3LjQwOTcwNjk0NCwgMzQuNzAwOTM5MTM5IF0sIFsgMTM3LjQwOTcxMTIyMiwgMzQuNzAwOTA4NzIyIF0sIFsgMTM3LjQwOTc4NzExMTAwMDAxNCwgMzQuNzAwOTE1OTcyIF0sIFsgMTM3LjQwOTgwNDg2MSwgMzQuNzAwNzg5NzIyIF0sIFsgMTM3LjQwOTc2MDQ0NCwgMzQuNzAwNzg1NSBdLCBbIDEzNy40MDk3MjgsIDM0LjcwMDc4MjM4OSBdLCBbIDEzNy40MDk0OTY4NjEsIDM0LjcwMDc2MDMzMyBdLCBbIDEzNy40MDk0NzQ4MzMsIDM0LjcwMDkxNjk3MiBdIF0gXSB9IH0sCnsgInR5cGUiOiAiRmVhdHVyZSIsICJwcm9wZXJ0aWVzIjogeyB9LCAiZ2VvbWV0cnkiOiB7ICJ0eXBlIjogIlBvbHlnb24iLCAiY29vcmRpbmF0ZXMiOiBbIFsgWyAxMzcuNDEwMjQ2ODYxLCAzNC43MDI2NTg1IF0sIFsgMTM3LjQxMDI1MTAyOCwgMzQuNzAyNjIzMTM5IF0sIFsgMTM3LjQxMDE4MDE2NywgMzQuNzAyNjE3NDQ0IF0sIFsgMTM3LjQxMDE3NiwgMzQuNzAyNjUyNzc4IF0sIFsgMTM3LjQxMDI0Njg2MSwgMzQuNzAyNjU4NSBdIF0gXSB9IH0sCnsgInR5cGUiOiAiRmVhdHVyZSIsICJwcm9wZXJ0aWVzIjogeyB9LCAiZ2VvbWV0cnkiOiB7ICJ0eXBlIjogIlBvbHlnb24iLCAiY29vcmRpbmF0ZXMiOiBbIFsgWyAxMzcuNDEwMzM0NDQ0LCAzNC43MDI3MDQyMjIgXSwgWyAxMzcuNDEwMzQ3Njk0LCAzNC43MDI2MDYxMTEgXSwgWyAxMzcuNDEwMjYxNDQ0MDAwMDE0LCAzNC43MDI1OTgxNjcgXSwgWyAxMzcuNDEwMjQ4MTk0LCAzNC43MDI2OTYyNzggXSwgWyAxMzcuNDEwMzM0NDQ0LCAzNC43MDI3MDQyMjIgXSBdIF0gfSB9LAp7ICJ0eXBlIjogIkZlYXR1cmUiLCAicHJvcGVydGllcyI6IHsgfSwgImdlb21ldHJ5IjogeyAidHlwZSI6ICJQb2x5Z29uIiwgImNvb3JkaW5hdGVzIjogWyBbIFsgMTM3LjQxMDE5NTQ5OTk5OTk4NiwgMzQuNzAyMDAxMDI4IF0sIFsgMTM3LjQxMDIwOTg2MSwgMzQuNzAyMDIxOTE3IF0sIFsgMTM3LjQxMDIyNzM2MTAwMDAxMSwgMzQuNzAyMDM3MzA2IF0sIFsgMTM3LjQxMDI0ODkxNywgMzQuNzAyMDQ4NjExIF0sIFsgMTM3LjQxMDI3MzE2NzAwMDAxNCwgMzQuNzAyMDU1MTY3IF0sIFsgMTM3LjQxMDI5ODY5NCwgMzQuNzAyMDU2NDQ0IF0sIFsgMTM3LjQxMDMyMzgwNiwgMzQuNzAyMDUyNTI4IF0sIFsgMTM3LjQxMDM0NjkxNywgMzQuNzAyMDQzNTU2IF0sIFsgMTM3LjQxMDM2NjUyOCwgMzQuNzAyMDMwMDgzIF0sIFsgMTM3LjQxMDM4MTUyNzk5OTk4OCwgMzQuNzAyMDEzMDI4IF0sIFsgMTM3LjQxMDM4MzgwNiwgMzQuNzAyMDA4MzMzIF0sIFsgMTM3LjQxMDM5NTY5Mzk5OTk4OCwgMzQuNzAxODkxODMzIF0sIFsgMTM3LjQxMDM5OTcyMiwgMzQuNzAxODUyMjUgXSwgWyAxMzcuNDEwMjEyMDU2LCAzNC43MDE4MzkwODMgXSwgWyAxMzcuNDEwMTk1NDk5OTk5OTg2LCAzNC43MDIwMDEwMjggXSBdIF0gfSB9LAp7ICJ0eXBlIjogIkZlYXR1cmUiLCAicHJvcGVydGllcyI6IHsgfSwgImdlb21ldHJ5IjogeyAidHlwZSI6ICJQb2x5Z29uIiwgImNvb3JkaW5hdGVzIjogWyBbIFsgMTM3LjQxMDc0MDk3MjAwMDAxMywgMzQuNzAxODkzMTk0IF0sIFsgMTM3LjQxMDUxNzI1LCAzNC43MDE4NzMgXSwgWyAxMzcuNDEwNDkxODMzLCAzNC43MDIwNjQgXSwgWyAxMzcuNDEwNzE1NTU2MDAwMDE0LCAzNC43MDIwODQyNzggXSwgWyAxMzcuNDEwNzQwOTcyMDAwMDEzLCAzNC43MDE4OTMxOTQgXSBdIF0gfSB9LAp7ICJ0eXBlIjogIkZlYXR1cmUiLCAicHJvcGVydGllcyI6IHsgfSwgImdlb21ldHJ5IjogeyAidHlwZSI6ICJQb2x5Z29uIiwgImNvb3JkaW5hdGVzIjogWyBbIFsgMTM3LjQxMDIyOTU4Mjk5OTk4OSwgMzQuNzAxNzEwMTM5IF0sIFsgMTM3LjQxMDIyNDY2NywgMzQuNzAxNzQ2MTExIF0sIFsgMTM3LjQxMDM4Mzg2MTAwMDAxNCwgMzQuNzAxNzYwOTQ0IF0sIFsgMTM3LjQxMDQxOTExMTAwMDAxLCAzNC43MDE3NjQzMDYgXSwgWyAxMzcuNDEwOTI0NTU2LCAzNC43MDE4MTEzMzMgXSwgWyAxMzcuNDEwOTM4NTU2LCAzNC43MDE3MDg3MjIgXSwgWyAxMzcuNDEwOTQyMTk0LCAzNC43MDE2ODIwMjggXSwgWyAxMzcuNDExMDE5OTQ0LCAzNC43MDE2ODkyNzggXSwgWyAxMzcuNDExMDUwNzIyLCAzNC43MDE0NjQgXSwgWyAxMzcuNDEwOTAwODA2LCAzNC43MDE0NDk5NzIgXSwgWyAxMzcuNDEwOTA0OTcyLCAzNC43MDE0MTkwMjggXSwgWyAxMzcuNDExMDIxNzc4LCAzNC43MDE0Mjk4ODkgXSwgWyAxMzcuNDExMDQ4MDgzLCAzNC43MDEyMzc2MzkgXSwgWyAxMzcuNDEwODExMDI4MDAwMDEyLCAzNC43MDEyMTU1IF0sIFsgMTM3LjQxMDc5NjkxNywgMzQuNzAxMzE5MTExIF0sIFsgMTM3LjQxMDcyMzc3OCwgMzQuNzAxMzEyMzA2IF0sIFsgMTM3LjQxMDcyOTYzOTAwMDAxLCAzNC43MDEyNjkxOTQgXSwgWyAxMzcuNDEwNTcxOTcyMDAwMDE0LCAzNC43MDEyNTQ1NTYgXSwgWyAxMzcuNDEwNTUzOTE2OTk5OTg3LCAzNC43MDEzODYzMDYgXSwgWyAxMzcuNDEwNjMzODMzLCAzNC43MDEzOTM4MDYgXSwgWyAxMzcuNDEwNzY2NDQzOTk5OTg5LCAzNC43MDE1MzQ3MjIgXSwgWyAxMzcuNDEwNzQzNjk0LCAzNC43MDE3MDEwODMgXSwgWyAxMzcuNDEwMjM3Mjc4MDAwMDExLCAzNC43MDE2NTM4NjEgXSwgWyAxMzcuNDEwMjI5NTgyOTk5OTg5LCAzNC43MDE3MTAxMzkgXSBdIF0gfSB9LAp7ICJ0eXBlIjogIkZlYXR1cmUiLCAicHJvcGVydGllcyI6IHsgfSwgImdlb21ldHJ5IjogeyAidHlwZSI6ICJQb2x5Z29uIiwgImNvb3JkaW5hdGVzIjogWyBbIFsgMTM3LjQxMDM4NzcyMiwgMzQuNzAxNzgxMDU2IF0sIFsgMTM3LjQxMDM3Nzg4ODk5OTk4OSwgMzQuNzAxODUwNjY3IF0sIFsgMTM3LjQxMDQwMDUsIDM0LjcwMTg1MjI1IF0sIFsgMTM3LjQxMDQxMDQ0NCwgMzQuNzAxNzgxNzIyIF0sIFsgMTM3LjQxMDQxNjY2NywgMzQuNzAxNzgyMzMzIF0sIFsgMTM3LjQxMDQxOTExMTAwMDAxLCAzNC43MDE3NjQzMDYgXSwgWyAxMzcuNDEwMzgzODYxMDAwMDE0LCAzNC43MDE3NjA5NDQgXSwgWyAxMzcuNDEwMzgxMDgzLCAzNC43MDE3ODA0MTcgXSwgWyAxMzcuNDEwMzg3NzIyLCAzNC43MDE3ODEwNTYgXSBdIF0gfSB9LAp7ICJ0eXBlIjogIkZlYXR1cmUiLCAicHJvcGVydGllcyI6IHsgfSwgImdlb21ldHJ5IjogeyAidHlwZSI6ICJQb2x5Z29uIiwgImNvb3JkaW5hdGVzIjogWyBbIFsgMTM3LjQxMDUwOTU1NiwgMzQuNzAxOTMwNDQ0IF0sIFsgMTM3LjQxMDUxMzMwNjAwMDAxMywgMzQuNzAxOTAyNDE3IF0sIFsgMTM3LjQxMDM5NTY5Mzk5OTk4OCwgMzQuNzAxODkxODMzIF0sIFsgMTM3LjQxMDM5MjYxMSwgMzQuNzAxOTIyMzA2IF0sIFsgMTM3LjQxMDUwOTU1NiwgMzQuNzAxOTMwNDQ0IF0gXSBdIH0gfSwKeyAidHlwZSI6ICJGZWF0dXJlIiwgInByb3BlcnRpZXMiOiB7IH0sICJnZW9tZXRyeSI6IHsgInR5cGUiOiAiUG9seWdvbiIsICJjb29yZGluYXRlcyI6IFsgWyBbIDEzNy40MTA0NDc5NzE5OTk5ODYsIDM0LjcwMDIxMDIyMiBdLCBbIDEzNy40MTA0NDYwNTYwMDAwMTIsIDM0LjcwMDIyMzE5NCBdLCBbIDEzNy40MTA2MTg2NjcsIDM0LjcwMDI0MDUyOCBdLCBbIDEzNy40MTA2MjA1LCAzNC43MDAyMjc1MjggXSwgWyAxMzcuNDEwNDQ3OTcxOTk5OTg2LCAzNC43MDAyMTAyMjIgXSBdIF0gfSB9LAp7ICJ0eXBlIjogIkZlYXR1cmUiLCAicHJvcGVydGllcyI6IHsgfSwgImdlb21ldHJ5IjogeyAidHlwZSI6ICJQb2x5Z29uIiwgImNvb3JkaW5hdGVzIjogWyBbIFsgMTM3LjQxMDQ0MjE2NzAwMDAxNCwgMzQuNzAwMjQwMDU2IF0sIFsgMTM3LjQxMDQ0MDI1LCAzNC43MDAyNTQ1IF0sIFsgMTM3LjQxMDYxMzYzOSwgMzQuNzAwMjcwMjc4IF0sIFsgMTM3LjQxMDYxNTU1NjAwMDAxLCAzNC43MDAyNTU5NDQgXSwgWyAxMzcuNDEwNDQyMTY3MDAwMDE0LCAzNC43MDAyNDAwNTYgXSBdIF0gfSB9LAp7ICJ0eXBlIjogIkZlYXR1cmUiLCAicHJvcGVydGllcyI6IHsgfSwgImdlb21ldHJ5IjogeyAidHlwZSI6ICJQb2x5Z29uIiwgImNvb3JkaW5hdGVzIjogWyBbIFsgMTM3LjQxMTEzNjY5NCwgMzQuNzAwNzg1IF0sIFsgMTM3LjQxMTE1MzI1MDAwMDAxMiwgMzQuNzAwNjYzMDgzIF0sIFsgMTM3LjQxMTExODE5NDAwMDAxMSwgMzQuNzAwNjU5ODA2IF0sIFsgMTM3LjQxMTEwMTUyNzk5OTk4OSwgMzQuNzAwNzgxNzIyIF0sIFsgMTM3LjQxMTEzNjY5NCwgMzQuNzAwNzg1IF0gXSBdIH0gfSwKeyAidHlwZSI6ICJGZWF0dXJlIiwgInByb3BlcnRpZXMiOiB7IH0sICJnZW9tZXRyeSI6IHsgInR5cGUiOiAiUG9seWdvbiIsICJjb29yZGluYXRlcyI6IFsgWyBbIDEzNy40MTE4NDAwMjgsIDM0LjcwMTQ5OTE5NCBdLCBbIDEzNy40MTE4NjcwMjc5OTk5ODksIDM0LjcwMTUwODI1IF0sIFsgMTM3LjQxMjEwNDk0NCwgMzQuNzAxMDkxNDQ0IF0sIFsgMTM3LjQxMjA3ODA4MzAwMDAxMSwgMzQuNzAxMDgwOTcyIF0sIFsgMTM3LjQxMTg0MDAyOCwgMzQuNzAxNDk5MTk0IF0gXSBdIH0gfSwKeyAidHlwZSI6ICJGZWF0dXJlIiwgInByb3BlcnRpZXMiOiB7IH0sICJnZW9tZXRyeSI6IHsgInR5cGUiOiAiUG9seWdvbiIsICJjb29yZGluYXRlcyI6IFsgWyBbIDEzNy40MTE3OTc3NSwgMzQuNzAxNDg0Njk0IF0sIFsgMTM3LjQxMTgyNDcyMiwgMzQuNzAxNDkzNjM5IF0sIFsgMTM3LjQxMjA2NDE5NDAwMDAxLCAzNC43MDEwNzYzODkgXSwgWyAxMzcuNDEyMDMzNTgzMDAwMDEsIDM0LjcwMTA2NDU1NiBdLCBbIDEzNy40MTE3OTc3NSwgMzQuNzAxNDg0Njk0IF0gXSBdIH0gfSwKeyAidHlwZSI6ICJGZWF0dXJlIiwgInByb3BlcnRpZXMiOiB7IH0sICJnZW9tZXRyeSI6IHsgInR5cGUiOiAiUG9seWdvbiIsICJjb29yZGluYXRlcyI6IFsgWyBbIDEzNy40MTE4MzkyNTAwMDAwMTQsIDM0LjcwMDQxNjAyOCBdLCBbIDEzNy40MTE4ODQ0NDQsIDM0LjcwMDQyMTYxMSBdLCBbIDEzNy40MTE4ODkxNjcsIDM0LjcwMDM5NTE5NCBdLCBbIDEzNy40MTE4NDM5NzIwMDAwMTQsIDM0LjcwMDM4OTY5NCBdLCBbIDEzNy40MTE4MzkyNTAwMDAwMTQsIDM0LjcwMDQxNjAyOCBdIF0gXSB9IH0sCnsgInR5cGUiOiAiRmVhdHVyZSIsICJwcm9wZXJ0aWVzIjogeyB9LCAiZ2VvbWV0cnkiOiB7ICJ0eXBlIjogIlBvbHlnb24iLCAiY29vcmRpbmF0ZXMiOiBbIFsgWyAxMzcuNDExNjg1NSwgMzQuNzAwNDA0NTI4IF0sIFsgMTM3LjQxMTgxMTMwNiwgMzQuNzAwNDE2NzIyIF0sIFsgMTM3LjQxMTgxNzE2NywgMzQuNzAwMzc1MjUgXSwgWyAxMzcuNDExODg5Nzc3OTk5OTg4LCAzNC43MDAzODIyMjIgXSwgWyAxMzcuNDExODk5MDgzLCAzNC43MDAzMTY1NTYgXSwgWyAxMzcuNDExNzAwNjk0LCAzNC43MDAyOTczODkgXSwgWyAxMzcuNDExNjg1NSwgMzQuNzAwNDA0NTI4IF0gXSBdIH0gfSwKeyAidHlwZSI6ICJGZWF0dXJlIiwgInByb3BlcnRpZXMiOiB7IH0sICJnZW9tZXRyeSI6IHsgInR5cGUiOiAiUG9seWdvbiIsICJjb29yZGluYXRlcyI6IFsgWyBbIDEzNy40MTI1MjQ1MjgsIDM0LjY5OTY4MSBdLCBbIDEzNy40MTI0NTM5NDQsIDM0LjY5OTYxNDMzMyBdLCBbIDEzNy40MTIyMjQ3NSwgMzQuNjk5Nzc5Njk0IF0sIFsgMTM3LjQxMjI4NDg2MDk5OTk4OSwgMzQuNjk5ODM2NTU2IF0sIFsgMTM3LjQxMjM2Nzk3MiwgMzQuNjk5Nzc2NjExIF0sIFsgMTM3LjQxMjM3ODM2MSwgMzQuNjk5Nzg2NSBdLCBbIDEzNy40MTI1MjQ1MjgsIDM0LjY5OTY4MSBdIF0gXSB9IH0sCnsgInR5cGUiOiAiRmVhdHVyZSIsICJwcm9wZXJ0aWVzIjogeyB9LCAiZ2VvbWV0cnkiOiB7ICJ0eXBlIjogIlBvbHlnb24iLCAiY29vcmRpbmF0ZXMiOiBbIFsgWyAxMzcuNDEyNjU4OTcyLCAzNC42OTk1ODc2MTEgXSwgWyAxMzcuNDEyNjgxODMzLCAzNC42OTk1NzEyNSBdLCBbIDEzNy40MTI1ODk1NTYsIDM0LjY5OTQ4MzI1IF0sIFsgMTM3LjQxMjU2NjY5NCwgMzQuNjk5NDk5NjExIF0sIFsgMTM3LjQxMjY1ODk3MiwgMzQuNjk5NTg3NjExIF0gXSBdIH0gfSwKeyAidHlwZSI6ICJGZWF0dXJlIiwgInByb3BlcnRpZXMiOiB7IH0sICJnZW9tZXRyeSI6IHsgInR5cGUiOiAiUG9seWdvbiIsICJjb29yZGluYXRlcyI6IFsgWyBbIDEzNy40MTMxMzcxNjcsIDM0LjcwMDUzOTYzOSBdLCBbIDEzNy40MTMwMzc1ODMsIDM0LjcwMDUzNDEzOSBdLCBbIDEzNy40MTMwMzQ1MjgsIDM0LjcwMDU3MjQ3MiBdLCBbIDEzNy40MTMwOTY3NzgwMDAwMTEsIDM0LjcwMDU3NTg2MSBdLCBbIDEzNy40MTMwOTQ4NjEsIDM0LjcwMDU5OTM4OSBdLCBbIDEzNy40MTMxMzIyMjIsIDM0LjcwMDYwMTM4OSBdLCBbIDEzNy40MTMxMzcxNjcsIDM0LjcwMDUzOTYzOSBdIF0gXSB9IH0sCnsgInR5cGUiOiAiRmVhdHVyZSIsICJwcm9wZXJ0aWVzIjogeyB9LCAiZ2VvbWV0cnkiOiB7ICJ0eXBlIjogIlBvbHlnb24iLCAiY29vcmRpbmF0ZXMiOiBbIFsgWyAxMzcuNDAzODgzOTM2MTQxLCAzNC43MDMyMzU0NDMyODUxMDIgXSwgWyAxMzcuNDAzODc2NjEwOTk5OTg3LCAzNC43MDMyNzE2NjcgXSwgWyAxMzcuNDAzOTI2MDU1OTk5OTg5LCAzNC43MDMyNzg1IF0sIFsgMTM3LjQwMzkzNDgzNjY4NjAwNSwgMzQuNzAzMjM1NDQzMjg1MTAyIF0sIFsgMTM3LjQwMzkzNTMzMywgMzQuNzAzMjMyOTQ0IF0sIFsgMTM3LjQwMzg4NTg2MSwgMzQuNzAzMjI2MTExIF0sIFsgMTM3LjQwMzg4MzkzNjE0MSwgMzQuNzAzMjM1NDQzMjg1MTAyIF0gXSBdIH0gfSwKeyAidHlwZSI6ICJGZWF0dXJlIiwgInByb3BlcnRpZXMiOiB7IH0sICJnZW9tZXRyeSI6IHsgInR5cGUiOiAiUG9seWdvbiIsICJjb29yZGluYXRlcyI6IFsgWyBbIDEzNy40MDQ4OTI2NjcwMDAwMTMsIDM0LjcwMzA3NzAyOCBdLCBbIDEzNy40MDQ4ODgwODMsIDM0LjcwMzExMzE2NyBdLCBbIDEzNy40MDUwMTI3NzgwMDAwMTQsIDM0LjcwMzEyNTc1IF0sIFsgMTM3LjQwNTAxNTk3MiwgMzQuNzAzMTAzNjM5IF0sIFsgMTM3LjQwNTEwODEzOSwgMzQuNzAzMTEzMTk0IF0sIFsgMTM3LjQwNTExNzQ3MiwgMzQuNzAzMDUyMDU2IF0sIFsgMTM3LjQwNDk3NDc1LCAzNC43MDMwMzcyNzggXSwgWyAxMzcuNDA0OTc3NTI3OTk5OTg5LCAzNC43MDMwMTYyNzggXSwgWyAxMzcuNDA0NzU1MjIyLCAzNC43MDI5OTYxMzkgXSwgWyAxMzcuNDA0NzUyODYxLCAzNC43MDMwMTQxOTQgXSwgWyAxMzcuNDA0NjMyNTY4MzU5MDA2LCAzNC43MDMwMDE2NTk0NjQxIF0sIFsgMTM3LjQwNDYwODUsIDM0LjcwMjk5OTEzOSBdLCBbIDEzNy40MDQ1OTkxOTQwMDAwMTQsIDM0LjcwMzA2MDE5NCBdLCBbIDEzNy40MDQ2MzI1NjgzNTkwMDYsIDM0LjcwMzA2MzY0ODYzMDQ5NyBdLCBbIDEzNy40MDQ2OTMzMDYwMDAwMTMsIDM0LjcwMzA3MDAyOCBdLCBbIDEzNy40MDQ2ODk4ODksIDM0LjcwMzA5MzI3OCBdLCBbIDEzNy40MDQ4MTg2MTEsIDM0LjcwMzEwNjI3OCBdLCBbIDEzNy40MDQ4MjMyMjIsIDM0LjcwMzA3MTAyOCBdLCBbIDEzNy40MDQ4OTI2NjcwMDAwMTMsIDM0LjcwMzA3NzAyOCBdIF0gXSB9IH0sCnsgInR5cGUiOiAiRmVhdHVyZSIsICJwcm9wZXJ0aWVzIjogeyB9LCAiZ2VvbWV0cnkiOiB7ICJ0eXBlIjogIlBvbHlnb24iLCAiY29vcmRpbmF0ZXMiOiBbIFsgWyAxMzcuNDA0NjMyNTY4MzU5MDA2LCAzNC43MDI0NDQ1MDI4NDA1IF0sIFsgMTM3LjQwNDU3NTI1LCAzNC43MDI0MzkwODMgXSwgWyAxMzcuNDA0NTY1NDE2OTk5OTg2LCAzNC43MDI1MTA1MjggXSwgWyAxMzcuNDA0NjMyNTY4MzU5MDA2LCAzNC43MDI1MTY4OTU3OTI3OTcgXSwgWyAxMzcuNDA0NjgzNDQ0LCAzNC43MDI1MjE3MjIgXSwgWyAxMzcuNDA0Njc3ODg5LCAzNC43MDI1NjE3NzggXSwgWyAxMzcuNDA0NzI2MTM5LCAzNC43MDI1NjYzNjEgXSwgWyAxMzcuNDA0NzMxNSwgMzQuNzAyNTI3MzMzIF0sIFsgMTM3LjQwNDgzNzUyOCwgMzQuNzAyNTM3Mzg5IF0sIFsgMTM3LjQwNDgzMzEzOSwgMzQuNzAyNTY5MDU2IF0sIFsgMTM3LjQwNDg4NzYxMSwgMzQuNzAyNTc0MTY3IF0sIFsgMTM3LjQwNDg5MTg4OSwgMzQuNzAyNTQzNTgzIF0sIFsgMTM3LjQwNDk5OTU1NiwgMzQuNzAyNTUzNzUgXSwgWyAxMzcuNDA0OTkzODg5LCAzNC43MDI1OTQ3NzggXSwgWyAxMzcuNDA1MDQxMjc4LCAzNC43MDI1OTkxOTQgXSwgWyAxMzcuNDA1MDQ2NTI4MDAwMDE0LCAzNC43MDI1NjEzMzMgXSwgWyAxMzcuNDA1MTY3NjExLCAzNC43MDI1NzI4MDYgXSwgWyAxMzcuNDA1MTc4MzA2MDAwMDEsIDM0LjcwMjQ5NjA1NiBdLCBbIDEzNy40MDQ2MzI1NjgzNTkwMDYsIDM0LjcwMjQ0NDUwMjg0MDUgXSBdIF0gfSB9LAp7ICJ0eXBlIjogIkZlYXR1cmUiLCAicHJvcGVydGllcyI6IHsgfSwgImdlb21ldHJ5IjogeyAidHlwZSI6ICJQb2x5Z29uIiwgImNvb3JkaW5hdGVzIjogWyBbIFsgMTM3LjQwNDYzMjU2ODM1OTAwNiwgMzQuNzAyNTgxMTM2NTY3NjAyIF0sIFsgMTM3LjQwNDU1NzE2NywgMzQuNzAyNjA0NDcyIF0sIFsgMTM3LjQwNDU2NTUyOCwgMzQuNzAyNjIyOTQ0IF0sIFsgMTM3LjQwNDYzMjU2ODM1OTAwNiwgMzQuNzAyNjAyMjc3NDM1NzAyIF0sIFsgMTM3LjQwNDY3MDQ0NCwgMzQuNzAyNTkwNTU2IF0sIFsgMTM3LjQwNDY2MjA4MywgMzQuNzAyNTcyIF0sIFsgMTM3LjQwNDYzMjU2ODM1OTAwNiwgMzQuNzAyNTgxMTM2NTY3NjAyIF0gXSBdIH0gfSwKeyAidHlwZSI6ICJGZWF0dXJlIiwgInByb3BlcnRpZXMiOiB7IH0sICJnZW9tZXRyeSI6IHsgInR5cGUiOiAiUG9seWdvbiIsICJjb29yZGluYXRlcyI6IFsgWyBbIDEzNy40MDQ4OTY1LCAzNC43MDExMDM1IF0sIFsgMTM3LjQwNDYzMjU2ODM1OTAwNiwgMzQuNzAxMDc1MTcwNjI4MyBdLCBbIDEzNy40MDQ2MjIsIDM0LjcwMTA3NDAyOCBdLCBbIDEzNy40MDQ2MTMzMDU5OTk5ODcsIDM0LjcwMTEyOTc1IF0sIFsgMTM3LjQwNDYzMjU2ODM1OTAwNiwgMzQuNzAxMTMxODIwMTExODk3IF0sIFsgMTM3LjQwNDg4NzcyMjAwMDAxMiwgMzQuNzAxMTU5MTM5IF0sIFsgMTM3LjQwNDg5NjUsIDM0LjcwMTEwMzUgXSBdIF0gfSB9LAp7ICJ0eXBlIjogIkZlYXR1cmUiLCAicHJvcGVydGllcyI6IHsgfSwgImdlb21ldHJ5IjogeyAidHlwZSI6ICJQb2x5Z29uIiwgImNvb3JkaW5hdGVzIjogWyBbIFsgMTM3LjQwNTcwNzMzMywgMzQuNzAwOTE5NjM5IF0sIFsgMTM3LjQwNTY1OTg2MSwgMzQuNzAwOTE0OTQ0IF0sIFsgMTM3LjQwNTY1MDg0MjkxMTAwMSwgMzQuNzAwOTc3NDE0NzIwMSBdLCBbIDEzNy40MDU2MzY3MjIsIDM0LjcwMTA3NTM2MSBdLCBbIDEzNy40MDU2ODQxMTEsIDM0LjcwMTA4MDA1NiBdLCBbIDEzNy40MDU2OTg5NjU2MjM5OTgsIDM0LjcwMDk3NzQxNDcyMDEgXSwgWyAxMzcuNDA1NzA3MzMzLCAzNC43MDA5MTk2MzkgXSBdIF0gfSB9LAp7ICJ0eXBlIjogIkZlYXR1cmUiLCAicHJvcGVydGllcyI6IHsgfSwgImdlb21ldHJ5IjogeyAidHlwZSI6ICJQb2x5Z29uIiwgImNvb3JkaW5hdGVzIjogWyBbIFsgMTM3LjQwNzU0MTk0NCwgMzQuNzAyNDU4Nzc4IF0sIFsgMTM3LjQwNzU1MDUyOCwgMzQuNzAyNDA4MTk0IF0sIFsgMTM3LjQwNzU1NjQ0NCwgMzQuNzAyMzczNDcyIF0sIFsgMTM3LjQwNzU2Mjg4OSwgMzQuNzAyMzM1OTQ0IF0sIFsgMTM3LjQwNzM3OTE1MDM5MDk5NCwgMzQuNzAyMzE0NjA1NDQxMjAyIF0sIFsgMTM3LjQwNzM3MDY5NCwgMzQuNzAyMzEzNjExIF0sIFsgMTM3LjQwNzM0OTY2NywgMzQuNzAyNDM2NDQ0IF0sIFsgMTM3LjQwNzM3OTE1MDM5MDk5NCwgMzQuNzAyNDM5ODkxOTY3MDAzIF0sIFsgMTM3LjQwNzU0MTk0NCwgMzQuNzAyNDU4Nzc4IF0gXSBdIH0gfSwKeyAidHlwZSI6ICJGZWF0dXJlIiwgInByb3BlcnRpZXMiOiB7IH0sICJnZW9tZXRyeSI6IHsgInR5cGUiOiAiUG9seWdvbiIsICJjb29yZGluYXRlcyI6IFsgWyBbIDEzNy40MDc4Nzc4NjEsIDM0LjcwMjYxNDI1IF0sIFsgMTM3LjQwNzM3OTE1MDM5MDk5NCwgMzQuNzAyNTYzMDE4NzkyMDk4IF0sIFsgMTM3LjQwNzMzNzM2MSwgMzQuNzAyNTU4NzIyIF0sIFsgMTM3LjQwNzMxNzYzOTAwMDAxMywgMzQuNzAyNjg5ODMzIF0sIFsgMTM3LjQwNzM3OTE1MDM5MDk5NCwgMzQuNzAyNjk2MTU0NDY0MSBdLCBbIDEzNy40MDc4NTgxMzkwMDAwMTIsIDM0LjcwMjc0NTM4OSBdLCBbIDEzNy40MDc4Nzc4NjEsIDM0LjcwMjYxNDI1IF0gXSBdIH0gfSwKeyAidHlwZSI6ICJGZWF0dXJlIiwgInByb3BlcnRpZXMiOiB7IH0sICJnZW9tZXRyeSI6IHsgInR5cGUiOiAiUG9seWdvbiIsICJjb29yZGluYXRlcyI6IFsgWyBbIDEzNy40MDczNzkxNTAzOTA5OTQsIDM0LjcwMjQ4MTMyMTQwNjk5OSBdLCBbIDEzNy40MDczNDk0NDQsIDM0LjcwMjQ3ODI3OCBdLCBbIDEzNy40MDczMzczNjEsIDM0LjcwMjU1ODcyMiBdLCBbIDEzNy40MDczNzkxNTAzOTA5OTQsIDM0LjcwMjU2MzAxODc5MjA5OCBdLCBbIDEzNy40MDc4Nzc4NjEsIDM0LjcwMjYxNDI1IF0sIFsgMTM3LjQwNzg5NDY2NywgMzQuNzAyNTAyNzIyIF0sIFsgMTM3LjQwNzU4NjQxNywgMzQuNzAyNDcxMDU2IF0sIFsgMTM3LjQwNzU4MTY5Mzk5OTk4NywgMzQuNzAyNTAyMTY3IF0sIFsgMTM3LjQwNzM3OTE1MDM5MDk5NCwgMzQuNzAyNDgxMzIxNDA2OTk5IF0gXSBdIH0gfSwKeyAidHlwZSI6ICJGZWF0dXJlIiwgInByb3BlcnRpZXMiOiB7IH0sICJnZW9tZXRyeSI6IHsgInR5cGUiOiAiUG9seWdvbiIsICJjb29yZGluYXRlcyI6IFsgWyBbIDEzNy40MDgwMTU4MDYsIDM0LjcwMzE2Nzg4OSBdLCBbIDEzNy40MDgwMDc4ODI2NDQ5OTUsIDM0LjcwMzIzNTQ0MzI4NTEwMiBdLCBbIDEzNy40MDc5OTk4MzMsIDM0LjcwMzMwMzg2MSBdLCBbIDEzNy40MDgwMjk3NSwgMzQuNzAzMzA2MjIyIF0sIFsgMTM3LjQwODAzODA2OTE5Mjk5NywgMzQuNzAzMjM1NDQzMjg1MTAyIF0sIFsgMTM3LjQwODA0NTcyMiwgMzQuNzAzMTcwMzMzIF0sIFsgMTM3LjQwODAxNTgwNiwgMzQuNzAzMTY3ODg5IF0gXSBdIH0gfSwKeyAidHlwZSI6ICJGZWF0dXJlIiwgInByb3BlcnRpZXMiOiB7IH0sICJnZW9tZXRyeSI6IHsgInR5cGUiOiAiUG9seWdvbiIsICJjb29yZGluYXRlcyI6IFsgWyBbIDEzNy40MDc5NzAwNTYwMDAwMTEsIDM0LjcwMzE2MzM2MSBdLCBbIDEzNy40MDc5NTg5MDE3NTQsIDM0LjcwMzIzNTQ0MzI4NTEwMiBdLCBbIDEzNy40MDc5NDg5NDQsIDM0LjcwMzI5OTcyMiBdLCBbIDEzNy40MDc5Nzk2MzksIDM0LjcwMzMwMyBdLCBbIDEzNy40MDc5OTAwNzUyODE5ODcsIDM0LjcwMzIzNTQ0MzI4NTEwMiBdLCBbIDEzNy40MDgwMDA3MjIsIDM0LjcwMzE2NjYzOSBdLCBbIDEzNy40MDc5NzAwNTYwMDAwMTEsIDM0LjcwMzE2MzM2MSBdIF0gXSB9IH0sCnsgInR5cGUiOiAiRmVhdHVyZSIsICJwcm9wZXJ0aWVzIjogeyB9LCAiZ2VvbWV0cnkiOiB7ICJ0eXBlIjogIlBvbHlnb24iLCAiY29vcmRpbmF0ZXMiOiBbIFsgWyAxMzcuNDA3NTUzMjUsIDM0LjcwMjA1OTgzMyBdLCBbIDEzNy40MDc0OTIzMDYsIDM0LjcwMjA1MzgzMyBdLCBbIDEzNy40MDc0ODQ3NTU3MTQ5ODksIDM0LjcwMjEwNjQzNjcwNTU5OCBdLCBbIDEzNy40MDc0NzY1ODMsIDM0LjcwMjE2MzExMSBdLCBbIDEzNy40MDc5MzczNjEsIDM0LjcwMjIwODQ3MiBdLCBbIDEzNy40MDc5NTIwNTYzMjA5OTQsIDM0LjcwMjEwNjQzNjcwNTU5OCBdLCBbIDEzNy40MDc5NTMwODMsIDM0LjcwMjA5OTE2NyBdLCBbIDEzNy40MDc4NDE3MjIsIDM0LjcwMjA4ODE5NCBdLCBbIDEzNy40MDc4NDQ5NDQsIDM0LjcwMjA2NzgzMyBdLCBbIDEzNy40MDc5NTYxOTQsIDM0LjcwMjA3ODQxNyBdLCBbIDEzNy40MDc5ODA4MDYwMDAwMTIsIDM0LjcwMTkwMjc1IF0sIFsgMTM3LjQwNzUyMDMzMywgMzQuNzAxODU4Nzc4IF0sIFsgMTM3LjQwNzQ5NTc1MDAwMDAxLCAzNC43MDIwMzQ0NDQgXSwgWyAxMzcuNDA3NTU2MDI3OTk5OTg4LCAzNC43MDIwNDAxNjcgXSwgWyAxMzcuNDA3NTUzMjUsIDM0LjcwMjA1OTgzMyBdIF0gXSB9IH0sCnsgInR5cGUiOiAiRmVhdHVyZSIsICJwcm9wZXJ0aWVzIjogeyB9LCAiZ2VvbWV0cnkiOiB7ICJ0eXBlIjogIlBvbHlnb24iLCAiY29vcmRpbmF0ZXMiOiBbIFsgWyAxMzcuNDA3NTcwNSwgMzQuNzAxMDgxMzA2IF0sIFsgMTM3LjQwNzM3OTE1MDM5MDk5NCwgMzQuNzAxMDY0MjUwNzc0ODk4IF0sIFsgMTM3LjQwNzA4MzcyMjAwMDAxLCAzNC43MDEwMzc5MTcgXSwgWyAxMzcuNDA3MDY1Njk0MDAwMDExLCAzNC43MDExNzU2MTEgXSwgWyAxMzcuNDA3Mzc5MTUwMzkwOTk0LCAzNC43MDEyMDM2MTU1MTIxIF0sIFsgMTM3LjQwNzQ2MDcyMiwgMzQuNzAxMjEwODg5IF0sIFsgMTM3LjQwNzQ1MTYzODk5OTk4NywgMzQuNzAxMjc5Njk0IF0sIFsgMTM3LjQwNzQyMDg2MSwgMzQuNzAxMjc2OTQ0IF0sIFsgMTM3LjQwNzM5NTk3MTk5OTk4OSwgMzQuNzAxNDY2OTQ0IF0sIFsgMTM3LjQwNzU3Nzg4OSwgMzQuNzAxNDgzMTk0IF0sIFsgMTM3LjQwNzYwNDg4OSwgMzQuNzAxMjc2MTM5IF0sIFsgMTM3LjQwNzU0NTcyMiwgMzQuNzAxMjcwODYxIF0sIFsgMTM3LjQwNzU3MDUsIDM0LjcwMTA4MTMwNiBdIF0gXSB9IH0sCnsgInR5cGUiOiAiRmVhdHVyZSIsICJwcm9wZXJ0aWVzIjogeyB9LCAiZ2VvbWV0cnkiOiB7ICJ0eXBlIjogIlBvbHlnb24iLCAiY29vcmRpbmF0ZXMiOiBbIFsgWyAxMzcuNDA3NjQzNzMwODMyMDA3LCAzNC43MDA5Nzc0MTQ3MjAxIF0sIFsgMTM3LjQwNzYzNDU4MywgMzQuNzAxMDUyOTQ0IF0sIFsgMTM3LjQwNzgyNzE5NCwgMzQuNzAxMDczMzA2IF0sIFsgMTM3LjQwNzg0MjE1NzIzOTk5OCwgMzQuNzAwOTc3NDE0NzIwMSBdLCBbIDEzNy40MDc4NDM5MTcsIDM0LjcwMDk2NiBdLCBbIDEzNy40MDc2NDc2OTQsIDM0LjcwMDk0NTI3OCBdLCBbIDEzNy40MDc2NDM3MzA4MzIwMDcsIDM0LjcwMDk3NzQxNDcyMDEgXSBdIF0gfSB9LAp7ICJ0eXBlIjogIkZlYXR1cmUiLCAicHJvcGVydGllcyI6IHsgfSwgImdlb21ldHJ5IjogeyAidHlwZSI6ICJQb2x5Z29uIiwgImNvb3JkaW5hdGVzIjogWyBbIFsgMTM3LjQwOTY5NDYxMSwgMzQuNzAzMTQwODMzIF0sIFsgMTM3LjQwOTY4MTg3NzUwOTk5NiwgMzQuNzAzMjM1NDQzMjg1MTAyIF0sIFsgMTM3LjQwOTY3NzQxNzAwMDAxMiwgMzQuNzAzMjY4ODg5IF0sIFsgMTM3LjQwOTk5OTQxNywgMzQuNzAzMjk4NTI4IF0sIFsgMTM3LjQxMDAwNzg5MjIyOTAwNCwgMzQuNzAzMjM1NDQzMjg1MTAyIF0sIFsgMTM3LjQxMDAxNjYxMSwgMzQuNzAzMTcwMzg5IF0sIFsgMTM3LjQwOTY5NDYxMSwgMzQuNzAzMTQwODMzIF0gXSBdIH0gfSwKeyAidHlwZSI6ICJGZWF0dXJlIiwgInByb3BlcnRpZXMiOiB7IH0sICJnZW9tZXRyeSI6IHsgInR5cGUiOiAiUG9seWdvbiIsICJjb29yZGluYXRlcyI6IFsgWyBbIDEzNy40MDg4MzYzODg5OTk5ODcsIDM0LjcwMjgzODU1NiBdLCBbIDEzNy40MDg4NTg2Mzg5OTk5ODgsIDM0LjcwMjY4MDc1IF0sIFsgMTM3LjQwODc1MjQ0MTQwNTk5NCwgMzQuNzAyNjcwNTg1MDY4NzAyIF0sIFsgMTM3LjQwODU1MDYxMTAwMDAxLCAzNC43MDI2NTEyNSBdLCBbIDEzNy40MDg1MjgzNjEsIDM0LjcwMjgwODk3MiBdLCBbIDEzNy40MDg3NTI0NDE0MDU5OTQsIDM0LjcwMjgzMDQ5NTE3MDQwMyBdLCBbIDEzNy40MDg4MzYzODg5OTk5ODcsIDM0LjcwMjgzODU1NiBdIF0gXSB9IH0sCnsgInR5cGUiOiAiRmVhdHVyZSIsICJwcm9wZXJ0aWVzIjogeyB9LCAiZ2VvbWV0cnkiOiB7ICJ0eXBlIjogIlBvbHlnb24iLCAiY29vcmRpbmF0ZXMiOiBbIFsgWyAxMzcuNDA4ODkwMzA1OTk5OTg5LCAzNC43MDI0NjMzMzMgXSwgWyAxMzcuNDA4NzUyNDQxNDA1OTk0LCAzNC43MDI0NDk4NjU1ODAxOTkgXSwgWyAxMzcuNDA4NTgwOTcyMDAwMDEsIDM0LjcwMjQzMzExMSBdLCBbIDEzNy40MDg1NTgwODMsIDM0LjcwMjU5Mjg4OSBdLCBbIDEzNy40MDg3NTI0NDE0MDU5OTQsIDM0LjcwMjYxMTg5MjMzMDk5OSBdLCBbIDEzNy40MDg4Njc0MTcwMDAwMSwgMzQuNzAyNjIzMTExIF0sIFsgMTM3LjQwODg5MDMwNTk5OTk4OSwgMzQuNzAyNDYzMzMzIF0gXSBdIH0gfSwKeyAidHlwZSI6ICJGZWF0dXJlIiwgInByb3BlcnRpZXMiOiB7IH0sICJnZW9tZXRyeSI6IHsgInR5cGUiOiAiUG9seWdvbiIsICJjb29yZGluYXRlcyI6IFsgWyBbIDEzNy40MDkxNTI2OTQsIDM0LjcwMzA4NjI3OCBdLCBbIDEzNy40MDkxMzE2ODYyNDg5OTgsIDM0LjcwMzIzNTQ0MzI4NTEwMiBdLCBbIDEzNy40MDkxMjEyNSwgMzQuNzAzMzA5NTU2IF0sIFsgMTM3LjQwOTU1MTY5Mzk5OTk4NywgMzQuNzAzMzUwODA2IF0sIFsgMTM3LjQwOTU2NzkzNzczOTAxMywgMzQuNzAzMjM1NDQzMjg1MTAyIF0sIFsgMTM3LjQwOTU4MzEzOSwgMzQuNzAzMTI3NjExIF0sIFsgMTM3LjQwOTE1MjY5NCwgMzQuNzAzMDg2Mjc4IF0gXSBdIH0gfSwKeyAidHlwZSI6ICJGZWF0dXJlIiwgInByb3BlcnRpZXMiOiB7IH0sICJnZW9tZXRyeSI6IHsgInR5cGUiOiAiUG9seWdvbiIsICJjb29yZGluYXRlcyI6IFsgWyBbIDEzNy40MDg4MzI0NjQ5OTI5OTcsIDM0LjcwMzIzNTQ0MzI4NTEwMiBdLCBbIDEzNy40MDg4MzAwNTYsIDM0LjcwMzI1NDUyOCBdLCBbIDEzNy40MDg5OTc4ODksIDM0LjcwMzI2OTA1NiBdLCBbIDEzNy40MDkwMDIxNDIyOTE5OTYsIDM0LjcwMzIzNTQ0MzI4NTEwMiBdLCBbIDEzNy40MDkwMjI3NSwgMzQuNzAzMDcxODYxIF0sIFsgMTM3LjQwODg1NTAyOCwgMzQuNzAzMDU3Mzg5IF0sIFsgMTM3LjQwODgzMjQ2NDk5Mjk5NywgMzQuNzAzMjM1NDQzMjg1MTAyIF0gXSBdIH0gfSwKeyAidHlwZSI6ICJGZWF0dXJlIiwgInByb3BlcnRpZXMiOiB7IH0sICJnZW9tZXRyeSI6IHsgInR5cGUiOiAiUG9seWdvbiIsICJjb29yZGluYXRlcyI6IFsgWyBbIDEzNy40MDg3NjA2NjcsIDM0LjcwMTMwOTcyMiBdLCBbIDEzNy40MDg3NTI0NDE0MDU5OTQsIDM0LjcwMTMwOTEwOTIwNjU5OCBdLCBbIDEzNy40MDg2ODgzNjEsIDM0LjcwMTMwMzY2NyBdLCBbIDEzNy40MDg2NTc5MTcsIDM0LjcwMTMwMTExMSBdLCBbIDEzNy40MDg2NTQ4MDU5OTk5ODcsIDM0LjcwMTMyNTI3OCBdLCBbIDEzNy40MDg1ODU2OTQwMDAwMSwgMzQuNzAxMzE4MTExIF0sIFsgMTM3LjQwODU1MDU1NiwgMzQuNzAxNTQ2OTcyIF0sIFsgMTM3LjQwODc1MjQ0MTQwNTk5NCwgMzQuNzAxNTY4MDY3OTQxMjAzIF0sIFsgMTM3LjQwODc3OTMwNjAwMDAxNCwgMzQuNzAxNTcwODYxIF0sIFsgMTM3LjQwODgxNDQ0NCwgMzQuNzAxMzQyIF0sIFsgMTM3LjQwODc1NzQ0NCwgMzQuNzAxMzM2MDU2IF0sIFsgMTM3LjQwODc2MDY2NywgMzQuNzAxMzA5NzIyIF0gXSBdIH0gfSwKeyAidHlwZSI6ICJGZWF0dXJlIiwgInByb3BlcnRpZXMiOiB7IH0sICJnZW9tZXRyeSI6IHsgInR5cGUiOiAiUG9seWdvbiIsICJjb29yZGluYXRlcyI6IFsgWyBbIDEzNy40MDg3NjY5NDQsIDM0LjcwMTcxMzA1NiBdLCBbIDEzNy40MDg3NjkxOTQsIDM0LjcwMTY5NTM4OSBdLCBbIDEzNy40MDg5NzEyNzgsIDM0LjcwMTcwNzY5NCBdLCBbIDEzNy40MDg5NzA1MjgsIDM0LjcwMTcxMjYzOSBdLCBbIDEzNy40MDg5Njk2OTQsIDM0LjcwMTcxODg2MSBdLCBbIDEzNy40MDkwMTA4NjEwMDAwMTMsIDM0LjcwMTcyMjk0NCBdLCBbIDEzNy40MDkwMTI0NDQwMDAwMTIsIDM0LjcwMTcxMjU1NiBdLCBbIDEzNy40MDkwMTY0MTcsIDM0LjcwMTY4Nzk0NCBdLCBbIDEzNy40MDg5MjQ0NzIsIDM0LjcwMTY3ODAyOCBdLCBbIDEzNy40MDg3NTI0NDE0MDU5OTQsIDM0LjcwMTY2NjExMDI0NzggXSwgWyAxMzcuNDA4NzQ3NSwgMzQuNzAxNjY1Nzc4IF0sIFsgMTM3LjQwODc0MjE2NzAwMDAxNCwgMzQuNzAxNzEzMTExIF0sIFsgMTM3LjQwODczODY2NywgMzQuNzAxNzQ0MTExIF0sIFsgMTM3LjQwODc1MjQ0MTQwNTk5NCwgMzQuNzAxNzQ1MjE2ODU0NDk4IF0sIFsgMTM3LjQwODc2MjgwNiwgMzQuNzAxNzQ2MDU2IF0sIFsgMTM3LjQwODc2Njk0NCwgMzQuNzAxNzEzMDU2IF0gXSBdIH0gfSwKeyAidHlwZSI6ICJGZWF0dXJlIiwgInByb3BlcnRpZXMiOiB7IH0sICJnZW9tZXRyeSI6IHsgInR5cGUiOiAiUG9seWdvbiIsICJjb29yZGluYXRlcyI6IFsgWyBbIDEzNy40MDkyMjE0MTcsIDM0LjcwMDgyNjk0NCBdLCBbIDEzNy40MDkyNDM2OTQsIDM0LjcwMDY3OTA1NiBdLCBbIDEzNy40MDg3NTI0NDE0MDU5OTQsIDM0LjcwMDYzMDA5NzMyNjE5NyBdLCBbIDEzNy40MDg2ODA3MjIwMDAwMTQsIDM0LjcwMDYyMjk0NCBdLCBbIDEzNy40MDg2NDE4MDYsIDM0LjcwMDkwNCBdLCBbIDEzNy40MDg3NTI0NDE0MDU5OTQsIDM0LjcwMDkxNTM3ODY5MDI5NyBdLCBbIDEzNy40MDg4NzY3NzgsIDM0LjcwMDkyODE2NyBdLCBbIDEzNy40MDg4NzM3Nzc5OTk5ODYsIDM0LjcwMDk0NzcyMiBdLCBbIDEzNy40MDg5ODI1MjgsIDM0LjcwMDk1ODk3MiBdLCBbIDEzNy40MDg5OTM3NzgsIDM0LjcwMDg4NDU1NiBdLCBbIDEzNy40MDkxOTc2MzkwMDAwMTMsIDM0LjcwMDkwNTUyOCBdLCBbIDEzNy40MDkyMDk2MzkwMDAwMTEsIDM0LjcwMDgyNTgwNiBdLCBbIDEzNy40MDkyMjE0MTcsIDM0LjcwMDgyNjk0NCBdIF0gXSB9IH0sCnsgInR5cGUiOiAiRmVhdHVyZSIsICJwcm9wZXJ0aWVzIjogeyB9LCAiZ2VvbWV0cnkiOiB7ICJ0eXBlIjogIlBvbHlnb24iLCAiY29vcmRpbmF0ZXMiOiBbIFsgWyAxMzcuNDEwMTI1NzMyNDIxOTg5LCAzNC43MDE2MTQ0Mjg0ODU1OTggXSwgWyAxMzcuNDEwMDQ1MTEwOTk5OTg4LCAzNC43MDE2MDczODkgXSwgWyAxMzcuNDEwMDQ4NjM5LCAzNC43MDE1Nzk2MTEgXSwgWyAxMzcuNDEwMDQ2NjY2OTk5OTg5LCAzNC43MDE1Nzk0MTcgXSwgWyAxMzcuNDEwMDA4MDI4LCAzNC43MDE1NzYwODMgXSwgWyAxMzcuNDA5OTMxNDcyMDAwMDExLCAzNC43MDE1NjkzODkgXSwgWyAxMzcuNDA5OTEzMjIyLCAzNC43MDE3MTA3NzggXSwgWyAxMzcuNDA5OTA2NjExLCAzNC43MDE3NjIzNjEgXSwgWyAxMzcuNDA5OTk3MTM5MDAwMDEyLCAzNC43MDE3NzAyNzggXSwgWyAxMzcuNDA5OTk0Njk0LCAzNC43MDE3OTMxMTEgXSwgWyAxMzcuNDEwMDgxOTE3MDAwMDE0LCAzNC43MDE3OTkyMjIgXSwgWyAxMzcuNDEwMDg0MDU1OTk5OTg4LCAzNC43MDE3Nzc4NjEgXSwgWyAxMzcuNDEwMTI1NzMyNDIxOTg5LCAzNC43MDE3ODE1NTI5MTIyMDIgXSwgWyAxMzcuNDEwMTM5NTAwMDAwMDE0LCAzNC43MDE3ODI3MjIgXSwgWyAxMzcuNDEwMTQ4ODA2LCAzNC43MDE3MTAzMDYgXSwgWyAxMzcuNDEwMTYwNzQ5OTk5OTg5LCAzNC43MDE2MTc1IF0sIFsgMTM3LjQxMDEyNTczMjQyMTk4OSwgMzQuNzAxNjE0NDI4NDg1NTk4IF0gXSBdIH0gfSwKeyAidHlwZSI6ICJGZWF0dXJlIiwgInByb3BlcnRpZXMiOiB7IH0sICJnZW9tZXRyeSI6IHsgInR5cGUiOiAiUG9seWdvbiIsICJjb29yZGluYXRlcyI6IFsgWyBbIDEzNy40MTAxMjU3MzI0MjE5ODksIDM0LjcwMTQ0MzQzOTY3ODU5OSBdLCBbIDEzNy40MTAwMzEwODMsIDM0LjcwMTQzNDQxNyBdLCBbIDEzNy40MTAwMzU2NjY5OTk5ODgsIDM0LjcwMTQwMTIyMiBdLCBbIDEzNy40MDk3ODEyNzgsIDM0LjcwMTM3Njk0NCBdLCBbIDEzNy40MDk3MTQ2OTQsIDM0LjcwMTMxMDUyOCBdLCBbIDEzNy40MDk2ODA2Mzg5OTk5ODcsIDM0LjcwMTMwNzI3OCBdLCBbIDEzNy40MDk2NzYzNjEwMDAwMSwgMzQuNzAxMzM4MTk0IF0sIFsgMTM3LjQwOTY3MjMwNiwgMzQuNzAxMzY2OTcyIF0sIFsgMTM3LjQwOTY1NDc0OTk5OTk4NywgMzQuNzAxNDkyMzg5IF0sIFsgMTM3LjQwOTY3MzYzOSwgMzQuNzAxNDk0MTY3IF0sIFsgMTM3LjQwOTcxNywgMzQuNzAxNDk4MzA2IF0sIFsgMTM3LjQxMDAxNDk3MiwgMzQuNzAxNTI2NzUgXSwgWyAxMzcuNDEwMDUzMzA2LCAzNC43MDE1MzA0NzIgXSwgWyAxMzcuNDEwMDQ5MTM5LCAzNC43MDE1NjAzMDYgXSwgWyAxMzcuNDEwMTI1NzMyNDIxOTg5LCAzNC43MDE1Njc2MzEzODgwMDIgXSwgWyAxMzcuNDEwMjg0ODYxLCAzNC43MDE1ODI4MzMgXSwgWyAxMzcuNDEwMjc1MTM5LCAzNC43MDE2NTE4MDYgXSwgWyAxMzcuNDEwMzU1OTQ0LCAzNC43MDE2NTk1IF0sIFsgMTM3LjQxMDM2NTI1MDAwMDAxMiwgMzQuNzAxNTkzMTExIF0sIFsgMTM3LjQxMDQzMDUyOCwgMzQuNzAxNTk5Mzg5IF0sIFsgMTM3LjQxMDQzODg4OSwgMzQuNzAxNTM5ODg5IF0sIFsgMTM3LjQxMDM0ODQ3MjAwMDAxLCAzNC43MDE1MzEyMjIgXSwgWyAxMzcuNDEwMzUzMDU2LCAzNC43MDE0OTgzODkgXSwgWyAxMzcuNDEwMzM4MTY3LCAzNC43MDE0NzczMzMgXSwgWyAxMzcuNDEwMzAyMTM5LCAzNC43MDE0NzM4ODkgXSwgWyAxMzcuNDEwMzA0MDU2LCAzNC43MDE0NjA0NDQgXSwgWyAxMzcuNDEwMTI1NzMyNDIxOTg5LCAzNC43MDE0NDM0Mzk2Nzg1OTkgXSBdIF0gfSB9LAp7ICJ0eXBlIjogIkZlYXR1cmUiLCAicHJvcGVydGllcyI6IHsgfSwgImdlb21ldHJ5IjogeyAidHlwZSI6ICJQb2x5Z29uIiwgImNvb3JkaW5hdGVzIjogWyBbIFsgMTM3LjQxMDUxNDUsIDM0LjcwMDgyNzYxMSBdLCBbIDEzNy40MTA0OTcwODMsIDM0LjcwMDk1MDgwNiBdLCBbIDEzNy40MTA3NzM1MjE0MTk5OTgsIDM0LjcwMDk3NzQxNDcyMDEgXSwgWyAxMzcuNDEwODQ2NTgzLCAzNC43MDA5ODQ0NDQgXSwgWyAxMzcuNDEwODQ3NTg0MzM4OTk1LCAzNC43MDA5Nzc0MTQ3MjAxIF0sIFsgMTM3LjQxMDg2NDAyOCwgMzQuNzAwODYxMjc4IF0sIFsgMTM3LjQxMDUxNDUsIDM0LjcwMDgyNzYxMSBdIF0gXSB9IH0sCnsgInR5cGUiOiAiRmVhdHVyZSIsICJwcm9wZXJ0aWVzIjogeyB9LCAiZ2VvbWV0cnkiOiB7ICJ0eXBlIjogIlBvbHlnb24iLCAiY29vcmRpbmF0ZXMiOiBbIFsgWyAxMzcuNDExMTM5OTEwNTIxMDAxLCAzNC43MDA5Nzc0MTQ3MjAxIF0sIFsgMTM3LjQxMTE2NTMzMzAwMDAxNCwgMzQuNzAwOTc5OTQ0IF0sIFsgMTM3LjQxMTE2NTY3NjcyNjk5NSwgMzQuNzAwOTc3NDE0NzIwMSBdLCBbIDEzNy40MTExNzY3NzgsIDM0LjcwMDkwMDY2NyBdLCBbIDEzNy40MTE0MjE1ODMsIDM0LjcwMDkyNDc3OCBdLCBbIDEzNy40MTE0NTA5NzIwMDAwMTEsIDM0LjcwMDc4NzA1NiBdLCBbIDEzNy40MTExNTc5MTcsIDM0LjcwMDc1OTA4MyBdLCBbIDEzNy40MTExNTM1MjgsIDM0LjcwMDc4OTE5NCBdLCBbIDEzNy40MTA5OTc5MTcsIDM0LjcwMDc3MzgzMyBdLCBbIDEzNy40MTA5NzA5NzIsIDM0LjcwMDk2MDc1IF0sIFsgMTM3LjQxMTEzOTkxMDUyMTAwMSwgMzQuNzAwOTc3NDE0NzIwMSBdIF0gXSB9IH0sCnsgInR5cGUiOiAiRmVhdHVyZSIsICJwcm9wZXJ0aWVzIjogeyB9LCAiZ2VvbWV0cnkiOiB7ICJ0eXBlIjogIlBvbHlnb24iLCAiY29vcmRpbmF0ZXMiOiBbIFsgWyAxMzcuNDEyODcyMzE0NDUzMDExLCAzNC42OTkzMTMxNDM0MTExMDQgXSwgWyAxMzcuNDEyNjIxODg5LCAzNC42OTk0OTQzNjEgXSwgWyAxMzcuNDEyNjk0MTM5LCAzNC42OTk1NjI0NzIgXSwgWyAxMzcuNDEyNzM5MTM5LCAzNC42OTk1Mjk5MTcgXSwgWyAxMzcuNDEyNzQ3MjIyLCAzNC42OTk1Mzc0NzIgXSwgWyAxMzcuNDEyNzkwNDcyMDAwMDEyLCAzNC42OTk1MDYxOTQgXSwgWyAxMzcuNDEyNzc3ODg5MDAwMDEyLCAzNC42OTk0OTQ0MTcgXSwgWyAxMzcuNDEyODcxLCAzNC42OTk0MjcwNTYgXSwgWyAxMzcuNDEyODcyMzE0NDUzMDExLCAzNC42OTk0MjgyMDUwNzAzOTcgXSwgWyAxMzcuNDEyODgxODYwOTk5OTg4LCAzNC42OTk0MzczMDYgXSwgWyAxMzcuNDEyOTI1OTcyMDAwMDExLCAzNC42OTk0MDU0MTcgXSwgWyAxMzcuNDEyOTA2MjUsIDM0LjY5OTM4Njc3OCBdLCBbIDEzNy40MTI5NTM5NzIsIDM0LjY5OTM1MjI1IF0sIFsgMTM3LjQxMjk4NDM4OSwgMzQuNjk5MzgwOTQ0IF0sIFsgMTM3LjQxMzA0NjkxNywgMzQuNjk5MzM1NjY3IF0sIFsgMTM3LjQxMzA2ODU4MzAwMDAxMiwgMzQuNjk5MzU2MDgzIF0sIFsgMTM3LjQxMzE3MzgwNiwgMzQuNjk5Mjc5ODYxIF0sIFsgMTM3LjQxMzE1MTgwNiwgMzQuNjk5MjU5MDgzIF0sIFsgMTM3LjQxMzIwMzg4ODk5OTk4OCwgMzQuNjk5MjIxMzg5IF0sIFsgMTM3LjQxMzI0MzUsIDM0LjY5OTI1ODgwNiBdLCBbIDEzNy40MTMyNjE1ODMsIDM0LjY5OTI0NTY5NCBdLCBbIDEzNy40MTMyODU1NTYsIDM0LjY5OTI2ODI3OCBdLCBbIDEzNy40MTMzMTYzODg5OTk5ODgsIDM0LjY5OTI0NTk0NCBdLCBbIDEzNy40MTMzMjk2MTEsIDM0LjY5OTI1ODM2MSBdLCBbIDEzNy40MTM0NDUzMDYsIDM0LjY5OTE3NDYzOSBdLCBbIDEzNy40MTM0MzMyNSwgMzQuNjk5MTYzMzA2IF0sIFsgMTM3LjQxMzQ4MTcyMiwgMzQuNjk5MTI4MzMzIF0sIFsgMTM3LjQxMzQzOTkxNywgMzQuNjk5MDg4OTE3IF0sIFsgMTM3LjQxMzI5NDUsIDM0LjY5OTE5NDE2NyBdLCBbIDEzNy40MTMyNTYwODMsIDM0LjY5OTE1OCBdLCBbIDEzNy40MTMxODgzMzMsIDM0LjY5OTIwNyBdLCBbIDEzNy40MTMxNTI1MjgwMDAwMTIsIDM0LjY5OTE3MzM2MSBdLCBbIDEzNy40MTI5MzExOTQsIDM0LjY5OTMzMzU1NiBdLCBbIDEzNy40MTI4OTMzMzMsIDM0LjY5OTI5NzkxNyBdLCBbIDEzNy40MTI4NzIzMTQ0NTMwMTEsIDM0LjY5OTMxMzE0MzQxMTEwNCBdIF0gXSB9IH0sCnsgInR5cGUiOiAiRmVhdHVyZSIsICJwcm9wZXJ0aWVzIjogeyB9LCAiZ2VvbWV0cnkiOiB7ICJ0eXBlIjogIlBvbHlnb24iLCAiY29vcmRpbmF0ZXMiOiBbIFsgWyAxMzcuNDA2MDA1ODU5Mzc1LCAzNC43MDI5OTc4ODM0NjY3MDEgXSwgWyAxMzcuNDA2MDA4OTcyLCAzNC43MDI5NzI4NjEgXSwgWyAxMzcuNDA2MDA1ODU5Mzc1LCAzNC43MDI5NzI1OTcwODU0OTggXSwgWyAxMzcuNDA1ODExMzMzLCAzNC43MDI5NTYxMzkgXSwgWyAxMzcuNDA1Nzg0NTU1OTk5OTg2LCAzNC43MDMxNzE4MzMgXSwgWyAxMzcuNDA1OTc5MjUsIDM0LjcwMzE4ODIyMiBdLCBbIDEzNy40MDU5NzY3NzgsIDM0LjcwMzIwNzc3OCBdLCBbIDEzNy40MDYwMDU4NTkzNzUsIDM0LjcwMzIxMDI4NzQ3OTMwMSBdLCBbIDEzNy40MDYwMzc4MzMsIDM0LjcwMzIxMjg4OSBdLCBbIDEzNy40MDYwNTMxOTQsIDM0LjcwMzA4ODg4OSBdLCBbIDEzNy40MDYxMjE5NzIsIDM0LjcwMzA5NDcyMiBdLCBbIDEzNy40MDYxMzIxMTEsIDM0LjcwMzAxMjc1IF0sIFsgMTM3LjQwNjAwNTg1OTM3NSwgMzQuNzAzMDAyMTE2MzgxMzk4IF0sIFsgMTM3LjQwNjAwNTMzMywgMzQuNzAzMDAyMDgzIF0sIFsgMTM3LjQwNjAwNTg1OTM3NSwgMzQuNzAyOTk3ODgzNDY2NzAxIF0gXSBdIH0gfSwKeyAidHlwZSI6ICJGZWF0dXJlIiwgInByb3BlcnRpZXMiOiB7IH0sICJnZW9tZXRyeSI6IHsgInR5cGUiOiAiUG9seWdvbiIsICJjb29yZGluYXRlcyI6IFsgWyBbIDEzNy40MDYyMTg1ODMsIDM0LjcwMDkzOTkxNyBdLCBbIDEzNy40MDYwMDU4NTkzNzUsIDM0LjcwMDkxOTM0MzkzNzMwMSBdLCBbIDEzNy40MDU3MTUwMjgsIDM0LjcwMDg5MTIyMiBdLCBbIDEzNy40MDU3MDI4MjMyNzgwMDYsIDM0LjcwMDk3NzQxNDcyMDEgXSwgWyAxMzcuNDA1Njc5NjExMDAwMDExLCAzNC43MDExNDE0NDQgXSwgWyAxMzcuNDA2MDA1ODU5Mzc1LCAzNC43MDExNzI5ODQzMTc1MDIgXSwgWyAxMzcuNDA2MTgzMTk0LCAzNC43MDExOTAxMzkgXSwgWyAxMzcuNDA2MjEzMjcyMjg5OTg5LCAzNC43MDA5Nzc0MTQ3MjAxIF0sIFsgMTM3LjQwNjIxODU4MywgMzQuNzAwOTM5OTE3IF0gXSBdIH0gfSwKeyAidHlwZSI6ICJGZWF0dXJlIiwgInByb3BlcnRpZXMiOiB7IH0sICJnZW9tZXRyeSI6IHsgInR5cGUiOiAiUG9seWdvbiIsICJjb29yZGluYXRlcyI6IFsgWyBbIDEzNy40MTAwMzgyMTA3MDc5OTUsIDM0LjcwMzIzNTQ0MzI4NTEwMiBdLCBbIDEzNy40MTAwMTY1NTU5OTk5ODgsIDM0LjcwMzM3MzMzMyBdLCBbIDEzNy40MTAxMjU3MzI0MjE5ODksIDM0LjcwMzM4NTA1NTk0NDUwMSBdLCBbIDEzNy40MTAyMzcyNSwgMzQuNzAzMzk3MDI4IF0sIFsgMTM3LjQxMDI2MjM1NzA5MSwgMzQuNzAzMjM1NDQzMjg1MTAyIF0sIFsgMTM3LjQxMDI2NDc3OCwgMzQuNzAzMjE5ODMzIF0sIFsgMTM3LjQxMDMwMjY2NywgMzQuNzAzMjIzODA2IF0sIFsgMTM3LjQxMDMwOTc1MDAwMDAxLCAzNC43MDMxNzg2MzkgXSwgWyAxMzcuNDEwMTI1NzMyNDIxOTg5LCAzNC43MDMxNTg5MDU4MDMwMDEgXSwgWyAxMzcuNDEwMDUxNSwgMzQuNzAzMTUwOTQ0IF0sIFsgMTM3LjQxMDAzODIxMDcwNzk5NSwgMzQuNzAzMjM1NDQzMjg1MTAyIF0gXSBdIH0gfSwKeyAidHlwZSI6ICJGZWF0dXJlIiwgInByb3BlcnRpZXMiOiB7IH0sICJnZW9tZXRyeSI6IHsgInR5cGUiOiAiUG9seWdvbiIsICJjb29yZGluYXRlcyI6IFsgWyBbIDEzNy40MDk5MzI5NzIsIDM0LjcwMDczNDU4MyBdLCBbIDEzNy40MDk5MDEzMjc3MDMwMTEsIDM0LjcwMDk3NzQxNDcyMDEgXSwgWyAxMzcuNDA5ODk4OTE3LCAzNC43MDA5OTYgXSwgWyAxMzcuNDEwMTI1NzMyNDIxOTg5LCAzNC43MDEwMTYxMjkzNjEzOTkgXSwgWyAxMzcuNDEwMzU5Njk0LCAzNC43MDEwMzY4ODkgXSwgWyAxMzcuNDEwMzY3NDYxOTk4OTg3LCAzNC43MDA5Nzc0MTQ3MjAxIF0sIFsgMTM3LjQxMDM4NzQ0NCwgMzQuNzAwODI0MTY3IF0sIFsgMTM3LjQxMDMxODMzMywgMzQuNzAwODE4IF0sIFsgMTM3LjQxMDMyNDcyMjAwMDAxMywgMzQuNzAwNzY5Mzg5IF0sIFsgMTM3LjQxMDEyNTczMjQyMTk4OSwgMzQuNzAwNzUxNzAyNzQxMjAxIF0sIFsgMTM3LjQwOTkzMjk3MiwgMzQuNzAwNzM0NTgzIF0gXSBdIH0gfSwKeyAidHlwZSI6ICJGZWF0dXJlIiwgInByb3BlcnRpZXMiOiB7IH0sICJnZW9tZXRyeSI6IHsgInR5cGUiOiAiUG9seWdvbiIsICJjb29yZGluYXRlcyI6IFsgWyBbIDEzNy40MDgzMzMzMzMsIDM0LjcwMjc5IF0sIFsgMTM3LjQwODQyMjExMSwgMzQuNzAyNzk4IF0sIFsgMTM3LjQwODQ0MzI3OCwgMzQuNzAyNjM4Mjc4IF0sIFsgMTM3LjQwODMzMzMzMywgMzQuNzAyNjI4Mzg5IF0sIFsgMTM3LjQwODA5MzUyOCwgMzQuNzAyNjA2ODA2IF0sIFsgMTM3LjQwODA3MjM4OTAwMDAxMiwgMzQuNzAyNzY2NSBdLCBbIDEzNy40MDgzMzMzMzMsIDM0LjcwMjc5IF0gXSBdIH0gfSwKeyAidHlwZSI6ICJGZWF0dXJlIiwgInByb3BlcnRpZXMiOiB7IH0sICJnZW9tZXRyeSI6IHsgInR5cGUiOiAiUG9seWdvbiIsICJjb29yZGluYXRlcyI6IFsgWyBbIDEzNy40MDgzMzMzMzMsIDM0LjcwMjU2OTc3OCBdLCBbIDEzNy40MDg0NTA3NDk5OTk5ODYsIDM0LjcwMjU4MzExMSBdLCBbIDEzNy40MDg0NzQwODI5OTk5ODcsIDM0LjcwMjQyMjQxNyBdLCBbIDEzNy40MDg0MjcxMzksIDM0LjcwMjM4OTMzMyBdLCBbIDEzNy40MDgzODkxMTEsIDM0LjcwMjQwODQxNyBdLCBbIDEzNy40MDgzMzMzMzMsIDM0LjcwMjQwNDM2MSBdLCBbIDEzNy40MDgxMjM2OTQwMDAwMTEsIDM0LjcwMjM4OTExMSBdLCBbIDEzNy40MDgwOTg0NzIsIDM0LjcwMjU0MzEzOSBdLCBbIDEzNy40MDgzMzMzMzMsIDM0LjcwMjU2OTc3OCBdIF0gXSB9IH0sCnsgInR5cGUiOiAiRmVhdHVyZSIsICJwcm9wZXJ0aWVzIjogeyB9LCAiZ2VvbWV0cnkiOiB7ICJ0eXBlIjogIlBvbHlnb24iLCAiY29vcmRpbmF0ZXMiOiBbIFsgWyAxMzcuNDA4MzMzMzMzLCAzNC43MDE1NTY2OTQgXSwgWyAxMzcuNDA4MzgyMTY3MDAwMDEzLCAzNC43MDE1NjE4MzMgXSwgWyAxMzcuNDA4NDIxMjc4LCAzNC43MDEzMDU1MjggXSwgWyAxMzcuNDA4MzMzMzMzLCAzNC43MDEyOTY0MTcgXSwgWyAxMzcuNDA4MjcwMzYxLCAzNC43MDEyODk4ODkgXSwgWyAxMzcuNDA4MjMxMjc3OTk5OTg4LCAzNC43MDE1NDYwODMgXSwgWyAxMzcuNDA4MjY2NjM5LCAzNC43MDE1NDk4MDYgXSwgWyAxMzcuNDA4MzA5NjY3LCAzNC43MDE1NTQyMjIgXSwgWyAxMzcuNDA4MzMzMzMzLCAzNC43MDE1NTY2OTQgXSBdIF0gfSB9LAp7ICJ0eXBlIjogIkZlYXR1cmUiLCAicHJvcGVydGllcyI6IHsgfSwgImdlb21ldHJ5IjogeyAidHlwZSI6ICJQb2x5Z29uIiwgImNvb3JkaW5hdGVzIjogWyBbIFsgMTM3LjQwODMzMzMzMywgMzQuNzAxNzUyMzA2IF0sIFsgMTM3LjQwODUyNjQ0Mzk5OTk4OSwgMzQuNzAxNzcxMTM5IF0sIFsgMTM3LjQwODUyODEzOSwgMzQuNzAxNzU4ODg5IF0sIFsgMTM3LjQwODUzNDY2NywgMzQuNzAxNzEzNTI4IF0sIFsgMTM3LjQwODUzNjY5NCwgMzQuNzAxNjk5MTY3IF0sIFsgMTM3LjQwODU0NDYxMSwgMzQuNzAxNjQ0MDgzIF0sIFsgMTM3LjQwODMzMzMzMywgMzQuNzAxNjIzNTI4IF0sIFsgMTM3LjQwODI5OTUsIDM0LjcwMTYyMDIyMiBdLCBbIDEzNy40MDgyNTY0NzIsIDM0LjcwMTYxNTk3MiBdLCBbIDEzNy40MDgyMjM4MDYsIDM0LjcwMTYxMjgwNiBdLCBbIDEzNy40MDgyMTIxNjY5OTk5ODgsIDM0LjcwMTY5NDUgXSwgWyAxMzcuNDA4MjM2NTU2LCAzNC43MDE3MTQxMTEgXSwgWyAxMzcuNDA4Mjc3NDcyLCAzNC43MDE3NDY4MzMgXSwgWyAxMzcuNDA4MzMzMzMzLCAzNC43MDE3NTIzMDYgXSBdIF0gfSB9LAp7ICJ0eXBlIjogIkZlYXR1cmUiLCAicHJvcGVydGllcyI6IHsgfSwgImdlb21ldHJ5IjogeyAidHlwZSI6ICJQb2x5Z29uIiwgImNvb3JkaW5hdGVzIjogWyBbIFsgMTM3LjQwODMzMzMzMywgMzQuNzAwOTAwMzYxIF0sIFsgMTM3LjQwODM1MzA4MywgMzQuNzAwOTAyMzMzIF0sIFsgMTM3LjQwODM3MjMzMjk5OTk4OCwgMzQuNzAwNzcwMzA2IF0sIFsgMTM3LjQwODMzMzMzMywgMzQuNzAwNzY2NDE3IF0sIFsgMTM3LjQwODMzMTYxMSwgMzQuNzAwNzY2MjUgXSwgWyAxMzcuNDA4MzEyNDQzOTk5OTg5LCAzNC43MDA4OTgyNzggXSwgWyAxMzcuNDA4MzMzMzMzLCAzNC43MDA5MDAzNjEgXSBdIF0gfSB9LAp7ICJ0eXBlIjogIkZlYXR1cmUiLCAicHJvcGVydGllcyI6IHsgfSwgImdlb21ldHJ5IjogeyAidHlwZSI6ICJQb2x5Z29uIiwgImNvb3JkaW5hdGVzIjogWyBbIFsgMTM3LjQwOTc0MTE0NTQwODI3NiwgMzQuNzAwNjkyMzUxNzU3OTA4IF0sIFsgMTM3LjQwOTczNjI1MDM3MzI0MywgMzQuNzAwNzIzOTY0Mjk2NzcgXSwgWyAxMzcuNDA5ODUwMzU5MDI0ODMsIDM0LjcwMDczNjE1OTg1NTQ0NSBdLCBbIDEzNy40MDk4NzQ4ODk0MzAxMTQsIDM0LjcwMDU3OTYyMjEwMDk2NyBdLCBbIDEzNy40MDk2ODYxODIxODU0NTMsIDM0LjcwMDU1OTM2MjUwODI2NSBdLCBbIDEzNy40MDk2NjY1OTgyMzQxMTEsIDM0LjcwMDY4NDM1ODYxOTE2NCBdLCBbIDEzNy40MDk3NDExNDU0MDgyNzYsIDM0LjcwMDY5MjM1MTc1NzkwOCBdIF0gXSB9IH0sCnsgInR5cGUiOiAiRmVhdHVyZSIsICJwcm9wZXJ0aWVzIjogeyB9LCAiZ2VvbWV0cnkiOiB7ICJ0eXBlIjogIlBvbHlnb24iLCAiY29vcmRpbmF0ZXMiOiBbIFsgWyAxMzcuNDA2MDI4Njk0MDAwMDE0LCAzNC43MDA3NjM1ODMgXSwgWyAxMzcuNDA2MDA1ODU5Mzc1LCAzNC43MDA3NjEzODQ3MjcxMDIgXSwgWyAxMzcuNDA1ODM3MTY2OTk5OTg3LCAzNC43MDA3NDUxOTQgXSwgWyAxMzcuNDA1ODMxNjExLCAzNC43MDA3ODUwNTYgXSwgWyAxMzcuNDA1NzU0NzUsIDM0LjcwMDc3NzQ3MiBdLCBbIDEzNy40MDU3NjA1MjgsIDM0LjcwMDczNzc3OCBdLCBbIDEzNy40MDU3OTAxMTA5OTk5ODgsIDM0LjcwMDc0MDc3OCBdLCBbIDEzNy40MDU4MzUxOTQsIDM0LjcwMDQzMDAyOCBdLCBbIDEzNy40MDYwMDU4NTkzNzUsIDM0LjcwMDQ0NjkzNDU1NDY5OCBdLCBbIDEzNy40MDYwNzM2MzksIDM0LjcwMDQ1MzYzOSBdLCBbIDEzNy40MDYwMjg2OTQwMDAwMTQsIDM0LjcwMDc2MzU4MyBdLCBbIDEzNy40MDYwMDU4NTkzNzUsIDM0LjcwMDc2MTM4NDcyNzEwMiBdLCBbIDEzNy40MDU4MzcxNjY5OTk5ODcsIDM0LjcwMDc0NTE5NCBdLCBbIDEzNy40MDU4MzE2MTEsIDM0LjcwMDc4NTA1NiBdLCBbIDEzNy40MDU4MzAyMjIsIDM0LjcwMDc5NDI1IF0sIFsgMTM3LjQwNjAwNTg1OTM3NSwgMzQuNzAwODExNjM4NDI2ODk5IF0sIFsgMTM3LjQwNjA0ODI3Nzk5OTk4NiwgMzQuNzAwODE1ODMzIF0sIFsgMTM3LjQwNjA1NTQ0NCwgMzQuNzAwNzY2MjIyIF0sIFsgMTM3LjQwNjAyODY5NDAwMDAxNCwgMzQuNzAwNzYzNTgzIF0gXSBdIH0gfSwKeyAidHlwZSI6ICJGZWF0dXJlIiwgInByb3BlcnRpZXMiOiB7IH0sICJnZW9tZXRyeSI6IHsgInR5cGUiOiAiUG9seWdvbiIsICJjb29yZGluYXRlcyI6IFsgWyBbIDEzNy40MDgzMzMzMzMsIDM0LjcwMzA4Njc1IF0sIFsgMTM3LjQwODIyOTgwNiwgMzQuNzAzMDc2NTgzIF0sIFsgMTM3LjQwODIxNjc3OCwgMzQuNzAzMTY2NzUgXSwgWyAxMzcuNDA4MzMzMzMzLCAzNC43MDMxNzgyMjIgXSwgWyAxMzcuNDA4MzcyMDI4LCAzNC43MDMxODIwNTYgXSwgWyAxMzcuNDA4MzY3NjM5LCAzNC43MDMyMTI0NDQgXSwgWyAxMzcuNDA4NDQ0MDgzLCAzNC43MDMyMjAwMjggXSwgWyAxMzcuNDA4NDQ4MjUsIDM0LjcwMzE5MDkxNyBdLCBbIDEzNy40MDg3NTI0NDE0MDU5OTQsIDM0LjcwMzIyMDgwOTY4Njc5OCBdLCBbIDEzNy40MDg3Nzg4ODksIDM0LjcwMzIyMzQxNyBdLCBbIDEzNy40MDg3OTIwNTYwMDAwMSwgMzQuNzAzMTMxNzIyIF0sIFsgMTM3LjQwODc1MjQ0MTQwNTk5NCwgMzQuNzAzMTI3ODM0MjA4NDAyIF0sIFsgMTM3LjQwODQyMzE5NCwgMzQuNzAzMDk1NSBdLCBbIDEzNy40MDg0MjYzMDYsIDM0LjcwMzA3Mzc1IF0sIFsgMTM3LjQwODM4NywgMzQuNzAzMDY5ODYxIF0sIFsgMTM3LjQwODM4Mzc3OCwgMzQuNzAzMDkxNjk0IF0sIFsgMTM3LjQwODMzMzMzMywgMzQuNzAzMDg2NzUgXSBdIF0gfSB9LAp7ICJ0eXBlIjogIkZlYXR1cmUiLCAicHJvcGVydGllcyI6IHsgfSwgImdlb21ldHJ5IjogeyAidHlwZSI6ICJQb2x5Z29uIiwgImNvb3JkaW5hdGVzIjogWyBbIFsgMTM3LjQwODMzMzMzMywgMzQuNzAxMjk2Mzg5IF0sIFsgMTM3LjQwODM0ODExMSwgMzQuNzAxMjk3OTE3IF0sIFsgMTM3LjQwODM1NTIyMjAwMDAxMiwgMzQuNzAxMjI3NDE3IF0sIFsgMTM3LjQwODMzMzMzMywgMzQuNzAxMjI0ODA2IF0sIFsgMTM3LjQwODM1NTIyMjAwMDAxMiwgMzQuNzAxMjI3NDE3IF0sIFsgMTM3LjQwODY2NDM2MSwgMzQuNzAxMjY0Mzg5IF0sIFsgMTM3LjQwODY5NDYxMDk5OTk4NywgMzQuNzAxMjY4MDI4IF0sIFsgMTM3LjQwODczOTgwNiwgMzQuNzAxMjczNDQ0IF0sIFsgMTM3LjQwODc1MjQ0MTQwNTk5NCwgMzQuNzAxMjAxMzAxMjMzNzAyIF0sIFsgMTM3LjQwODc2MTkxNywgMzQuNzAxMTQ3MTk0IF0sIFsgMTM3LjQwODc1MjQ0MTQwNTk5NCwgMzQuNzAxMTQ2MDY1NjA0NTk3IF0sIFsgMTM3LjQwODM3NjI1LCAzNC43MDExMDA5NzIgXSwgWyAxMzcuNDA4MzgxNSwgMzQuNzAxMDcwNzc4IF0sIFsgMTM3LjQwODM2MjQ0NCwgMzQuNzAxMDUxMDU2IF0sIFsgMTM3LjQwODMzMzMzMywgMzQuNzAxMDQ3NjExIF0sIFsgMTM3LjQwODMyMjA1NiwgMzQuNzAxMDQ2Mjc4IF0sIFsgMTM3LjQwODI5MTU1NiwgMzQuNzAxMjE5Nzc4IF0sIFsgMTM3LjQwODMxNDQ5OTk5OTk4OSwgMzQuNzAxMjIyNTI4IF0sIFsgMTM3LjQwODMzMzMzMywgMzQuNzAxMjI0ODA2IF0sIFsgMTM3LjQwODMxNDQ5OTk5OTk4OSwgMzQuNzAxMjIyNTI4IF0sIFsgMTM3LjQwODMwNzUsIDM0LjcwMTI5MzY2NyBdLCBbIDEzNy40MDgzMzMzMzMsIDM0LjcwMTI5NjM4OSBdIF0gXSB9IH0sCnsgInR5cGUiOiAiRmVhdHVyZSIsICJwcm9wZXJ0aWVzIjogeyB9LCAiZ2VvbWV0cnkiOiB7ICJ0eXBlIjogIlBvbHlnb24iLCAiY29vcmRpbmF0ZXMiOiBbIFsgWyAxMzcuNDA4MzA5ODg0OTMyODM0LCAzNC43MDExNjU0MTM0ODU2ODMgXSwgWyAxMzcuNDA4MDg0NjI1MTEzODQ0LCAzNC43MDExNDI1MzAzODg4MDcgXSwgWyAxMzcuNDA4MDkwNDUwNzk4ODI0LCAzNC43MDExMDQ3NDY2NTY4ODggXSwgWyAxMzcuNDA4MzEzMTIxNDI0NDcsIDM0LjcwMTEyODY5NDA5NDYxNCBdLCBbIDEzNy40MDgzMDk4ODQ5MzI4MzQsIDM0LjcwMTE2NTQxMzQ4NTY4MyBdIF0gXSB9IH0sCnsgInR5cGUiOiAiRmVhdHVyZSIsICJwcm9wZXJ0aWVzIjogeyB9LCAiZ2VvbWV0cnkiOiB7ICJ0eXBlIjogIlBvbHlnb24iLCAiY29vcmRpbmF0ZXMiOiBbIFsgWyAxMzcuNDA3NTYwMzEzNDY2MjA2LCAzNC43MDExMjA3MTE2MTYxNDkgXSwgWyAxMzcuNDA3NTYzNTQ5OTU3ODQyLCAzNC43MDEwOTMwMzkwMTgxNCBdLCBbIDEzNy40MDc2MzQ3NTI3NzQxNTgsIDM0LjcwMTA5Njc2NDE3NjEgXSwgWyAxMzcuNDA3NjI5NTc0Mzg3NTU2LCAzNC43MDExMjY1NjU0MzM3NjggXSwgWyAxMzcuNDA3NTYwMzEzNDY2MjA2LCAzNC43MDExMjA3MTE2MTYxNDkgXSBdIF0gfSB9LAp7ICJ0eXBlIjogIkZlYXR1cmUiLCAicHJvcGVydGllcyI6IHsgfSwgImdlb21ldHJ5IjogeyAidHlwZSI6ICJQb2x5Z29uIiwgImNvb3JkaW5hdGVzIjogWyBbIFsgMTM3LjQwODI0MTI3MTMwOTgzNCwgMzQuNzAxNTQ0MzE0MDc2NjA3IF0sIFsgMTM3LjQwODAyNzY2Mjg2MDcxOCwgMzQuNzAxNTIxOTYzMjQ3MjEgXSwgWyAxMzcuNDA4MDMyODQxMjQ3NDA1LCAzNC43MDE0ODg5NjkxNTQ2ODEgXSwgWyAxMzcuNDA4MjQ1MTU1MDk5ODIsIDM0LjcwMTUxMDI1NTY2NzQ5MyBdLCBbIDEzNy40MDgyNDEyNzEzMDk4MzQsIDM0LjcwMTU0NDMxNDA3NjYwNyBdIF0gXSB9IH0sCnsgInR5cGUiOiAiRmVhdHVyZSIsICJwcm9wZXJ0aWVzIjogeyB9LCAiZ2VvbWV0cnkiOiB7ICJ0eXBlIjogIlBvbHlnb24iLCAiY29vcmRpbmF0ZXMiOiBbIFsgWyAxMzcuNDA4NzQ1NTE2NzA5MzAzLCAzNC43MDExOTg5Mzk4NzE5OTMgXSwgWyAxMzcuNDA5MDE4Njc2NjA0NzQ1LCAzNC43MDEyMjk4MDU0MjE5NjcgXSwgWyAxMzcuNDA5MDIzODU0OTkxMzc1LCAzNC43MDEyMDIxMzI4NjA0NTIgXSwgWyAxMzcuNDA4NzQ5NDAwNDk5Mjg5LCAzNC43MDExNzIzMzE2Mjk5OTggXSwgWyAxMzcuNDA4NzQ1NTE2NzA5MzAzLCAzNC43MDExOTg5Mzk4NzE5OTMgXSBdIF0gfSB9LAp7ICJ0eXBlIjogIkZlYXR1cmUiLCAicHJvcGVydGllcyI6IHsgfSwgImdlb21ldHJ5IjogeyAidHlwZSI6ICJQb2x5Z29uIiwgImNvb3JkaW5hdGVzIjogWyBbIFsgMTM3LjQwNTM3NjMyODg5OTUzNiwgMzQuNzAyNjk3NTAyMjQ4OTMxIF0sIFsgMTM3LjQwNTY0MzY2MzEwOTk5OCwgMzQuNzAyNzI0NjQyMTU1NDEgXSwgWyAxMzcuNDA1NjU3OTAzNjczMzAxLCAzNC43MDI2MzczNjg2OTkwMTUgXSwgWyAxMzcuNDA1Mzg2Njg1NjcyNzk1LCAzNC43MDI2MTAyMjg3NjM5MjMgXSwgWyAxMzcuNDA1Mzc2MzI4ODk5NTM2LCAzNC43MDI2OTc1MDIyNDg5MzEgXSBdIF0gfSB9LAp7ICJ0eXBlIjogIkZlYXR1cmUiLCAicHJvcGVydGllcyI6IHsgfSwgImdlb21ldHJ5IjogeyAidHlwZSI6ICJQb2x5Z29uIiwgImNvb3JkaW5hdGVzIjogWyBbIFsgMTM3LjQwNTY3Nzk2OTkyMTUyNywgMzQuNzAyNzEyNDAyNTkwODU1IF0sIFsgMTM3LjQwNTY4NjM4NDc5OTgyMiwgMzQuNzAyNjQwMDI5NDc2NDkxIF0sIFsgMTM3LjQwNTg4MTIyMTU5NzI0MSwgMzQuNzAyNjU5MTg3MDcxNzM4IF0sIFsgMTM3LjQwNTg3MjE1OTQyMDY4MiwgMzQuNzAyNzMxNTYwMTY5MzU0IF0sIFsgMTM3LjQwNTY3Nzk2OTkyMTUyNywgMzQuNzAyNzEyNDAyNTkwODU1IF0gXSBdIH0gfSwKeyAidHlwZSI6ICJGZWF0dXJlIiwgInByb3BlcnRpZXMiOiB7IH0sICJnZW9tZXRyeSI6IHsgInR5cGUiOiAiUG9seWdvbiIsICJjb29yZGluYXRlcyI6IFsgWyBbIDEzNy40MDU4OTE1NzgzNzA1NTcsIDM0LjcwMjczNTgxNzQwODQwMyBdLCBbIDEzNy40MDU5MDM4NzcwMzg4MzgsIDM0LjcwMjY2MjkxMjE1OTE5MSBdLCBbIDEzNy40MDYxNjM0NDM2NjkzNTcsIDM0LjcwMjY5MTExNjM4NzMwNyBdLCBbIDEzNy40MDYxNTM3MzQxOTQ0MTksIDM0LjcwMjc2NDAyMTYxMTY3OCBdLCBbIDEzNy40MDU4OTE1NzgzNzA1NTcsIDM0LjcwMjczNTgxNzQwODQwMyBdIF0gXSB9IH0sCnsgInR5cGUiOiAiRmVhdHVyZSIsICJwcm9wZXJ0aWVzIjogeyB9LCAiZ2VvbWV0cnkiOiB7ICJ0eXBlIjogIlBvbHlnb24iLCAiY29vcmRpbmF0ZXMiOiBbIFsgWyAxMzcuNDA2MTg0MTU3MjE1OTMyLCAzNC43MDI3NzYyNjExNjg1ODcgXSwgWyAxMzcuNDA2NDUwODQ0MTI4MDc0LCAzNC43MDI4MDE4MDQ1ODU4ODkgXSwgWyAxMzcuNDA2NDYxODQ4MTk5NzEyLCAzNC43MDI3Mjg4OTkzOTQ4MjggXSwgWyAxMzcuNDA2MTk0NTEzOTg5MTkyLCAzNC43MDI2OTk2MzA4NjkzNzUgXSwgWyAxMzcuNDA2MTg0MTU3MjE1OTMyLCAzNC43MDI3NzYyNjExNjg1ODcgXSBdIF0gfSB9LAp7ICJ0eXBlIjogIkZlYXR1cmUiLCAicHJvcGVydGllcyI6IHsgfSwgImdlb21ldHJ5IjogeyAidHlwZSI6ICJQb2x5Z29uIiwgImNvb3JkaW5hdGVzIjogWyBbIFsgMTM3LjQwNTk2NDA3NTc4MzU0NCwgMzQuNzAyNjAzODQyODk1NTQ5IF0sIFsgMTM3LjQwNjI1NDA2NTQzNTYzMywgMzQuNzAyNjM1NzcyMjMyNDgzIF0sIFsgMTM3LjQwNjI2NjM2NDEwMzkxNCwgMzQuNzAyNTUxMTU5NDYyNjg2IF0sIFsgMTM3LjQwNTk3NzAyMTc1MDE3NSwgMzQuNzAyNTIwODI2NTYxODczIF0sIFsgMTM3LjQwNTk2NDA3NTc4MzU0NCwgMzQuNzAyNjAzODQyODk1NTQ5IF0gXSBdIH0gfSwKeyAidHlwZSI6ICJGZWF0dXJlIiwgInByb3BlcnRpZXMiOiB7IH0sICJnZW9tZXRyeSI6IHsgInR5cGUiOiAiUG9seWdvbiIsICJjb29yZGluYXRlcyI6IFsgWyBbIDEzNy40MDU2NjExNDAxNjQ5MzgsIDM0LjcwMjU2OTc4NDkyMjU2NiBdLCBbIDEzNy40MDU5MjQ1OTA1ODU0NDMsIDM0LjcwMjU5NTg2MDU1OTM5OCBdLCBbIDEzNy40MDU5MzM2NTI3NjIwNTksIDM0LjcwMjUxOTIzMDA5MzExIF0sIFsgMTM3LjQwNTY3MTQ5NjkzODIyNiwgMzQuNzAyNDkzMTU0NDMyMTI2IF0sIFsgMTM3LjQwNTY2MTE0MDE2NDkzOCwgMzQuNzAyNTY5Nzg0OTIyNTY2IF0gXSBdIH0gfSwKeyAidHlwZSI6ICJGZWF0dXJlIiwgInByb3BlcnRpZXMiOiB7IH0sICJnZW9tZXRyeSI6IHsgInR5cGUiOiAiUG9seWdvbiIsICJjb29yZGluYXRlcyI6IFsgWyBbIDEzNy40MDUzNjMzODI5MzI5MDQsIDM0LjcwMjUyOTM0MTA2MTQ1NyBdLCBbIDEzNy40MDU2MzUyNDgyMzE3MzIsIDM0LjcwMjU1NzAxMzE3OTA4OSBdLCBbIDEzNy40MDU2NDc1NDY5MDAwMTMsIDM0LjcwMjQ4NTE3MjA4NTMwNCBdLCBbIDEzNy40MDUzNzYzMjg4OTk1MzYsIDM0LjcwMjQ1Njk2Nzc4Njk3MiBdLCBbIDEzNy40MDUzNjMzODI5MzI5MDQsIDM0LjcwMjUyOTM0MTA2MTQ1NyBdIF0gXSB9IH0sCnsgInR5cGUiOiAiRmVhdHVyZSIsICJwcm9wZXJ0aWVzIjogeyB9LCAiZ2VvbWV0cnkiOiB7ICJ0eXBlIjogIlBvbHlnb24iLCAiY29vcmRpbmF0ZXMiOiBbIFsgWyAxMzcuNDExOTMwNzk5NzI0NjE1LCAzNC42OTk5NzYzNDIyMDUyNjEgXSwgWyAxMzcuNDEyMjEwMTYxMTY1NzQ2LCAzNC42OTk4OTg5NTE1NDE4NjEgXSwgWyAxMzcuNDEyMTg1ODY4ODY2NDg3LCAzNC42OTk4MzY1Mzk2NjM4MzUgXSwgWyAxMzcuNDExOTA0OTg5MTU2NzEsIDM0LjY5OTkxNjQyNjg1OTI4OSBdLCBbIDEzNy40MTE5MzA3OTk3MjQ2MTUsIDM0LjY5OTk3NjM0MjIwNTI2MSBdIF0gXSB9IH0sCnsgInR5cGUiOiAiRmVhdHVyZSIsICJwcm9wZXJ0aWVzIjogeyB9LCAiZ2VvbWV0cnkiOiB7ICJ0eXBlIjogIlBvbHlnb24iLCAiY29vcmRpbmF0ZXMiOiBbIFsgWyAxMzcuNDA0NTQxMzg1OTU0MjQ2LCAzNC43MDE2NDM5Njg1OTI4OTcgXSwgWyAxMzcuNDA0NTQ5NzM2NDMyMTMxLCAzNC43MDE1ODk2NzE0MDY3NzIgXSwgWyAxMzcuNDA0NTA3MjI0OTA4NDU3LCAzNC43MDE1ODQ2Nzg1NjAyODggXSwgWyAxMzcuNDA0NDk5NjMzNTY0OTY3LCAzNC43MDE2Mzk1OTk4NTUwOTkgXSwgWyAxMzcuNDA0NTQxMzg1OTU0MjQ2LCAzNC43MDE2NDM5Njg1OTI4OTcgXSBdIF0gfSB9LAp7ICJ0eXBlIjogIkZlYXR1cmUiLCAicHJvcGVydGllcyI6IHsgfSwgImdlb21ldHJ5IjogeyAidHlwZSI6ICJQb2x5Z29uIiwgImNvb3JkaW5hdGVzIjogWyBbIFsgMTM3LjQwNDUyMjAyODAyODI4MiwgMzQuNzAxNTEzODQyNTE4MjYgXSwgWyAxMzcuNDA0NTE0NDM2Njg0NzkyLCAzNC43MDE1NTEyODg4OTE2NSBdLCBbIDEzNy40MDQ1NTU0Mjk5Mzk2NzcsIDM0LjcwMTU1NzUyOTk1MjIyNSBdLCBbIDEzNy40MDQ1NzY2ODU3MDE1MjgsIDM0LjcwMTQ0MjY5NDM2MjE1IF0sIFsgMTM3LjQwNDQ4NDA3MTMxMDc0OCwgMzQuNzAxNDI4OTY0MDA5MTg5IF0sIFsgMTM3LjQwNDQ3MDQwNjg5MjQ0MywgMzQuNzAxNTA3NjAxNDU0Mzg4IF0sIFsgMTM3LjQwNDUyMjAyODAyODI4MiwgMzQuNzAxNTEzODQyNTE4MjYgXSBdIF0gfSB9LAp7ICJ0eXBlIjogIkZlYXR1cmUiLCAicHJvcGVydGllcyI6IHsgfSwgImdlb21ldHJ5IjogeyAidHlwZSI6ICJQb2x5Z29uIiwgImNvb3JkaW5hdGVzIjogWyBbIFsgMTM3LjQwOTkyNzQ0NDE3MjkyMiwgMzQuNzAyOTU5ODg0MzI3OTYgXSwgWyAxMzcuNDA5OTM5NzgwMTA2MTI5LCAzNC43MDI4NzY1Njc1NDI1MzIgXSwgWyAxMzcuNDEwMDIxNTc2ODMyNDYzLCAzNC43MDI4ODM3NDQ2NDcyMSBdLCBbIDEzNy40MTAwMzU0MzEwMzQzMTYsIDM0LjcwMjc5MjMxNDUyODEzMiBdLCBbIDEzNy40MTAzMjIxOTQwMzUzNTksIDM0LjcwMjgyMTMzNTAyMDU2NiBdLCBbIDEzNy40MTAzMDA5MzgyNzM1MzcsIDM0LjcwMjk1NzM4Nzk0NjEgXSwgWyAxMzcuNDEwMjQ0MTkyOTgwODI2LCAzNC43MDI5NTE3NzEwODY2MzIgXSwgWyAxMzcuNDEwMjM4Njg5MjU2NzQ0LCAzNC43MDI5ODk4NDA5MDQ0NzIgXSwgWyAxMzcuNDA5OTI3NDQ0MTcyOTIyLCAzNC43MDI5NTk4ODQzMjc5NiBdIF0gXSB9IH0sCnsgInR5cGUiOiAiRmVhdHVyZSIsICJwcm9wZXJ0aWVzIjogeyB9LCAiZ2VvbWV0cnkiOiB7ICJ0eXBlIjogIlBvbHlnb24iLCAiY29vcmRpbmF0ZXMiOiBbIFsgWyAxMzcuNDEwMTU2ODkyNTMwNDA5LCAzNC43MDMxNjczOTU4MDcwODUgXSwgWyAxMzcuNDEwMTgyNzAzMDk4MzcxLCAzNC43MDI5ODQ0ODczMzY2NDMgXSwgWyAxMzcuNDEwMjE0NTg2NzQxMDkxLCAzNC43MDI5ODc2MDc4MTM0ODMgXSwgWyAxMzcuNDEwMTg5NTM1MzA3NTI0LCAzNC43MDMxNzA1MTYyNzY0OTQgXSwgWyAxMzcuNDEwMTU2ODkyNTMwNDA5LCAzNC43MDMxNjczOTU4MDcwODUgXSBdIF0gfSB9LAp7ICJ0eXBlIjogIkZlYXR1cmUiLCAicHJvcGVydGllcyI6IHsgfSwgImdlb21ldHJ5IjogeyAidHlwZSI6ICJQb2x5Z29uIiwgImNvb3JkaW5hdGVzIjogWyBbIFsgMTM3LjQwNjU2NjI3NzQxNTUyMSwgMzQuNzAxMjQzNTk3NjU5NjI3IF0sIFsgMTM3LjQwNjYwMTg1MjU4NjY0NywgMzQuNzAxMDE3NzQxODQ3MDUzIF0sIFsgMTM3LjQwNjY4MTg5NjcyMTY5MywgMzQuNzAxMDI1MDUzNzM1NTM1IF0sIFsgMTM3LjQwNjY0ODI5Nzk0ODk3NiwgMzQuNzAxMjUwOTA5NTI4MTYzIF0sIFsgMTM3LjQwNjU2NjI3NzQxNTUyMSwgMzQuNzAxMjQzNTk3NjU5NjI3IF0gXSBdIH0gfSwKeyAidHlwZSI6ICJGZWF0dXJlIiwgInByb3BlcnRpZXMiOiB7IH0sICJnZW9tZXRyeSI6IHsgInR5cGUiOiAiUG9seWdvbiIsICJjb29yZGluYXRlcyI6IFsgWyBbIDEzNy40MDk3MjgwNzEzNjM4MTYsIDM0LjcwMDc4MjMyMjg1MTUzMSBdLCBbIDEzNy40MDk3NjA0NDUwOTM2OTYsIDM0LjcwMDc4NTQ5ODgyMjAyOSBdLCBbIDEzNy40MDk3Njk0NDE3MDg5MDMsIDM0LjcwMDcyNzQ5ODI1ODk0OSBdLCBbIDEzNy40MDk3MzYyNTAyMjUxNjYsIDM0LjcwMDcyMzk3MTc2NzUzOCBdLCBbIDEzNy40MDk3MjgwNzEzNjM4MTYsIDM0LjcwMDc4MjMyMjg1MTUzMSBdIF0gXSB9IH0KXQp9Cg==", DN = "data:application/geo+json;base64,ewoidHlwZSI6ICJGZWF0dXJlQ29sbGVjdGlvbiIsCiJuYW1lIjogInN0cmVldHNfb3JpZ2luYWwiLAoiY3JzIjogeyAidHlwZSI6ICJuYW1lIiwgInByb3BlcnRpZXMiOiB7ICJuYW1lIjogInVybjpvZ2M6ZGVmOmNyczpPR0M6MS4zOkNSUzg0IiB9IH0sCiJmZWF0dXJlcyI6IFsKeyAidHlwZSI6ICJGZWF0dXJlIiwgInByb3BlcnRpZXMiOiB7IH0sICJnZW9tZXRyeSI6IHsgInR5cGUiOiAiTXVsdGlQb2x5Z29uIiwgImNvb3JkaW5hdGVzIjogWyBbIFsgWyAxMzcuNDA1MDIxOTE3LCAzNC42OTc2MDI3NzggXSwgWyAxMzcuNDA1MDEwOTE3LCAzNC42OTc2MDk4MDYgXSwgWyAxMzcuNDA1MDQ1NjY3LCAzNC42OTc2NjA2OTQgXSwgWyAxMzcuNDA1MDYxNTU2LCAzNC42OTc2NDEyNzggXSwgWyAxMzcuNDA1MDcyMTk0MDAwMDEzLCAzNC42OTc2MjA5NzIgXSwgWyAxMzcuNDA1MDc3NTgzLCAzNC42OTc1OTk3NzggXSwgWyAxMzcuNDA1MDc4NDYzMjg0MDEzLCAzNC42OTc1OTAyNTYzMzA0IF0sIFsgMTM3LjQwNTAzMjk3MjYxNTAwNCwgMzQuNjk3NTkwMjU2MzMwNCBdLCBbIDEzNy40MDUwMzA0MTcsIDM0LjY5NzU5NDYzOSBdLCBbIDEzNy40MDUwMjE5MTcsIDM0LjY5NzYwMjc3OCBdIF0gXSwgWyBbIFsgMTM3LjQwMTg4NTk4NjMyODAxMSwgMzQuNjk3NzYwMDUxMDAxMTk3IF0sIFsgMTM3LjQwMTg4NTk4NjMyODAxMSwgMzQuNjk3NzkyOTU3MTM3NTAxIF0sIFsgMTM3LjQwMTk3NjAyOCwgMzQuNjk3NzcwNzc4IF0sIFsgMTM3LjQwMjM3MTI0OTk5OTk4NywgMzQuNjk3NjgwODYxIF0sIFsgMTM3LjQwMjUwNjA4MywgMzQuNjk3NjYwNjY3IF0sIFsgMTM3LjQwMzAwNzYxMSwgMzQuNjk3NjAyODg5IF0sIFsgMTM3LjQwMzExMTY2NDQzNjAxMSwgMzQuNjk3NTkwMjU2MzMwNCBdLCBbIDEzNy40MDI4NDExMzQ0MjYwMTIsIDM0LjY5NzU5MDI1NjMzMDQgXSwgWyAxMzcuNDAyNjY3OTQ0LCAzNC42OTc2MTAyMjIgXSwgWyAxMzcuNDAyNjYzNTU2LCAzNC42OTc2MDc3MjIgXSwgWyAxMzcuNDAyNjU5NzUsIDM0LjY5NzYwNDkxNyBdLCBbIDEzNy40MDI2NTYzMzMwMDAwMSwgMzQuNjk3NjAxODYxIF0sIFsgMTM3LjQwMjY1MzUwMDAwMDAxNCwgMzQuNjk3NTk4NTI4IF0sIFsgMTM3LjQwMjY1MTE5Mzk5OTk4NiwgMzQuNjk3NTk0OTQ0IF0sIFsgMTM3LjQwMjY0OTMzMywgMzQuNjk3NTkxMDU2IF0sIFsgMTM3LjQwMjY0OTE1MjY4NTAwMSwgMzQuNjk3NTkwMjU2MzMwNCBdLCBbIDEzNy40MDI2MTg2MDMyNzYwMTEsIDM0LjY5NzU5MDI1NjMzMDQgXSwgWyAxMzcuNDAyNjE5NDE3MDAwMDExLCAzNC42OTc1OTM1NTYgXSwgWyAxMzcuNDAyNjE5NjY3MDAwMDEsIDM0LjY5NzU5NzUyOCBdLCBbIDEzNy40MDI2MTkzMzMsIDM0LjY5NzYwMTMwNiBdLCBbIDEzNy40MDI2MTgzNjEsIDM0LjY5NzYwNDkxNyBdLCBbIDEzNy40MDI2MTY1MjgwMDAwMSwgMzQuNjk3NjA5MTY3IF0sIFsgMTM3LjQwMjYxMzgwNiwgMzQuNjk3NjEzMTM5IF0sIFsgMTM3LjQwMjYxMDIyMiwgMzQuNjk3NjE2ODMzIF0sIFsgMTM3LjQwMjUwMDExMSwgMzQuNjk3NjI5NTgzIF0sIFsgMTM3LjQwMjM2Mjc1LCAzNC42OTc2NTAwMjggXSwgWyAxMzcuNDAxOTY1ODg5LCAzNC42OTc3NDA0MTcgXSwgWyAxMzcuNDAxODg1OTg2MzI4MDExLCAzNC42OTc3NjAwNTEwMDExOTcgXSBdIF0sIFsgWyBbIDEzNy40MDI1NjkyNSwgMzQuNjk4MjkzNzc4IF0sIFsgMTM3LjQwMjQ0NDQ3MjAwMDAxMywgMzQuNjk4MjkwMjIyIF0sIFsgMTM3LjQwMjM1NTI1LCAzNC42OTgyODIyNzggXSwgWyAxMzcuNDAyMjc2MzA2LCAzNC42OTgyNzE1MjggXSwgWyAxMzcuNDAyMjA0NDQ0LCAzNC42OTgyNTgxMzkgXSwgWyAxMzcuNDAyMTQ0Mjc4LCAzNC42OTgyNDMxOTQgXSwgWyAxMzcuNDAyMDg0Mzg5LCAzNC42OTgyMjU2NjcgXSwgWyAxMzcuNDAyMDE0MTM4OTk5OTg4LCAzNC42OTgxOTk5MTcgXSwgWyAxMzcuNDAxODg1OTg2MzI4MDExLCAzNC42OTgxNDkzNjk2MDI2MDQgXSwgWyAxMzcuNDAxODg1OTg2MzI4MDExLCAzNC42OTgxNzkyNjA5MDEgXSwgWyAxMzcuNDAyMDAwNTU2LCAzNC42OTgyMjQ0NzIgXSwgWyAxMzcuNDAyMDcyMjUsIDM0LjY5ODI1MDgzMyBdLCBbIDEzNy40MDIxMzQxOTQwMDAwMTMsIDM0LjY5ODI2OSBdLCBbIDEzNy40MDIxOTYxMTEsIDM0LjY5ODI4NDMwNiBdLCBbIDEzNy40MDIyNzAwNTYsIDM0LjY5ODI5ODEzOSBdLCBbIDEzNy40MDIzNTA4NjEsIDM0LjY5ODMwOTA1NiBdLCBbIDEzNy40MDI0NDIwMjgsIDM0LjY5ODMxNzE5NCBdLCBbIDEzNy40MDI1NjkxOTQsIDM0LjY5ODMyMDgwNiBdLCBbIDEzNy40MDI2Njg3NSwgMzQuNjk4MzE5IF0sIFsgMTM3LjQwMjc0NiwgMzQuNjk4MzExNTU2IF0sIFsgMTM3LjQwMjg1ODUsIDM0LjY5ODI5Nzg4OSBdLCBbIDEzNy40MDI5NjQ4ODksIDM0LjY5ODI3NzUgXSwgWyAxMzcuNDAzMDYwODYxLCAzNC42OTgyNTI5NzIgXSwgWyAxMzcuNDAzMTY1NDQ0LCAzNC42OTgyMTk4NjEgXSwgWyAxMzcuNDAzMjU5Mjc3MzQ0MDA2LCAzNC42OTgxODMxMzU0NDU2MDMgXSwgWyAxMzcuNDAzMjY4MTY3LCAzNC42OTgxNzk2MzkgXSwgWyAxMzcuNDAzNDQ5NjM5LCAzNC42OTgwOTIyNzggXSwgWyAxMzcuNDAzNjQ3MDgzMDAwMDEsIDM0LjY5Nzk3MDQ3MiBdLCBbIDEzNy40MDQwMDgzMDYsIDM0LjY5Nzc0NjgzMyBdLCBbIDEzNy40MDQyNDQzOTA5MzQ5OTEsIDM0LjY5NzU5MDI1NjMzMDQgXSwgWyAxMzcuNDA0MTkyMTA1NTEwOTg3LCAzNC42OTc1OTAyNTYzMzA0IF0sIFsgMTM3LjQwMzk4ODE2NywgMzQuNjk3NzI1NSBdLCBbIDEzNy40MDM2Mjc2MTEsIDM0LjY5Nzk0ODc3OCBdLCBbIDEzNy40MDM0MzE1ODMwMDAwMTQsIDM0LjY5ODA2OTY5NCBdLCBbIDEzNy40MDMyNTkyNzczNDQwMDYsIDM0LjY5ODE1MjYyODMyMjI5OCBdLCBbIDEzNy40MDMyNTI5MTcsIDM0LjY5ODE1NTY5NCBdLCBbIDEzNy40MDMxNTI1LCAzNC42OTgxOTUgXSwgWyAxMzcuNDAzMDUwMDgzMDAwMDExLCAzNC42OTgyMjczODkgXSwgWyAxMzcuNDAyOTU2Mzg5LCAzNC42OTgyNTEzNjEgXSwgWyAxMzcuNDAyODUyNDQ0LCAzNC42OTgyNzEzMDYgXSwgWyAxMzcuNDAyNzQxNjY2OTk5OTg3LCAzNC42OTgyODQ2OTQgXSwgWyAxMzcuNDAyNjY2NSwgMzQuNjk4MjkxOTcyIF0sIFsgMTM3LjQwMjU2OTI1LCAzNC42OTgyOTM3NzggXSBdIF0sIFsgWyBbIDEzNy40MTU2MTg4OTY0ODQwMDYsIDM0LjY5NzgxODY2ODg0IF0sIFsgMTM3LjQxNTYxODg5NjQ4NDAwNiwgMzQuNjk3Nzk0MzUyOTE3Mzk4IF0sIFsgMTM3LjQxNTQ3MjIyMiwgMzQuNjk3Nzk2ODA2IF0sIFsgMTM3LjQxNTMyOTU1NTk5OTk4OSwgMzQuNjk3NzkyMTM5IF0sIFsgMTM3LjQxNTI2NjU1NiwgMzQuNjk3NzgzNzc4IF0sIFsgMTM3LjQxNTIyNjQ3MiwgMzQuNjk3Nzc1OTQ0IF0sIFsgMTM3LjQxNTE5NTg2MSwgMzQuNjk3NzY0OTE3IF0sIFsgMTM3LjQxNTE1NDYzOSwgMzQuNjk3NzQwODMzIF0sIFsgMTM3LjQxNTEyNjA4MywgMzQuNjk3NzE1NzUgXSwgWyAxMzcuNDE1MDk2MzA2LCAzNC42OTc2ODQ2OTQgXSwgWyAxMzcuNDE1MDQ2NDcyLCAzNC42OTc2Mjg5MTcgXSwgWyAxMzcuNDE1MDI5NTgzLCAzNC42OTc2MDAwODMgXSwgWyAxMzcuNDE1MDI1MzkyOTU3MDA2LCAzNC42OTc1OTAyNTYzMzA0IF0sIFsgMTM3LjQxNDk5NDI1NDI0OTk5LCAzNC42OTc1OTAyNTYzMzA0IF0sIFsgMTM3LjQxNTAwMjE5NDAwMDAxLCAzNC42OTc2MDk0NDQgXSwgWyAxMzcuNDE1MDIxMTk0LCAzNC42OTc2NDE1ODMgXSwgWyAxMzcuNDE1MDczMDgzMDAwMDEsIDM0LjY5NzY5OTcyMiBdLCBbIDEzNy40MTUxMDM3NDk5OTk5ODYsIDM0LjY5NzczMTU1NiBdLCBbIDEzNy40MTUxMzUyNzgsIDM0LjY5Nzc1OTI1IF0sIFsgMTM3LjQxNTE4MTMwNiwgMzQuNjk3Nzg2MjIyIF0sIFsgMTM3LjQxNTIxNzEzOSwgMzQuNjk3Nzk5MTExIF0sIFsgMTM3LjQxNTI2MDgzMywgMzQuNjk3ODA3Njk0IF0sIFsgMTM3LjQxNTMyNjU4MywgMzQuNjk3ODE2Mzg5IF0sIFsgMTM3LjQxNTQ3MTk3MiwgMzQuNjk3ODIxMTM5IF0sIFsgMTM3LjQxNTYxODg5NjQ4NDAwNiwgMzQuNjk3ODE4NjY4ODQgXSBdIF0sIFsgWyBbIDEzNy40MTU2MTg4OTY0ODQwMDYsIDM0LjcwMDM1ODc0MDQ2NTQ5NyBdLCBbIDEzNy40MTU2MTg4OTY0ODQwMDYsIDM0LjcwMDMzMDg4NTA5OTM5NyBdLCBbIDEzNy40MTU0MTMyNzc5OTk5ODgsIDM0LjcwMDIzNjI1IF0sIFsgMTM3LjQxNTM5ODk0NCwgMzQuNzAwMjU3NTU2IF0sIFsgMTM3LjQxNTYxODg5NjQ4NDAwNiwgMzQuNzAwMzU4NzQwNDY1NDk3IF0gXSBdLCBbIFsgWyAxMzcuNDE1NjA2NzgwNDM1MDEzLCAzNC43MDA5Nzc0MTQ3MjAxIF0sIFsgMTM3LjQxNTUyNDcyMTk5OTk4NiwgMzQuNzAxMDM3MTk0IF0sIFsgMTM3LjQxNTM2MDkxNjk5OTk4NywgMzQuNzAxMTYyNTU2IF0sIFsgMTM3LjQxNTM4MzE2Njk5OTk4NywgMzQuNzAxMTE4NjExIF0sIFsgMTM3LjQxNTQ1NTA4MzAwMDAxMiwgMzQuNzAxMDAxMzYxIF0sIFsgMTM3LjQxNTQ2Nzg3NzAxMTk5MiwgMzQuNzAwOTc3NDE0NzIwMSBdLCBbIDEzNy40MTU1MDMzODksIDM0LjcwMDkxMTE5NCBdLCBbIDEzNy40MTU1NDk3NzgwMDAwMTMsIDM0LjcwMDgzNjkxNyBdLCBbIDEzNy40MTU1NzQ1NTYsIDM0LjcwMDgwMTA4MyBdLCBbIDEzNy40MTU2MTg4OTY0ODQwMDYsIDM0LjcwMDczMTg1NzQxNTM5OCBdLCBbIDEzNy40MTU2MTg4OTY0ODQwMDYsIDM0LjcwMDY2NjM4NzAxNzQ5OSBdLCBbIDEzNy40MTU2MTYwODMsIDM0LjcwMDY3MDcyMiBdLCBbIDEzNy40MTU1NDE3NzgsIDM0LjcwMDc4NjcyMiBdLCBbIDEzNy40MTU1MjIzMDYwMDAwMTQsIDM0LjcwMDgxNjUgXSwgWyAxMzcuNDE1NDczNzc4LCAzNC43MDA5MDI3NzggXSwgWyAxMzcuNDE1NDMzMzg4OTk5OTg2LCAzNC43MDA5NzAwMjggXSwgWyAxMzcuNDE1NDI3NTUyMzIzOTksIDM0LjcwMDk3NzQxNDcyMDEgXSwgWyAxMzcuNDE1NDA2MzA2LCAzNC43MDEwMDQ1MjggXSwgWyAxMzcuNDE1MzY3MjIxOTk5OTg2LCAzNC43MDEwNDA5NDQgXSwgWyAxMzcuNDE1MzMxNTgzMDAwMDExLCAzNC43MDEwOTg5NzIgXSwgWyAxMzcuNDE1MzA4NDcyLCAzNC43MDExNDQ0NzIgXSwgWyAxMzcuNDE1MzA3NDQ0LCAzNC43MDExNjYzNjEgXSwgWyAxMzcuNDE1MjkxMTEwOTk5OTg4LCAzNC43MDEyMTQwODMgXSwgWyAxMzcuNDE1MjM0ODA2LCAzNC43MDEyNTQ4NjEgXSwgWyAxMzcuNDE1MTExOTQzOTk5OTg5LCAzNC43MDEzNDgwNTYgXSwgWyAxMzcuNDE1MDk0OTE3LCAzNC43MDEzNDkzNjEgXSwgWyAxMzcuNDE1MDYxMzA2MDAwMDEzLCAzNC43MDEzNTE3NzggXSwgWyAxMzcuNDE0NzYzNjY2OTk5OTg4LCAzNC43MDEyMTUyNSBdLCBbIDEzNy40MTQ3MjM3NSwgMzQuNzAxMTk2OTQ0IF0sIFsgMTM3LjQxNDU3NzYzODk5OTk4NywgMzQuNzAxMTMyODg5IF0sIFsgMTM3LjQxNDQxOTU4MzAwMDAxMSwgMzQuNzAxMDYzNjExIF0sIFsgMTM3LjQxNDM5ODcyMTk5OTk4NywgMzQuNzAxMDIxNzIyIF0sIFsgMTM3LjQxNDQwNDgzNjAxNCwgMzQuNzAwOTc3NDE0NzIwMSBdLCBbIDEzNy40MTQ0MDU3NDk5OTk5ODYsIDM0LjcwMDk3MDQxNyBdLCBbIDEzNy40MTQ0NDMxNjcsIDM0LjcwMDg0MzY2NyBdLCBbIDEzNy40MTQ0NjgwNTYsIDM0LjcwMDczMzgwNiBdLCBbIDEzNy40MTQ0ODQwMjgsIDM0LjcwMDY0MjkxNyBdLCBbIDEzNy40MTQ0OTIzODksIDM0LjcwMDU4NTAyOCBdLCBbIDEzNy40MTQ1MDI0NzIsIDM0LjcwMDQ4OTM2MSBdLCBbIDEzNy40MTQ1MDk2OTQsIDM0LjcwMDQyMSBdLCBbIDEzNy40MTQ1MTg0NzIsIDM0LjcwMDI1MzAyOCBdLCBbIDEzNy40MTQ1MjU3NSwgMzQuNzAwMTc1MDI4IF0sIFsgMTM3LjQxNDUzMDgzMjk5OTk4NiwgMzQuNzAwMTIwMjIyIF0sIFsgMTM3LjQxNDU2OTMzMywgMzQuNzAwMTExMDI4IF0sIFsgMTM3LjQxNDU5MDgzMywgMzQuNzAwMTA1MzA2IF0sIFsgMTM3LjQxNDYxNjU1NiwgMzQuNzAwMDkxODA2IF0sIFsgMTM3LjQxNDYzMjExMSwgMzQuNzAwMDc3NzIyIF0sIFsgMTM3LjQxNDY2MTkxNjk5OTk4OSwgMzQuNzAwMDQ2Mzg5IF0sIFsgMTM3LjQxNDcwMDkxNywgMzQuNyBdLCBbIDEzNy40MTQ3MDMzNjEsIDM0LjY5OTk5NzA4MyBdLCBbIDEzNy40MTQ3NzAxNjcsIDM0LjY5OTg4MTgwNiBdLCBbIDEzNy40MTQ3OTE3MzgwNzIwMTIsIDM0LjY5OTg0ODM3NzMyODg5OCBdLCBbIDEzNy40MTQ5MiwgMzQuNjk5NjQ5NDQ0IF0sIFsgMTM3LjQxNDk0NDgzMywgMzQuNjk5NTk1NSBdLCBbIDEzNy40MTUwMjc1MjgsIDM0LjY5OTQ3NjMzMyBdLCBbIDEzNy40MTUwNDUxOTM5OTk5ODcsIDM0LjY5OTQ2ODgwNiBdLCBbIDEzNy40MTUxNTk5NDQwMDAwMSwgMzQuNjk5NTE2NzIyIF0sIFsgMTM3LjQxNTUyNDY2NywgMzQuNjk5NjY5MDU2IF0sIFsgMTM3LjQxNTYxODg5NjQ4NDAwNiwgMzQuNjk5NzA5MjAzNjAwNDk5IF0sIFsgMTM3LjQxNTYxODg5NjQ4NDAwNiwgMzQuNjk5NjY0NTE3MTU4NDAzIF0sIFsgMTM3LjQxNTU0NzUsIDM0LjY5OTYzNDExMSBdLCBbIDEzNy40MTUwMTY2Mzg5OTk5ODcsIDM0LjY5OTQxMjQ0NCBdLCBbIDEzNy40MTQ4NzYxNjY5OTk5ODksIDM0LjY5OTYzMzA1NiBdLCBbIDEzNy40MTQ3MzczNTM4NTA5OTUsIDM0LjY5OTg0ODM3NzMyODg5OCBdLCBbIDEzNy40MTQ3MjczMDYsIDM0LjY5OTg2Mzk3MiBdLCBbIDEzNy40MTQ2NTMxNjcwMDAwMTIsIDM0LjY5OTk2MzU1NiBdLCBbIDEzNy40MTQ2MjI2NjcsIDM0LjcgXSwgWyAxMzcuNDE0NjExMDgzMDAwMDExLCAzNC43MDAwMTM4NjEgXSwgWyAxMzcuNDE0NTgzLCAzNC43MDAwNDMzMDYgXSwgWyAxMzcuNDE0NTgwMjc3OTk5OTg4LCAzNC43MDAwNDU3MjIgXSwgWyAxMzcuNDE0NTc0ODMyOTk5OTg5LCAzNC43MDAwNTA2OTQgXSwgWyAxMzcuNDE0NTYzMjc4LCAzNC43MDAwNTY3NzggXSwgWyAxMzcuNDE0NTUwNjM5LCAzNC43MDAwNjAxMzkgXSwgWyAxMzcuNDE0NTM2MjIyMDAwMDEsIDM0LjcwMDA2MzU4MyBdLCBbIDEzNy40MTQ1NDIxNjcsIDM0LjcgXSwgWyAxMzcuNDE0NTUxNDcyLCAzNC42OTk5MDAxMTEgXSwgWyAxMzcuNDE0NTU2NjEzOTM4MDA0LCAzNC42OTk4NDgzNzczMjg4OTggXSwgWyAxMzcuNDE0NTgwODMzLCAzNC42OTk2MDUwODMgXSwgWyAxMzcuNDE0NTkwNzUsIDM0LjY5OTUxOCBdLCBbIDEzNy40MTQ2MDAyNzgsIDM0LjY5OTQzNDQxNyBdLCBbIDEzNy40MTQ2NDE5NzIsIDM0LjY5OTA2ODU1NiBdLCBbIDEzNy40MTQ2NTIwODMsIDM0LjY5OTAxNzIyMiBdLCBbIDEzNy40MTQ2NjYzODksIDM0LjY5ODk3NTkxNyBdLCBbIDEzNy40MTQ2NzY5MTcsIDM0LjY5ODk2MDMwNiBdLCBbIDEzNy40MTQ2ODc2NjcwMDAwMSwgMzQuNjk4OTQ0ODYxIF0sIFsgMTM3LjQxNDY5ODU1NiwgMzQuNjk4OTI5NDE3IF0sIFsgMTM3LjQxNDcwNjI3ODAwMDAxMSwgMzQuNjk4OTE4NTgzIF0sIFsgMTM3LjQxNDcxNDE5NCwgMzQuNjk4OTA3ODMzIF0sIFsgMTM3LjQxNDcyMjQ3MiwgMzQuNjk4ODk3Mjc4IF0sIFsgMTM3LjQxNDczMjY5NCwgMzQuNjk4ODg1MDgzIF0sIFsgMTM3LjQxNDc0MzU4Mjk5OTk4OSwgMzQuNjk4ODczMzMzIF0sIFsgMTM3LjQxNDc1NTQ0NCwgMzQuNjk4ODYyMjIyIF0sIFsgMTM3LjQxNDc2MzcyMiwgMzQuNjk4ODU1Mjc4IF0sIFsgMTM3LjQxNDc3MjMwNiwgMzQuNjk4ODQ4NSBdLCBbIDEzNy40MTQ3ODEwMjgsIDM0LjY5ODg0MTg4OSBdLCBbIDEzNy40MTQ4MDUwODMsIDM0LjY5ODgyNCBdLCBbIDEzNy40MTQ4MjkxNjcsIDM0LjY5ODgwNjE5NCBdLCBbIDEzNy40MTQ4NTMzMzMsIDM0LjY5ODc4ODM4OSBdLCBbIDEzNy40MTQ5OTc4OTE4ODYwMDMsIDM0LjY5ODcxOTMyNDUzMjI5OCBdLCBbIDEzNy40MTUxNTE2NjcsIDM0LjY5ODY0NTg2MSBdLCBbIDEzNy40MTU2MTg4OTY0ODQwMDYsIDM0LjY5ODQyNzk5MzI4OTMgXSwgWyAxMzcuNDE1NjE4ODk2NDg0MDA2LCAzNC42OTgzNDM3NDYzMDA0MDIgXSwgWyAxMzcuNDE1NTg5OTQ0LCAzNC42OTgzNTY3NSBdLCBbIDEzNy40MTUzODM3NzgsIDM0LjY5ODQ0MzE5NCBdLCBbIDEzNy40MTUwODU0MTcsIDM0LjY5ODU2ODE5NCBdLCBbIDEzNy40MTQ3NjkwOTU5OTIsIDM0LjY5ODcxOTMyNDUzMjI5OCBdLCBbIDEzNy40MTQ3MTkwNTYsIDM0LjY5ODc0MzIyMiBdLCBbIDEzNy40MTQ2ODk3NSwgMzQuNjk4NzI2NTgzIF0sIFsgMTM3LjQxNDY5MTE5ODUxNzAwNSwgMzQuNjk4NzE5MzI0NTMyMjk4IF0sIFsgMTM3LjQxNDc3NTU4MywgMzQuNjk4Mjk2NTgzIF0sIFsgMTM3LjQxNDc3NjIyMiwgMzQuNjk4MjkzNzc4IF0sIFsgMTM3LjQxNDgyMzc1MDAwMDAxMSwgMzQuNjk4MDU1NSBdLCBbIDEzNy40MTQ4MzE2MTEwMDAwMTEsIDM0LjY5ODAxNzM2MSBdLCBbIDEzNy40MTQ4MzczMDYwMDAwMSwgMzQuNjk3OTg4OTQ0IF0sIFsgMTM3LjQxNDg5NTgzMywgMzQuNjk3NzAyNjk0IF0sIFsgMTM3LjQxNDkxODkwNzE5OCwgMzQuNjk3NTkwMjU2MzMwNCBdLCBbIDEzNy40MTQ4MzY1MTAwNjIwMDMsIDM0LjY5NzU5MDI1NjMzMDQgXSwgWyAxMzcuNDE0ODE1NTgzLCAzNC42OTc2OTQ3MjIgXSwgWyAxMzcuNDE0NzU3MDU2MDAwMDEzLCAzNC42OTc5ODEyNzggXSwgWyAxMzcuNDE0NzMxMjc4LCAzNC42OTgwMDUxMTEgXSwgWyAxMzcuNDE0NTMzMTExLCAzNC42OTc5OTQ4MDYgXSwgWyAxMzcuNDE0MjQ1NjA1NDY5MDA2LCAzNC42OTc5ODA2NzIxOTU1OTggXSwgWyAxMzcuNDE0MTkyOTQ0LCAzNC42OTc5NzgwODMgXSwgWyAxMzcuNDEzOTUzODYxMDAwMDEsIDM0LjY5Nzk2Mzg4OSBdLCBbIDEzNy40MTM2NjM5MTcsIDM0LjY5Nzk1NDgwNiBdLCBbIDEzNy40MTM2NTE2OTQsIDM0LjY5Nzk1NTAyOCBdLCBbIDEzNy40MTM1MjMyMjIsIDM0LjY5Nzk1NzYzOSBdLCBbIDEzNy40MTMzNTgxMTEsIDM0LjY5Nzk2OTA1NiBdLCBbIDEzNy40MTMyNTA1MjgsIDM0LjY5Nzk4MjMzMyBdLCBbIDEzNy40MTMxNDYxMTEsIDM0LjY5Nzk5NzY5NCBdLCBbIDEzNy40MTMxMTcyNSwgMzQuNjk3OTQ4MDgzIF0sIFsgMTM3LjQxMzA1NDQzOTMzODk5MywgMzQuNjk3NTkwMjU2MzMwNCBdLCBbIDEzNy40MTMwMjQ3MDc5MjQ5OSwgMzQuNjk3NTkwMjU2MzMwNCBdLCBbIDEzNy40MTMwODgxMTEsIDM0LjY5Nzk1MTU1NiBdLCBbIDEzNy40MTMwOTA0NzIsIDM0LjY5ODAwNiBdLCBbIDEzNy40MTI4NzIzMTQ0NTMwMTEsIDM0LjY5ODAzOTg0MTMzMDY5NyBdLCBbIDEzNy40MTI4NjM4NjEsIDM0LjY5ODA0MTE2NyBdLCBbIDEzNy40MTI3Njc1LCAzNC42OTgwNTYwNTYgXSwgWyAxMzcuNDEyNjIzOTQzOTk5OTg5LCAzNC42OTgwNzgzNjEgXSwgWyAxMzcuNDEyNDYzODYxLCAzNC42OTgxMDIwMjggXSwgWyAxMzcuNDEyNDM2MDI4LCAzNC42OTc5NTQzMzMgXSwgWyAxMzcuNDEyNDI3NTI4LCAzNC42OTc5MjIzMzMgXSwgWyAxMzcuNDEyNDA3NjY3LCAzNC42OTc4NDY1NTYgXSwgWyAxMzcuNDEyNDAyMTY3MDAwMDEsIDM0LjY5Nzc5OTc3OCBdLCBbIDEzNy40MTIzOTkyNzgsIDM0LjY5Nzc3NDM2MSBdLCBbIDEzNy40MTIzOTQyMjE5OTk5ODksIDM0LjY5NzczMTYzOSBdLCBbIDEzNy40MTIzNzI1LCAzNC42OTc3MzMzODkgXSwgWyAxMzcuNDEyMzg1OTQ0LCAzNC42OTc4NDgzMDYgXSwgWyAxMzcuNDEyMzk3MTk0LCAzNC42OTc5NTkyNzggXSwgWyAxMzcuNDEyNDI0MTM5LCAzNC42OTgxMDIzODkgXSwgWyAxMzcuNDEyMTA2OTQzOTk5OTg3LCAzNC42OTgxMDY3MjIgXSwgWyAxMzcuNDEyMDg1LCAzNC42OTgxMDY5NDQgXSwgWyAxMzcuNDEyMDEwMDgzMDAwMDEzLCAzNC42OTgxMDY2MzkgXSwgWyAxMzcuNDExOTY0NTAwMDAwMDExLCAzNC42OTgxMDY0NDQgXSwgWyAxMzcuNDExODc1NDQ0LCAzNC42OTgxMDYwODMgXSwgWyAxMzcuNDExNzgxLCAzNC42OTgxMDQ4MzMgXSwgWyAxMzcuNDExNzA3ODYxLCAzNC42OTgwOTk5NDQgXSwgWyAxMzcuNDExNTE2MzYxLCAzNC42OTgwODE5NDQgXSwgWyAxMzcuNDExNDk5MDIzNDM2OTg4LCAzNC42OTgwODA5Njk0MTk1IF0sIFsgMTM3LjQxMTE2NDM4OSwgMzQuNjk4MDYyMTY3IF0sIFsgMTM3LjQxMTEwODkxNywgMzQuNjk4MDU5MDU2IF0sIFsgMTM3LjQxMTAxNzYzOSwgMzQuNjk4MDU0IF0sIFsgMTM3LjQxMDgzMzA1NiwgMzQuNjk4MDQ5NTgzIF0sIFsgMTM3LjQxMDgzMzI1LCAzNC42OTgwMzYwNTYgXSwgWyAxMzcuNDEwNzMwMDgzLCAzNC42OTgwMzM3NSBdLCBbIDEzNy40MTA3MDM5NzIsIDM0LjY5NzgwNDA4MyBdLCBbIDEzNy40MTA2NjA0NDQsIDM0LjY5NzgwNzQxNyBdLCBbIDEzNy40MTA2ODU5NzIwMDAwMSwgMzQuNjk4MDMxOTQ0IF0sIFsgMTM3LjQxMDQ5ODc0OTk5OTk4OCwgMzQuNjk4MDI0MTk0IF0sIFsgMTM3LjQxMDQzMDIyMiwgMzQuNjk4MDMwMzA2IF0sIFsgMTM3LjQxMDQyMTYzOSwgMzQuNjk4MDQ3MjUgXSwgWyAxMzcuNDEwMTMzMzg5LCAzNC42OTgwNTQ4NjEgXSwgWyAxMzcuNDEwMTI1NzMyNDIxOTg5LCAzNC42OTgwNTUxMDc0Njg0OTggXSwgWyAxMzcuNDEwMDg4NzUsIDM0LjY5ODA1NjAyOCBdLCBbIDEzNy40MTAwMzM0MTcsIDM0LjY5ODA2IF0sIFsgMTM3LjQwOTYxMTYzOSwgMzQuNjk4MDkwMjUgXSwgWyAxMzcuNDA5NjAwNDcyLCAzNC42OTgwODMzMzMgXSwgWyAxMzcuNDA5NTkwMjc4LCAzNC42OTgwNzExOTQgXSwgWyAxMzcuNDA5NTgxMTk0LCAzNC42OTc5ODczNjEgXSwgWyAxMzcuNDA5NTczOTE2OTk5OTg5LCAzNC42OTc5NTk4MDYgXSwgWyAxMzcuNDA5NTU5NjY3LCAzNC42OTc5Mzg4MDYgXSwgWyAxMzcuNDA5NTM4Nzc4MDAwMDEyLCAzNC42OTc5MjMzNjEgXSwgWyAxMzcuNDA5NTA2LCAzNC42OTc5MTEyNSBdLCBbIDEzNy40MDk0NjA4ODksIDM0LjY5NzkwNzU1NiBdLCBbIDEzNy40MDk0NTY4NjEsIDM0LjY5Nzk0MDcyMiBdLCBbIDEzNy40MDk0OTU1LCAzNC42OTc5NDM4ODkgXSwgWyAxMzcuNDA5NTE1ODMzLCAzNC42OTc5NDk4ODkgXSwgWyAxMzcuNDA5NTI3NzUsIDM0LjY5Nzk1OTk3MiBdLCBbIDEzNy40MDk1MzU3NSwgMzQuNjk3OTcxNzc4IF0sIFsgMTM3LjQwOTU0MTI3OCwgMzQuNjk3OTkyNDE3IF0sIFsgMTM3LjQwOTU1MDgwNiwgMzQuNjk4MDgxMjc4IF0sIFsgMTM3LjQwOTU0NTkxNywgMzQuNjk4MDg3NDE3IF0sIFsgMTM3LjQwOTU0Mjg2MSwgMzQuNjk4MDkxMDI4IF0sIFsgMTM3LjQwOTUzNDQ3MiwgMzQuNjk4MDk1ODMzIF0sIFsgMTM3LjQwODc3MDMzMywgMzQuNjk4MTUzODYxIF0sIFsgMTM3LjQwODc1MjQ0MTQwNTk5NCwgMzQuNjk4MTU1MjM5NzU3OTAyIF0sIFsgMTM3LjQwODYyNDcyMjAwMDAxMywgMzQuNjk4MTY0OTE3IF0sIFsgMTM3LjQwODYwMTk0NCwgMzQuNjk4MTY2NjM5IF0sIFsgMTM3LjQwODU0MzM4ODk5OTk4OCwgMzQuNjk4MTcxNjM5IF0sIFsgMTM3LjQwODQ3NTI1LCAzNC42OTgxNzc0NDQgXSwgWyAxMzcuNDA4Mzc1NTI4LCAzNC42OTgxODU5NDQgXSwgWyAxMzcuNDA4MzMzMzMzLCAzNC42OTgxOTA3NzggXSwgWyAxMzcuNDA4MjQ1NDQzOTk5OTg4LCAzNC42OTgyMDA4ODkgXSwgWyAxMzcuNDA4MTk3OTcyMDAwMDExLCAzNC42OTgyMDQ5NDQgXSwgWyAxMzcuNDA4MTMwMTExLCAzNC42OTgyMTA2NjcgXSwgWyAxMzcuNDA4MTA0NTI4LCAzNC42OTgxOTU5NDQgXSwgWyAxMzcuNDA4MDk2MDgzLCAzNC42OTgwMDA0MTcgXSwgWyAxMzcuNDA4MDg1NjY3LCAzNC42OTc3NTgzODkgXSwgWyAxMzcuNDA4MDQwOTE3LCAzNC42OTc3NTk2MzkgXSwgWyAxMzcuNDA4MDUyMDU2LCAzNC42OTgwMTk2MTEgXSwgWyAxMzcuNDA4MDU5Nzc4LCAzNC42OTgxOTY1NTYgXSwgWyAxMzcuNDA4MDQzODg5LCAzNC42OTgyMTc5NzIgXSwgWyAxMzcuNDA4MDA2NjY3LCAzNC42OTgyMjExMTEgXSwgWyAxMzcuNDA3NzA3NTU2LCAzNC42OTgyNDY1ODMgXSwgWyAxMzcuNDA3NjU2MTY3LCAzNC42OTgyNTA5MTcgXSwgWyAxMzcuNDA3NjM2NjM5LCAzNC42OTgwMzM3NzggXSwgWyAxMzcuNDA3NjAxMTExLCAzNC42OTc2Mzc0NDQgXSwgWyAxMzcuNDA3NTYzMDI4LCAzNC42OTc2Mzk3NzggXSwgWyAxMzcuNDA3NTc0MzA1OTk5OTg3LCAzNC42OTc3NjQ5NzIgXSwgWyAxMzcuNDA3NjE4MTk0LCAzNC42OTgyNTQxMzkgXSwgWyAxMzcuNDA3NDQ2NDE2OTk5OTg5LCAzNC42OTgyNjg3MjIgXSwgWyAxMzcuNDA3MzgzNTU2MDAwMDEzLCAzNC42OTgyNzI2OTQgXSwgWyAxMzcuNDA3Mzc5MTUwMzkwOTk0LCAzNC42OTgyNzI5OTc1NDk3MDEgXSwgWyAxMzcuNDA3MzQsIDM0LjY5ODI3NTQxNyBdLCBbIDEzNy40MDcyNjk1MDAwMDAwMTIsIDM0LjY5ODI4MDk0NCBdLCBbIDEzNy40MDY4MDc1NTYsIDM0LjY5ODMxNzEzOSBdLCBbIDEzNy40MDY3Mzc1LCAzNC42OTgzMjI1ODMgXSwgWyAxMzcuNDA2NjkwNDcyLCAzNC42OTgzMjYzMDYgXSwgWyAxMzcuNDA2NjU3OTQzOTk5OTg4LCAzNC42OTgzMjkwNTYgXSwgWyAxMzcuNDA2NDg1OTcyMDAwMDEzLCAzNC42OTgzNDI5NzIgXSwgWyAxMzcuNDA2NDIxOTQzOTk5OTg3LCAzNC42OTgzNDgxMzkgXSwgWyAxMzcuNDA2MTQ3ODg5MDAwMDEsIDM0LjY5ODM3MDI3OCBdLCBbIDEzNy40MDYxMjY0NDQsIDM0LjY5ODM1NzMzMyBdLCBbIDEzNy40MDYwOTgwODI5OTk5ODksIDM0LjY5ODA1NzM2MSBdLCBbIDEzNy40MDYwOTQ1ODMsIDM0LjY5ODAxOTMzMyBdLCBbIDEzNy40MDYwNDQzMzE2Nzg5OTksIDM0LjY5NzU5MDI1NjMzMDQgXSwgWyAxMzcuNDA2MDAwNDU3MjE2MDEsIDM0LjY5NzU5MDI1NjMzMDQgXSwgWyAxMzcuNDA2MDA1ODU5Mzc1LCAzNC42OTc2MzY0NjgyNDY2OTkgXSwgWyAxMzcuNDA2MDE2OTE2OTk5OTg4LCAzNC42OTc3MzEgXSwgWyAxMzcuNDA2MDUxMDI4LCAzNC42OTgwMjI1NTYgXSwgWyAxMzcuNDA2MDgxNDQ0LCAzNC42OTgzNDQ3MjIgXSwgWyAxMzcuNDA2MDYzODMzLCAzNC42OTgzNzMwNTYgXSwgWyAxMzcuNDA2MDA1ODU5Mzc1LCAzNC42OTgzNzc3MjQ0NjAyMDEgXSwgWyAxMzcuNDA1ODQ1Njk0LCAzNC42OTgzOTA2MTEgXSwgWyAxMzcuNDA1NzgyMTY3MDAwMDEyLCAzNC42OTgzOTM4ODkgXSwgWyAxMzcuNDA1NzgwODMzLCAzNC42OTgzODc1IF0sIFsgMTM3LjQwNTQ4MDk0NCwgMzQuNjk4NDExNjk0IF0sIFsgMTM3LjQwNTQ1NTk3MiwgMzQuNjk4MTkzNzUgXSwgWyAxMzcuNDA1NDQ1MzMyOTk5OTg5LCAzNC42OTgxMzE1IF0sIFsgMTM3LjQwNTQyNjI1LCAzNC42OTc5ODQ3NSBdLCBbIDEzNy40MDU0MDYwNTYsIDM0LjY5Nzc5NTQ3MiBdLCBbIDEzNy40MDUzODQ4OTU5NjU5OTQsIDM0LjY5NzU5MDI1NjMzMDQgXSwgWyAxMzcuNDA1MzUyMDMyMDQxMDA5LCAzNC42OTc1OTAyNTYzMzA0IF0sIFsgMTM3LjQwNTM3MzMwNiwgMzQuNjk3Nzk3NDQ0IF0sIFsgMTM3LjQwNTM5MzcyMjAwMDAxNCwgMzQuNjk3OTg3Njk0IF0sIFsgMTM3LjQwNTQxMjU4Mjk5OTk4NiwgMzQuNjk4MTMzIF0sIFsgMTM3LjQwNTQxMjc3OCwgMzQuNjk4MTk5MjUgXSwgWyAxMzcuNDA1NDIwMjc4LCAzNC42OTgyNjQzMzMgXSwgWyAxMzcuNDA1NDIzMzA1OTk5OTg5LCAzNC42OTgyOTA3NSBdLCBbIDEzNy40MDU0MzU3MjIsIDM0LjY5ODQwMDUyOCBdLCBbIDEzNy40MDU0MjYxNjcsIDM0LjY5ODQxNTc3OCBdLCBbIDEzNy40MDUzOTcwMjgwMDAwMSwgMzQuNjk4NDE3IF0sIFsgMTM3LjQwNTM0NzU4MywgMzQuNjk4NDE4NTI4IF0sIFsgMTM3LjQwNTI5NTcyMiwgMzQuNjk4NDE3MTM5IF0sIFsgMTM3LjQwNTI2MTIyMiwgMzQuNjk4NDE2MTk0IF0sIFsgMTM3LjQwNTI0NTM2MSwgMzQuNjk4NDE1NTI4IF0sIFsgMTM3LjQwNTE2Mzc1MDAwMDAxNCwgMzQuNjk4NDEyMDU2IF0sIFsgMTM3LjQwNTEyNDQ0NCwgMzQuNjk4NDEwNDE3IF0sIFsgMTM3LjQwNTAzMTQxNywgMzQuNjk4NDA0MTExIF0sIFsgMTM3LjQwNDkwODk0NCwgMzQuNjk4Mzk2OTQ0IF0sIFsgMTM3LjQwNDg4NzI3OCwgMzQuNjk4Mzc4MzMzIF0sIFsgMTM3LjQwNDg2NDc3OCwgMzQuNjk4MTQ0NTI4IF0sIFsgMTM3LjQwNDg0NywgMzQuNjk3OTYwOTE3IF0sIFsgMTM3LjQwNDgzMjEzOSwgMzQuNjk3ODAyNjM5IF0sIFsgMTM3LjQwNDgxNzI3OCwgMzQuNjk3NjQ0MzYxIF0sIFsgMTM3LjQwNDkwMDQ1NTM4OTk5MiwgMzQuNjk3NTkwMjU2MzMwNCBdLCBbIDEzNy40MDQ4MDUxNjU5MzgwMDEsIDM0LjY5NzU5MDI1NjMzMDQgXSwgWyAxMzcuNDA0NzYyMzA2LCAzNC42OTc2MTgxMzkgXSwgWyAxMzcuNDA0Nzk0NzIyLCAzNC42OTc5NjM2MzkgXSwgWyAxMzcuNDA0ODEyODMzLCAzNC42OTgxNTEzMDYgXSwgWyAxMzcuNDA0ODM0MDgzLCAzNC42OTgzNzE1IF0sIFsgMTM3LjQwNDgxOCwgMzQuNjk4MzkyNjExIF0sIFsgMTM3LjQwNDYzMjU2ODM1OTAwNiwgMzQuNjk4Mzg0MTYxNzc4MTAxIF0sIFsgMTM3LjQwNDYyMjY5NDAwMDAxMSwgMzQuNjk4MzgzNzIyIF0sIFsgMTM3LjQwNDMzMzk0NCwgMzQuNjk4MzcxMzA2IF0sIFsgMTM3LjQwNDI5MjgwNiwgMzQuNjk4Mzc3MTM5IF0sIFsgMTM3LjQwNDI1MzQxNywgMzQuNjk4Mzg0MzYxIF0sIFsgMTM3LjQwNDIzODA1NiwgMzQuNjk4Mzg4NTI4IF0sIFsgMTM3LjQwNDEwNzMwNTk5OTk4NiwgMzQuNjk4NDIzODA2IF0sIFsgMTM3LjQwNDAxOTMwNiwgMzQuNjk4NDQ3NTU2IF0sIFsgMTM3LjQwMzk3ODI1LCAzNC42OTg0NTg2MzkgXSwgWyAxMzcuNDAzNzY2ODMzLCAzNC42OTg1MDgwODMgXSwgWyAxMzcuNDAzNjg0NTgzLCAzNC42OTg1Mjc4MDYgXSwgWyAxMzcuNDAzNTQ2MDU2MDAwMDEsIDM0LjY5ODU2MDg4OSBdLCBbIDEzNy40MDMyOTUxNjcwMDAwMSwgMzQuNjk4NjE5ODg5IF0sIFsgMTM3LjQwMzI1OTI3NzM0NDAwNiwgMzQuNjk4NjI4NTI4OTM3IF0sIFsgMTM3LjQwMjg4MTc5MTE0NDAxMSwgMzQuNjk4NzE5MzI0NTMyMjk4IF0sIFsgMTM3LjQwMjc4MjA1NiwgMzQuNjk4NzQzMzA2IF0sIFsgMTM3LjQwMjc3ODAyOCwgMzQuNjk4NzQxODYxIF0sIFsgMTM3LjQwMjc3NDcyMiwgMzQuNjk4NzM5OTcyIF0sIFsgMTM3LjQwMjc3MiwgMzQuNjk4NzM3NjM5IF0sIFsgMTM3LjQwMjc3MDEzOTAwMDAxMiwgMzQuNjk4NzM1MzA2IF0sIFsgMTM3LjQwMjc2ODgwNjAwMDAxMiwgMzQuNjk4NzMyNjk0IF0sIFsgMTM3LjQwMjc2NzgzMzAwMDAxMywgMzQuNjk4NzI5ODA2IF0sIFsgMTM3LjQwMjc2NTQ2NjcyMjAwMiwgMzQuNjk4NzE5MzI0NTMyMjk4IF0sIFsgMTM3LjQwMjczMjc3OCwgMzQuNjk4NTczNDcyIF0sIFsgMTM3LjQwMjczMjc3OCwgMzQuNjk4NTcxMjIyIF0sIFsgMTM3LjQwMjczMzE5NCwgMzQuNjk4NTY5MTM5IF0sIFsgMTM3LjQwMjczMzk3MiwgMzQuNjk4NTY3MjUgXSwgWyAxMzcuNDAyNzM1OTE3LCAzNC42OTg1NjUwODMgXSwgWyAxMzcuNDAyNzM4NzUsIDM0LjY5ODU2MzE2NyBdLCBbIDEzNy40MDI3NDIzNjEsIDM0LjY5ODU2MTgwNiBdLCBbIDEzNy40MDI3NzI1ODMsIDM0LjY5ODU2MDA1NiBdLCBbIDEzNy40MDI5MTQyMjIsIDM0LjY5ODU0MiBdLCBbIDEzNy40MDMwNTE0NzE5OTk5ODcsIDM0LjY5ODUxODY2NyBdLCBbIDEzNy40MDMxNDc1ODMsIDM0LjY5ODQ5ODM4OSBdLCBbIDEzNy40MDMyNTU1NTYsIDM0LjY5ODQ2NTE2NyBdLCBbIDEzNy40MDMyNTkyNzczNDQwMDYsIDM0LjY5ODQ2MzgxMTUxMzM5OSBdLCBbIDEzNy40MDM0NDc0NzIwMDAwMTEsIDM0LjY5ODM5NjE5NCBdLCBbIDEzNy40MDM2MDkxOTQwMDAwMTIsIDM0LjY5ODMwOTk3MiBdLCBbIDEzNy40MDM3Mzc0NDQsIDM0LjY5ODIyOTk0NCBdLCBbIDEzNy40MDQwMDQ2MzksIDM0LjY5ODA2NzUgXSwgWyAxMzcuNDA0MzU1Njk0LCAzNC42OTc4NDMwNTYgXSwgWyAxMzcuNDA0NjMyNTY4MzU5MDA2LCAzNC42OTc2NDMxMjM0NTc5MDEgXSwgWyAxMzcuNDA0NzA1Nzc4MDA0OTk1LCAzNC42OTc1OTAyNTYzMzA0IF0sIFsgMTM3LjQwNDY1NTk2MDEzODk5NiwgMzQuNjk3NTkwMjU2MzMwNCBdLCBbIDEzNy40MDQ2MzI1NjgzNTkwMDYsIDM0LjY5NzYwNzE0OTMzMDIwMyBdLCBbIDEzNy40MDQzMzQ3NzgsIDM0LjY5NzgyMjE5NCBdLCBbIDEzNy40MDM5ODQ4MDYwMDAwMTEsIDM0LjY5ODA0NiBdLCBbIDEzNy40MDM3MTgyNzgwMDAwMTQsIDM0LjY5ODIwNzk3MiBdLCBbIDEzNy40MDM1OTA0NzIsIDM0LjY5ODI4NzcyMiBdLCBbIDEzNy40MDM0MzIsIDM0LjY5ODM3MjMzMyBdLCBbIDEzNy40MDMyNTkyNzczNDQwMDYsIDM0LjY5ODQzNDM5OTA4MjEwMyBdLCBbIDEzNy40MDMyNDMzNjEsIDM0LjY5ODQ0MDEzOSBdLCBbIDEzNy40MDMxMzc3NzgsIDM0LjY5ODQ3MjQ0NCBdLCBbIDEzNy40MDMwNDM5NzIsIDM0LjY5ODQ5MjM2MSBdLCBbIDEzNy40MDI5MDgzNjA5OTk5ODcsIDM0LjY5ODUxNTMzMyBdLCBbIDEzNy40MDI3Njg5MTcsIDM0LjY5ODUzMzE5NCBdLCBbIDEzNy40MDI3MzkzODksIDM0LjY5ODUzNDkxNyBdLCBbIDEzNy40MDI2NzMzNjEwMDAwMTIsIDM0LjY5ODUzODc3OCBdLCBbIDEzNy40MDI2MzMwMjgsIDM0LjY5ODU0MTExMSBdLCBbIDEzNy40MDI1MDk2OTQsIDM0LjY5ODU0MTcyMiBdLCBbIDEzNy40MDI0MTg3NTAwMDAwMSwgMzQuNjk4NTM3NjY3IF0sIFsgMTM3LjQwMjI0MTQxNywgMzQuNjk4NTEzNjY3IF0sIFsgMTM3LjQwMjExOTc1LCAzNC42OTg0OTE4ODkgXSwgWyAxMzcuNDAyMDI2OTE3LCAzNC42OTg0Njg2MzkgXSwgWyAxMzcuNDAxOTU2NDQ0LCAzNC42OTg0NDgyMjIgXSwgWyAxMzcuNDAxODg1OTg2MzI4MDExLCAzNC42OTg0MjMxNTUyNDc0OTcgXSwgWyAxMzcuNDAxODg1OTg2MzI4MDExLCAzNC42OTg0NTI3MjMzMDM2MDMgXSwgWyAxMzcuNDAxOTQ0NTAwMDAwMDEzLCAzNC42OTg0NzM0NzIgXSwgWyAxMzcuNDAyMDE2ODMzLCAzNC42OTg0OTQ0NDQgXSwgWyAxMzcuNDAyMTExNTI4LCAzNC42OTg1MTgwNTYgXSwgWyAxMzcuNDAyMjM1Mzg5LCAzNC42OTg1NDAyNSBdLCBbIDEzNy40MDI0MTUyMjIsIDM0LjY5ODU2NDUyOCBdLCBbIDEzNy40MDI1MDg3NzgsIDM0LjY5ODU2ODc1IF0sIFsgMTM3LjQwMjYzNDMwNjAwMDAxLCAzNC42OTg1NjgxNjcgXSwgWyAxMzcuNDAyNjc0Njk0MDAwMDEyLCAzNC42OTg1NjU4MzMgXSwgWyAxMzcuNDAyNjc4MDgzMDAwMDEyLCAzNC42OTg1NjcgXSwgWyAxMzcuNDAyNjgxMTM5LCAzNC42OTg1Njg1MjggXSwgWyAxMzcuNDAyNjgzODYxMDAwMDE0LCAzNC42OTg1NzAzMDYgXSwgWyAxMzcuNDAyNjg1NzIyLCAzNC42OTg1NzE5NDQgXSwgWyAxMzcuNDAyNjg3NDcyLCAzNC42OTg1NzM3MjIgXSwgWyAxMzcuNDAyNjg4OTE3LCAzNC42OTg1NzU4MDYgXSwgWyAxMzcuNDAyNzIxMDIxNjM3MDA3LCAzNC42OTg3MTkzMjQ1MzIyOTggXSwgWyAxMzcuNDAyNzI2NjExLCAzNC42OTg3NDQyMjIgXSwgWyAxMzcuNDAyNzI2Mzg5LCAzNC42OTg3NDY4MzMgXSwgWyAxMzcuNDAyNzI1ODYxLCAzNC42OTg3NDk0NDQgXSwgWyAxMzcuNDAyNzI0ODg5MDAwMDEyLCAzNC42OTg3NTE4ODkgXSwgWyAxMzcuNDAyNzIzNDcyLCAzNC42OTg3NTQxMzkgXSwgWyAxMzcuNDAyNzIxNzIyLCAzNC42OTg3NTYzMDYgXSwgWyAxMzcuNDAyNzE5NTU2LCAzNC42OTg3NTgzODkgXSwgWyAxMzcuNDAyMzA3NTU2MDAwMDExLCAzNC42OTg4NTc0NDQgXSwgWyAxMzcuNDAxODg1OTg2MzI4MDExLCAzNC42OTg4MDg1ODUyMDE0OTggXSwgWyAxMzcuNDAxODg1OTg2MzI4MDExLCAzNC42OTg4ODE0NDU5NTU3OTkgXSwgWyAxMzcuNDAyMDk3Nzc4MDAwMDEyLCAzNC42OTg5MDYgXSwgWyAxMzcuNDAyMTU5MTM5LCAzNC42OTg5MDg1IF0sIFsgMTM3LjQwMjMyMzQ3MiwgMzQuNjk4OTI3NTU2IF0sIFsgMTM3LjQwMjMyNDM4OSwgMzQuNjk4OTA1MDI4IF0sIFsgMTM3LjQwMjczNDUsIDM0LjY5ODgwNjM4OSBdLCBbIDEzNy40MDI3OTg5MTcwMDAwMTMsIDM0LjY5ODc5MDkxNyBdLCBbIDEzNy40MDMwOTY2Mjk5NDQwMDIsIDM0LjY5ODcxOTMyNDUzMjI5OCBdLCBbIDEzNy40MDMyNTkyNzczNDQwMDYsIDM0LjY5ODY4MDIxMDU5ODE5OCBdLCBbIDEzNy40MDMzMTE4ODksIDM0LjY5ODY2NzU1NiBdLCBbIDEzNy40MDMzMTM0NDQsIDM0LjY5ODY3Mjc3OCBdLCBbIDEzNy40MDMzNTA4NjEsIDM0LjY5ODY2Mzk0NCBdLCBbIDEzNy40MDM1NjQzMzMsIDM0LjY5ODYxMzc3OCBdLCBbIDEzNy40MDM2NTU0MTcwMDAwMSwgMzQuNjk4NTkzNSBdLCBbIDEzNy40MDM3OTI3NSwgMzQuNjk4NTYyOTQ0IF0sIFsgMTM3LjQwMzk5ODgwNiwgMzQuNjk4NTE0NjY3IF0sIFsgMTM3LjQwNDAzNTU4MywgMzQuNjk4NTA0Nzc4IF0sIFsgMTM3LjQwNDA2MTU4Mjk5OTk4NywgMzQuNjk4NTEzODA2IF0sIFsgMTM3LjQwNDA4MTI3OCwgMzQuNjk4Njg3ODYxIF0sIFsgMTM3LjQwNDA4NDQ5Njk2NTk5MywgMzQuNjk4NzE5MzI0NTMyMjk4IF0sIFsgMTM3LjQwNDExMTM4OSwgMzQuNjk4OTgyMzMzIF0sIFsgMTM3LjQwNDEzOSwgMzQuNjk5MjI0NTU2IF0sIFsgMTM3LjQwNDE0MDM4OSwgMzQuNjk5MjM2Nzc4IF0sIFsgMTM3LjQwNDE0OTI3OCwgMzQuNjk5MzE1MTk0IF0sIFsgMTM3LjQwNDE2NjU4MywgMzQuNjk5NDY3MjUgXSwgWyAxMzcuNDA0MTgyMDgzLCAzNC42OTk1ODYzMDYgXSwgWyAxMzcuNDA0MTg2ODg4OTk5OTg4LCAzNC42OTk2MjI1MjggXSwgWyAxMzcuNDA0MjAwMDU2LCAzNC42OTk3MTk5NDQgXSwgWyAxMzcuNDA0MTg3OTQ0LCAzNC42OTk3MjA5NzIgXSwgWyAxMzcuNDAzNjgyLCAzNC42OTk3NjM0MTcgXSwgWyAxMzcuNDAzNTkyNTI4LCAzNC42OTk3NzA5MTcgXSwgWyAxMzcuNDAzMzM0ODYxLCAzNC42OTk3OTIwNTYgXSwgWyAxMzcuNDAzMjU5Mjc3MzQ0MDA2LCAzNC42OTk3OTc0MTYxNTUzOTggXSwgWyAxMzcuNDAzMDYwMzg5LCAzNC42OTk4MTE1IF0sIFsgMTM3LjQwMzAxNTUyOCwgMzQuNjk5ODEyMTM5IF0sIFsgMTM3LjQwMjk5NzgzMywgMzQuNjk5ODA5NTU2IF0sIFsgMTM3LjQwMjk3MjkxNywgMzQuNjk5ODAzMjIyIF0sIFsgMTM3LjQwMjk0Mjk3MiwgMzQuNjk5NzkwMzg5IF0sIFsgMTM3LjQwMjg2ODQxNywgMzQuNjk5NzQ1NzIyIF0sIFsgMTM3LjQwMjgzNzU4MywgMzQuNjk5NzI5Mjc4IF0sIFsgMTM3LjQwMjc3NTE5Mzk5OTk4NiwgMzQuNjk5NzA4Mzg5IF0sIFsgMTM3LjQwMjY0MTM4OSwgMzQuNjk5Njc0MzA2IF0sIFsgMTM3LjQwMjYwMjE2NywgMzQuNjk5NjY4ODg5IF0sIFsgMTM3LjQwMjU1OTYxMDk5OTk4NywgMzQuNjk5NjY4OTcyIF0sIFsgMTM3LjQwMjU2MTMzMywgMzQuNjk5NjYwNTgzIF0sIFsgMTM3LjQwMjUzOTkxNzAwMDAxMywgMzQuNjk5NjU2NTU2IF0sIFsgMTM3LjQwMjUyODQ3MiwgMzQuNjk5NzAwMzg5IF0sIFsgMTM3LjQwMjUyMzE2NywgMzQuNjk5NzE3NDQ0IF0sIFsgMTM3LjQwMjUxNzYxMSwgMzQuNjk5NzE2MzYxIF0sIFsgMTM3LjQwMjQ3ODcyMjAwMDAxMiwgMzQuNjk5NzA5NTgzIF0sIFsgMTM3LjQwMjQ3ODcyMjAwMDAxMiwgMzQuNjk5NzAzOTE3IF0sIFsgMTM3LjQwMjQ2MjIyMiwgMzQuNjk5NzAwODg5IF0sIFsgMTM3LjQwMjM0ODcyMiwgMzQuNjk5NjcyNTI4IF0sIFsgMTM3LjQwMjI1OCwgMzQuNjk5NjY3ODMzIF0sIFsgMTM3LjQwMTg4NTk4NjMyODAxMSwgMzQuNjk5NTk1ODExMDk3NzAxIF0sIFsgMTM3LjQwMTg4NTk4NjMyODAxMSwgMzQuNjk5NjMyODgwMTc0MiBdLCBbIDEzNy40MDIyNTI0MTcsIDM0LjY5OTcwMzgwNiBdLCBbIDEzNy40MDIzNDM1ODMsIDM0LjY5OTcwNDUyOCBdLCBbIDEzNy40MDIzOTA4MzMsIDM0LjY5OTcwNDgwNiBdLCBbIDEzNy40MDI0NTk2MzksIDM0LjY5OTcxODkxNyBdLCBbIDEzNy40MDI1MTQzNjA5OTk5ODcsIDM0LjY5OTczMDQ0NCBdLCBbIDEzNy40MDI1Mzk5MTcwMDAwMTMsIDM0LjY5OTczNTA4MyBdLCBbIDEzNy40MDI1NTU1LCAzNC42OTk2ODM4MzMgXSwgWyAxMzcuNDAyNjAwODA2LCAzNC42OTk2ODIzMDYgXSwgWyAxMzcuNDAyNjM3NSwgMzQuNjk5Njg3NDcyIF0sIFsgMTM3LjQwMjc2OTQ0NCwgMzQuNjk5NzIxMDI4IF0sIFsgMTM3LjQwMjgyOTk3MiwgMzQuNjk5NzQxMjc4IF0sIFsgMTM3LjQwMjg1OTE2NywgMzQuNjk5NzU2ODMzIF0sIFsgMTM3LjQwMjkzNDM4OSwgMzQuNjk5ODAxOTQ0IF0sIFsgMTM3LjQwMjk2Njc1LCAzNC42OTk4MTU4MzMgXSwgWyAxMzcuNDAyOTk0MDU2MDAwMDExLCAzNC42OTk4MjI3MjIgXSwgWyAxMzcuNDAzMDEyNzIyLCAzNC42OTk4MjUzODkgXSwgWyAxMzcuNDAzMDYxNzIyLCAzNC42OTk4MjQ3NSBdLCBbIDEzNy40MDMwNjQyNzMyMzUwMDMsIDM0LjY5OTg0ODM3NzMyODg5OCBdLCBbIDEzNy40MDMwNjQzMDYsIDM0LjY5OTg0OTE5NCBdLCBbIDEzNy40MDMwNzU4NTIxNDEwMDEsIDM0LjY5OTg0ODM3NzMyODg5OCBdLCBbIDEzNy40MDMyNTkyNzczNDQwMDYsIDM0LjY5OTgzNTQwODE2MjY5OSBdLCBbIDEzNy40MDMzMzY5NDM5OTk5ODksIDM0LjY5OTgyOTkxNyBdLCBbIDEzNy40MDM2MDM4NjEsIDM0LjY5OTgxMDcyMiBdLCBbIDEzNy40MDQyMDQ5NzIsIDM0LjY5OTc2MDMzMyBdLCBbIDEzNy40MDQyMTI5MTcsIDM0LjY5OTgzMzg4OSBdLCBbIDEzNy40MDQyMTQ1OTU1MzgwMDgsIDM0LjY5OTg0ODM3NzMyODg5OCBdLCBbIDEzNy40MDQyMTcxOTQwMDAwMTIsIDM0LjY5OTg3MjU1NiBdLCBbIDEzNy40MDQyMjc5NDQwMDAwMTMsIDM0LjY5OTk3MTQxNyBdLCBbIDEzNy40MDQyMzEwMjgsIDM0LjcgXSwgWyAxMzcuNDA0MjQ1NTU2LCAzNC43MDAxMzQwMjggXSwgWyAxMzcuNDA0MjY2MTY3LCAzNC43MDAzMjM5NDQgXSwgWyAxMzcuNDA0MjU4NDcyLCAzNC43MDAzMzY3NSBdLCBbIDEzNy40MDQyNDM5MTcsIDM0LjcwMDM2MDk0NCBdLCBbIDEzNy40MDQwOTQxOTQwMDAwMSwgMzQuNzAwNDE3MzA2IF0sIFsgMTM3LjQwNDAxNjMzMjk5OTk4NywgMzQuNzAwNDQ2NTgzIF0sIFsgMTM3LjQwMzg1NjgzMywgMzQuNzAwNDc2ODA2IF0sIFsgMTM3LjQwMzgzODA4MzAwMDAxMSwgMzQuNzAwNDgyNDQ0IF0sIFsgMTM3LjQwMzgxOTg2MDk5OTk4OCwgMzQuNzAwNDg5ODYxIF0sIFsgMTM3LjQwMzgwMzMwNTk5OTk4NiwgMzQuNzAwNDk4NzUgXSwgWyAxMzcuNDAzNzkxNTI4LCAzNC43MDA1MDY1IF0sIFsgMTM3LjQwMzc4Njg2MDk5OTk4NiwgMzQuNzAwNTEwMjIyIF0sIFsgMTM3LjQwMzcxNDkxNywgMzQuNzAwNTA2NTgzIF0sIFsgMTM3LjQwMzY5NTI3Nzk5OTk4NywgMzQuNzAwNTEwMzA2IF0sIFsgMTM3LjQwMzY3ODQ3MiwgMzQuNzAwNTE2MTk0IF0sIFsgMTM3LjQwMzY2Mzk3MiwgMzQuNzAwNTIyNzIyIF0sIFsgMTM3LjQwMzY1MDU4MywgMzQuNzAwNTMyNjY3IF0sIFsgMTM3LjQwMzY0MDAyODAwMDAxMiwgMzQuNzAwNTQzMzMzIF0sIFsgMTM3LjQwMzYzMzUwMDAwMDAxMiwgMzQuNzAwNTU1OTQ0IF0sIFsgMTM3LjQwMzYyOTMwNiwgMzQuNzAwNTcxNzUgXSwgWyAxMzcuNDAzNjI4NDcyLCAzNC43MDA1ODg5NzIgXSwgWyAxMzcuNDAzNjMwNSwgMzQuNzAwNjA3NTI4IF0sIFsgMTM3LjQwMzYzNTc3OCwgMzQuNzAwNjI1NjM5IF0sIFsgMTM3LjQwMzY4NjU1NiwgMzQuNzAwNjMyMTExIF0sIFsgMTM3LjQwMzY4MTI3OCwgMzQuNzAwNjIyNzUgXSwgWyAxMzcuNDAzNjc2NDQ0MDAwMDEzLCAzNC43MDA2MTE1ODMgXSwgWyAxMzcuNDAzNjczMzYwOTk5OTg5LCAzNC43MDA1OTQ4MzMgXSwgWyAxMzcuNDAzNjcyOTcyMDAwMDEsIDM0LjcwMDU4MDM4OSBdLCBbIDEzNy40MDM2NzU1NTYsIDM0LjcwMDU2ODc1IF0sIFsgMTM3LjQwMzY4MDQ0NCwgMzQuNzAwNTU4Mzg5IF0sIFsgMTM3LjQwMzY4NjMzMywgMzQuNzAwNTUyMjUgXSwgWyAxMzcuNDAzNjk3MzMzLCAzNC43MDA1NDU1NTYgXSwgWyAxMzcuNDAzNzEwMzA2LCAzNC43MDA1NDExOTQgXSwgWyAxMzcuNDAzNzIxNzc4LCAzNC43MDA1Mzk5MTcgXSwgWyAxMzcuNDAzNzMyODA2LCAzNC43MDA1Mzk1MjggXSwgWyAxMzcuNDAzNzU5NTU2MDAwMDExLCAzNC43MDA1NDY2OTQgXSwgWyAxMzcuNDAzNzU3NTAwMDAwMDEyLCAzNC43MDA1NTU0NDQgXSwgWyAxMzcuNDAzNzU2OTcyLCAzNC43MDA1NjQwODMgXSwgWyAxMzcuNDAzNzU3ODg5LCAzNC43MDA1NzI0NzIgXSwgWyAxMzcuNDAzNzY0MjUsIDM0LjcwMDU4OTIyMiBdLCBbIDEzNy40MDM3NzQ2NjcsIDM0LjcwMDYwNTE2NyBdLCBbIDEzNy40MDM3ODY4MzMsIDM0LjcwMDYyMDQ3MiBdLCBbIDEzNy40MDM3OTMxOTQsIDM0LjcwMDYyODIyMiBdLCBbIDEzNy40MDM3OTkyMjIsIDM0LjcwMDYzNTg2MSBdLCBbIDEzNy40MDM4MDQ5MTcsIDM0LjcwMDY0MzY5NCBdLCBbIDEzNy40MDM4MDkxOTQsIDM0LjcwMDY1MDE5NCBdLCBbIDEzNy40MDM4MTMxMzksIDM0LjcwMDY1NjgzMyBdLCBbIDEzNy40MDM4MTY3NSwgMzQuNzAwNjYzNjk0IF0sIFsgMTM3LjQwMzgxOTAyNzk5OTk4NywgMzQuNzAwNjg5NjM5IF0sIFsgMTM3LjQwMzgxNDgzMzAwMDAxMywgMzQuNzAwNzE0NzIyIF0sIFsgMTM3LjQwMzgxMzY2NywgMzQuNzAwNzI3NjExIF0sIFsgMTM3LjQwMzgwNzYxMSwgMzQuNzAwNzQ0NzUgXSwgWyAxMzcuNDAzNzEzLCAzNC43MDA5MTIxNjcgXSwgWyAxMzcuNDAzNjY2MTc3MTQ0MDA0LCAzNC43MDA5Nzc0MTQ3MjAxIF0sIFsgMTM3LjQwMzYyMzg2MSwgMzQuNzAxMDM2NDcyIF0sIFsgMTM3LjQwMzYxOTM4OSwgMzQuNzAxMDQyNjExIF0sIFsgMTM3LjQwMzQ2NDQxNywgMzQuNzAxMjAzODMzIF0sIFsgMTM3LjQwMzQ0MDk0NDAwMDAxLCAzNC43MDEyMDY4NjEgXSwgWyAxMzcuNDAzMzI2MjIyLCAzNC43MDExMzA1NTYgXSwgWyAxMzcuNDAzMjg4NTU2LCAzNC43MDExMDU1IF0sIFsgMTM3LjQwMzI1OTI3NzM0NDAwNiwgMzQuNzAxMDg1OTc1Mzg5MDk4IF0sIFsgMTM3LjQwMzI1LCAzNC43MDEwNzk4NjEgXSwgWyAxMzcuNDAzMjAyODYxMDAwMDExLCAzNC43MDEwNTQxNjcgXSwgWyAxMzcuNDAzMTI2NDQ0LCAzNC43MDEwMTI1NTYgXSwgWyAxMzcuNDAzMDM2NjM5LCAzNC43MDA5ODEwODMgXSwgWyAxMzcuNDAzMDEwOTYzNDY0OTkzLCAzNC43MDA5Nzc0MTQ3MjAxIF0sIFsgMTM3LjQwMzAwODAyNzk5OTk4OCwgMzQuNzAwOTc3IF0sIFsgMTM3LjQwMjk4MDA4Mjk5OTk4OSwgMzQuNzAwOTc3MDU2IF0sIFsgMTM3LjQwMjk3Njk3NzM5MDAxMSwgMzQuNzAwOTc3NDE0NzIwMSBdLCBbIDEzNy40MDI4ODQxNjcsIDM0LjcwMDk4ODY5NCBdLCBbIDEzNy40MDI3MjA5NDQsIDM0LjcwMTAyMDM4OSBdLCBbIDEzNy40MDI2MjM1MjgsIDM0LjcwMTA0MjM4OSBdLCBbIDEzNy40MDI1NzI1LCAzNC43MDEwMjEzMDYgXSwgWyAxMzcuNDAyNTcxNSwgMzQuNzAxMDE2MTY3IF0sIFsgMTM3LjQwMjU2NDUwMTkxNjk5OSwgMzQuNzAwOTc3NDE0NzIwMSBdLCBbIDEzNy40MDI1NjExOTM5OTk5ODYsIDM0LjcwMDk1ODY2NyBdLCBbIDEzNy40MDI1NTExOTQwMDAwMTEsIDM0LjcwMDg5ODcyMiBdLCBbIDEzNy40MDI1NDIyNzgsIDM0LjcwMDgzNjU1NiBdLCBbIDEzNy40MDI1Mzc1MjgwMDAwMTEsIDM0LjcwMDc3NjMzMyBdLCBbIDEzNy40MDI1Mzk3NzgsIDM0LjcwMDcxNzYzOSBdLCBbIDEzNy40MDI1NDYwODMsIDM0LjcwMDY3ODc3OCBdLCBbIDEzNy40MDI1NTUwMjgsIDM0LjcwMDYzNzI3OCBdLCBbIDEzNy40MDI1NjQ3MjIsIDM0LjcwMDU5MTgzMyBdLCBbIDEzNy40MDI1NzM1ODMsIDM0LjcwMDUxNzgwNiBdLCBbIDEzNy40MDI1NzU2MTEsIDM0LjcwMDUwMDM4OSBdLCBbIDEzNy40MDI1NzYxMzksIDM0LjcwMDQ5NjE2NyBdLCBbIDEzNy40MDI1NzQ2NjcwMDAwMSwgMzQuNzAwMzk4ODA2IF0sIFsgMTM3LjQwMjU2NzY2NywgMzQuNzAwMzUyMDI4IF0sIFsgMTM3LjQwMjYwMDg2MSwgMzQuNzAwMzIzMzA2IF0sIFsgMTM3LjQwMzAzMzk3MiwgMzQuNzAwMzg3NDQ0IF0sIFsgMTM3LjQwMzA0MTA4MywgMzQuNzAwMzU1NTI4IF0sIFsgMTM3LjQwMjU5MjkxNywgMzQuNzAwMjg3NjExIF0sIFsgMTM3LjQwMjU0ODQxNywgMzQuNzAwMjYxNTU2IF0sIFsgMTM3LjQwMjUzMDc3OCwgMzQuNzAwMjAxMDgzIF0sIFsgMTM3LjQwMjQ4NDk3MiwgMzQuNzAwMTAzODA2IF0sIFsgMTM3LjQwMjQyMTA4MywgMzQuNzAwMDEzODg5IF0sIFsgMTM3LjQwMjQwNzE5NCwgMzQuNyBdLCBbIDEzNy40MDIzNTk0NDQwMDAwMTIsIDM0LjY5OTk1MjMzMyBdLCBbIDEzNy40MDIyODk4ODksIDM0LjY5OTg5ODI3OCBdLCBbIDEzNy40MDIyMTQ3NTAwMDAwMTMsIDM0LjY5OTg1MTM4OSBdLCBbIDEzNy40MDIyMDg5NDE0NDQwMDIsIDM0LjY5OTg0ODM3NzMyODg5OCBdLCBbIDEzNy40MDIxNTk3NzgsIDM0LjY5OTgyMjYzOSBdLCBbIDEzNy40MDIxMTQwODI5OTk5ODcsIDM0LjY5OTgwMjMzMyBdLCBbIDEzNy40MDIxMDMwMjgsIDM0LjY5OTc5NzQxNyBdLCBbIDEzNy40MDIwNDQyNDk5OTk5ODksIDM0LjY5OTc3NTY5NCBdLCBbIDEzNy40MDE5OTU1Mjc5OTk5ODYsIDM0LjY5OTc2MTAyOCBdLCBbIDEzNy40MDE5NDU4MzMwMDAwMTMsIDM0LjY5OTc0ODk0NCBdLCBbIDEzNy40MDE4OTQ4MzMsIDM0LjY5OTczOTQ3MiBdLCBbIDEzNy40MDE4ODU5ODYzMjgwMTEsIDM0LjY5OTczODQwOTY1NjQ5NyBdLCBbIDEzNy40MDE4ODU5ODYzMjgwMTEsIDM0LjY5OTgwNzE0ODY2Mjg5OSBdLCBbIDEzNy40MDE5MjU1LCAzNC42OTk4MTQ0NDQgXSwgWyAxMzcuNDAxOTY5ODMzMDAwMDEsIDM0LjY5OTgyNTI1IF0sIFsgMTM3LjQwMTk4Mjk0NCwgMzQuNjk5ODI5MTk0IF0sIFsgMTM3LjQwMjAxMzIyMiwgMzQuNjk5ODM4MzMzIF0sIFsgMTM3LjQwMjA0MDMzNDg2Njk5NiwgMzQuNjk5ODQ4Mzc3MzI4ODk4IF0sIFsgMTM3LjQwMjA2Njg2MSwgMzQuNjk5ODU4MTM5IF0sIFsgMTM3LjQwMjExODU1NiwgMzQuNjk5ODgxMTM5IF0sIFsgMTM3LjQwMjE2Nzk3MiwgMzQuNjk5OTA3IF0sIFsgMTM3LjQwMjIzNzA4Mjk5OTk4OSwgMzQuNjk5OTUwMDU2IF0sIFsgMTM3LjQwMjI5OTU1NiwgMzQuNjk5OTk4NjExIF0sIFsgMTM3LjQwMjMwMDk0NCwgMzQuNyBdLCBbIDEzNy40MDIzNTM3MjE5OTk5ODcsIDM0LjcwMDA1Mjc3OCBdLCBbIDEzNy40MDI0MTEwNTYsIDM0LjcwMDEzMzM2MSBdLCBbIDEzNy40MDI0MzkwNTYsIDM0LjcwMDE5MjgwNiBdLCBbIDEzNy40MDI0NDQyMjIwMDAwMTQsIDM0LjcwMDIwMzY5NCBdLCBbIDEzNy40MDI0NTI0NDQsIDM0LjcwMDIyMTM2MSBdLCBbIDEzNy40MDI0Nzk0NDQsIDM0LjcwMDMxMzc3OCBdLCBbIDEzNy40MDI0OTI4MDYsIDM0LjcwMDQwMzQ3MiBdLCBbIDEzNy40MDI0OTQyNzgsIDM0LjcwMDQ5MzE2NyBdLCBbIDEzNy40MDI0ODM0OTk5OTk5ODgsIDM0LjcwMDU4MjgwNiBdLCBbIDEzNy40MDI0NzQ3NzgsIDM0LjcwMDYyNDM2MSBdLCBbIDEzNy40MDI0NjUxOTQsIDM0LjcwMDY2ODMwNiBdLCBbIDEzNy40MDI0NjQ0MTcsIDM0LjcwMDY3MjcyMiBdLCBbIDEzNy40MDI0NTgsIDM0LjcwMDcxMjExMSBdLCBbIDEzNy40MDI0NTYzNjEsIDM0LjcwMDc1NzI3OCBdLCBbIDEzNy40MDI0NTU1NTYsIDM0LjcwMDc3NzUgXSwgWyAxMzcuNDAyNDU3NzIyLCAzNC43MDA4MDUyNSBdLCBbIDEzNy40MDI0NjA2NjcwMDAwMTQsIDM0LjcwMDg0MjY2NyBdLCBbIDEzNy40MDI0NywgMzQuNzAwOTA3ODA2IF0sIFsgMTM3LjQwMjQ3MywgMzQuNzAwOTI1MjIyIF0sIFsgMTM3LjQwMjQ4LCAzNC43MDA5Njc3NSBdLCBbIDEzNy40MDI0ODE3MTI1MTY5ODcsIDM0LjcwMDk3NzQxNDcyMDEgXSwgWyAxMzcuNDAyNDkwNjM5LCAzNC43MDEwMjY3NzggXSwgWyAxMzcuNDAyNDk0NDE3MDAwMDE0LCAzNC43MDEwNDY0MTcgXSwgWyAxMzcuNDAyNDc2MDU2MDAwMDEyLCAzNC43MDEwNzQ1IF0sIFsgMTM3LjQwMjE1NzI3OCwgMzQuNzAxMTQyNzIyIF0sIFsgMTM3LjQwMTg4OTQ0NCwgMzQuNzAxMTk4MDU2IF0sIFsgMTM3LjQwMTg4NTk4NjMyODAxMSwgMzQuNzAxMTk4Nzg5NDE2MjAzIF0sIFsgMTM3LjQwMTg4NTk4NjMyODAxMSwgMzQuNzAxMjQwNjE3MDA5Mzk3IF0sIFsgMTM3LjQwMTkwMTg4ODk5OTk4NywgMzQuNzAxMjM3MzMzIF0sIFsgMTM3LjQwMjA4MDM4OSwgMzQuNzAxMjAzNDQ0IF0sIFsgMTM3LjQwMjE3MTkxNywgMzQuNzAxMTg2MTM5IF0sIFsgMTM3LjQwMjQ4ODA4MywgMzQuNzAxMTE4NDcyIF0sIFsgMTM3LjQwMjU5MDA4MywgMzQuNzAxMDk2NjM5IF0sIFsgMTM3LjQwMjYzNDA4MywgMzQuNzAxMDg2NzIyIF0sIFsgMTM3LjQwMjczNDYxMSwgMzQuNzAxMDY0MDgzIF0sIFsgMTM3LjQwMjg5ODM2MTAwMDAxMywgMzQuNzAxMDMyMzA2IF0sIFsgMTM3LjQwMjk2MTY2NywgMzQuNzAxMDIyMDgzIF0sIFsgMTM3LjQwMjgxNzI1LCAzNC43MDEyMTQ0NzIgXSwgWyAxMzcuNDAyNjEwNDcyLCAzNC43MDE0NzkxOTQgXSwgWyAxMzcuNDAyNTk1NDcyLCAzNC43MDE0OTc4MDYgXSwgWyAxMzcuNDAyNDEyNSwgMzQuNzAxNzI1NSBdLCBbIDEzNy40MDIzNzU0MTcsIDM0LjcwMTc3MTY2NyBdLCBbIDEzNy40MDIzMzAwNTYwMDAwMTEsIDM0LjcwMTgyODE2NyBdLCBbIDEzNy40MDIxMTI0MTMzODQwMDMsIDM0LjcwMjEwNjQzNjcwNTU5OCBdLCBbIDEzNy40MDIwNzc1LCAzNC43MDIxNTEwNTYgXSwgWyAxMzcuNDAxODg1OTg2MzI4MDExLCAzNC43MDIzODYzNzU1OTM1OTggXSwgWyAxMzcuNDAxODg1OTg2MzI4MDExLCAzNC43MDI0MzQ3NzU2ODkyOTggXSwgWyAxMzcuNDAyMTA0NjExLCAzNC43MDIxNjYxMzkgXSwgWyAxMzcuNDAyMTI4NjY3LCAzNC43MDIxMzU0NDQgXSwgWyAxMzcuNDAyMTUxMzM1Njc5MDA4LCAzNC43MDIxMDY0MzY3MDU1OTggXSwgWyAxMzcuNDAyMzU3Mjc4MDAwMDExLCAzNC43MDE4NDMwODMgXSwgWyAxMzcuNDAyNDUxODA1OTk5OTg4LCAzNC43MDE3MjU0NDQgXSwgWyAxMzcuNDAyNjM4MjUsIDM0LjcwMTQ5MzU1NiBdLCBbIDEzNy40MDI3ODUxOTM5OTk5ODksIDM0LjcwMTMwNTQxNyBdLCBbIDEzNy40MDI4NDQ3NzgsIDM0LjcwMTIyOTExMSBdLCBbIDEzNy40MDI5OTAwODMsIDM0LjcwMTAzNTYzOSBdLCBbIDEzNy40MDI5OTU5NDQsIDM0LjcwMTAzMDg2MSBdLCBbIDEzNy40MDMwMDIyNzgsIDM0LjcwMTAyNzMwNiBdLCBbIDEzNy40MDMwMDkwMjgwMDAwMTQsIDM0LjcwMTAyNDg2MSBdLCBbIDEzNy40MDMwMTYyNSwgMzQuNzAxMDIzNTgzIF0sIFsgMTM3LjQwMzAyMzg4OSwgMzQuNzAxMDIzNSBdLCBbIDEzNy40MDMwMzE4NjA5OTk5ODgsIDM0LjcwMTAyNDQ3MiBdLCBbIDEzNy40MDMxMDI2NjcwMDAwMTMsIDM0LjcwMTA0OTIyMiBdLCBbIDEzNy40MDMxNzUyNSwgMzQuNzAxMDg4ODMzIF0sIFsgMTM3LjQwMzE4MDA1NiwgMzQuNzAxMDk0NSBdLCBbIDEzNy40MDMxODM1ODI5OTk5ODYsIDM0LjcwMTEwMDQ0NCBdLCBbIDEzNy40MDMxODU2NjcsIDM0LjcwMTEwNjU1NiBdLCBbIDEzNy40MDMxODY0NDQsIDM0LjcwMTExMjUyOCBdLCBbIDEzNy40MDMxODYxMzkwMDAwMTMsIDM0LjcwMTExODU1NiBdLCBbIDEzNy40MDMxODQ1MjgsIDM0LjcwMTEyNDg2MSBdLCBbIDEzNy40MDMwNjk1NTYsIDM0LjcwMTI2OTY5NCBdLCBbIDEzNy40MDI4MDY5NzIsIDM0LjcwMTYwMDA4MyBdLCBbIDEzNy40MDI3MTE5NDQsIDM0LjcwMTcyNDk0NCBdLCBbIDEzNy40MDI2NDUwNTYwMDAwMTEsIDM0LjcwMTgxMjc3OCBdLCBbIDEzNy40MDI0MTA4NDQyOTEwMTIsIDM0LjcwMjEwNjQzNjcwNTU5OCBdLCBbIDEzNy40MDIzMzg2MzksIDM0LjcwMjE5Njk3MiBdLCBbIDEzNy40MDIxMzE2OTQsIDM0LjcwMjQ1NyBdLCBbIDEzNy40MDIxMTc5MTcsIDM0LjcwMjQ3NDMwNiBdLCBbIDEzNy40MDE5NDY3MjIsIDM0LjcwMjY4OTQxNyBdLCBbIDEzNy40MDE5MjYwODMsIDM0LjcwMjY4NjMwNiBdLCBbIDEzNy40MDE4ODU5ODYzMjgwMTEsIDM0LjcwMjU3ODA5ODY0MTE5NyBdLCBbIDEzNy40MDE4ODU5ODYzMjgwMTEsIDM0LjcwMjcxMDY0MjUyNTA5OCBdLCBbIDEzNy40MDE4OTQzMzMsIDM0LjcwMjczMzEzOSBdLCBbIDEzNy40MDE4OTU0NzIsIDM0LjcwMjc0MTYxMSBdLCBbIDEzNy40MDE4OTQ3MjIsIDM0LjcwMjc0ODExMSBdLCBbIDEzNy40MDE4OTMzMDYsIDM0LjcwMjc1MzA4MyBdLCBbIDEzNy40MDE4ODk5NDQsIDM0LjcwMjc1OTgzMyBdLCBbIDEzNy40MDE4ODU5ODYzMjgwMTEsIDM0LjcwMjc2NDgxNDQyMTc5OCBdLCBbIDEzNy40MDE4ODU5ODYzMjgwMTEsIDM0LjcwMjgyMjU0MTM1MTMwMyBdLCBbIDEzNy40MDE5MDEwODMwMDAwMTMsIDM0LjcwMjgwMzQ0NCBdLCBbIDEzNy40MDE5MDYyMjIsIDM0LjcwMjc5ODgzMyBdLCBbIDEzNy40MDE5MTIsIDM0LjcwMjc5NjY2NyBdLCBbIDEzNy40MDE5MTc1NTYsIDM0LjcwMjc5NjQ3MiBdLCBbIDEzNy40MDE5MjEwNTYsIDM0LjcwMjc5NzU1NiBdLCBbIDEzNy40MDE5MjQ1NTYwMDAwMTIsIDM0LjcwMjc5OTQ0NCBdLCBbIDEzNy40MDE5Mjc4MzMsIDM0LjcwMjgwMjIyMiBdLCBbIDEzNy40MDIwODc1MzQxMiwgMzQuNzAzMjM1NDQzMjg1MTAyIF0sIFsgMTM3LjQwMjE0OTk0NCwgMzQuNzAzNDA0NzIyIF0sIFsgMTM3LjQwMjEzODg4OTAwMDAxNCwgMzQuNzAzNDM1NDE3IF0sIFsgMTM3LjQwMTg4NTk4NjMyODAxMSwgMzQuNzAzNzQwODM4NjYzODk3IF0sIFsgMTM3LjQwMTg4NTk4NjMyODAxMSwgMzQuNzAzODIwNjk4NTUyOTAzIF0sIFsgMTM3LjQwMjE3NzA4MywgMzQuNzAzNDY5MDU2IF0sIFsgMTM3LjQwMjE4NTc3Nzk5OTk4OSwgMzQuNzAzNDU5MTk0IF0sIFsgMTM3LjQwMjE5NjY5NCwgMzQuNzAzNDU0MDU2IF0sIFsgMTM3LjQwMjIwODM2MSwgMzQuNzAzNDUyMjIyIF0sIFsgMTM3LjQwMzI1OTI3NzM0NDAwNiwgMzQuNzAzMzg1NzE4MDE4MTk3IF0sIFsgMTM3LjQwMzM5NDQxNjk5OTk4NywgMzQuNzAzMzc3MTY3IF0sIFsgMTM3LjQwMzQwNDgzMywgMzQuNzAzMzk2MjUgXSwgWyAxMzcuNDAzMzIzMDU2LCAzNC43MDM0NjgwODMgXSwgWyAxMzcuNDAzMzIwMTM4OTk5OTg3LCAzNC43MDM0Nzg1NTYgXSwgWyAxMzcuNDAzMjU5Mjc3MzQ0MDA2LCAzNC43MDM1MzM3NTkyNTUwMDIgXSwgWyAxMzcuNDAzMjIzODg5LCAzNC43MDM1NjU5MTcgXSwgWyAxMzcuNDAzMTczOTE3LCAzNC43MDM2MTAyNzggXSwgWyAxMzcuNDAyOTYyMjIyMDAwMDE0LCAzNC43MDM3OTc5NDQgXSwgWyAxMzcuNDAyOTQyNjM5LCAzNC43MDM4MTQwMjggXSwgWyAxMzcuNDAyOTMyNDE2OTk5OTg4LCAzNC43MDM4MjcxMTEgXSwgWyAxMzcuNDAyOTIzOTE3MDAwMDEsIDM0LjcwMzgzOTM4OSBdLCBbIDEzNy40MDI5MTA1ODMsIDM0LjcwMzg2NDU1NiBdLCBbIDEzNy40MDI4OTg1MjgsIDM0LjcwMzg4ODY2NyBdLCBbIDEzNy40MDI4ODY1ODMsIDM0LjcwMzkxMTY2NyBdLCBbIDEzNy40MDI3MDQxMTkwODU5OTYsIDM0LjcwNDM2NDQzNDQ1ODQ5OCBdLCBbIDEzNy40MDI3NTAxNjUzNjY5OTYsIDM0LjcwNDM2NDQzNDQ1ODQ5OCBdLCBbIDEzNy40MDI5Mjc4ODkwMDAwMTEsIDM0LjcwMzkyMzUgXSwgWyAxMzcuNDAyOTU3NjM5LCAzNC43MDM5MTMwNTYgXSwgWyAxMzcuNDAzMTgzMzYxLCAzNC43MDM5Mzk0MTcgXSwgWyAxMzcuNDAzMjU5Mjc3MzQ0MDA2LCAzNC43MDM5NDgyODI5ODA2OTcgXSwgWyAxMzcuNDAzMzI1NzUsIDM0LjcwMzk1NjA4MyBdLCBbIDEzNy40MDMyNTkyNzczNDQwMDYsIDM0LjcwNDI3MDc3NTc2ODEwMSBdLCBbIDEzNy40MDMyMzk0OTQ5NTg5OTYsIDM0LjcwNDM2NDQzNDQ1ODQ5OCBdLCBbIDEzNy40MDMyNzI2MDg4ODQwMDksIDM0LjcwNDM2NDQzNDQ1ODQ5OCBdLCBbIDEzNy40MDMzNTgwODMsIDM0LjcwMzk1OTgwNiBdLCBbIDEzNy40MDM0NzcxMTEsIDM0LjcwMzk3MzcyMiBdLCBbIDEzNy40MDM0OTE1ODMsIDM0LjcwMzk5NDk3MiBdLCBbIDEzNy40MDM0MDY5OTM3ODYwMDcsIDM0LjcwNDM2NDQzNDQ1ODQ5OCBdLCBbIDEzNy40MDM0NzM2MzMwODIwMDEsIDM0LjcwNDM2NDQzNDQ1ODQ5OCBdLCBbIDEzNy40MDM1NTY0NDQsIDM0LjcwNDAwMjc3OCBdLCBbIDEzNy40MDM1ODM2OTQsIDM0LjcwMzk4NjEzOSBdLCBbIDEzNy40MDQwMjQzMDYsIDM0LjcwNDAzNzQ3MiBdLCBbIDEzNy40MDQwOTA2OTQsIDM0LjcwNDA0NTI3OCBdLCBbIDEzNy40MDQwOTg2OTQsIDM0LjcwNDA1ODMzMyBdLCBbIDEzNy40MDQwNjUyMjIwMDAwMTQsIDM0LjcwNDIyMDY2NyBdLCBbIDEzNy40MDQwMzM5MTI1MzQ5OTksIDM0LjcwNDM2NDQzNDQ1ODQ5OCBdLCBbIDEzNy40MDQwNzgyNTkxNTQwMDUsIDM0LjcwNDM2NDQzNDQ1ODQ5OCBdLCBbIDEzNy40MDQxMDgyNSwgMzQuNzA0MjI3MDgzIF0sIFsgMTM3LjQwNDEyNDM4OSwgMzQuNzA0MjI5MDI4IF0sIFsgMTM3LjQwNDE2MDU4MywgMzQuNzA0MDUzNTI4IF0sIFsgMTM3LjQwNDYzMjU2ODM1OTAwNiwgMzQuNzA0MTA4ODg0NjI5Njk3IF0sIFsgMTM3LjQwNDg1Mzc3Nzk5OTk4OSwgMzQuNzA0MTM0ODMzIF0sIFsgMTM3LjQwNDg1NTM4OSwgMzQuNzA0MTI1OTE3IF0sIFsgMTM3LjQwNTAyMzExMSwgMzQuNzA0MTQ1NjExIF0sIFsgMTM3LjQwNTE5MjU4MywgMzQuNzA0MTYyNjY3IF0sIFsgMTM3LjQwNTMxMDQxNzAwMDAxLCAzNC43MDQxNzY1IF0sIFsgMTM3LjQwNTMxNzc1LCAzNC43MDQxODA5MTcgXSwgWyAxMzcuNDA1MzIzOTcyLCAzNC43MDQxODU4NjEgXSwgWyAxMzcuNDA1MzI5MjIyLCAzNC43MDQxOTEzMzMgXSwgWyAxMzcuNDA1MzM0Mzg4OTk5OTg5LCAzNC43MDQxOTkwODMgXSwgWyAxMzcuNDA1MzM3ODg5LCAzNC43MDQyMDc3MjIgXSwgWyAxMzcuNDA1MzM5NjY3LCAzNC43MDQyMTcyNzggXSwgWyAxMzcuNDA1MzM4NDE3LCAzNC43MDQyNzE3MjIgXSwgWyAxMzcuNDA1MzQyNzc4LCAzNC43MDQzMTQxOTQgXSwgWyAxMzcuNDA1MzQxNzE0MTk5MDExLCAzNC43MDQzNjQ0MzQ0NTg0OTggXSwgWyAxMzcuNDA1Mzc0NDcxODI3MDAyLCAzNC43MDQzNjQ0MzQ0NTg0OTggXSwgWyAxMzcuNDA1Mzc1NTI4LCAzNC43MDQzMTQ2NjcgXSwgWyAxMzcuNDA1Mzc5MjUwMDAwMDEsIDM0LjcwNDE1ODk3MiBdLCBbIDEzNy40MDUzODMxMTEsIDM0LjcwNDEzNTY5NCBdLCBbIDEzNy40MDUzODkxOTQsIDM0LjcwNDEzMDcyMiBdLCBbIDEzNy40MDU0MDA1NTU5OTk5ODksIDM0LjcwNDEyODkxNyBdLCBbIDEzNy40MDU0MTA2MTEsIDM0LjcwNDEzMTA1NiBdLCBbIDEzNy40MDU0MjU0NzIsIDM0LjcwNDE0NDU1NiBdLCBbIDEzNy40MDU2MTczMjgzMzAwMSwgMzQuNzA0MzY0NDM0NDU4NDk4IF0sIFsgMTM3LjQwNTY1Nzc5MjQyMTAxLCAzNC43MDQzNjQ0MzQ0NTg0OTggXSwgWyAxMzcuNDA1Mzg3NDQ0MDAwMDEzLCAzNC43MDQwNTQ2MzkgXSwgWyAxMzcuNDA1MzkyMzMzLCAzNC43MDM4MjYgXSwgWyAxMzcuNDA1MzkzMjIxOTk5OTg3LCAzNC43MDM3ODM2OTQgXSwgWyAxMzcuNDA1Mzk3MzYxMDAwMDEzLCAzNC43MDM1ODk1MjggXSwgWyAxMzcuNDA1NDEzODA2MDAwMDEzLCAzNC43MDM1NzIzNjEgXSwgWyAxMzcuNDA1ODIwOTcxOTk5OTg3LCAzNC43MDM0OTYzMDYgXSwgWyAxMzcuNDA1ODczMDI4LCAzNC43MDM0OTAwNTYgXSwgWyAxMzcuNDA1ODg0ODA1OTk5OTg5LCAzNC43MDM0ODk3NzggXSwgWyAxMzcuNDA1OTE1MTY2OTk5OTg5LCAzNC43MDM0ODkgXSwgWyAxMzcuNDA2MDA1ODU5Mzc1LCAzNC43MDM0OTU3MDkwODM2OTcgXSwgWyAxMzcuNDA2Mjg2NSwgMzQuNzAzNTE2NDcyIF0sIFsgMTM3LjQwNjM0OTE5NCwgMzQuNzAzNTI3NzIyIF0sIFsgMTM3LjQwNjQwMjk0NCwgMzQuNzAzNTQyNDcyIF0sIFsgMTM3LjQwNjU2OTAyOCwgMzQuNzAzNjAyMTk0IF0sIFsgMTM3LjQwNjY3MTYzOSwgMzQuNzAzNjQyNTI4IF0sIFsgMTM3LjQwNjc1OTQ0Mzk5OTk4OCwgMzQuNzAzNjc3MDgzIF0sIFsgMTM3LjQwNjc4MDcyMiwgMzQuNzAzNjg1NDQ0IF0sIFsgMTM3LjQwNjgyMzEzOTAwMDAxMSwgMzQuNzAzNzA0ODMzIF0sIFsgMTM3LjQwNjg5MzY2NywgMzQuNzAzNzQ5ODYxIF0sIFsgMTM3LjQwNzA2NzU1NTk5OTk4NywgMzQuNzAzODYxNDcyIF0sIFsgMTM3LjQwNzA4NzU4MywgMzQuNzAzODc0MzMzIF0sIFsgMTM3LjQwNzI2ODEzOSwgMzQuNzAzOTg3NzUgXSwgWyAxMzcuNDA3MjcwNTU1OTk5OTg2LCAzNC43MDM5OTY1IF0sIFsgMTM3LjQwNzIyMDg4OSwgMzQuNzA0MDc3IF0sIFsgMTM3LjQwNzIwMzYxMSwgMzQuNzA0MTA0NDQ0IF0sIFsgMTM3LjQwNzE4Nzg2MTAwMDAxMSwgMzQuNzA0MTI5MzYxIF0sIFsgMTM3LjQwNzE1NzExMSwgMzQuNzA0MTc3Mjc4IF0sIFsgMTM3LjQwNzE0MDYzOSwgMzQuNzA0MjE0NTU2IF0sIFsgMTM3LjQwNzExODcyMiwgMzQuNzA0MjY2NjExIF0sIFsgMTM3LjQwNzA4OTY4MDk5OTAwNywgMzQuNzA0MzY0NDM0NDU4NDk4IF0sIFsgMTM3LjQwNzEyMTEyMDQ5NDk5MiwgMzQuNzA0MzY0NDM0NDU4NDk4IF0sIFsgMTM3LjQwNzE0OCwgMzQuNzA0MjczNjY3IF0sIFsgMTM3LjQwNzE2OTQ3MiwgMzQuNzA0MjIyNzc4IF0sIFsgMTM3LjQwNzE4NTA4MywgMzQuNzA0MTg3NjExIF0sIFsgMTM3LjQwNzIxNTUyOCwgMzQuNzA0MTQwMjIyIF0sIFsgMTM3LjQwNzIyOTc1LCAzNC43MDQxMTc1NTYgXSwgWyAxMzcuNDA3MjQ3Nzc4LCAzNC43MDQwODg5NDQgXSwgWyAxMzcuNDA3Mjk0NjExLCAzNC43MDQwMTMxMTEgXSwgWyAxMzcuNDA3MzA1MzA2MDAwMDEyLCAzNC43MDQwMTExMTEgXSwgWyAxMzcuNDA3MzE3NDQ0LCAzNC43MDQwMTg3NSBdLCBbIDEzNy40MDczMTgyMjE5OTk5ODYsIDM0LjcwNDAxOTE5NCBdLCBbIDEzNy40MDczNzAxNjcwMDAwMSwgMzQuNzA0MDUwMTk0IF0sIFsgMTM3LjQwNzM3OTE1MDM5MDk5NCwgMzQuNzA0MDU1Mzg0MDA3NzAyIF0sIFsgMTM3LjQwNzQzNDIyMiwgMzQuNzA0MDg3MjIyIF0sIFsgMTM3LjQwNzQ2NjkxNywgMzQuNzA0MTA1Mjc4IF0sIFsgMTM3LjQwNzQ5NDkxNywgMzQuNzA0MTE2MzA2IF0sIFsgMTM3LjQwNzUyNzU4MywgMzQuNzA0MTI2MjUgXSwgWyAxMzcuNDA3NTUyMjc4LCAzNC43MDQxMzM2OTQgXSwgWyAxMzcuNDA3NTg5ODMzLCAzNC43MDQxNDE1NTYgXSwgWyAxMzcuNDA3NjMwNDcyLCAzNC43MDQxNDU5NzIgXSwgWyAxMzcuNDA3NjY4NTU2LCAzNC43MDQxNDg1IF0sIFsgMTM3LjQwNzcwMDU1NiwgMzQuNzA0MTQ5OTcyIF0sIFsgMTM3LjQwNzc2MDM4OSwgMzQuNzA0MTQ5Nzc4IF0sIFsgMTM3LjQwNzkxMDExMSwgMzQuNzA0MTMzNDE3IF0sIFsgMTM3LjQwODAwNjQ0NCwgMzQuNzA0MTE5Mjc4IF0sIFsgMTM3LjQwODAxMDI3OCwgMzQuNzA0MTE4ODg5IF0sIFsgMTM3LjQwODAzNjc3OCwgMzQuNzA0MTE3NjY3IF0sIFsgMTM3LjQwODE5ODU1NiwgMzQuNzA0MTA5Nzc4IF0sIFsgMTM3LjQwODIwMDU1NiwgMzQuNzA0MTI2IF0sIFsgMTM3LjQwODMsIDM0LjcwNDEyMDEzOSBdLCBbIDEzNy40MDgzMjQ0NDM5OTk5ODcsIDM0LjcwNDExODYzOSBdLCBbIDEzNy40MDgzMzMzMzMsIDM0LjcwNDExODQ0NCBdLCBbIDEzNy40MDgzOTUxNjcsIDM0LjcwNDExNzA1NiBdLCBbIDEzNy40MDg0MDE1LCAzNC43MDQxMTczMDYgXSwgWyAxMzcuNDA4NDI1NTI4LCAzNC43MDQxMTgyNSBdLCBbIDEzNy40MDg0MjMzMDYsIDM0LjcwNDEwMzU1NiBdLCBbIDEzNy40MDg0NTg4ODksIDM0LjcwNDEwNzExMSBdLCBbIDEzNy40MDg1Njc1NTYsIDM0LjcwNDEyNjg4OSBdLCBbIDEzNy40MDg3NTI0NDE0MDU5OTQsIDM0LjcwNDE2OTg4MTkwOTEwMiBdLCBbIDEzNy40MDg4NTEyNSwgMzQuNzA0MTkyODYxIF0sIFsgMTM3LjQwODg4NjYzOSwgMzQuNzA0MjAxMTY3IF0sIFsgMTM3LjQwODg4OTQxNzAwMDAxMiwgMzQuNzA0MjE5MDI4IF0sIFsgMTM3LjQwODc1MjQ0MTQwNTk5NCwgMzQuNzA0Mjg0NDM1MTQzMTAxIF0sIFsgMTM3LjQwODY0OTM4OSwgMzQuNzA0MzMzNjM5IF0sIFsgMTM3LjQwODYxMTI1LCAzNC43MDQzNTQ5NzIgXSwgWyAxMzcuNDA4NTk1OTAzNjQ5OTk2LCAzNC43MDQzNjQ0MzQ0NTg0OTggXSwgWyAxMzcuNDA4NjU4NTY3MzgwMDAyLCAzNC43MDQzNjQ0MzQ0NTg0OTggXSwgWyAxMzcuNDA4NjY4NTU2LCAzNC43MDQzNTg4MzMgXSwgWyAxMzcuNDA4NzUyNDQxNDA1OTk0LCAzNC43MDQzMTg3NzExMDYwMDMgXSwgWyAxMzcuNDA4OTQxODYwOTk5OTg4LCAzNC43MDQyMjgzMDYgXSwgWyAxMzcuNDA4OTYzNDQ0LCAzNC43MDQyMjU0NDQgXSwgWyAxMzcuNDA5MTQ2Mjc4LCAzNC43MDQyNTY5MTcgXSwgWyAxMzcuNDA5MjE3OTQ0LCAzNC43MDQyNzMzNjEgXSwgWyAxMzcuNDA5MzQxMjc4LCAzNC43MDQzMDIzMzMgXSwgWyAxMzcuNDA5NjQ4ODMzLCAzNC43MDQzNTcxNjcgXSwgWyAxMzcuNDA5Njg5OTQyODA4MDAxLCAzNC43MDQzNjQ0MzQ0NTg0OTggXSwgWyAxMzcuNDA5OTQ4NDA4NTU3LCAzNC43MDQzNjQ0MzQ0NTg0OTggXSwgWyAxMzcuNDA5ODIzMTExLCAzNC43MDQzMzc5NzIgXSwgWyAxMzcuNDA5NzUwODA2LCAzNC43MDQzMjQ1IF0sIFsgMTM3LjQwOTY3NSwgMzQuNzA0MzExMTM5IF0sIFsgMTM3LjQwOTU2ODE5NCwgMzQuNzA0MjkyMDU2IF0sIFsgMTM3LjQwOTQyNzA4MywgMzQuNzA0MjY2OTE3IF0sIFsgMTM3LjQwOTMzODYxMTAwMDAxLCAzNC43MDQyNTExMTEgXSwgWyAxMzcuNDA5MTYxNjY3LCAzNC43MDQyMTcyMjIgXSwgWyAxMzcuNDA5MDE0MTExLCAzNC43MDQxOTE4MDYgXSwgWyAxMzcuNDA4OTgyMzMzMDAwMDEyLCAzNC43MDQxODYzODkgXSwgWyAxMzcuNDA4OTQ4Njk0LCAzNC43MDQxODA1ODMgXSwgWyAxMzcuNDA4OTM2NTgzMDAwMDEzLCAzNC43MDQxNzg0NDQgXSwgWyAxMzcuNDA4OTI4ODg5LCAzNC43MDQxNjE2MTEgXSwgWyAxMzcuNDA4OTYxODYxLCAzNC43MDQxMjU1ODMgXSwgWyAxMzcuNDA4OTc5Mzg5LCAzNC43MDQxMTAwMjggXSwgWyAxMzcuNDA4OTkxOTE3LCAzNC43MDQxMDA4ODkgXSwgWyAxMzcuNDA5MDI4MDgzMDAwMDEsIDM0LjcwNDA3ODgzMyBdLCBbIDEzNy40MDkyNDM4MDYsIDM0LjcwMzkzNjA1NiBdLCBbIDEzNy40MDkyNzEzNjEsIDM0LjcwMzkxMzE5NCBdLCBbIDEzNy40MDk0ODc0NzIsIDM0LjcwMzc1MzM2MSBdLCBbIDEzNy40MDk1MDc5NzIsIDM0LjcwMzc0NzI3OCBdLCBbIDEzNy40MDk1NDU5NzE5OTk5ODksIDM0LjcwMzc0ODQ3MiBdLCBbIDEzNy40MDk1NjM3NzgsIDM0LjcwMzc0ODk3MiBdLCBbIDEzNy40MDk1NzA2MzksIDM0LjcwMzc0OTI1IF0sIFsgMTM3LjQwOTYwNjc3ODAwMDAxMSwgMzQuNzAzNzUwMzMzIF0sIFsgMTM3LjQwOTYxNTMwNiwgMzQuNzAzNzUwNTgzIF0sIFsgMTM3LjQwOTY2MTkxNywgMzQuNzAzNzUyMDI4IF0sIFsgMTM3LjQxMDEyNTczMjQyMTk4OSwgMzQuNzAzNzY2MTcxNDA1ODAzIF0sIFsgMTM3LjQxMDI1MDQ0NDAwMDAxMywgMzQuNzAzNzY5OTcyIF0sIFsgMTM3LjQxMDI2OCwgMzQuNzAzNzkyNzUgXSwgWyAxMzcuNDEwMjE5Njk0LCAzNC43MDM4ODc3NzggXSwgWyAxMzcuNDEwMTc0MTY3LCAzNC43MDM5OTQ5NzIgXSwgWyAxMzcuNDEwMTkwMjIyMDAwMDExLCAzNC43MDM5OTc3MjIgXSwgWyAxMzcuNDEwMTQ2MDgzLCAzNC43MDQwOTY4MDYgXSwgWyAxMzcuNDEwMTI1NzMyNDIxOTg5LCAzNC43MDQxNDI0MjY1MTIgXSwgWyAxMzcuNDEwMDI2NzY0MzM3OTk5LCAzNC43MDQzNjQ0MzQ0NTg0OTggXSwgWyAxMzcuNDEwMDYyOTI0ODQwOTg2LCAzNC43MDQzNjQ0MzQ0NTg0OTggXSwgWyAxMzcuNDEwMTI1NzMyNDIxOTg5LCAzNC43MDQyMjM0NDExNDM4MDMgXSwgWyAxMzcuNDEwMjY2NTgzLCAzNC43MDM5MDcyNSBdLCBbIDEzNy40MTAzMTc0MTY5OTk5ODcsIDM0LjcwMzgwNzM4OSBdLCBbIDEzNy40MTAzNjgzODkwMDAwMTMsIDM0LjcwMzcwNzI1IF0sIFsgMTM3LjQxMDM3MDExMSwgMzQuNzAzNzAzMjc4IF0sIFsgMTM3LjQxMDU2ODIyNTg1MzAxMiwgMzQuNzAzMjM1NDQzMjg1MTAyIF0sIFsgMTM3LjQxMDU3Njk3MiwgMzQuNzAzMjE0ODA2IF0sIFsgMTM3LjQxMDU4MjI3OCwgMzQuNzAzMjAyMzMzIF0sIFsgMTM3LjQxMDY4OTgzMywgMzQuNzAyOTQ4MzYxIF0sIFsgMTM3LjQxMDc0NzE2NzAwMDAxMSwgMzQuNzAyODEyNzUgXSwgWyAxMzcuNDEwODAxMzYxMDAwMDExLCAzNC43MDI2ODQ4MDYgXSwgWyAxMzcuNDEwODExMTk0LCAzNC43MDI2ODA3MjIgXSwgWyAxMzcuNDExMDkyMjc4MDAwMDEyLCAzNC43MDI3NTI4MDYgXSwgWyAxMzcuNDExMTQ5NjM5LCAzNC43MDI3Njk0NzIgXSwgWyAxMzcuNDExMjEwNTgzMDAwMDEzLCAzNC43MDI3ODc5MTcgXSwgWyAxMzcuNDExMjQ5MDU2LCAzNC43MDI4MDExOTQgXSwgWyAxMzcuNDExMjg0OTE2OTk5OTg5LCAzNC43MDI4MTg4NjEgXSwgWyAxMzcuNDExMjkzNzc3OTk5OTg3LCAzNC43MDI4MjY1MjggXSwgWyAxMzcuNDExMjk4OTQ0LCAzNC43MDI4MzYzMzMgXSwgWyAxMzcuNDExMjk5NzIyLCAzNC43MDI4NDQ3MjIgXSwgWyAxMzcuNDExMjk4NTU2LCAzNC43MDI4NTU1MjggXSwgWyAxMzcuNDExMjk0Nzc4MDAwMDEzLCAzNC43MDI4NzA4NjEgXSwgWyAxMzcuNDExMjkxODYxLCAzNC43MDI4ODM0MTcgXSwgWyAxMzcuNDExMjgzNjM5LCAzNC43MDI5MDE3MjIgXSwgWyAxMzcuNDExMjcxNjY3LCAzNC43MDI5MTY4ODkgXSwgWyAxMzcuNDExMjYzNjExMDAwMDEsIDM0LjcwMjkyMzU4MyBdLCBbIDEzNy40MTEyNTAwODMsIDM0LjcwMjkzMDkxNyBdLCBbIDEzNy40MTEyMzk5NDM5OTk5ODgsIDM0LjcwMjkzNTA4MyBdLCBbIDEzNy40MTEyMzI4NjEsIDM0LjcwMjkzNjQ0NCBdLCBbIDEzNy40MTEyMjM5MTcsIDM0LjcwMjkzNzE5NCBdLCBbIDEzNy40MTEyMTcxMzksIDM0LjcwMjkzNTgzMyBdLCBbIDEzNy40MTEyMDA3NSwgMzQuNzAyOTMxNjM5IF0sIFsgMTM3LjQxMTA1NzMwNiwgMzQuNzAyODkyMjUgXSwgWyAxMzcuNDExMDQ4MzA2LCAzNC43MDI5MTQ0NDQgXSwgWyAxMzcuNDExMTkyMDgzLCAzNC43MDI5NTM5MTcgXSwgWyAxMzcuNDExMjA5NjY3LCAzNC43MDI5NTgzODkgXSwgWyAxMzcuNDExMjIxODA1OTk5OTg2LCAzNC43MDI5NjA4ODkgXSwgWyAxMzcuNDExMjM3NTI3OTk5OTg3LCAzNC43MDI5NTk2MTEgXSwgWyAxMzcuNDExMjQ5NzIyLCAzNC43MDI5NTcyMjIgXSwgWyAxMzcuNDExMjY0NDQ0MDAwMDExLCAzNC43MDI5NTExNjcgXSwgWyAxMzcuNDExMjgxNjY3LCAzNC43MDI5NDE3NSBdLCBbIDEzNy40MTEyOTM3NSwgMzQuNzAyOTMxNzIyIF0sIFsgMTM3LjQxMTMwOTA4MywgMzQuNzAyOTEyMzA2IF0sIFsgMTM3LjQxMTMxOTE2Njk5OTk4OCwgMzQuNzAyODg5NzUgXSwgWyAxMzcuNDExMzIyNTI4LCAzNC43MDI4NzU0MTcgXSwgWyAxMzcuNDExMzI2NjExLCAzNC43MDI4NTg5MTcgXSwgWyAxMzcuNDExMzI4MjIyLCAzNC43MDI4NDQ4MzMgXSwgWyAxMzcuNDExMzI2NzUsIDM0LjcwMjgzMDYxMSBdLCBbIDEzNy40MTEzMTc4NjA5OTk5ODYsIDM0LjcwMjgxMzM4OSBdLCBbIDEzNy40MTEzMDI3NSwgMzQuNzAyODAwNDQ0IF0sIFsgMTM3LjQxMTI2MTc3ODAwMDAxMSwgMzQuNzAyNzgwMTY3IF0sIFsgMTM3LjQxMTIyMDg4OSwgMzQuNzAyNzY2MDgzIF0sIFsgMTM3LjQxMTE1OTA1NiwgMzQuNzAyNzQ3MzYxIF0sIFsgMTM3LjQxMTEwMTM2MSwgMzQuNzAyNzMwNjExIF0sIFsgMTM3LjQxMDgyMDgzMywgMzQuNzAyNjU4NjExIF0sIFsgMTM3LjQxMDgxNTg4OSwgMzQuNzAyNjUwNjExIF0sIFsgMTM3LjQxMDg3NTc1LCAzNC43MDI1MDkzMDYgXSwgWyAxMzcuNDEwOTQ0NSwgMzQuNzAyMzU3MDgzIF0sIFsgMTM3LjQxMDk3NzQ0NCwgMzQuNzAyMjc4Mzg5IF0sIFsgMTM3LjQxMDk4MzQxNzAwMDAxMSwgMzQuNzAyMjY2ODYxIF0sIFsgMTM3LjQxMDk4ODQxNywgMzQuNzAyMjYwMjUgXSwgWyAxMzcuNDEwOTk4ODg5MDAwMDEyLCAzNC43MDIyNTI5NDQgXSwgWyAxMzcuNDExMDA4MjUsIDM0LjcwMjI0NjI1IF0sIFsgMTM3LjQxMTIwMTkyMDEzNjk4OSwgMzQuNzAyMTA2NDM2NzA1NTk4IF0sIFsgMTM3LjQxMTQ1MDk0NCwgMzQuNzAxOTI2NjY3IF0sIFsgMTM3LjQxMTQ1NzA1NTk5OTk4OSwgMzQuNzAxOTIzNzc4IF0sIFsgMTM3LjQxMTQ2OTI1MDAwMDAxLCAzNC43MDE5MjA2OTQgXSwgWyAxMzcuNDExNDg4Nzc4LCAzNC43MDE5MTY0MTcgXSwgWyAxMzcuNDExNDk5MDIzNDM2OTg4LCAzNC43MDE5MTQ2ODI0NjY1MDEgXSwgWyAxMzcuNDExNTA2MzYxLCAzNC43MDE5MTM4NjEgXSwgWyAxMzcuNDExNTI1Nzc4LCAzNC43MDE5MTE5MTcgXSwgWyAxMzcuNDExNTI4NSwgMzQuNzAxOTExOTE3IF0sIFsgMTM3LjQxMTU1MzMwNiwgMzQuNzAxOTE0MDI4IF0sIFsgMTM3LjQxMTU3ODQxNjk5OTk4NywgMzQuNzAxOTIwMTExIF0sIFsgMTM3LjQxMTY2NjAyODAwMDAxMywgMzQuNzAxOTQxMTk0IF0sIFsgMTM3LjQxMTg2NTcyMTk5OTk4NywgMzQuNzAxOTg5MzA2IF0sIFsgMTM3LjQxMTg3NjMzMywgMzQuNzAyMDA1MDU2IF0sIFsgMTM3LjQxMTg0MzU1Mzg5Mjk5MywgMzQuNzAyMTA2NDM2NzA1NTk4IF0sIFsgMTM3LjQxMTc0OTU1NiwgMzQuNzAyMzk3MTExIF0sIFsgMTM3LjQxMjIwMzYxMSwgMzQuNzAyNTIzMjIyIF0sIFsgMTM3LjQxMjIxNjMzMywgMzQuNzAyNTQ4MTY3IF0sIFsgMTM3LjQxMjEyNjg2MSwgMzQuNzAyNzA1MTExIF0sIFsgMTM3LjQxMTkzMDMwNTk5OTk4OCwgMzQuNzAzMDQ5NjM5IF0sIFsgMTM3LjQxMTcwNDcyMiwgMzQuNzAyOTkyNDcyIF0sIFsgMTM3LjQxMTY3NDY2NywgMzQuNzAyOTg1NSBdLCBbIDEzNy40MTE2NTUzMzMsIDM0LjcwMjk4MjkxNyBdLCBbIDEzNy40MTE1MzkyNSwgMzQuNzAyOTY4NjM5IF0sIFsgMTM3LjQxMTQ5OTAyMzQzNjk4OCwgMzQuNzAyOTY0MDY1NDk2MzAzIF0sIFsgMTM3LjQxMTQxNDU1NjAwMDAxMSwgMzQuNzAyOTU0NDcyIF0sIFsgMTM3LjQxMTQxMDY5NDAwMDAxMSwgMzQuNzAyOTc3NjM5IF0sIFsgMTM3LjQxMTQ5OTAyMzQzNjk4OCwgMzQuNzAyOTg3NzAwMjE1NTAyIF0sIFsgMTM3LjQxMTUzNDk3MiwgMzQuNzAyOTkxODMzIF0sIFsgMTM3LjQxMTY1MDgzMzAwMDAxLCAzNC43MDMwMDYxMTEgXSwgWyAxMzcuNDExNjY4NjM5LCAzNC43MDMwMDg1IF0sIFsgMTM3LjQxMTY5NjY5NCwgMzQuNzAzMDE0OTQ0IF0sIFsgMTM3LjQxMTg3ODQ3MjAwMDAxMiwgMzQuNzAzMDYxIF0sIFsgMTM3LjQxMTkxNzkxNzAwMDAxMSwgMzQuNzAzMDcwOTE3IF0sIFsgMTM3LjQxMTgyMjM3OTQ3Mzk4OSwgMzQuNzAzMjM1NDQzMjg1MTAyIF0sIFsgMTM3LjQxMTcyOTEzODk5OTk4OCwgMzQuNzAzMzk2MDI4IF0sIFsgMTM3LjQxMTU2MjQ0NCwgMzQuNzAzNjg4NTU2IF0sIFsgMTM3LjQxMTQ5OTAyMzQzNjk4OCwgMzQuNzAzNzk2NzM3NzI4NzAyIF0sIFsgMTM3LjQxMTQ1NjExMSwgMzQuNzAzODY5OTcyIF0sIFsgMTM3LjQxMTQ1MzcyMiwgMzQuNzAzODc0MTExIF0sIFsgMTM3LjQxMTQzMDAyODAwMDAxMiwgMzQuNzAzODY2NTgzIF0sIFsgMTM3LjQxMTI5Mzg2MSwgMzQuNzAzODIzNDE3IF0sIFsgMTM3LjQxMTI0MjgzMjk5OTk4OSwgMzQuNzAzODA3MTk0IF0sIFsgMTM3LjQxMTIxMzAyOCwgMzQuNzAzNzk4Nzc4IF0sIFsgMTM3LjQxMTE5MzEzOSwgMzQuNzAzNzk2MDI4IF0sIFsgMTM3LjQxMTE3NTU4Mjk5OTk4OCwgMzQuNzAzNzk2MDU2IF0sIFsgMTM3LjQxMTE2MDMwNiwgMzQuNzAzODAwNjk0IF0sIFsgMTM3LjQxMTE0Mzk0NCwgMzQuNzAzODA3MDI4IF0sIFsgMTM3LjQxMTA5MSwgMzQuNzAzODM5NTgzIF0sIFsgMTM3LjQxMTAyMjI3OCwgMzQuNzAzODk3MzMzIF0sIFsgMTM3LjQxMTAxMTgzMywgMzQuNzAzOTExMTY3IF0sIFsgMTM3LjQxMDk5NzY5NCwgMzQuNzAzOTMwNjY3IF0sIFsgMTM3LjQxMDk1LCAzNC43MDQwNDU3NzggXSwgWyAxMzcuNDEwOTA4MDU2MDAwMDExLCAzNC43MDQxNDYxMTEgXSwgWyAxMzcuNDEwOTM0OTQ0LCAzNC43MDQxNTM3MjIgXSwgWyAxMzcuNDEwOTc3MTExLCAzNC43MDQwNTI4NjEgXSwgWyAxMzcuNDExMDIzNSwgMzQuNzAzOTQwNjk0IF0sIFsgMTM3LjQxMTAzNjIyMiwgMzQuNzAzOTIzMTk0IF0sIFsgMTM3LjQxMTA0NDY5NCwgMzQuNzAzOTExODg5IF0sIFsgMTM3LjQxMTEwOTY5NCwgMzQuNzAzODU3MzA2IF0sIFsgMTM3LjQxMTE1ODUyNzk5OTk4NywgMzQuNzAzODI3MTk0IF0sIFsgMTM3LjQxMTE3MTI3ODAwMDAxMiwgMzQuNzAzODIyMzA2IF0sIFsgMTM3LjQxMTE4MDY2NywgMzQuNzAzODE5NSBdLCBbIDEzNy40MTExOTA4MDYsIDM0LjcwMzgxOTQ3MiBdLCBbIDEzNy40MTEyMDYxMTEwMDAwMTMsIDM0LjcwMzgyMTYxMSBdLCBbIDEzNy40MTEyMzMzMDYwMDAwMTQsIDM0LjcwMzgyOTIyMiBdLCBbIDEzNy40MTEyODU4NjEwMDAwMSwgMzQuNzAzODQ1OTcyIF0sIFsgMTM3LjQxMTQ0MTMzMywgMzQuNzAzODk1MzMzIF0sIFsgMTM3LjQxMTQzMjk3MiwgMzQuNzAzOTA5NSBdLCBbIDEzNy40MTEzMDE2NjcsIDM0LjcwNDEzMzUyOCBdLCBbIDEzNy40MTEyMTQzMDYsIDM0LjcwNDMwODg2MSBdLCBbIDEzNy40MTEyMDMyNSwgMzQuNzA0MzMzMDI4IF0sIFsgMTM3LjQxMTE5MTExNjU3MzAwOCwgMzQuNzA0MzY0NDM0NDU4NDk4IF0sIFsgMTM3LjQxMTI2ODkyNjYxNTAwOCwgMzQuNzA0MzY0NDM0NDU4NDk4IF0sIFsgMTM3LjQxMTI4NDU1NiwgMzQuNzA0MzI2NTU2IF0sIFsgMTM3LjQxMTM0NjgzMzAwMDAxLCAzNC43MDQyMDE2NjcgXSwgWyAxMzcuNDExMzY4NDQ0LCAzNC43MDQxNTgxNjcgXSwgWyAxMzcuNDExNDk5MDIzNDM2OTg4LCAzNC43MDM5MzU0NTY1NDczOTkgXSwgWyAxMzcuNDExNTA4NDQ0LCAzNC43MDM5MTkzNjEgXSwgWyAxMzcuNDExNTIwMzYwOTk5OTg3LCAzNC43MDM4OTkgXSwgWyAxMzcuNDExNTYwMTM4OTk5OTg4LCAzNC43MDM4MzEwODMgXSwgWyAxMzcuNDExNjI4MjUsIDM0LjcwMzcxNDgzMyBdLCBbIDEzNy40MTE2MTk3MjIwMDAwMTIsIDM0LjcwMzcxMDc3OCBdLCBbIDEzNy40MTE3Nzk2OTM5OTk5ODksIDM0LjcwMzQzMDA4MyBdLCBbIDEzNy40MTE3ODE2MzksIDM0LjcwMzQyNjY2NyBdLCBbIDEzNy40MTE4MDIxNjcsIDM0LjcwMzM5NTMzMyBdLCBbIDEzNy40MTE4OTUwMTE4MTYsIDM0LjcwMzIzNTQ0MzI4NTEwMiBdLCBbIDEzNy40MTE5NDI5NDQsIDM0LjcwMzE1MjkxNyBdLCBbIDEzNy40MTE5ODAwNTYsIDM0LjcwMzA4OTA4MyBdLCBbIDEzNy40MTE5ODY2MTEsIDM0LjcwMzA3NzgzMyBdLCBbIDEzNy40MTE5OTMxMTA5OTk5ODcsIDM0LjcwMzA2NjM4OSBdLCBbIDEzNy40MTIyNzc5MTcwMDAwMTEsIDM0LjcwMjU2NzEzOSBdLCBbIDEzNy40MTIzMjM4MDU5OTk5ODksIDM0LjcwMjQ4NjY5NCBdLCBbIDEzNy40MTIzNTYzODksIDM0LjcwMjQyOTYxMSBdLCBbIDEzNy40MTIzNjYxNjY5OTk5ODgsIDM0LjcwMjQxNjY5NCBdLCBbIDEzNy40MTIzNjg2NjcwMDAwMSwgMzQuNzAyNDEyMzYxIF0sIFsgMTM3LjQxMjQwMDk0NDAwMDAxMiwgMzQuNzAyNDA3ODg5IF0sIFsgMTM3LjQxMjQ2NDg2MDk5OTk4OSwgMzQuNzAyNDYxOTQ0IF0sIFsgMTM3LjQxMjQ5MTI0OTk5OTk4OCwgMzQuNzAyNDg3Mzg5IF0sIFsgMTM3LjQxMjQ5OTgwNiwgMzQuNzAyNTAxMzYxIF0sIFsgMTM3LjQxMjUwNTQxNywgMzQuNzAyNTEyMTY3IF0sIFsgMTM3LjQxMjUwOTY5NCwgMzQuNzAyNTIyODg5IF0sIFsgMTM3LjQxMjUxNCwgMzQuNzAyNTM2MTExIF0sIFsgMTM3LjQxMjUxNzUyOCwgMzQuNzAyNTUxNDQ0IF0sIFsgMTM3LjQxMjUyMDA4MywgMzQuNzAyNTY1NDE3IF0sIFsgMTM3LjQxMjUyMDQxNywgMzQuNzAyNTY4NDcyIF0sIFsgMTM3LjQxMjUyMDY5NCwgMzQuNzAyNTkyNTgzIF0sIFsgMTM3LjQxMjUyMTMwNiwgMzQuNzAyNjQ4MTY3IF0sIFsgMTM3LjQxMjUxOTg4OSwgMzQuNzAyODcxMTExIF0sIFsgMTM3LjQxMjM1MTMzMywgMzQuNzAzMTI2Mzg5IF0sIFsgMTM3LjQxMjM0MDAyNzk5OTk4OCwgMzQuNzAzMTQ0IF0sIFsgMTM3LjQxMjMyNDM4OSwgMzQuNzAzMTcwMTY3IF0sIFsgMTM3LjQxMjI4MjYxMjgyMTAwMiwgMzQuNzAzMjM1NDQzMjg1MTAyIF0sIFsgMTM3LjQxMjI2MjY2NywgMzQuNzAzMjY2NjY3IF0sIFsgMTM3LjQxMjI2MDYxMSwgMzQuNzAzMjY5ODMzIF0sIFsgMTM3LjQxMjI1NDc0OTk5OTk4OCwgMzQuNzAzMjc5MzA2IF0sIFsgMTM3LjQxMjIyMjkxNywgMzQuNzAzMzI5Nzc4IF0sIFsgMTM3LjQxMjIwMTEzOSwgMzQuNzAzMzgzNjM5IF0sIFsgMTM3LjQxMjEyNzU4MywgMzQuNzAzNTc0NzIyIF0sIFsgMTM3LjQxMjEyNDUyOCwgMzQuNzAzNTgyNjY3IF0sIFsgMTM3LjQxMjAxNjYzOSwgMzQuNzAzODY0ODYxIF0sIFsgMTM3LjQxMTk4NzgzMzAwMDAxMiwgMzQuNzAzOTQwMTExIF0sIFsgMTM3LjQxMTk2MDQ0Mzk5OTk4OCwgMzQuNzA0MDIxMjIyIF0sIFsgMTM3LjQxMTkzOTg4OSwgMzQuNzA0MDgxNDcyIF0sIFsgMTM3LjQxMTkzMTU4MzAwMDAxMiwgMzQuNzA0MTE2ODMzIF0sIFsgMTM3LjQxMTkyMTY5NCwgMzQuNzA0MTcwNzc4IF0sIFsgMTM3LjQxMTkxOTI1MDAwMDAxMSwgMzQuNzA0MTkzNjY3IF0sIFsgMTM3LjQxMTkxMzA1NiwgMzQuNzA0MjAxMTY3IF0sIFsgMTM3LjQxMTg2ODY5NCwgMzQuNzA0MjE5NDcyIF0sIFsgMTM3LjQxMTg0Mjk3MTk5OTk4OCwgMzQuNzA0MjM4MzYxIF0sIFsgMTM3LjQxMTgxNzM4OSwgMzQuNzA0MjYwNSBdLCBbIDEzNy40MTE4NDQzMzMsIDM0LjcwNDI4OTM4OSBdLCBbIDEzNy40MTE4NzMzMDYsIDM0LjcwNDI2NDM2MSBdLCBbIDEzNy40MTE4OTM0NDM5OTk5ODYsIDM0LjcwNDI0OTUyOCBdLCBbIDEzNy40MTE5MDQxMzksIDM0LjcwNDI0NTA4MyBdLCBbIDEzNy40MTE5MTMxOTQsIDM0LjcwNDI1MDE5NCBdLCBbIDEzNy40MTE5MDEwMDU0ODM5OTgsIDM0LjcwNDM2NDQzNDQ1ODQ5OCBdLCBbIDEzNy40MTE5NTAyNzY2NzYwMDksIDM0LjcwNDM2NDQzNDQ1ODQ5OCBdLCBbIDEzNy40MTE5NjIxOTQwMDAwMTIsIDM0LjcwNDI1Mjg2MSBdLCBbIDEzNy40MTE5NjgyNzc5OTk5ODksIDM0LjcwNDE5NTY5NCBdLCBbIDEzNy40MTE5NzA0MTcsIDM0LjcwNDE3NTcyMiBdLCBbIDEzNy40MTE5ODAwODMsIDM0LjcwNDEyMzU4MyBdLCBbIDEzNy40MTE5ODc2MTEsIDM0LjcwNDA5MDg2MSBdLCBbIDEzNy40MTIwMDc1MjgsIDM0LjcwNDAzMjgzMyBdLCBbIDEzNy40MTIwMzQ4MDYsIDM0LjcwMzk1MTgzMyBdLCBbIDEzNy40MTIxNzI5MTcsIDM0LjcwMzU5MDg2MSBdLCBbIDEzNy40MTIyNDc2NjcsIDM0LjcwMzM5NjYxMSBdLCBbIDEzNy40MTIyNjgzNjEsIDM0LjcwMzM0NTYzOSBdLCBbIDEzNy40MTIzMDM0NzIsIDM0LjcwMzI4OTc1IF0sIFsgMTM3LjQxMjMzODE3MzI4Njk5NywgMzQuNzAzMjM1NDQzMjg1MTAyIF0sIFsgMTM3LjQxMjM5MDYxMSwgMzQuNzAzMTUzNDQ0IF0sIFsgMTM3LjQxMjU3MDAyOCwgMzQuNzAyODgxODMzIF0sIFsgMTM3LjQxMjU3MTQxNywgMzQuNzAyNjUzOTE3IF0sIFsgMTM3LjQxMjU4MDI1LCAzNC43MDI2NDg2NjcgXSwgWyAxMzcuNDEyODcyMzE0NDUzMDExLCAzNC43MDI3MjkwMTQzODcxMDMgXSwgWyAxMzcuNDEyODcyMzg5LCAzNC43MDI3MjkwMjggXSwgWyAxMzcuNDEzMTc1ODg5LCAzNC43MDI4MTI1MjggXSwgWyAxMzcuNDEzMjU5OTE3LCAzNC43MDI4Mzg3NzggXSwgWyAxMzcuNDEzMjcyMjUsIDM0LjcwMjg0MTI3OCBdLCBbIDEzNy40MTMzMDI5NzIsIDM0LjcwMjg1NTI3OCBdLCBbIDEzNy40MTMzMSwgMzQuNzAyODY4MDgzIF0sIFsgMTM3LjQxMzEwMDI5Mzc4MjAwOSwgMzQuNzAzMjM1NDQzMjg1MTAyIF0sIFsgMTM3LjQxMzA1ODk3MTk5OTk4OCwgMzQuNzAzMzA3ODMzIF0sIFsgMTM3LjQxMzAyOTYzOSwgMzQuNzAzMzU5MTk0IF0sIFsgMTM3LjQxMjg3MjMxNDQ1MzAxMSwgMzQuNzAzNjM0ODE2NzI5MSBdLCBbIDEzNy40MTI1ODgyNSwgMzQuNzA0MTMyNDcyIF0sIFsgMTM3LjQxMjQ0ODM3NDI4NTk4NywgMzQuNzA0MzY0NDM0NDU4NDk4IF0sIFsgMTM3LjQxMjY2NDE2NTk4MTk5NCwgMzQuNzA0MzY0NDM0NDU4NDk4IF0sIFsgMTM3LjQxMjc2MjEzOSwgMzQuNzA0MjAxOTcyIF0sIFsgMTM3LjQxMjg3MjMxNDQ1MzAxMSwgMzQuNzA0MDA4OTUzMTIwNTk5IF0sIFsgMTM3LjQxMzIwMzkxNywgMzQuNzAzNDI4MDI4IF0sIFsgMTM3LjQxMzIxMDc3OCwgMzQuNzAzNDI2MDI4IF0sIFsgMTM3LjQxMzQ5NjM4ODk5OTk4OCwgMzQuNzAzNTg1OTE3IF0sIFsgMTM3LjQxMzY5ODg4ODk5OTk4OCwgMzQuNzAzNjk2Nzc4IF0sIFsgMTM3LjQxMzcwMjA1NiwgMzQuNzAzNjk4NTU2IF0sIFsgMTM3LjQxMzg3OTE5NCwgMzQuNzAzNzk5Mjc4IF0sIFsgMTM3LjQxNDA1ODYzOSwgMzQuNzAzODk5NSBdLCBbIDEzNy40MTQxMzkxMTEsIDM0LjcwMzk0Njc3OCBdLCBbIDEzNy40MTQxMzM0NDM5OTk5ODcsIDM0LjcwMzk1NDQ0NCBdLCBbIDEzNy40MTQwODMzODkwMDAwMTIsIDM0LjcwMzkzMzE2NyBdLCBbIDEzNy40MTQwMTg0NDQsIDM0LjcwMzkwMDM4OSBdLCBbIDEzNy40MTM5NTIsIDM0LjcwMzg2ODUyOCBdLCBbIDEzNy40MTM5MDI1ODMsIDM0LjcwMzg0MjMwNiBdLCBbIDEzNy40MTM4NzczMDU5OTk5ODksIDM0LjcwMzgyODgzMyBdLCBbIDEzNy40MTM4NTQ0NzIsIDM0LjcwMzgxOTk0NCBdLCBbIDEzNy40MTM4MjY5NDQsIDM0LjcwMzgxMzA4MyBdLCBbIDEzNy40MTM2OTk1ODMwMDAwMSwgMzQuNzAzNzg1NzUgXSwgWyAxMzcuNDEzNjcyNjExMDAwMDEsIDM0LjcwMzc4MzA4MyBdLCBbIDEzNy40MTM2NTc3NSwgMzQuNzAzNzgyMDU2IF0sIFsgMTM3LjQxMzYzOTQxNzAwMDAxMywgMzQuNzAzNzgxNDQ0IF0sIFsgMTM3LjQxMzYzMDAyOCwgMzQuNzAzNzgyMTk0IF0sIFsgMTM3LjQxMzYyLCAzNC43MDM3ODQgXSwgWyAxMzcuNDEzNjEzMjIyLCAzNC43MDM3ODUzODkgXSwgWyAxMzcuNDEzNjAxMzYxLCAzNC43MDM3OSBdLCBbIDEzNy40MTM1OTM4MzMsIDM0LjcwMzc5MzUyOCBdLCBbIDEzNy40MTM1ODk1ODMsIDM0LjcwMzc5ODQxNyBdLCBbIDEzNy40MTM1ODU0NzIsIDM0LjcwMzgwNjE2NyBdLCBbIDEzNy40MTM1ODU2OTQsIDM0LjcwMzgxNTU1NiBdLCBbIDEzNy40MTM1ODk1NTYsIDM0LjcwMzgyNTYzOSBdLCBbIDEzNy40MTM1OTMzODksIDM0LjcwMzgzMDg2MSBdLCBbIDEzNy40MTM2MzM0MTcsIDM0LjcwMzg1NTc1IF0sIFsgMTM3LjQxMzczNDU4MywgMzQuNzAzOTE1OTQ0IF0sIFsgMTM3LjQxMzc1MDQ0Mzk5OTk4NywgMzQuNzAzODk3Njk0IF0sIFsgMTM3LjQxMzY0OTQxNjk5OTk4OCwgMzQuNzAzODM3NSBdLCBbIDEzNy40MTM2MTUxOTM5OTk5ODgsIDM0LjcwMzgxNjE5NCBdLCBbIDEzNy40MTM2MTM4NjA5OTk5ODgsIDM0LjcwMzgxNDMwNiBdLCBbIDEzNy40MTM2MTI5NzIwMDAwMSwgMzQuNzAzODEyMTY3IF0sIFsgMTM3LjQxMzYxMjk3MjAwMDAxLCAzNC43MDM4MTA5NzIgXSwgWyAxMzcuNDEzNjEzNDE3LCAzNC43MDM4MTAzNjEgXSwgWyAxMzcuNDEzNjEzNzUsIDM0LjcwMzgxMDA4MyBdLCBbIDEzNy40MTM2MjI1ODMsIDM0LjcwMzgwNjYzOSBdLCBbIDEzNy40MTM2MjYxNjcsIDM0LjcwMzgwNTkxNyBdLCBbIDEzNy40MTM2MzQyNSwgMzQuNzAzODA0NDQ0IF0sIFsgMTM3LjQxMzY0MDEzOSwgMzQuNzAzODAzOTcyIF0sIFsgMTM3LjQxMzY1NjE5NCwgMzQuNzAzODA0NTgzIF0sIFsgMTM3LjQxMzY2OTcyMiwgMzQuNzAzODA1NDQ0IF0sIFsgMTM3LjQxMzY5NDUyOCwgMzQuNzAzODA3OTQ0IF0sIFsgMTM3LjQxMzgxOTU4MywgMzQuNzAzODM0ODA2IF0sIFsgMTM3LjQxMzg0NDYxMSwgMzQuNzAzODQwOTcyIF0sIFsgMTM3LjQxMzg2Mzk0NDAwMDAxMywgMzQuNzAzODQ4NjExIF0sIFsgMTM3LjQxMzg3NDU1NiwgMzQuNzAzODU0MTY3IF0sIFsgMTM3LjQxMzg4NjkxNzAwMDAxMywgMzQuNzAzODYwODMzIF0sIFsgMTM3LjQxMzkzNzYzOTAwMDAxMSwgMzQuNzAzODg3Nzc4IF0sIFsgMTM3LjQxNDAwNDU1NiwgMzQuNzAzOTE5NzIyIF0sIFsgMTM3LjQxNDA3MDEzODk5OTk4OSwgMzQuNzAzOTUyODYxIF0sIFsgMTM3LjQxNDA5NjA1NiwgMzQuNzAzOTYzODg5IF0sIFsgMTM3LjQxNDEwMTgzMjk5OTk4OSwgMzQuNzAzOTY3NDcyIF0sIFsgMTM3LjQxNDEwNTg4OTAwMDAxMiwgMzQuNzAzOTcyMzMzIF0sIFsgMTM3LjQxNDEwNzg2MSwgMzQuNzAzOTc4MTExIF0sIFsgMTM3LjQxNDEwNzMzMywgMzQuNzAzOTg0MDU2IF0sIFsgMTM3LjQxNDEwNDYzODk5OTk4NywgMzQuNzAzOTg5NTU2IF0sIFsgMTM3LjQxNDA0ODA4MzAwMDAxMiwgMzQuNzA0MDYzNjk0IF0sIFsgMTM3LjQxMzkwODA4MywgMzQuNzA0MjMzNTgzIF0sIFsgMTM3LjQxMzg4ODc1MDAwMDAxMiwgMzQuNzA0MjU3MDI4IF0sIFsgMTM3LjQxMzg2NzMwNTk5OTk4NiwgMzQuNzA0MjgzNDcyIF0sIFsgMTM3LjQxMzgwMTU5MjMxNDAwMiwgMzQuNzA0MzY0NDM0NDU4NDk4IF0sIFsgMTM3LjQxMzg1NTQ4OTc5MjAxMywgMzQuNzA0MzY0NDM0NDU4NDk4IF0sIFsgMTM3LjQxMzkwMzcyMTk5OTk4NiwgMzQuNzA0MzA1MDU2IF0sIFsgMTM3LjQxMzkwODYzOSwgMzQuNzA0MzAwNzIyIF0sIFsgMTM3LjQxMzkxNDk0NCwgMzQuNzA0Mjk3OTE3IF0sIFsgMTM3LjQxMzkyMjA1NiwgMzQuNzA0Mjk3IF0sIFsgMTM3LjQxMzkyOTEzOSwgMzQuNzA0Mjk4MDU2IF0sIFsgMTM3LjQxMzkzNTQ3MiwgMzQuNzA0MzAwOTQ0IF0sIFsgMTM3LjQxNDAzMTY4MDcyNDAwOCwgMzQuNzA0MzY0NDM0NDU4NDk4IF0sIFsgMTM3LjQxNDA3NzA3NTgyOTk5NCwgMzQuNzA0MzY0NDM0NDU4NDk4IF0sIFsgMTM3LjQxMzk0OTUsIDM0LjcwNDI4MDE2NyBdLCBbIDEzNy40MTM5NDUwMjgsIDM0LjcwNDI3NjMwNiBdLCBbIDEzNy40MTM5NDIyNzgsIDM0LjcwNDI3MTQ0NCBdLCBbIDEzNy40MTM5NDEyNzgwMDAwMSwgMzQuNzA0MjY2MTExIF0sIFsgMTM3LjQxMzk0MjI1LCAzNC43MDQyNjA4MDYgXSwgWyAxMzcuNDEzOTQ1MDU1OTk5OTg5LCAzNC43MDQyNTYwMjggXSwgWyAxMzcuNDE0MDg2NDcyLCAzNC43MDQwODQ0NDQgXSwgWyAxMzcuNDE0MTQyNDE3LCAzNC43MDQwMTA5MTcgXSwgWyAxMzcuNDE0MTYyODA2LCAzNC43MDM5ODQxMzkgXSwgWyAxMzcuNDE0MTY3MzYxMDAwMDExLCAzNC43MDM5Nzk4ODkgXSwgWyAxMzcuNDE0MTczMzYxLCAzNC43MDM5NzY5NzIgXSwgWyAxMzcuNDE0MTgwMTM5LCAzNC43MDM5NzU3MjIgXSwgWyAxMzcuNDE0MTg3LCAzNC43MDM5NzYzMzMgXSwgWyAxMzcuNDE0MTkzMzYxLCAzNC43MDM5Nzg2NjcgXSwgWyAxMzcuNDE0MjQ1NjA1NDY5MDA2LCAzNC43MDQwMDcxMDkzNDYyIF0sIFsgMTM3LjQxNDM2MzE2NywgMzQuNzA0MDcxMDgzIF0sIFsgMTM3LjQxNDU0MjE2NywgMzQuNzA0MTc1NjM5IF0sIFsgMTM3LjQxNDcwMzc3Nzk5OTk4OSwgMzQuNzA0MjY1NTU2IF0sIFsgMTM3LjQxNDczMTk3MiwgMzQuNzA0MjgxMTk0IF0sIFsgMTM3LjQxNDgxODgwNiwgMzQuNzA0MzI4ODA2IF0sIFsgMTM3LjQxNDg4NDE0OTc3MTAxMiwgMzQuNzA0MzY0NDM0NDU4NDk4IF0sIFsgMTM3LjQxNDk2MTM4NDYxNTk5MiwgMzQuNzA0MzY0NDM0NDU4NDk4IF0sIFsgMTM3LjQxNDg0MTA4MywgMzQuNzA0Mjk4ODMzIF0sIFsgMTM3LjQxNDc1NTM2MSwgMzQuNzA0MjUxODMzIF0sIFsgMTM3LjQxNDU2NjE5NCwgMzQuNzA0MTQ2NjY3IF0sIFsgMTM3LjQxNDM4NzA4MywgMzQuNzA0MDQyIF0sIFsgMTM3LjQxNDI0NTYwNTQ2OTAwNiwgMzQuNzAzOTY0OTUwMzU1MSBdLCBbIDEzNy40MTQyMjA0NDQsIDM0LjcwMzk1MTI3OCBdLCBbIDEzNy40MTQxODkyNzgsIDM0LjcwMzkzMzA1NiBdLCBbIDEzNy40MTQyNDU2MDU0NjkwMDYsIDM0LjcwMzg2NzQyMTI5MzYwMiBdLCBbIDEzNy40MTQ1MDA5NDQsIDM0LjcwMzU2OTgzMyBdLCBbIDEzNy40MTQ0ODIyNSwgMzQuNzAzNTYwNSBdLCBbIDEzNy40MTQyNDU2MDU0NjkwMDYsIDM0LjcwMzgzNjI2NjAzNDk5NyBdLCBbIDEzNy40MTQxNzE0NzIsIDM0LjcwMzkyMjYzOSBdLCBbIDEzNy40MTQxNTg4ODksIDM0LjcwMzkxNTE2NyBdLCBbIDEzNy40MTQwODI4ODkwMDAwMTQsIDM0LjcwMzg3MDYxMSBdLCBbIDEzNy40MTM5MDMsIDM0LjcwMzc3MDA4MyBdLCBbIDEzNy40MTM3MjI1ODMsIDM0LjcwMzY2NzUgXSwgWyAxMzcuNDEzNjk2MzYxLCAzNC43MDM2NTMxMzkgXSwgWyAxMzcuNDEzNTE5OTcxOTk5OTg5LCAzNC43MDM1NTY2NjcgXSwgWyAxMzcuNDEzMjI3NjExLCAzNC43MDMzOTI5MTcgXSwgWyAxMzcuNDEzMjI3OTE3LCAzNC43MDMzODU5NzIgXSwgWyAxMzcuNDEzMzEzODU1MjY4MDAxLCAzNC43MDMyMzU0NDMyODUxMDIgXSwgWyAxMzcuNDEzNDg2OTE3LCAzNC43MDI5MzIyNSBdLCBbIDEzNy40MTM1MDc1LCAzNC43MDI4OTYxOTQgXSwgWyAxMzcuNDEzNjMyLCAzNC43MDI2NzgxMTEgXSwgWyAxMzcuNDEzNzgwMDgzLCAzNC43MDI0MTA2OTQgXSwgWyAxMzcuNDEzNzg4NTAwMDAwMDEsIDM0LjcwMjQwOTUgXSwgWyAxMzcuNDEzODAxMTY3LCAzNC43MDI0MTUwNTYgXSwgWyAxMzcuNDEzOTIwNjM5LCAzNC43MDI0Njc3MjIgXSwgWyAxMzcuNDEzOTMwNTgzLCAzNC43MDI0NzIwMjggXSwgWyAxMzcuNDEzOTU3Mzg4OTk5OTg5LCAzNC43MDI0OTEzNjEgXSwgWyAxMzcuNDE0MTk5ODA2LCAzNC43MDI2NjYyMjIgXSwgWyAxMzcuNDE0MjE5MTk0LCAzNC43MDI2NDc4ODkgXSwgWyAxMzcuNDEzOTc2ODg5LCAzNC43MDI0NzMxMTEgXSwgWyAxMzcuNDEzOTQ3NDQ0LCAzNC43MDI0NTE4ODkgXSwgWyAxMzcuNDEzOTQyNTI4LCAzNC43MDI0NDk3NSBdLCBbIDEzNy40MTM4MTIwMjgsIDM0LjcwMjM5MjIyMiBdLCBbIDEzNy40MTM3OTgzNjEsIDM0LjcwMjM4NjIyMiBdLCBbIDEzNy40MTM3OTY4MDYsIDM0LjcwMjM4MDM2MSBdLCBbIDEzNy40MTM5NDg0Nzg1MTEwMDMsIDM0LjcwMjEwNjQzNjcwNTU5OCBdLCBbIDEzNy40MTM5NTIzMDYsIDM0LjcwMjA5OTUgXSwgWyAxMzcuNDE0MDA1MzA2LCAzNC43MDIwNDU4MzMgXSwgWyAxMzcuNDE0MDMzODMzLCAzNC43MDIwMjg0NzIgXSwgWyAxMzcuNDE0MTQ3Mjc4LCAzNC43MDE5NTkzNjEgXSwgWyAxMzcuNDE0MjQ1NjA1NDY5MDA2LCAzNC43MDE4OTQ2MTQwODM4OTggXSwgWyAxMzcuNDE0MjcyNzc4LCAzNC43MDE4NzY2OTQgXSwgWyAxMzcuNDE0Mzg3ODMzLCAzNC43MDE4MDA5MTcgXSwgWyAxMzcuNDE0NDY1NjM5MDAwMDE0LCAzNC43MDE3NTg5NDQgXSwgWyAxMzcuNDE0NTM3NjY3LCAzNC43MDE3MjAxOTQgXSwgWyAxMzcuNDE0NTcyNTU2LCAzNC43MDE3MDEzODkgXSwgWyAxMzcuNDE0NTc5NjM5MDAwMDEsIDM0LjcwMTY5NzU4MyBdLCBbIDEzNy40MTUwOTc3NSwgMzQuNzAxNDE4NDE3IF0sIFsgMTM3LjQxNTExOTE2NywgMzQuNzAxNDI2MzA2IF0sIFsgMTM3LjQxNTEyMTc1LCAzNC43MDE1NTg3MjIgXSwgWyAxMzcuNDE1MTA5MTM5LCAzNC43MDE1NzU4ODkgXSwgWyAxMzcuNDE0ODQ1NDQ0LCAzNC43MDE3MDA4MzMgXSwgWyAxMzcuNDE0NzIzNjk0LCAzNC43MDE3NTg1IF0sIFsgMTM3LjQxNDc1NDA4MywgMzQuNzAxODA4NTU2IF0sIFsgMTM3LjQxNDc4MTcyMTk5OTk4NywgMzQuNzAxODUwNjExIF0sIFsgMTM3LjQxNDgxMjY5NCwgMzQuNzAxODg0MjUgXSwgWyAxMzcuNDE1MTA5MjUsIDM0LjcwMjAxNTcyMiBdLCBbIDEzNy40MTUxMjYxMzksIDM0LjcwMjAzODg2MSBdLCBbIDEzNy40MTUxMjY3MDE0NjA5OTEsIDM0LjcwMjEwNjQzNjcwNTU5OCBdLCBbIDEzNy40MTUxMjgzMzMwMDAwMTMsIDM0LjcwMjMwMzQ0NCBdLCBbIDEzNy40MTUxMzAwNTYwMDAwMSwgMzQuNzAyMzI3MDgzIF0sIFsgMTM3LjQxNTEzMDExMSwgMzQuNzAyMzQ4MTY3IF0sIFsgMTM3LjQxNTEyNzI1MDAwMDAxMiwgMzQuNzAyMzc0Nzc4IF0sIFsgMTM3LjQxNTEyMzEzOSwgMzQuNzAyMzkyOTcyIF0sIFsgMTM3LjQxNTExNzA4MzAwMDAxMywgMzQuNzAyNDEwNTgzIF0sIFsgMTM3LjQxNTA4NTY2NywgMzQuNzAyNDU3NjExIF0sIFsgMTM3LjQxNTA2OTA1NiwgMzQuNzAyNDgxMDgzIF0sIFsgMTM3LjQxNTAxODg2MSwgMzQuNzAyNTU5NDQ0IF0sIFsgMTM3LjQxNDg2NTMzMywgMzQuNzAyNzk5Mjc4IF0sIFsgMTM3LjQxNDg0NTI1MDAwMDAxMywgMzQuNzAyODA2MzYxIF0sIFsgMTM3LjQxNDgzNTc1LCAzNC43MDI4MDQxMTEgXSwgWyAxMzcuNDE0ODE0MDI4LCAzNC43MDI4MDQwODMgXSwgWyAxMzcuNDE0Nzk2NjkzOTk5OTg5LCAzNC43MDI4MDk2OTQgXSwgWyAxMzcuNDE0Nzc5Njk0LCAzNC43MDI4MTg5MTcgXSwgWyAxMzcuNDE0NzU2ODMzMDAwMDEzLCAzNC43MDI4Mzk0NDQgXSwgWyAxMzcuNDE0NzMwODMzLCAzNC43MDI4NzAxMzkgXSwgWyAxMzcuNDE0NzI1NjExLCAzNC43MDI4NzU0NzIgXSwgWyAxMzcuNDE0NjQ4MzMzLCAzNC43MDI5NTUyMjIgXSwgWyAxMzcuNDE0NjcwNDQ0LCAzNC43MDI5Njk4ODkgXSwgWyAxMzcuNDE0NzUzNTgzLCAzNC43MDI4ODQwODMgXSwgWyAxMzcuNDE0Nzc4OTE3LCAzNC43MDI4NTQxNjcgXSwgWyAxMzcuNDE0Nzk4MTk0MDAwMDE0LCAzNC43MDI4MzY4MzMgXSwgWyAxMzcuNDE0ODA5NzQ5OTk5OTg5LCAzNC43MDI4MzA1ODMgXSwgWyAxMzcuNDE0ODE5MzMzLCAzNC43MDI4Mjc1IF0sIFsgMTM3LjQxNDgzMTc3OCwgMzQuNzAyODI3NTU2IF0sIFsgMTM3LjQxNDg0MjA1NiwgMzQuNzAyODI5OTcyIF0sIFsgMTM3LjQxNDg0MjcyMiwgMzQuNzAyODM0NjY3IF0sIFsgMTM3LjQxNDc3MTExMSwgMzQuNzAyOTQ2NSBdLCBbIDEzNy40MTQ3MTQ2MzkwMDAwMSwgMzQuNzAzMDQxMDI4IF0sIFsgMTM3LjQxNDcwNzA1NiwgMzQuNzAzMDYyMDI4IF0sIFsgMTM3LjQxNDcwMzQxNywgMzQuNzAzMDg0NjY3IF0sIFsgMTM3LjQxNDcwNDY5NCwgMzQuNzAzMTEyMjUgXSwgWyAxMzcuNDE0NzEzMzg5MDAwMDEzLCAzNC43MDMxMzYzODkgXSwgWyAxMzcuNDE0NzMwNTgzLCAzNC43MDMxNTY4MzMgXSwgWyAxMzcuNDE0NzUzNDQ0MDAwMDEzLCAzNC43MDMxNzE5MTcgXSwgWyAxMzcuNDE0Nzg4MjIyLCAzNC43MDMxODcwODMgXSwgWyAxMzcuNDE0OTIwMDg5NjM3MDA4LCAzNC43MDMyMzU0NDMyODUxMDIgXSwgWyAxMzcuNDE1MjQwNTI4LCAzNC43MDMzNTI5NDQgXSwgWyAxMzcuNDE1MjQ3MDgzLCAzNC43MDMzNTQ0NzIgXSwgWyAxMzcuNDE1MjcxODg5LCAzNC43MDMzNjAyNzggXSwgWyAxMzcuNDE1MzA5MTk0LCAzNC43MDMzNTczMDYgXSwgWyAxMzcuNDE1MzQzNzc4LCAzNC43MDMzNDM4MDYgXSwgWyAxMzcuNDE1MzU0NjM4OTk5OTg2LCAzNC43MDMzMzI0NDQgXSwgWyAxMzcuNDE1MzgzMzg5LCAzNC43MDMzMDQxNjcgXSwgWyAxMzcuNDE1NDI2MjYxMTQ4MDE0LCAzNC43MDMyMzU0NDMyODUxMDIgXSwgWyAxMzcuNDE1NTE3MjIyLCAzNC43MDMwODk2OTQgXSwgWyAxMzcuNDE1NTE4MTkzOTk5OTg2LCAzNC43MDMwODg3NzggXSwgWyAxMzcuNDE1NTE4OTcyLCAzNC43MDMwODgzMzMgXSwgWyAxMzcuNDE1NTIwNTAwMDAwMDE0LCAzNC43MDMwODc1IF0sIFsgMTM3LjQxNTUyMjI1LCAzNC43MDMwODcwNTYgXSwgWyAxMzcuNDE1NTI0NjM5MDAwMDEyLCAzNC43MDMwODY2OTQgXSwgWyAxMzcuNDE1NTI2MDU2LCAzNC43MDMwODY4NjEgXSwgWyAxMzcuNDE1NjE4ODk2NDg0MDA2LCAzNC43MDMwOTQ2MzY5OTY0OTcgXSwgWyAxMzcuNDE1NjE4ODk2NDg0MDA2LCAzNC43MDMwNDQ4NDU3MDY4OTkgXSwgWyAxMzcuNDE1NTEzMDI4LCAzNC43MDMwMzU5NzIgXSwgWyAxMzcuNDE1NDk3ODYxLCAzNC43MDMwMzczMzMgXSwgWyAxMzcuNDE1NDg2MDgzLCAzNC43MDMwNDM1ODMgXSwgWyAxMzcuNDE1NDc1OTcyLCAzNC43MDMwNTIgXSwgWyAxMzcuNDE1NDY3NTgzLCAzNC43MDMwNjEwMjggXSwgWyAxMzcuNDE1MzU4NzI5NDI1MDA5LCAzNC43MDMyMzU0NDMyODUxMDIgXSwgWyAxMzcuNDE1MzIyODYxLCAzNC43MDMyOTI5MTcgXSwgWyAxMzcuNDE1MzA4ODMzMDAwMDEyLCAzNC43MDMzMDc2MzkgXSwgWyAxMzcuNDE1Mjk0NTU2LCAzNC43MDMzMTMxNjcgXSwgWyAxMzcuNDE1Mjc2ODYxLCAzNC43MDMzMTQ1NTYgXSwgWyAxMzcuNDE1MjU5MTY2OTk5OTg4LCAzNC43MDMzMTA0NDQgXSwgWyAxMzcuNDE1MTQ0NDE3LCAzNC43MDMyNjg0MTcgXSwgWyAxMzcuNDE1MDU0NTM3OTI4OTk1LCAzNC43MDMyMzU0NDMyODUxMDIgXSwgWyAxMzcuNDE0ODEyMTExLCAzNC43MDMxNDY0NzIgXSwgWyAxMzcuNDE0NzgzNDcyMDAwMDExLCAzNC43MDMxMzQgXSwgWyAxMzcuNDE0NzcwNzc4LCAzNC43MDMxMjU3MjIgXSwgWyAxMzcuNDE0NzYzMjIyLCAzNC43MDMxMTY2MzkgXSwgWyAxMzcuNDE0NzU5MDI4LCAzNC43MDMxMDQ4MzMgXSwgWyAxMzcuNDE0NzU4MTExLCAzNC43MDMwODY4MDYgXSwgWyAxMzcuNDE0NzYwNTgzLCAzNC43MDMwNzE0NzIgXSwgWyAxMzcuNDE0NzY1NjY3MDAwMDEyLCAzNC43MDMwNTc1ODMgXSwgWyAxMzcuNDE0ODIwMDgzLCAzNC43MDI5NjY0MTcgXSwgWyAxMzcuNDE1MTIzODg5LCAzNC43MDI0OTE2OTQgXSwgWyAxMzcuNDE1MTY2ODA2LCAzNC43MDI0Mjc1MjggXSwgWyAxMzcuNDE1MTc1MjUsIDM0LjcwMjQwMzA1NiBdLCBbIDEzNy40MTUxODAzMDYsIDM0LjcwMjM4MDc3OCBdLCBbIDEzNy40MTUxODM2MTEsIDM0LjcwMjM1MDAyOCBdLCBbIDEzNy40MTUxODM1MjgsIDM0LjcwMjMyNTY5NCBdLCBbIDEzNy40MTUxODE4MzMsIDM0LjcwMjMwMiBdLCBbIDEzNy40MTUxODAxODk5OTA5OTEsIDM0LjcwMjEwNjQzNjcwNTU5OCBdLCBbIDEzNy40MTUxNzk1ODMsIDM0LjcwMjAzMiBdLCBbIDEzNy40MTUxODYzMzMsIDM0LjcwMTkzNjIyMiBdLCBbIDEzNy40MTUxODkzMzMsIDM0LjcwMTg5MzUgXSwgWyAxMzcuNDE1MTg1NTgzMDAwMDEsIDM0LjcwMTcwMDEzOSBdLCBbIDEzNy40MTUxODQ2OTQsIDM0LjcwMTY1MzUgXSwgWyAxMzcuNDE1MTgyNzIyLCAzNC43MDE1NTMwODMgXSwgWyAxMzcuNDE1MTgwODA2LCAzNC43MDE0NTM1IF0sIFsgMTM3LjQxNTI4MjU4MywgMzQuNzAxNDk4Mjc4IF0sIFsgMTM3LjQxNTYxODg5NjQ4NDAwNiwgMzQuNzAxNjQyMzM1NDE5MDAyIF0sIFsgMTM3LjQxNTYxODg5NjQ4NDAwNiwgMzQuNzAxNTg2NjY2MjQ4NzAxIF0sIFsgMTM3LjQxNTMxMDI3OCwgMzQuNzAxNDU0MzA2IF0sIFsgMTM3LjQxNTE1NDQxNywgMzQuNzAxMzg1NjY3IF0sIFsgMTM3LjQxNTI3NjYxMSwgMzQuNzAxMjkyOTE3IF0sIFsgMTM3LjQxNTMyODg2MSwgMzQuNzAxMjUzODMzIF0sIFsgMTM3LjQxNTM3NjgwNjAwMDAxMiwgMzQuNzAxMjE3OTcyIF0sIFsgMTM3LjQxNTM5NDk3MiwgMzQuNzAxMjA0MDU2IF0sIFsgMTM3LjQxNTQyNzQ0Mzk5OTk4OCwgMzQuNzAxMTc5MTk0IF0sIFsgMTM3LjQxNTU2NTg4OSwgMzQuNzAxMDczMjUgXSwgWyAxMzcuNDE1NjE4ODk2NDg0MDA2LCAzNC43MDEwMzI2NTU2NzkyOTkgXSwgWyAxMzcuNDE1NjE4ODk2NDg0MDA2LCAzNC43MDA5Njg1OTA1NzExMDEgXSwgWyAxMzcuNDE1NjA2NzgwNDM1MDEzLCAzNC43MDA5Nzc0MTQ3MjAxIF0gXSwgWyBbIDEzNy40MTAxNjA1MTA4NTk3MjUsIDM0LjcwMDIwMzc4NTc5NzM4NSBdLCBbIDEzNy40MTAxOTE1ODExNzk1NjEsIDM0LjY5OTk1ODk4NjcwNDIxIF0sIFsgMTM3LjQxMDE0MjM4NjUwNjQ2NSwgMzQuNjk5OTUwNDcxOTQwMDkyIF0sIFsgMTM3LjQxMDE0NTU5NjE5MjE5NCwgMzQuNjk5OTMzMzE5NTcwODg5IF0sIFsgMTM3LjQxMDI5MzE2NywgMzQuNjk5ODY5MDI4IF0sIFsgMTM3LjQxMDMwODc3OCwgMzQuNjk5ODYyMzMzIF0sIFsgMTM3LjQxMDMxODc1OTM4MzQ0MywgMzQuNjk5ODU4MDQ1Mzk4Nzg0IF0sIFsgMTM3LjQxMDMwNTUwNTY4NTcyNywgMzQuNjk5OTI3MDU2MzM0MzAzIF0sIFsgMTM3LjQxMDI2MTQ4OTM5OTI2MSwgMzQuNjk5OTI3MDU2MzM0MzAzIF0sIFsgMTM3LjQxMDIxMjI5NDcyNjEzNiwgMzQuNzAwMjIwODE1MjcyNTggXSwgWyAxMzcuNDEwMzk2MTI3NDUyMDAzLCAzNC43MDAyMjcyMDEzMjQ4ODYgXSwgWyAxMzcuNDEwNDQ3OTExMzE4NDQyLCAzNC42OTk4NjMxOTU1NTc1NDEgXSwgWyAxMzcuNDEwMzg1NzcwNjc4NzQ0LCAzNC42OTk4NDgyOTQ3MDI1NDEgXSwgWyAxMzcuNDEwMzczNzYyMzk2OTQ0LCAzNC42OTk4MzQ0NzMxMjM3MzcgXSwgWyAxMzcuNDEwMzgyMTM5LCAzNC42OTk4MzA4ODkgXSwgWyAxMzcuNDEwNTQyMjc4LCAzNC42OTk3NjIyNSBdLCBbIDEzNy40MTA1NTQ0NzIsIDM0LjY5OTc1NyBdLCBbIDEzNy40MTA2NTM5MTcsIDM0LjY5OTcxNDMzMyBdLCBbIDEzNy40MTA3MTI4NjcxMzI4MTYsIDM0LjY5OTcyMDIyMDIzNzg4NiBdLCBbIDEzNy40MTA3MTIwMDkwMzcyOTcsIDM0LjY5OTcyMDU3Mjk3ODE3MyBdLCBbIDEzNy40MTA2NzMxNzExMzc0NjEsIDM0LjY5OTcyMDU3Mjk3ODE3MyBdLCBbIDEzNy40MTA1NzIxOTI1OTc5MjUsIDM0LjY5OTc2OTUzMjk5NTgwOSBdLCBbIDEzNy40MTA1NTQwNjgyNDQ2NjQsIDM0LjY5OTgzMzM5Mzg0NDg3IF0sIFsgMTM3LjQxMDQ5OTY5NTE4NDg4MiwgMzQuNjk5ODI3MDA3NzYyMTY3IF0sIFsgMTM3LjQxMDQ0NzkxMTMxODQ0MiwgMzQuNzAwMTk5NTI4NDI4MDUxIF0sIFsgMTM3LjQxMDY4MzUyNzkxMDcyLCAzNC43MDAyMjUwNzI2NDA4MzMgXSwgWyAxMzcuNDEwNjcwNzM2NjExNjc4LCAzNC43MDAzMDkyMDI2ODI1NCBdLCBbIDEzNy40MTA2NTI1ODMsIDM0LjcwMDMwNzQ0NCBdLCBbIDEzNy40MTA0MDgzMzMsIDM0LjcwMDI4MzQxNyBdLCBbIDEzNy40MTA0MDIyMjE5OTk5ODgsIDM0LjcwMDI4MzA1NiBdLCBbIDEzNy40MTAxMjU3MzI0MjE5ODksIDM0LjcwMDI1OTAxNjE1OTc5OCBdLCBbIDEzNy40MTAwNDE0NzE5OTk5ODksIDM0LjcwMDI1MTY5NCBdLCBbIDEzNy40MTAwMTg1NTYwMDAwMTEsIDM0LjcwMDI0OTgzMyBdLCBbIDEzNy40MDk5OTQ0MTcsIDM0LjcwMDI0OTk3MiBdLCBbIDEzNy40MDk5NjAyNzgsIDM0LjcwMDI1MjQ3MiBdLCBbIDEzNy40MDk5MjY0NDQsIDM0LjcwMDI1ODU4MyBdLCBbIDEzNy40MDk4ODcyNzgwMDAwMTQsIDM0LjcwMDI2ODY2NyBdLCBbIDEzNy40MDk2ODAxOTQsIDM0LjcwMDMzMDgzMyBdLCBbIDEzNy40MDk1NjkzODkwMDAwMTIsIDM0LjcwMDM2NTg2MSBdLCBbIDEzNy40MDk1MzkxNjcsIDM0LjcwMDM3MDI1IF0sIFsgMTM3LjQwOTUwODE2NzAwMDAxMywgMzQuNzAwMzcwODMzIF0sIFsgMTM3LjQwOTMxMjYxMSwgMzQuNzAwMzUyNTU2IF0sIFsgMTM3LjQwOTE4MDU4MywgMzQuNzAwMzQwMjIyIF0sIFsgMTM3LjQwOTE0MzY5NCwgMzQuNzAwMzM2NDE3IF0sIFsgMTM3LjQwOTEwNjg4ODk5OTk4NiwgMzQuNzAwMzM0MDU2IF0sIFsgMTM3LjQwOTA1OCwgMzQuNzAwMzM0MTM5IF0sIFsgMTM3LjQwOTAwNzY5NCwgMzQuNzAwMzQwNDcyIF0sIFsgMTM3LjQwODk2NTU4MywgMzQuNzAwMzUxNDcyIF0sIFsgMTM3LjQwODc1MjQ0MTQwNTk5NCwgMzQuNzAwNDI0NTU3NDIzODAxIF0sIFsgMTM3LjQwODUwMzMzMywgMzQuNzAwNTA5OTcyIF0sIFsgMTM3LjQwODQ3NTA4MzAwMDAxMywgMzQuNzAwNTE3ODYxIF0sIFsgMTM3LjQwODQ0MDUwMDAwMDAxMiwgMzQuNzAwNTIwMjc4IF0sIFsgMTM3LjQwODQwMjE2NywgMzQuNzAwNTE4NzIyIF0sIFsgMTM3LjQwODM2MjE5NCwgMzQuNzAwNTEzMzg5IF0sIFsgMTM3LjQwODMzMzMzMywgMzQuNzAwNTA3ODYxIF0sIFsgMTM3LjQwODMxOTk0NCwgMzQuNzAwNTA1Mjc4IF0sIFsgMTM3LjQwODI3MzcyMiwgMzQuNzAwNDg3OTcyIF0sIFsgMTM3LjQwODI0ODY2NywgMzQuNzAwNDc0NjY3IF0sIFsgMTM3LjQwODIxMjU4MywgMzQuNzAwNDU0MTk0IF0sIFsgMTM3LjQwNzc3MzkxNjk5OTk4NiwgMzQuNzAwMTk4MDU2IF0sIFsgMTM3LjQwNzQxNjk3MiwgMzQuNzAwMTY0MzA2IF0sIFsgMTM3LjQwNzM3OTE1MDM5MDk5NCwgMzQuNzAwMDk3NDkyMzg0MjAyIF0sIFsgMTM3LjQwNzM3ODQ3MiwgMzQuNzAwMDk2MzMzIF0sIFsgMTM3LjQwNzM3OTE1MDM5MDk5NCwgMzQuNzAwMDk1MjE0ODM1MTAyIF0sIFsgMTM3LjQwNzQzODk3MiwgMzQuNyBdLCBbIDEzNy40MDc0OTE4MDYsIDM0LjY5OTkxNTg4OSBdLCBbIDEzNy40MDc0OTcxMTEsIDM0LjY5OTkwNzUgXSwgWyAxMzcuNDA3NTI5MDU1OTk5OTg3LCAzNC42OTk4NTY2NjcgXSwgWyAxMzcuNDA3NTM1NzU3NTA5MDA5LCAzNC42OTk4NDgzNzczMjg4OTggXSwgWyAxMzcuNDA3NjM0MjUsIDM0LjY5OTcyNjU1NiBdLCBbIDEzNy40MDgwMzU4MDU5OTk5ODcsIDM0LjY5OTUyNjY5NCBdLCBbIDEzNy40MDgwNTI0MTcsIDM0LjY5OTUzNTk3MiBdLCBbIDEzNy40MDgwNzgyMjIsIDM0LjY5OTU1MDQxNyBdLCBbIDEzNy40MDgzMzMzMzMsIDM0LjY5OTY5Mjg4OSBdLCBbIDEzNy40MDg2MTE3OTY2NTM5ODYsIDM0LjY5OTg0ODM3NzMyODg5OCBdLCBbIDEzNy40MDg3NTI0NDE0MDU5OTQsIDM0LjY5OTkyNjkxMTAxNzc5OCBdLCBbIDEzNy40MDg4ODMzMzMsIDM0LjcgXSwgWyAxMzcuNDA5MDA0MDU1OTk5OTg2LCAzNC43MDAwNjc0MTcgXSwgWyAxMzcuNDA5MDU2MzMzLCAzNC43IF0sIFsgMTM3LjQwOTE3MzkzODcxMTAwNywgMzQuNjk5ODQ4Mzc3MzI4ODk4IF0sIFsgMTM3LjQwOTM3NjA4MzAwMDAxMiwgMzQuNjk5NTg3Nzc4IF0sIFsgMTM3LjQwOTQ4MTMzMywgMzQuNjk5NTk2Nzc4IF0sIFsgMTM3LjQwOTY1ODg3OTA1MTk4OSwgMzQuNjk5ODQ4Mzc3MzI4ODk4IF0sIFsgMTM3LjQwOTc1ODc1LCAzNC42OTk5ODk5MTcgXSwgWyAxMzcuNDA5OTIwNTI3OTk5OTg2LCAzNC42OTk5MDk3MjIgXSwgWyAxMzcuNDEwMDM0NjAxOTYxOTk2LCAzNC42OTk4NDgzNzczMjg4OTggXSwgWyAxMzcuNDEwMTA2NjY3LCAzNC42OTk4MDk2MzkgXSwgWyAxMzcuNDEwMTI1NzMyNDIxOTg5LCAzNC42OTk3OTk3MjI4MzAyOTkgXSwgWyAxMzcuNDEwNTEzNjM4OTk5OTg3LCAzNC42OTk1OTgxMzkgXSwgWyAxMzcuNDEwNzE3MTM5MDAwMDEzLCAzNC42OTk0OTk2MzkgXSwgWyAxMzcuNDEwODA1NSwgMzQuNjk5NDU2NTU2IF0sIFsgMTM3LjQxMDgzMywgMzQuNjk5NDQzMTY3IF0sIFsgMTM3LjQxMDg1NjQ0NCwgMzQuNjk5NDM0IF0sIFsgMTM3LjQxMDkwMjE2Njk5OTk4OSwgMzQuNjk5NDE2MDU2IF0sIFsgMTM3LjQxMTAwMDM2MSwgMzQuNjk5Mzc3NDcyIF0sIFsgMTM3LjQxMTE3Mzk3MiwgMzQuNjk5MzIxODYxIF0sIFsgMTM3LjQxMTMxNjM4OSwgMzQuNjk5Mjc0MDU2IF0sIFsgMTM3LjQxMTQ5OTAyMzQzNjk4OCwgMzQuNjk5MjEwNTYwMDg3MDAzIF0sIFsgMTM3LjQxMTc4NjY5NCwgMzQuNjk5MTEwNTU2IF0sIFsgMTM3LjQxMjA0MzI3OCwgMzQuNjk5MDIwNjExIF0sIFsgMTM3LjQxMjEwMDUyOCwgMzQuNjk4OTk5OTQ0IF0sIFsgMTM3LjQxMjI3NzE2NzAwMDAxMywgMzQuNjk4OTczMTY3IF0sIFsgMTM3LjQxMjc2MTI3OCwgMzQuNjk4OTAxMDgzIF0sIFsgMTM3LjQxMjg3MjMxNDQ1MzAxMSwgMzQuNjk4ODgyMDYxNzgwNjAxIF0sIFsgMTM3LjQxMjk0NTg4OTAwMDAxNCwgMzQuNjk4ODY5NSBdLCBbIDEzNy40MTMxNzExOTQsIDM0LjY5ODgzNjc3OCBdLCBbIDEzNy40MTMyNjA2NjcsIDM0LjY5ODgzMTU1NiBdLCBbIDEzNy40MTMzNzU4MzMsIDM0LjY5ODgzMzQ3MiBdLCBbIDEzNy40MTM3Njk5MTcsIDM0LjY5ODgzODcyMiBdLCBbIDEzNy40MTM4MTczODksIDM0LjY5ODgzNTAyOCBdLCBbIDEzNy40MTM4NDEwNTYsIDM0LjY5ODgzMDExMSBdLCBbIDEzNy40MTM5MDM2NjcsIDM0LjY5ODgxMzE5NCBdLCBbIDEzNy40MTM5NjI4ODksIDM0LjY5ODc5OTgzMyBdLCBbIDEzNy40MTQwMDg5NDM5OTk5ODgsIDM0LjY5ODc5MzMzMyBdLCBbIDEzNy40MTQwNjA2NjcsIDM0LjY5ODc5MjQxNyBdLCBbIDEzNy40MTQxMDY0MTcsIDM0LjY5ODc5OCBdLCBbIDEzNy40MTQxNjQsIDM0LjY5ODgxMTU4MyBdLCBbIDEzNy40MTQyMjUwNTYsIDM0LjY5ODgyOTUgXSwgWyAxMzcuNDE0MjQ1NjA1NDY5MDA2LCAzNC42OTg4MzYwMzgxOTQ1OTkgXSwgWyAxMzcuNDE0MzI0ODA2LCAzNC42OTg4NjExMTEgXSwgWyAxMzcuNDE0NDg5NTU2LCAzNC42OTg5MDk3NSBdLCBbIDEzNy40MTQ1MDAwODMsIDM0LjY5ODkyNTUgXSwgWyAxMzcuNDE0NDQ5NzIyLCAzNC42OTkwNTg0NzIgXSwgWyAxMzcuNDE0NDA3OTcyLCAzNC42OTkxODQ1IF0sIFsgMTM3LjQxNDM1NDQ0NCwgMzQuNjk5NDA5MTM5IF0sIFsgMTM3LjQxNDMzNTMwNiwgMzQuNjk5NDg5NDQ0IF0sIFsgMTM3LjQxNDMwMjk3MiwgMzQuNjk5NTkwNzUgXSwgWyAxMzcuNDE0MjgxODYxLCAzNC42OTk2NTI4MzMgXSwgWyAxMzcuNDE0MjU3ODg5LCAzNC42OTk3MDMwODMgXSwgWyAxMzcuNDE0MjQ1NjA1NDY5MDA2LCAzNC42OTk3MjIxODI4MjQ5OTkgXSwgWyAxMzcuNDE0MjA2Mjc4LCAzNC42OTk3ODMzMzMgXSwgWyAxMzcuNDE0MTY2Mjc4MDAwMDEsIDM0LjY5OTgzNzYxMSBdLCBbIDEzNy40MTQxNTc4NTIwMzQwMDksIDM0LjY5OTg0ODM3NzMyODg5OCBdLCBbIDEzNy40MTQxMTQ0MTcsIDM0LjY5OTkwMzc3OCBdLCBbIDEzNy40MTQwMzcxNjcsIDM0LjcgXSwgWyAxMzcuNDEzOTQzMDI4LCAzNC43MDAxMTcyNSBdLCBbIDEzNy40MTM4Mjg3NzgwMDAwMSwgMzQuNzAwMjQxIF0sIFsgMTM3LjQxMzY3OTMzMywgMzQuNzAwMzkwODYxIF0sIFsgMTM3LjQxMzQ5NzUsIDM0LjcwMDU3Njg2MSBdLCBbIDEzNy40MTM0NjUyNzgsIDM0LjcwMDYxMDcyMiBdLCBbIDEzNy40MTM0NDI5MTcsIDM0LjcwMDYxMTEzOSBdLCBbIDEzNy40MTMyNzIyNzgsIDM0LjcwMDYwOTY2NyBdLCBbIDEzNy40MTMxNjk0NDQsIDM0LjcwMDYwNzUyOCBdLCBbIDEzNy40MTMxNDY1MjgsIDM0LjcwMDYwNTQxNyBdLCBbIDEzNy40MTMwODk2MzksIDM0LjcwMDYwMDMwNiBdLCBbIDEzNy40MTMwNjAzNjEsIDM0LjcwMDU5NTA1NiBdLCBbIDEzNy40MTMwMzU1NTYwMDAwMTEsIDM0LjcwMDU4NzA4MyBdLCBbIDEzNy40MTMwMTY0MTcsIDM0LjcwMDU3NTMwNiBdLCBbIDEzNy40MTMwMDA0MTcsIDM0LjcwMDU1NDMzMyBdLCBbIDEzNy40MTI5ODc5MTcsIDM0LjcwMDUzNDQxNyBdLCBbIDEzNy40MTI5NzM0NzIsIDM0LjcwMDUxNzEzOSBdLCBbIDEzNy40MTI5NTcxMzkwMDAwMTQsIDM0LjcwMDQ5ODUyOCBdLCBbIDEzNy40MTI5NDE0OTk5OTk5ODgsIDM0LjcwMDQ4NDU4MyBdLCBbIDEzNy40MTI5MjE2OTQsIDM0LjcwMDQ2NzM4OSBdLCBbIDEzNy40MTI5MDQwODMsIDM0LjcwMDQ1NjUyOCBdLCBbIDEzNy40MTI4ODg4ODg5OTk5ODcsIDM0LjcwMDQ0OTg4OSBdLCBbIDEzNy40MTI4ODI2NjcsIDM0LjcwMDQ0NzExMSBdLCBbIDEzNy40MTI4NzIzMTQ0NTMwMTEsIDM0LjcwMDQ0MzcyNDk5MDU5OSBdLCBbIDEzNy40MTI4NjQ1MjgsIDM0LjcwMDQ0MTI3OCBdLCBbIDEzNy40MTI4NDgwMjgwMDAwMTMsIDM0LjcwMDQzNDQ3MiBdLCBbIDEzNy40MTI4NDIxMTEsIDM0LjcwMDQyOTE2NyBdLCBbIDEzNy40MTI4MzQ2NjcsIDM0LjcwMDQyMzMwNiBdLCBbIDEzNy40MTI4MzA5NzIsIDM0LjcwMDQxOTA1NiBdLCBbIDEzNy40MTI4NzIzMTQ0NTMwMTEsIDM0LjcwMDM4NDIwNzUwMjk5OSBdLCBbIDEzNy40MTI5MTA4NjEsIDM0LjcwMDM1MTY2NyBdLCBbIDEzNy40MTMwNzkzMzMwMDAwMTMsIDM0LjcwMDQ0MTU1NiBdLCBbIDEzNy40MTMxMDc2MTA5OTk5ODcsIDM0LjcwMDQwNDcyMiBdLCBbIDEzNy40MTMyMDYxMTEsIDM0LjcwMDQ1ODA4MyBdLCBbIDEzNy40MTMyMTkzODksIDM0LjcwMDQzODg2MSBdLCBbIDEzNy40MTMyNTc3NTAwMDAwMTQsIDM0LjcwMDQ1NTE5NCBdLCBbIDEzNy40MTMyOTg4ODksIDM0LjcwMDQxMzE2NyBdLCBbIDEzNy40MTMzOTQyMjIsIDM0LjcwMDQ2MDMwNiBdLCBbIDEzNy40MTM0MTk2MzkwMDAwMTEsIDM0LjcwMDQyNTgzMyBdLCBbIDEzNy40MTM0NjYxOTQsIDM0LjcwMDQ0NTE5NCBdLCBbIDEzNy40MTM3NjM4ODksIDM0LjcwMDA4MjExMSBdLCBbIDEzNy40MTM1OTY1NTU5OTk5ODcsIDM0LjcgXSwgWyAxMzcuNDEzNDc1MzA2LCAzNC42OTk5NDA1MjggXSwgWyAxMzcuNDEzNDYzNjY3LCAzNC42OTk5NTUyMjIgXSwgWyAxMzcuNDEzMjc2MzI3NDQwOTk3LCAzNC42OTk4NDgzNzczMjg4OTggXSwgWyAxMzcuNDEzMjA1MDU2MDAwMDEsIDM0LjY5OTgwNzcyMiBdLCBbIDEzNy40MTMwODczMzA0NjAwMDIsIDM0LjY5OTg0ODM3NzMyODg5OCBdLCBbIDEzNy40MTI5ODM2OTQsIDM0LjY5OTg4NDE2NyBdLCBbIDEzNy40MTI4OTQ4MDYsIDM0LjcgXSwgWyAxMzcuNDEyODcyMzE0NDUzMDExLCAzNC43MDAwMjkzMjA4NTUyMDEgXSwgWyAxMzcuNDEyNzgwODA2LCAzNC43MDAxNDg1NTYgXSwgWyAxMzcuNDEyNzY2NSwgMzQuNzAwMzY5MTY3IF0sIFsgMTM3LjQxMjc2NTEzODk5OTk4NywgMzQuNzAwMzg1NTgzIF0sIFsgMTM3LjQxMjc2MzE2NywgMzQuNzAwMzg5NzUgXSwgWyAxMzcuNDEyNzU1Nzc4LCAzNC43MDA0MDA0NzIgXSwgWyAxMzcuNDEyNzQ2MTExLCAzNC43MDA0MDk3NzggXSwgWyAxMzcuNDEyNzM2MTk0LCAzNC43MDA0MTU4NjEgXSwgWyAxMzcuNDEyNzI0OTQ0LCAzNC43MDA0MTYxMzkgXSwgWyAxMzcuNDEyNjc4MjUsIDM0LjcwMDQyNjYxMSBdLCBbIDEzNy40MTI2MjE3NSwgMzQuNzAwNDQ0NDcyIF0sIFsgMTM3LjQxMjYwMjI1LCAzNC43MDA0NTA5MTcgXSwgWyAxMzcuNDEyNTg1ODg5MDAwMDEzLCAzNC43MDA0NTI4MzMgXSwgWyAxMzcuNDEyNTc1NzIyMDAwMDE0LCAzNC43MDA0NTE2MTEgXSwgWyAxMzcuNDEyNTU4NDcyLCAzNC43MDA0NDc1IF0sIFsgMTM3LjQxMjUzOTU1NjAwMDAxMywgMzQuNzAwNDQxMzg5IF0sIFsgMTM3LjQxMjUxODg4OTAwMDAxMiwgMzQuNzAwNDMxMTY3IF0sIFsgMTM3LjQxMjI0Mzc0OTk5OTk4OCwgMzQuNzAwMjYxNjExIF0sIFsgMTM3LjQxMjIyMjU1NTk5OTk4OSwgMzQuNzAwMjUwMTk0IF0sIFsgMTM3LjQxMjIwNTYxMSwgMzQuNzAwMjQxMTExIF0sIFsgMTM3LjQxMjE4NTU4MywgMzQuNzAwMjMyMDU2IF0sIFsgMTM3LjQxMjE2MDI1LCAzNC43MDAyMjE2MzkgXSwgWyAxMzcuNDEyMTMyNDcyLCAzNC43MDAyMTEwNTYgXSwgWyAxMzcuNDEyMTA2MDU2LCAzNC43MDAyMDUwODMgXSwgWyAxMzcuNDEyMDczMzg5LCAzNC43MDAxOTY3NzggXSwgWyAxMzcuNDEyMDQwMTk0MDAwMDE0LCAzNC43MDAxODkwODMgXSwgWyAxMzcuNDEyMDEyNDQ0LCAzNC43MDAxODM4MDYgXSwgWyAxMzcuNDExOTc1NDE3LCAzNC43MDAxOCBdLCBbIDEzNy40MTE5Mzg1MjgsIDM0LjcwMDE3NjgzMyBdLCBbIDEzNy40MTE4NjA3NzgsIDM0LjcwMDE2ODA4MyBdLCBbIDEzNy40MTE4NTE2OTQsIDM0LjcwMDE2NDMwNiBdLCBbIDEzNy40MTE4NDIzMDYwMDAwMTEsIDM0LjcwMDE1NzE5NCBdLCBbIDEzNy40MTE4MzIyMjE5OTk5ODcsIDM0LjcwMDE0NjU4MyBdLCBbIDEzNy40MTE4MjQ2MzksIDM0LjcwMDEzMjM2MSBdLCBbIDEzNy40MTE4MjM1MjgwMDAwMTQsIDM0LjcwMDExNzk0NCBdLCBbIDEzNy40MTE4MjYwODMsIDM0LjcwMDEwMjg2MSBdLCBbIDEzNy40MTE4MzY4NjEwMDAwMTIsIDM0LjcwMDA4ODg4OSBdLCBbIDEzNy40MTE4NDg5NDQwMDAwMTMsIDM0LjcwMDA3ODQ3MiBdLCBbIDEzNy40MTIwMTE3NzgsIDM0LjcwMDAzNTQxNyBdLCBbIDEzNy40MTIxMDU2OTQsIDM0LjcwMDAxMTg4OSBdLCBbIDEzNy40MTIxMzU4ODkwMDAwMTIsIDM0LjcgXSwgWyAxMzcuNDEyMzMwOTQ0LCAzNC42OTk5MjMxNjcgXSwgWyAxMzcuNDEyNDM2ODk0MzM2OTkyLCAzNC42OTk4NDgzNzczMjg4OTggXSwgWyAxMzcuNDEyNzgzNDQ0MDAwMDEzLCAzNC42OTk2MDM3NSBdLCBbIDEzNy40MTI3NzE4MzMsIDM0LjY5OTU5MjY5NCBdLCBbIDEzNy40MTI4NzIzMTQ0NTMwMTEsIDM0LjY5OTUyMDc2NTY4OTQ5OSBdLCBbIDEzNy40MTI5MDMxOTQsIDM0LjY5OTQ5ODY2NyBdLCBbIDEzNy40MTI5NzA0MTcsIDM0LjY5OTQ1MTE5NCBdLCBbIDEzNy40MTMwMDU1LCAzNC42OTk0MjY2MTEgXSwgWyAxMzcuNDEyOTY0MDI4LCAzNC42OTkzOTczODkgXSwgWyAxMzcuNDEyODg3Nzc4LCAzNC42OTk0NTEzNjEgXSwgWyAxMzcuNDEyODcyMzE0NDUzMDExLCAzNC42OTk0NjI1MzE3NjY3OTggXSwgWyAxMzcuNDEyNzgwMTY3LCAzNC42OTk1MjkyMjIgXSwgWyAxMzcuNDEyNTc0NTI4LCAzNC42OTk2NzYyMjIgXSwgWyAxMzcuNDEyMzQxNDg4NTc2OTk5LCAzNC42OTk4NDgzNzczMjg4OTggXSwgWyAxMzcuNDEyMjkxNzc4LCAzNC42OTk4ODUxMTEgXSwgWyAxMzcuNDEyMTY1MjQ5OTk5OTg3LCAzNC42OTk5MjAyNzggXSwgWyAxMzcuNDEyMTMwNTU2LCAzNC42OTk5Mjk4ODkgXSwgWyAxMzcuNDExOTA0OTg5MTU2Nzk1LCAzNC42OTk5ODYxNzIwNjI1NzMgXSwgWyAxMzcuNDExODkxMzI0NzM4NTE5LCAzNC42OTk5NTQzNDIwNDQyMDggXSwgWyAxMzcuNDExOTA4MDI1Njk0MjAzLCAzNC42OTk4ODI1Njg0Mjg0NjQgXSwgWyAxMzcuNDEyMTAzODgyMzU2Njg5LCAzNC42OTk4MjcwMjE4NDgzMTQgXSwgWyAxMzcuNDEyMTI4OTMzNzkwMjg1LCAzNC42OTk3OTc2ODgyNDYwMDEgXSwgWyAxMzcuNDEyMTM2NTI1MTMzODAzLCAzNC42OTk3Njg5Nzg3NTI4MjIgXSwgWyAxMzcuNDEyMTQyMjc4LCAzNC42OTk3MjM5NzIgXSwgWyAxMzcuNDEyMTUyNDcyLCAzNC42OTk2OTg3NzggXSwgWyAxMzcuNDEyMTc2Mjc4LCAzNC42OTk2NjI1IF0sIFsgMTM3LjQxMjI3NzExMSwgMzQuNjk5NTgxOTcyIF0sIFsgMTM3LjQxMjUwMjkxNzAwMDAxMiwgMzQuNjk5NDE5MzMzIF0sIFsgMTM3LjQxMjQ2NDcyMjAwMDAxLCAzNC42OTkzODM3MjIgXSwgWyAxMzcuNDEyMTQyNDQ0MDAwMDExLCAzNC42OTk2MjkwMjggXSwgWyAxMzcuNDEyMTI3OTcyLCAzNC42OTk2NDQzODkgXSwgWyAxMzcuNDEyMTE3LCAzNC42OTk2NjMyNSBdLCBbIDEzNy40MTIwOTY3NzgsIDM0LjY5OTcyNDg2MSBdLCBbIDEzNy40MTIwODU2NjMxMzIzMDIsIDM0LjY5OTc2NTg1ODE1NTEzOSBdLCBbIDEzNy40MTIwNjgyMDMwNDIyMjQsIDM0LjY5OTc4NzA3ODIxNzA3MSBdLCBbIDEzNy40MTE4NzQ2MjM3ODI4MDgsIDM0LjY5OTg0MjYyNDgyNDAzNiBdLCBbIDEzNy40MTE4NTU2NDU0MjQwMjYsIDM0LjY5OTk3MTE5MzIzMTkyNCBdLCBbIDEzNy40MTE4NjI0Nzc2MzMxNzksIDM0LjY5OTk5MzY2MTQ3Njg4OCBdLCBbIDEzNy40MTE4NTQxMjcxNTUzMjMsIDM0LjY5OTk5ODAzMDMwMTU4NiBdLCBbIDEzNy40MTE4NDYxNjcsIDM0LjY5OTk4Njg4OSBdLCBbIDEzNy40MTE4NjUxNDQ4NDkwMDMsIDM0LjY5OTg0ODM3NzMyODg5OCBdLCBbIDEzNy40MTE4NzQ5MTcsIDM0LjY5OTc3NzA1NiBdLCBbIDEzNy40MTE1NDAyNDcxNzAxMDksIDM0LjY5OTc0MzIzMDI2Njg5IF0sIFsgMTM3LjQxMTU0NTcyOTI4NjkyOCwgMzQuNjk5Njk5Mjg2MDA0OTQzIF0sIFsgMTM3LjQxMTM5Mjk2Njg4MDg5NiwgMzQuNjk5NTQxNzYyMjMyODQ3IF0sIFsgMTM3LjQxMDk2NTc0OTk4MjgwNywgMzQuNjk5NDkyODAyMDgwNDQ5IF0sIFsgMTM3LjQxMDc3NjczODg3MDMxMSwgMzQuNjk5NTg0MzM2MjU0ODg3IF0sIFsgMTM3LjQxMDc2NDI4NzAzOTM5OSwgMzQuNjk5NjY0NzcxNzMzNjQ0IF0sIFsgMTM3LjQxMDc1MDg4OTAwMDAxMywgMzQuNjk5NjYzNDE3IF0sIFsgMTM3LjQxMDYzMjQ0Mzk5OTk4NywgMzQuNjk5NjUxNDQ0IF0sIFsgMTM3LjQxMDE4MTMzMzY1MTk5MSwgMzQuNjk5ODQ4Mzc3MzI4ODk4IF0sIFsgMTM3LjQxMDEyNTczMjQyMTk4OSwgMzQuNjk5ODcyNjUwNTU3OSBdLCBbIDEzNy40MDk4MzQwMjgsIDM0LjcgXSwgWyAxMzcuNDA5ODA5MjUsIDM0LjcwMDAxMDgwNiBdLCBbIDEzNy40MDkzMjY0MTY5OTk5ODgsIDM0LjcwMDE4NzQ3MiBdLCBbIDEzNy40MDkzMjg2NjcwMDAwMTEsIDM0LjcwMDI0NzQxNyBdLCBbIDEzNy40MDk0MjcyNzgwMDAwMSwgMzQuNzAwMjIwNDQ0IF0sIFsgMTM3LjQwOTU2OTY5NCwgMzQuNzAwMTcxNSBdLCBbIDEzNy40MDk2OTcyNzgwMDAwMSwgMzQuNzAwMTI3NjExIF0sIFsgMTM3LjQwOTgxMzA1NiwgMzQuNzAwMDc3ODg5IF0sIFsgMTM3LjQwOTgyMDY5NCwgMzQuNzAwMDc0NTU2IF0sIFsgMTM3LjQwOTgxNDYxMSwgMzQuNzAwMTIyNTgzIF0sIFsgMTM3LjQwOTkzNDA1NiwgMzQuNzAwMTMwOTE3IF0sIFsgMTM3LjQwOTk0NjM2MTAwMDAxLCAzNC43MDAwNTQ5NzIgXSwgWyAxMzcuNDA5ODk0MzA2MDAwMDEyLCAzNC43MDAwNTE3NSBdLCBbIDEzNy40MDk4OTQ1LCAzNC43MDAwNDI1IF0sIFsgMTM3LjQwOTk5MjM2MSwgMzQuNyBdLCBbIDEzNy40MTAwNTIyNSwgMzQuNjk5OTc0IF0sIFsgMTM3LjQxMDA1ODIyMiwgMzQuNjk5OTcxMzg5IF0sIFsgMTM3LjQxMDA2Mzg4OTAwMDAxNCwgMzQuNjk5OTY4OTE3IF0sIFsgMTM3LjQxMDA3MDM3NDc4NDM2OCwgMzQuNjk5OTY2MDg5ODExNzE3IF0sIFsgMTM3LjQxMDA1OTUzMjMyMDIxOSwgMzQuNzAwMDM1NjE5NTQxNjczIF0sIFsgMTM3LjQxMDAxNTUxNjAzMzY5NSwgMzQuNzAwMDMxMzYyMTYzNjc4IF0sIFsgMTM3LjQwOTk4NzAzNDkwNzIwMywgMzQuNzAwMTg4ODg1MDAzNzMzIF0sIFsgMTM3LjQxMDE2MDUxMDg1OTcyNSwgMzQuNzAwMjAzNzg1Nzk3Mzg1IF0gXSwgWyBbIDEzNy40MTA5MjE3MzM2OTYzNywgMzQuNzAwMjEwMTcxODUwOTkxIF0sIFsgMTM3LjQxMDk5MTY0MTkxNjAxMywgMzQuNzAwMjE4Njg2NTg4Mzc5IF0sIFsgMTM3LjQxMTY3Nzc3ODE0NjMyNywgMzQuNzAwMDE2NDYxMzM4OTU0IF0sIFsgMTM3LjQxMTcwMzY1ODM5NTg1MSwgMzQuNjk5ODE5MTYyNTg0OTA5IF0sIFsgMTM3LjQxMTc0NjAyODAwMDAxLCAzNC42OTk4MjMzODkgXSwgWyAxMzcuNDExNzc0ODMzODY0MDAxLCAzNC42OTk4NDgzNzczMjg4OTggXSwgWyAxMzcuNDExNzc2NjY3LCAzNC42OTk4NDk5MTcgXSwgWyAxMzcuNDExNzg2NTI4LCAzNC42OTk4Njg5MTcgXSwgWyAxMzcuNDExNzY2NSwgMzQuNyBdLCBbIDEzNy40MTE3NjMxOTQsIDM0LjcwMDAyMTY5NCBdLCBbIDEzNy40MTE2MzA5MTcsIDM0LjcwMDA2MzYxMSBdLCBbIDEzNy40MTE0OTkwMjM0MzY5ODgsIDM0LjcwMDEwNDA3ODY2Nzc5OSBdLCBbIDEzNy40MTE0MTU5NDQsIDM0LjcwMDEyOTU4MyBdLCBbIDEzNy40MTE0MDc3NzgwMDAwMTIsIDM0LjcwMDEzMTk0NCBdLCBbIDEzNy40MTEzNzUwNTYsIDM0LjcwMDE0MTYzOSBdLCBbIDEzNy40MTEzNjQ2OTQwMDAwMTQsIDM0LjcwMDE0NDcyMiBdLCBbIDEzNy40MTExOTgwNTU5OTk5ODksIDM0LjcwMDE5NyBdLCBbIDEzNy40MTEwODU3MjIsIDM0LjcwMDIzMTkxNyBdLCBbIDEzNy40MTA5ODIxMzksIDM0LjcwMDI2NDUgXSwgWyAxMzcuNDEwOTIwNjExLCAzNC43MDAyODM5MTcgXSwgWyAxMzcuNDEwOTE0MzA2LCAzNC43MDAyODU4MDYgXSwgWyAxMzcuNDEwODgxNDcyLCAzNC43MDAyOTUgXSwgWyAxMzcuNDEwODYwODMyOTk5OTg3LCAzNC43MDAyOTkgXSwgWyAxMzcuNDEwODIzMzA2LCAzNC43MDAzMDU5MTcgXSwgWyAxMzcuNDEwODAxNjExMDAwMDExLCAzNC43MDAzMTEwMjggXSwgWyAxMzcuNDEwNzg1NjY3LCAzNC43MDAzMTQwMjggXSwgWyAxMzcuNDEwNzc1MDgzLCAzNC43MDAzMTUyMjIgXSwgWyAxMzcuNDEwNzU3NTI4LCAzNC43MDAzMTU4ODkgXSwgWyAxMzcuNDEwNzQ1NTI4LCAzNC43MDAzMTYxNjcgXSwgWyAxMzcuNDEwNzMyMTQyMDIzMDUxLCAzNC43MDAzMTUwNTc0MzY4OTYgXSwgWyAxMzcuNDEwNzQwNDkwMTYzNzg5LCAzNC43MDAyMzc4NDQ3NDQyNjUgXSwgWyAxMzcuNDEwOTExMzc2OTIzMDgyLCAzNC43MDAyNTA2MTY4NDU3MzYgXSwgWyAxMzcuNDEwOTIxNzMzNjk2MzcsIDM0LjcwMDIxMDE3MTg1MDk5MSBdIF0sIFsgWyAxMzcuNDA4ODI5Njc2ODc1MDg3LCAzNC43MDE2NTMwNTYyNjE2NjIgXSwgWyAxMzcuNDA4ODA0MDIzODc5MTU2LCAzNC43MDE4MTMyMzg5MzE1MjggXSwgWyAxMzcuNDA4Nzk5MDI4LCAzNC43MDE4MTMwNTYgXSwgWyAxMzcuNDA4NzkzMTk0LCAzNC43MDE4NDI2MzkgXSwgWyAxMzcuNDA4NzgyOTcyMDAwMDEyLCAzNC43MDE4NTEwNTYgXSwgWyAxMzcuNDA4NzcwMTExLCAzNC43MDE4NTg1NTYgXSwgWyAxMzcuNDA4NzU4NTU2LCAzNC43MDE4NjI5MTcgXSwgWyAxMzcuNDA4NzUyNDQxNDA1OTk0LCAzNC43MDE4NjQzNDQyMDc3OTkgXSwgWyAxMzcuNDA4NzQzMjc4LCAzNC43MDE4NjY4ODkgXSwgWyAxMzcuNDA4NzM4NDcyMDAwMDEsIDM0LjcwMTg2NjM2MSBdLCBbIDEzNy40MDg1NDE5NDQsIDM0LjcwMTg0NjY2NyBdLCBbIDEzNy40MDgzNzU2MzkwMDAwMTMsIDM0LjcwMTgyOTQxNyBdLCBbIDEzNy40MDgzMzMzMzMsIDM0LjcwMTgyNDk0NCBdLCBbIDEzNy40MDgyMjU4MzI5OTk5ODksIDM0LjcwMTgxMzU1NiBdLCBbIDEzNy40MDgyMDY1LCAzNC43MDE4MTA4ODkgXSwgWyAxMzcuNDA4MTk2NjY3LCAzNC43MDE4MDY1ODMgXSwgWyAxMzcuNDA4MTg2MjUsIDM0LjcwMTc5Nzg2MSBdLCBbIDEzNy40MDgxNzkyNDk5OTk5ODksIDM0LjcwMTc4NzY5NCBdLCBbIDEzNy40MDgxNzYzNjA5OTk5ODgsIDM0LjcwMTc3NTk3MiBdLCBbIDEzNy40MDgxNzk2NjcwMDAwMTMsIDM0LjcwMTc0OTQ3MiBdLCBbIDEzNy40MDgxODQxNjcsIDM0LjcwMTcxNDIyMiBdLCBbIDEzNy40MDgxOTEwODMsIDM0LjcwMTY1OTMwNiBdLCBbIDEzNy40MDgyMTMwNTYsIDM0LjcwMTQ0Mzg4OSBdLCBbIDEzNy40MDgyNTA2NTcxMzU1NCwgMzQuNzAxMTY3OTQxMjY5MjA1IF0sIFsgMTM3LjQwODI5NjEyOTg0MzIyMiwgMzQuNzAxMTMwMDI0NTA3NTg0IF0sIFsgMTM3LjQwODMxMjQ3NDEyNjEyLCAzNC43MDEwMjUzMjA5Mzg3NTQgXSwgWyAxMzcuNDA4Mzg1NTY4NjM1MTY4LCAzNC43MDEwMzMyMjc5NzM4OCBdLCBbIDEzNy40MDgzODU1NTYwMDAwMTMsIDM0LjcwMTAzMzM2MSBdLCBbIDEzNy40MDg0MzIxNjcsIDM0LjcwMTAzODc1IF0sIFsgMTM3LjQwODQ1NTgzMywgMzQuNzAxMDY1NjY3IF0sIFsgMTM3LjQwODc4MDMwODk5NDIzOCwgMzQuNzAxMDk0OTAxNTk3MDg4IF0sIFsgMTM3LjQwODkwMDA1OTE4NTM4NSwgMzQuNzAxMjEzNTc0NDAxMzc5IF0sIFsgMTM3LjQwODgzNjE3MDI1ODkyMiwgMzQuNzAxNjEyNTEwMjE1MzQ4IF0sIFsgMTM3LjQwODUxNjM3MzEwMDQxMiwgMzQuNzAxNTc4OTA0NjM0MDQ3IF0sIFsgMTM3LjQwODU1MDAzMjYxMzYxOCwgMzQuNzAxMzE5MjA5MDE5MDU0IF0sIFsgMTM3LjQwODQ5ODI0ODc0NzE1MSwgMzQuNzAxMzEyODIzMDUxMDQgXSwgWyAxMzcuNDA4NDU5NDEwODQ3MzcxLCAzNC43MDE2MDg3MDU3MTgwNDQgXSwgWyAxMzcuNDA4ODI5Njc2ODc1MDg3LCAzNC43MDE2NTMwNTYyNjE2NjIgXSBdLCBbIFsgMTM3LjQwNzU2MTAzMzI0MDA4NiwgMzQuNzAxNzYxODM5NDQ3MTA5IF0sIFsgMTM3LjQwNzQwNDg2MSwgMzQuNzAxNzQ1ODYxIF0sIFsgMTM3LjQwNzM3OTE1MDM5MDk5NCwgMzQuNzAxNzQzMjc2OTk1Nzk5IF0sIFsgMTM3LjQwNzE4MDQ3MiwgMzQuNzAxNzIzNSBdLCBbIDEzNy40MDcxMDU4ODksIDM0LjcwMTcxNjMzMyBdLCBbIDEzNy40MDY5OTExMzkwMDAwMTMsIDM0LjcwMTcwNTMwNiBdLCBbIDEzNy40MDY4MjkwODMsIDM0LjcwMTY4NzA1NiBdLCBbIDEzNy40MDY4MzIwODMwMDAwMTIsIDM0LjcwMTY2NTc3OCBdLCBbIDEzNy40MDY4NDcyMjIwMDAwMSwgMzQuNzAxNTc1ODYxIF0sIFsgMTM3LjQwNjg2NDc1MDAwMDAxMSwgMzQuNzAxNDg0OTQ0IF0sIFsgMTM3LjQwNjg4MjUsIDM0LjcwMTM5NTk0NCBdLCBbIDEzNy40MDY5MDIsIDM0LjcwMTMwNDU4MyBdLCBbIDEzNy40MDY5MjM1NTYwMDAwMSwgMzQuNzAxMjE0Mzg5IF0sIFsgMTM3LjQwNjk0NTI1LCAzNC43MDExMjQ5MTcgXSwgWyAxMzcuNDA2OTc5ODA2MDAwMDEsIDM0LjcwMDk5NDExMSBdLCBbIDEzNy40MDcwNDQxMTEsIDM0LjcwMTAwMDAyOCBdLCBbIDEzNy40MDcwNjUwNTYsIDM0LjcwMDk5NzQ3MiBdLCBbIDEzNy40MDcwOTAwMjgsIDM0LjcwMDk4OTgzMyBdLCBbIDEzNy40MDcxMTE4OTI3NDE5OTUsIDM0LjcwMDk3NzQxNDcyMDEgXSwgWyAxMzcuNDA3MTMyMjIyLCAzNC43MDA5NjU4NjEgXSwgWyAxMzcuNDA3MTQ2NTgzMDAwMDE0LCAzNC43MDA5NTcxOTQgXSwgWyAxMzcuNDA3MzU1OTU2MTc5OTk4LCAzNC43MDA5Nzc0MTQ3MjAxIF0sIFsgMTM3LjQwNzM3OTE1MDM5MDk5NCwgMzQuNzAwOTc5NjU0Mzg0OTAyIF0sIFsgMTM3LjQwNzQwMDAyODAwMDAxMiwgMzQuNzAwOTgxNjY3IF0sIFsgMTM3LjQwNzQxMzM4OSwgMzQuNzAwOTk1NjExIF0sIFsgMTM3LjQwNzQwNzM4OTAwMDAxNCwgMzQuNzAxMDM5NDQ0IF0sIFsgMTM3LjQwNzYzMDU4MzAwMDAxNCwgMzQuNzAxMDY0Nzc4IF0sIFsgMTM3LjQwNzY0MTM0NjY5OCwgMzQuNzAwOTc3NDE0NzIwMSBdLCBbIDEzNy40MDc2NDYzNjEsIDM0LjcwMDkzNjgwNiBdLCBbIDEzNy40MDc2Nzk2MTEsIDM0LjcwMDkxNjM4OSBdLCBbIDEzNy40MDc4NDUyNSwgMzQuNzAwOTMzNzIyIF0sIFsgMTM3LjQwNzg4MjQ4MTU0NzgzLCAzNC43MDA5MzY4MTEzODc4NDEgXSwgWyAxMzcuNDA3OTcyNDgwNjc4MDQsIDM0LjcwMTAyMzU5MTM5OTY1NCBdLCBbIDEzNy40MDgwNTUzMzQ4NjQzNDMsIDM0LjcwMTAzMTA0MTcyMTY3IF0sIFsgMTM3LjQwODE2NjY3MDE3NzE2NywgMzQuNzAxMTQxNzMyMTQxMDk2IF0sIFsgMTM3LjQwODIwMDQ5MTUxNDk0NywgMzQuNzAxMTQ1MzI0MjU1NTk5IF0sIFsgMTM3LjQwODE2OTg4OSwgMzQuNzAxMzg5OTcyIF0sIFsgMTM3LjQwODE0NTExMTAwMDAxLCAzNC43MDE1Njk1ODMgXSwgWyAxMzcuNDA4MTM3Mjc4LCAzNC43MDE2MjQxNjcgXSwgWyAxMzcuNDA4MTExNjk0MDAwMDEzLCAzNC43MDE2NDA3NzggXSwgWyAxMzcuNDA4MDE1ODA2LCAzNC43MDE2MzA5NzIgXSwgWyAxMzcuNDA4MDEwODg5LCAzNC43MDE2NjY5NDQgXSwgWyAxMzcuNDA4MTA2MTExLCAzNC43MDE2NzY1ODMgXSwgWyAxMzcuNDA4MTI2NTgzMDAwMDEyLCAzNC43MDE2OTgxMTEgXSwgWyAxMzcuNDA4MTI0MjIyLCAzNC43MDE3MTQzMzMgXSwgWyAxMzcuNDA4MTE5MDgzLCAzNC43MDE3NDk4NjEgXSwgWyAxMzcuNDA4MTExNjY2OTk5OTg2LCAzNC43MDE3ODEyNSBdLCBbIDEzNy40MDgxMDgzMDYsIDM0LjcwMTc5MSBdLCBbIDEzNy40MDgxMDI1MjgsIDM0LjcwMTc5NzA1NiBdLCBbIDEzNy40MDgwOTQ0NzE5OTk5ODgsIDM0LjcwMTgwMzExMSBdLCBbIDEzNy40MDgwODMwMjgsIDM0LjcwMTgwNjYzOSBdLCBbIDEzNy40MDgwNzM4NjEsIDM0LjcwMTgwOCBdLCBbIDEzNy40MDgwNjM2OTQsIDM0LjcwMTgwODM4OSBdLCBbIDEzNy40MDgwNDQxNjcwMDAwMTQsIDM0LjcwMTgwOTEzOSBdLCBbIDEzNy40MDgwMjYyNzgsIDM0LjcwMTgwODkxNyBdLCBbIDEzNy40MDc3ODY0NzIsIDM0LjcwMTc4NTEzOSBdLCBbIDEzNy40MDc2NzI5OTI5MzQ2OTMsIDM0LjcwMTc3MzM3MTM1NzYxOCBdLCBbIDEzNy40MDc2NTE1ODI1MzA5NDYsIDM0LjcwMTc0MDY4MTgxODIyOSBdLCBbIDEzNy40MDc2ODMzMDAxNDkxODgsIDM0LjcwMTU1MjI5NjUxNDI1MSBdLCBbIDEzNy40MDc4MDQ5OTIyMzUzMjcsIDM0LjcwMTU2NTA2ODQxMjgyNiBdLCBbIDEzNy40MDc4MTIxMTI1MTY4OTMsIDM0LjcwMTUwNDQwMTg3NzA0NSBdLCBbIDEzNy40MDc2OTc1NDA3MTI0NjIsIDM0LjcwMTQ5MjY5NDI5NDg2MyBdLCBbIDEzNy40MDc3MjkyNTgzMzA2MTksIDM0LjcwMTI2Mzg2Mzk0NjU1OCBdLCBbIDEzNy40MDc2NzQ4ODUyNzA4MDgsIDM0LjcwMTI1NTM0OTMxNjczMiBdLCBbIDEzNy40MDc2MDc1NjYyNDQ0NzksIDM0LjcwMTczODU1MzE3MzEyOSBdLCBbIDEzNy40MDc1NjEwMzMyNDAwODYsIDM0LjcwMTc2MTgzOTQ0NzEwOSBdIF0sIFsgWyAxMzcuNDExMDA5ODg5MDAwMDEzLCAzNC43MDE3MjgyMjIgXSwgWyAxMzcuNDEwOTYyNzIyLCAzNC43MDE3MjM3MjIgXSwgWyAxMzcuNDEwOTYwODMzLCAzNC43MDE3NDc2MTEgXSwgWyAxMzcuNDEwOTg4NTU2LCAzNC43MDE3NTA1MjggXSwgWyAxMzcuNDExMDE5NjExLCAzNC43MDE3NjY4MDYgXSwgWyAxMzcuNDExMDQ2MTExLCAzNC43MDE3ODk4MzMgXSwgWyAxMzcuNDExMDMyMjUsIDM0LjcwMTg2NDUgXSwgWyAxMzcuNDEwOTQ3MTY2OTk5OTg5LCAzNC43MDE4NTYzNjEgXSwgWyAxMzcuNDEwOTU0NzUsIDM0LjcwMTgyOTAyOCBdLCBbIDEzNy40MTA5MjYzMzMsIDM0LjcwMTgyNDk0NCBdLCBbIDEzNy40MTA5MTg3NSwgMzQuNzAxODczMjc4IF0sIFsgMTM3LjQxMDk4NTc3OCwgMzQuNzAxODc5ODMzIF0sIFsgMTM3LjQxMDk5MTYzOSwgMzQuNzAxOTA1Nzc4IF0sIFsgMTM3LjQxMDkyOTIyMiwgMzQuNzAxOTUwODA2IF0sIFsgMTM3LjQxMDg4MzI1MDAwMDAxMiwgMzQuNzAxOTg0OTcyIF0sIFsgMTM3LjQxMDg3MjU4MzAwMDAxNCwgMzQuNzAxOTkzIF0sIFsgMTM3LjQxMDg1MjY2NywgMzQuNzAyMDEyMzMzIF0sIFsgMTM3LjQxMDgwMDE5Mzk5OTk4OSwgMzQuNzAyMDYyMzA2IF0sIFsgMTM3LjQxMDc1NDE3NTc3MDk5LCAzNC43MDIxMDY0MzY3MDU1OTggXSwgWyAxMzcuNDEwNzM0MDI4LCAzNC43MDIxMjU3MjIgXSwgWyAxMzcuNDEwNjE0NjY3LCAzNC43MDIxMTMwNTYgXSwgWyAxMzcuNDEwNTQ5MjcxNDY4LCAzNC43MDIxMDY0MzY3MDU1OTggXSwgWyAxMzcuNDEwMzY3MTM4OTk5OTg3LCAzNC43MDIwODgwNTYgXSwgWyAxMzcuNDEwMTUzODg4OTk5OTg2LCAzNC43MDIwNjU4NjEgXSwgWyAxMzcuNDEwMTQ5OTQ0MDAwMDExLCAzNC43MDIwNjUzMDYgXSwgWyAxMzcuNDEwMjAxNTI3OTk5OTg4LCAzNC43MDE3MTAxOTQgXSwgWyAxMzcuNDEwMjEyMzMzLCAzNC43MDE2MzU5NzIgXSwgWyAxMzcuNDEwMTg0Mzg5LCAzNC43MDE2MzMxMzkgXSwgWyAxMzcuNDEwMTczMTM5LCAzNC43MDE3MTAyNSBdLCBbIDEzNy40MTAxMjU3MzI0MjE5ODksIDM0LjcwMjAzNjkwNDY5NTYwMyBdLCBbIDEzNy40MTAxMjIxMTEsIDM0LjcwMjA2MTg2MSBdLCBbIDEzNy40MTAxMTA4NjEsIDM0LjcwMjA2MDQ0NCBdLCBbIDEzNy40MDk5MzQxOTM5OTk5ODcsIDM0LjcwMjA0MzAyOCBdLCBbIDEzNy40MDk4NjMzMDYsIDM0LjcwMjAzNTQxNyBdLCBbIDEzNy40MDk4MTIsIDM0LjcwMjAyOTkxNyBdLCBbIDEzNy40MDk3OTIyNTAwMDAwMSwgMzQuNzAxOTk4MDU2IF0sIFsgMTM3LjQwOTgxNDYxMSwgMzQuNzAxODQzMzg5IF0sIFsgMTM3LjQwOTgzMzQ0Mzk5OTk4NiwgMzQuNzAxNzE0MTY3IF0sIFsgMTM3LjQwOTgzMzk3MiwgMzQuNzAxNzEwOTE3IF0sIFsgMTM3LjQwOTg1ODM4OSwgMzQuNzAxNTQ2Mjc4IF0sIFsgMTM3LjQwOTgyMDM4OSwgMzQuNzAxNTM4MTM5IF0sIFsgMTM3LjQwOTgwMjUwMDAwMDAxMiwgMzQuNzAxNjYxMTM5IF0sIFsgMTM3LjQwOTc5NDY5NCwgMzQuNzAxNzExIF0sIFsgMTM3LjQwOTc5NDY5NCwgMzQuNzAxNzExMTk0IF0sIFsgMTM3LjQwOTc4NTY5NCwgMzQuNzAxNzc1OTQ0IF0sIFsgMTM3LjQwOTc3ODYzOSwgMzQuNzAxODI2MjUgXSwgWyAxMzcuNDA5NzYzMzYwOTk5OTg5LCAzNC43MDE5Mzc3MjIgXSwgWyAxMzcuNDA5NzU5NTI4LCAzNC43MDE5NzI1MjggXSwgWyAxMzcuNDA5NzU3Mzg5LCAzNC43MDE5ODU1IF0sIFsgMTM3LjQwOTc1MTYzOSwgMzQuNzAxOTk2MjUgXSwgWyAxMzcuNDA5NzQyNSwgMzQuNzAyMDA3MzYxIF0sIFsgMTM3LjQwOTczMTgzMywgMzQuNzAyMDE0NjY3IF0sIFsgMTM3LjQwOTcxOTI3ODAwMDAxMSwgMzQuNzAyMDE5OTE3IF0sIFsgMTM3LjQwOTcwNjk3MiwgMzQuNzAyMDIyMTk0IF0sIFsgMTM3LjQwOTYxNTEzOTAwMDAxLCAzNC43MDIwMTgwNTYgXSwgWyAxMzcuNDA5NTY1NTgyOTk5OTg4LCAzNC43MDIwMTM5MTcgXSwgWyAxMzcuNDA5NTUzNzc4LCAzNC43MDIwMTA1MjggXSwgWyAxMzcuNDA5NTQ0MjUwMDAwMDEsIDM0LjcwMjAwNTUgXSwgWyAxMzcuNDA5NTM2ODA2LCAzNC43MDE5OTY1IF0sIFsgMTM3LjQwOTUzMjMwNTk5OTk4OCwgMzQuNzAxOTg2NSBdLCBbIDEzNy40MDk1MywgMzQuNzAxOTc2NzUgXSwgWyAxMzcuNDA5NTI5OTcyLCAzNC43MDE5NjkxOTQgXSwgWyAxMzcuNDA5NTc0MzA2LCAzNC43MDE3MTE0NDQgXSwgWyAxMzcuNDA5NjQxODYzMDcyMTI1LCAzNC43MDEzMTc4Nzg2MDg5OSBdLCBbIDEzNy40MDk2ODY1NjA2OTQwNDEsIDM0LjcwMTI4NTI0OTY0NTY3OSBdLCBbIDEzNy40MDk3OTgxODU2MTg3NjksIDM0LjcwMTI5NjU5MjA0NjY2NyBdLCBbIDEzNy40MDk4MjUzNzIxNDg2NDYsIDM0LjcwMTMyMzIwMDI0ODY3MyBdLCBbIDEzNy40MTA1MzA5NTU5ODIwNCwgMzQuNzAxMzg1NDMyNTM0MTgxIF0sIFsgMTM3LjQxMDU1MTk2NDUyNDcyOCwgMzQuNzAxMjM2OTg5NjQzMDkzIF0sIFsgMTM3LjQxMDcwOTkwNTMxNzI0OCwgMzQuNzAxMjUxODkwMjQ4MDAyIF0sIFsgMTM3LjQxMDg0ODQyNzE2MDA5LCAzNC43MDExODA1ODAxODU4NjMgXSwgWyAxMzcuNDExMTE0Njk0LCAzNC43MDEyMDcyMjIgXSwgWyAxMzcuNDExMTI4Mzg5LCAzNC43MDEyMjM1ODMgXSwgWyAxMzcuNDExMDU4NzUsIDM0LjcwMTcwODQ3MiBdLCBbIDEzNy40MTEwNTczNjEsIDM0LjcwMTcxNzUgXSwgWyAxMzcuNDExMDA5ODg5MDAwMDEzLCAzNC43MDE3MjgyMjIgXSBdLCBbIFsgMTM3LjQwOTY5MDY0MjEzNDkwNSwgMzQuNzAxMDQxOTcyNzExNjg1IF0sIFsgMTM3LjQxMDU2ODkxMjY5OTU0NiwgMzQuNzAxMTIyNjgyOTI5ODY0IF0sIFsgMTM3LjQxMDY3MzY1NjYxMDcyNiwgMzQuNzAxMDUwNzMxODU1MTQgXSwgWyAxMzcuNDExMDA3NjYyNTQ5MzM4LCAzNC43MDEwNzczNDAxMzYyNDQgXSwgWyAxMzcuNDExMjM4MTQwMjQzLCAzNC43MDA5Nzc0MTQ3MjAxIF0sIFsgMTM3LjQxMTI5Mjc1LCAzNC43MDA5NTUwNTYgXSwgWyAxMzcuNDExMzA3NDExNTMyOTg4LCAzNC43MDA5Nzc0MTQ3MjAxIF0sIFsgMTM3LjQxMTMzOTEzOSwgMzQuNzAxMDI2IF0sIFsgMTM3LjQxMTQ1MDc2OTc0MTAwOSwgMzQuNzAwOTc3NDE0NzIwMSBdLCBbIDEzNy40MTE0OTkwMjM0MzY5ODgsIDM0LjcwMDk1NjQxMzQ2Nzk5OSBdLCBbIDEzNy40MTE4MzE2NjcsIDM0LjcwMDgxMTYzOSBdLCBbIDEzNy40MTE4NTc2MzksIDM0LjcwMDgwOTI1IF0sIFsgMTM3LjQxMTg5Mjc3OCwgMzQuNzAwODA3ODA2IF0sIFsgMTM3LjQxMTkzMjA4MzAwMDAxMSwgMzQuNzAwODA1NzUgXSwgWyAxMzcuNDExOTgyMzA2LCAzNC43MDA4MDkyNSBdLCBbIDEzNy40MTIwOTQ4ODksIDM0LjcwMDgyNTg4OSBdLCBbIDEzNy40MTIxMjMxNjcsIDM0LjcwMDgyNTc1IF0sIFsgMTM3LjQxMjE1MDk3MiwgMzQuNzAwODE2Mzg5IF0sIFsgMTM3LjQxMjQzNTk0NCwgMzQuNzAwNjkxOTQ0IF0sIFsgMTM3LjQxMjQ0OTY2NywgMzQuNzAwNjgzNjM5IF0sIFsgMTM3LjQxMjQ2MDIyMiwgMzQuNzAwNjcwMzYxIF0sIFsgMTM3LjQxMjQ2NjA1NiwgMzQuNzAwNjUzNSBdLCBbIDEzNy40MTI0OCwgMzQuNzAwNTY1MTk0IF0sIFsgMTM3LjQxMjQ3OTMwNiwgMzQuNzAwNTQ4NjExIF0sIFsgMTM3LjQxMjQ3Mzg4OTAwMDAxMiwgMzQuNzAwNTMyMzA2IF0sIFsgMTM3LjQxMjQ2MzA1NiwgMzQuNzAwNTE5MjUgXSwgWyAxMzcuNDEyNDQwMzA2LCAzNC43MDA1MDE1NTYgXSwgWyAxMzcuNDEyNDA5Nzc4MDAwMDExLCAzNC43MDA0ODE2OTQgXSwgWyAxMzcuNDEyMTkyMzYxLCAzNC43MDAzNDMxOTQgXSwgWyAxMzcuNDEyMTcxODA2LCAzNC43MDAzMjkxNjcgXSwgWyAxMzcuNDEyMTQ0OTE3LCAzNC43MDAzMTU2MTEgXSwgWyAxMzcuNDEyMTE4MzYxMDAwMDEyLCAzNC43MDAzMDQ4NjEgXSwgWyAxMzcuNDEyMDg4MDgyOTk5OTg2LCAzNC43MDAyOTQgXSwgWyAxMzcuNDEyMDU2Mzg5MDAwMDE0LCAzNC43MDAyODMzMzMgXSwgWyAxMzcuNDEyMDIxMTExLCAzNC43MDAyNzYzODkgXSwgWyAxMzcuNDExOTE2MzA2LCAzNC43MDAyNjc3NSBdLCBbIDEzNy40MTE5MDk4ODg5OTk5ODYsIDM0LjcwMDMxMzY2NyBdLCBbIDEzNy40MTE2OTg2MTEsIDM0LjcwMDI5MzI1IF0sIFsgMTM3LjQxMTcwNTU4MzAwMDAxNCwgMzQuNzAwMjU0MTExIF0sIFsgMTM3LjQxMTY5OTAyNzk5OTk4NywgMzQuNzAwMjQ2MTk0IF0sIFsgMTM3LjQxMTY5MTg4OSwgMzQuNzAwMjQgXSwgWyAxMzcuNDExNjc4NDcyLCAzNC43MDAyMzQwODMgXSwgWyAxMzcuNDExNjY0OTE3LCAzNC43MDAyMzAwMjggXSwgWyAxMzcuNDExNjQ1MTY2OTk5OTg5LCAzNC43MDAyMzA4MDYgXSwgWyAxMzcuNDExNjM0MTM5LCAzNC43MDAyMzI4MDYgXSwgWyAxMzcuNDExNjIzNDQ0MDAwMDE0LCAzNC43MDAyMzkwNTYgXSwgWyAxMzcuNDExNTU0NTI4MDAwMDExLCAzNC43MDA3MDMyNzggXSwgWyAxMzcuNDExNDk5MDIzNDM2OTg4LCAzNC43MDA2OTgxNzM3MjU1OTggXSwgWyAxMzcuNDExMjgxNjY3LCAzNC43MDA2NzgyMjIgXSwgWyAxMzcuNDExMTQyMTM5LCAzNC43MDA3NDQ4NjEgXSwgWyAxMzcuNDExMTA0MTkzOTk5OTg5LCAzNC43MDA3NjIyNSBdLCBbIDEzNy40MTA5NTk5NzIsIDM0LjcwMDc0OTkxNyBdLCBbIDEzNy40MTA5MjYzMDYsIDM0LjcwMDk1NjgwNiBdLCBbIDEzNy40MTA4ODc2NjcsIDM0LjcwMDk1NTA1NiBdLCBbIDEzNy40MTA5MDU0MTcsIDM0LjcwMDc5NDkxNyBdLCBbIDEzNy40MTA3NzAxMzksIDM0LjcwMDc4MTU4MyBdLCBbIDEzNy40MTA3MzU3NzgsIDM0LjcwMDc1MzYxMSBdLCBbIDEzNy40MTA1NDgzMDYwMDAwMSwgMzQuNzAwNzQxMzYxIF0sIFsgMTM3LjQxMDQ5MjcyMTk5OTk4NywgMzQuNzAwNzcyMDI4IF0sIFsgMTM3LjQxMDQ5MTYxMSwgMzQuNzAwNzgwMDU2IF0sIFsgMTM3LjQxMDMzMDA1NiwgMzQuNzAwNzY0NDE3IF0sIFsgMTM3LjQxMDM4NTA1NiwgMzQuNzAwMzg2MDU2IF0sIFsgMTM3LjQxMDM1OTkxNywgMzQuNzAwMzcwMDU2IF0sIFsgMTM3LjQxMDEyNTczMjQyMTk4OSwgMzQuNzAwMzQ5NjA5NTkwMDk5IF0sIFsgMTM3LjQxMDAzMDYxMSwgMzQuNzAwMzQxMzA2IF0sIFsgMTM3LjQxMDAxMzgwNiwgMzQuNzAwMzQgXSwgWyAxMzcuNDA5OTk5NSwgMzQuNzAwMzQwMTExIF0sIFsgMTM3LjQwOTk3NjY5NCwgMzQuNzAwMzQxNzc4IF0sIFsgMTM3LjQwOTk1NDQxNywgMzQuNzAwMzQ1ODA2IF0sIFsgMTM3LjQwOTkyMjI1LCAzNC43MDAzNTQwNTYgXSwgWyAxMzcuNDA5NzE3NTU2LCAzNC43MDA0MTU1IF0sIFsgMTM3LjQwOTcwNjMzMywgMzQuNzAwNTA0MzMzIF0sIFsgMTM3LjQwOTY2OTQ0NCwgMzQuNzAwNTM2NTgzIF0sIFsgMTM3LjQwOTY1LCAzNC43MDA2ODMzODkgXSwgWyAxMzcuNDA5NjQxNjM5LCAzNC43MDA3NDQ1IF0sIFsgMTM3LjQwOTUxMDk3MiwgMzQuNzAwNzMyMzYxIF0sIFsgMTM3LjQwOTQ5NjQ0NDAwMDAxMywgMzQuNzAwNzM2NDQ0IF0sIFsgMTM3LjQwOTQ4MzA1NiwgMzQuNzAwNzQxNSBdLCBbIDEzNy40MDk0NzExNjcsIDM0LjcwMDc1MDQ0NCBdLCBbIDEzNy40MDk0NTg3NSwgMzQuNzAwNzU5NDE3IF0sIFsgMTM3LjQwOTQzNzExMDk5OTk4OCwgMzQuNzAwOTM2ODYxIF0sIFsgMTM3LjQwOTQ3NDExMSwgMzQuNzAwOTM5NSBdLCBbIDEzNy40MDk0NjU1ODc0MjM5OTUsIDM0LjcwMDk3NzQxNDcyMDEgXSwgWyAxMzcuNDA5NDY0NzQ2MDU2MDQ1LCAzNC43MDA5ODExNDQ1ODY2NjMgXSwgWyAxMzcuNDA5NjYyNTc2NjE4NTMsIDM0LjcwMTAwMzkwMTI1OTY0NyBdLCBbIDEzNy40MDk2OTA2NDIxMzQ5MDUsIDM0LjcwMTA0MTk3MjcxMTY4NSBdIF0sIFsgWyAxMzcuNDA1MTUzOTQ0LCAzNC43MDI3NTIwNTYgXSwgWyAxMzcuNDA1MTUwNzc4LCAzNC43MDI3NTU3NSBdLCBbIDEzNy40MDUxMzIzNjEsIDM0LjcwMjc2Nzc3OCBdLCBbIDEzNy40MDUwNTk5MTY5OTk5ODgsIDM0LjcwMjgxNDgwNiBdLCBbIDEzNy40MDQ5Nzc4NjEsIDM0LjcwMjg2ODA1NiBdLCBbIDEzNy40MDQ5ODcxMzkwMDAwMTMsIDM0LjcwMjc5NTExMSBdLCBbIDEzNy40MDQ5OTM4ODksIDM0LjcwMjc0MzM2MSBdLCBbIDEzNy40MDQ5OTUyNzgsIDM0LjcwMjczNjUgXSwgWyAxMzcuNDA0OTk3NTU2MDAwMDEyLCAzNC43MDI3MzQyNSBdLCBbIDEzNy40MDUwMDEzODksIDM0LjcwMjczMzMzMyBdLCBbIDEzNy40MDUwMDczODksIDM0LjcwMjczMjk0NCBdLCBbIDEzNy40MDUwMjQxOTQsIDM0LjcwMjczNDI3OCBdLCBbIDEzNy40MDUwOTIxMTA5OTk5ODgsIDM0LjcwMjc0MDM2MSBdLCBbIDEzNy40MDUxNDI2NjcsIDM0LjcwMjc0NTY2NyBdLCBbIDEzNy40MDUxNTAzMDYsIDM0LjcwMjc0NzI3OCBdLCBbIDEzNy40MDUxNTM5MTcsIDM0LjcwMjc0OTUyOCBdLCBbIDEzNy40MDUxNTM5NDQsIDM0LjcwMjc1MjA1NiBdIF0sIFsgWyAxMzcuNDA2Njg5ODA2LCAzNC43MDI3MDcxOTQgXSwgWyAxMzcuNDA2NzMyODA2LCAzNC43MDI3NDcxMzkgXSwgWyAxMzcuNDA2NzI1MzA2LCAzNC43MDI3ODkxNjcgXSwgWyAxMzcuNDA2NjUzMjc4LCAzNC43MDI4MzI1IF0sIFsgMTM3LjQwNjYzNDU4MywgMzQuNzAyODMwNjM5IF0sIFsgMTM3LjQwNjY1MDU4Mjk5OTk4NywgMzQuNzAyNzMxMTY3IF0sIFsgMTM3LjQwNjY4OTgwNiwgMzQuNzAyNzA3MTk0IF0gXSwgWyBbIDEzNy40MDY4MTExOTQsIDM0LjcwMjcwOTUgXSwgWyAxMzcuNDA2ODIwMjc4LCAzNC43MDI3MTY5NDQgXSwgWyAxMzcuNDA2ODI0NzUsIDM0LjcwMjcyMDYzOSBdLCBbIDEzNy40MDY4NDMzNjEsIDM0LjcwMjczNTIyMiBdLCBbIDEzNy40MDY4NjQyNTAwMDAwMTIsIDM0LjcwMjc1MDg2MSBdLCBbIDEzNy40MDY4NzkzNjEsIDM0LjcwMjc2MTYzOSBdLCBbIDEzNy40MDY4OTc5NDQsIDM0LjcwMjc3NDMzMyBdLCBbIDEzNy40MDY5MTI1LCAzNC43MDI3ODQwMjggXSwgWyAxMzcuNDA2OTIzNDE3LCAzNC43MDI3OTA1ODMgXSwgWyAxMzcuNDA2OTA2NjM5LCAzNC43MDI5MDk1MjggXSwgWyAxMzcuNDA2ODk3MzYxLCAzNC43MDI5MTM0MTcgXSwgWyAxMzcuNDA2ODg5MDgzMDAwMDEsIDM0LjcwMjkxNTQxNyBdLCBbIDEzNy40MDY4NTIzMzI5OTk5ODksIDM0LjcwMjkyNzc1IF0sIFsgMTM3LjQwNjgyMDg4ODk5OTk4OCwgMzQuNzAyOTI2Mzg5IF0sIFsgMTM3LjQwNjcyNzQxNzAwMDAxMywgMzQuNzAyOTE5MzYxIF0sIFsgMTM3LjQwNjcyMzE5NCwgMzQuNzAyOTMxODg5IF0sIFsgMTM3LjQwNjY1OTYzOSwgMzQuNzAyOTI1NTI4IF0sIFsgMTM3LjQwNjY1OCwgMzQuNzAyOTI1MzMzIF0sIFsgMTM3LjQwNjUzODg4ODk5OTk4OSwgMzQuNzAyOTEzMzMzIF0sIFsgMTM3LjQwNjU5NzYxMSwgMzQuNzAyODc0IF0sIFsgMTM3LjQwNjY0NSwgMzQuNzAyODc3MjIyIF0sIFsgMTM3LjQwNjY4NDI1MDAwMDAxMiwgMzQuNzAyODY3Njk0IF0sIFsgMTM3LjQwNjcwMjg4OSwgMzQuNzAyODU0OTQ0IF0sIFsgMTM3LjQwNjc3OTY2NywgMzQuNzAyNzkzNjY3IF0sIFsgMTM3LjQwNjc4OTA1NiwgMzQuNzAyNzIwNTI4IF0sIFsgMTM3LjQwNjgxMTE5NCwgMzQuNzAyNzA5NSBdIF0sIFsgWyAxMzcuNDA2NzMwNjY3LCAzNC43MDIzODQ3NSBdLCBbIDEzNy40MDY3MzI1ODMsIDM0LjcwMjM2NTUyOCBdLCBbIDEzNy40MDY3MzUyMjIsIDM0LjcwMjMzNjk0NCBdLCBbIDEzNy40MDY3Mzc2NjY5OTk5ODcsIDM0LjcwMjMxMDgwNiBdLCBbIDEzNy40MDY3NDA2MzksIDM0LjcwMjI4MjMwNiBdLCBbIDEzNy40MDY3NDQ1ODMsIDM0LjcwMjI0NDI1IF0sIFsgMTM3LjQwNjc0OTM4OSwgMzQuNzAyMjEwNDQ0IF0sIFsgMTM3LjQwNjc1Mzc3OCwgMzQuNzAyMTc5Nzc4IF0sIFsgMTM3LjQwNjgxODc1MDAwMDAxNCwgMzQuNzAyMTg0OTcyIF0sIFsgMTM3LjQwNjg2NjAyOCwgMzQuNzAyMTg5MTExIF0sIFsgMTM3LjQwNjk1MTUsIDM0LjcwMjE5NzI1IF0sIFsgMTM3LjQwNzExNjE2NywgMzQuNzAyMjEzMjUgXSwgWyAxMzcuNDA3MjY3NzIyLCAzNC43MDIyMjc5MTcgXSwgWyAxMzcuNDA3Mjc0OTQ0LCAzNC43MDIyMzA2OTQgXSwgWyAxMzcuNDA3Mjc0ODMzLCAzNC43MDIyMzUxOTQgXSwgWyAxMzcuNDA3MjcxNjM4OTk5OTg3LCAzNC43MDIyNjE1MjggXSwgWyAxMzcuNDA3MjU5ODA2MDAwMDEzLCAzNC43MDIzNTY4MzMgXSwgWyAxMzcuNDA3MjQ2ODg5LCAzNC43MDI0NTkwODMgXSwgWyAxMzcuNDA3MjMzNDE2OTk5OTg2LCAzNC43MDI1NTc3NSBdLCBbIDEzNy40MDcyMjIzMzMsIDM0LjcwMjY0MzQxNyBdLCBbIDEzNy40MDcyMTM2NjcsIDM0LjcwMjcwOTMzMyBdLCBbIDEzNy40MDcyMDY3Nzc5OTk5ODgsIDM0LjcwMjc0NjY2NyBdLCBbIDEzNy40MDcxNTczMzI5OTk5ODYsIDM0LjcwMjc0MjUyOCBdLCBbIDEzNy40MDcxMDc0MTcsIDM0LjcwMjczNzMwNiBdLCBbIDEzNy40MDcwNjA0NzIwMDAwMTIsIDM0LjcwMjczMDE5NCBdLCBbIDEzNy40MDcwMjM4NjEsIDM0LjcwMjcyMDUyOCBdLCBbIDEzNy40MDY5NzU4ODksIDM0LjcwMjcwMTg2MSBdLCBbIDEzNy40MDY5NDM0MTcsIDM0LjcwMjY4NDgwNiBdLCBbIDEzNy40MDY5MTQ4ODksIDM0LjcwMjY2NzYzOSBdLCBbIDEzNy40MDY4ODY4ODksIDM0LjcwMjY0ODk0NCBdLCBbIDEzNy40MDY4NjAwODMsIDM0LjcwMjYyNzE2NyBdLCBbIDEzNy40MDY4MzcxOTQsIDM0LjcwMjYwNTIyMiBdLCBbIDEzNy40MDY4MTk4ODksIDM0LjcwMjU4NzQxNyBdLCBbIDEzNy40MDY4MTk4MDU5OTk5ODcsIDM0LjcwMjU4NzIyMiBdLCBbIDEzNy40MDY4MDQ4ODksIDM0LjcwMjU2ODYxMSBdLCBbIDEzNy40MDY3OTQwNTYsIDM0LjcwMjU1NDQ3MiBdLCBbIDEzNy40MDY3NzQ1MjgsIDM0LjcwMjUyNjM4OSBdLCBbIDEzNy40MDY3NjQ1NTYwMDAwMTMsIDM0LjcwMjUxMDQ0NCBdLCBbIDEzNy40MDY3NTg3MjIsIDM0LjcwMjQ5ODYzOSBdLCBbIDEzNy40MDY3NTAwNTYsIDM0LjcwMjQ4MDQ0NCBdLCBbIDEzNy40MDY3NDI5MTcsIDM0LjcwMjQ2MjA4MyBdLCBbIDEzNy40MDY3MzY1LCAzNC43MDI0MzY2NjcgXSwgWyAxMzcuNDA2NzMzNDE3LCAzNC43MDI0MjEwODMgXSwgWyAxMzcuNDA2NzMxMzg4OTk5OTg3LCAzNC43MDI0MDYyNzggXSwgWyAxMzcuNDA2NzMwNjY3LCAzNC43MDIzODQ3NSBdIF0sIFsgWyAxMzcuNDA5Mzg2NzIyLCAzNC43MDI0NDY5MTcgXSwgWyAxMzcuNDA5Mzk0MTY2OTk5OTg4LCAzNC43MDI0NTgzNjEgXSwgWyAxMzcuNDA5Mzk3NjExLCAzNC43MDI0NzMxMzkgXSwgWyAxMzcuNDA5Mzk2MzMyOTk5OTg5LCAzNC43MDI0ODU4MzMgXSwgWyAxMzcuNDA5MzI4NDcyLCAzNC43MDI5NDUwMjggXSwgWyAxMzcuNDA5MzI1NDQ0LCAzNC43MDI5NTc4MzMgXSwgWyAxMzcuNDA4OTA1NzIxOTk5OTg2LCAzNC43MDI5MTY2NjcgXSwgWyAxMzcuNDA4OTExNzc4LCAzNC43MDI4NjU1MjggXSwgWyAxMzcuNDA4OTc0NjM5LCAzNC43MDI0MTA1ODMgXSwgWyAxMzcuNDA4OTc3MjUsIDM0LjcwMjQwNjA4MyBdLCBbIDEzNy40MDg5ODE3MjIsIDM0LjcwMjQwMjU1NiBdLCBbIDEzNy40MDg5ODg1ODMsIDM0LjcwMjM5OTQ3MiBdLCBbIDEzNy40MDkwMDI4ODksIDM0LjcwMjM5NzQ3MiBdLCBbIDEzNy40MDkwMTc4MzMsIDM0LjcwMjM5ODUyOCBdLCBbIDEzNy40MDkzNjAxNjY5OTk5ODgsIDM0LjcwMjQzMjE5NCBdLCBbIDEzNy40MDkzNjkxMTEsIDM0LjcwMjQzNDEzOSBdLCBbIDEzNy40MDkzNzc5NzE5OTk5ODcsIDM0LjcwMjQzODU1NiBdLCBbIDEzNy40MDkzODY3MjIsIDM0LjcwMjQ0NjkxNyBdIF0sIFsgWyAxMzcuNDExMjMxOTQ0LCAzNC43MDE3MzEwMjggXSwgWyAxMzcuNDExMTQ1NDQ0LCAzNC43MDE3OTM1IF0sIFsgMTM3LjQxMTEyOTgwNiwgMzQuNzAxNzg1MDU2IF0sIFsgMTM3LjQxMTEyMzU1NiwgMzQuNzAxNzc3MTM5IF0sIFsgMTM3LjQxMTExOTM4OSwgMzQuNzAxNzY3MjIyIF0sIFsgMTM3LjQxMTEyODE2Njk5OTk4NywgMzQuNzAxNzA4MzMzIF0sIFsgMTM3LjQxMTE2MjE5NDAwMDAxMywgMzQuNzAxNDc4ODMzIF0sIFsgMTM3LjQxMTMwMDU1NTk5OTk4NiwgMzQuNzAxNDkxNzIyIF0sIFsgMTM3LjQxMTQ1MSwgMzQuNzAxNTA2OTE3IF0sIFsgMTM3LjQxMTQ2NjQxNzAwMDAxNCwgMzQuNzAxNTA4ODg5IF0sIFsgMTM3LjQxMTQ3NDA1NiwgMzQuNzAxNTEyNjM5IF0sIFsgMTM3LjQxMTQ4MTE2NywgMzQuNzAxNTE5MTM5IF0sIFsgMTM3LjQxMTQ4ODA4MywgMzQuNzAxNTI4NSBdLCBbIDEzNy40MTE0OTM0NzE5OTk5ODksIDM0LjcwMTU0MDAyOCBdLCBbIDEzNy40MTE0MjU5NDQsIDM0LjcwMTU4OTYzOSBdLCBbIDEzNy40MTEzMjE2OTQsIDM0LjcwMTY2NTU4MyBdLCBbIDEzNy40MTEyNjM0MTY5OTk5ODYsIDM0LjcwMTcwODA1NiBdLCBbIDEzNy40MTEyMzE5NDQsIDM0LjcwMTczMTAyOCBdIF0sIFsgWyAxMzcuNDExMzA2OTQzOTk5OTg5LCAzNC43MDExMDc4MzMgXSwgWyAxMzcuNDExMzA2OTcyLCAzNC43MDExMTEzNjEgXSwgWyAxMzcuNDExMjI2ODMzLCAzNC43MDExNDkxMTEgXSwgWyAxMzcuNDExMjIwOTQ0LCAzNC43MDExNDg0MTcgXSwgWyAxMzcuNDExMjE3NTU2LCAzNC43MDExNDYzMzMgXSwgWyAxMzcuNDExMjE0MTY3LCAzNC43MDExNDE0NzIgXSwgWyAxMzcuNDExMjEzMjUsIDM0LjcwMTEzNTE2NyBdLCBbIDEzNy40MTEyMTUsIDM0LjcwMTEzMDMwNiBdLCBbIDEzNy40MTEyOTY4ODksIDM0LjcwMTA5ODAyOCBdLCBbIDEzNy40MTEzMDI3NzgsIDM0LjcwMTEwMDgzMyBdLCBbIDEzNy40MTEzMDY5NDM5OTk5ODksIDM0LjcwMTEwNzgzMyBdIF0sIFsgWyAxMzcuNDExMTQ4Mjc4MDAwMDEzLCAzNC43MDExNjMxNjcgXSwgWyAxMzcuNDExMTc5NTgzLCAzNC43MDExNDg1IF0sIFsgMTM3LjQxMTE4ODg4ODk5OTk4OCwgMzQuNzAxMTYyNDQ0IF0sIFsgMTM3LjQxMTE2MzQ5OTk5OTk4NiwgMzQuNzAxMTcyOTQ0IF0sIFsgMTM3LjQxMTE1NTk0NCwgMzQuNzAxMTcyODg5IF0sIFsgMTM3LjQxMTE1MTY5NDAwMDAxMiwgMzQuNzAxMTcxNTI4IF0sIFsgMTM3LjQxMTE0NzQxNywgMzQuNzAxMTY4MDI4IF0sIFsgMTM3LjQxMTE0ODI3ODAwMDAxMywgMzQuNzAxMTYzMTY3IF0gXSwgWyBbIDEzNy40MTI2NTk4NjEsIDM0LjcwMDg0ODExMSBdLCBbIDEzNy40MTI2NzE2NjcwMDAwMTIsIDM0LjcwMDg1MzU4MyBdLCBbIDEzNy40MTI2ODY1MjgsIDM0LjcwMDg1NzYxMSBdLCBbIDEzNy40MTI2OTY2OTQsIDM0LjcwMDg2MjcyMiBdLCBbIDEzNy40MTI2ODk5NzIwMDAwMSwgMzQuNzAwODg0MTk0IF0sIFsgMTM3LjQxMjMzMzY5NDAwMDAxMiwgMzQuNzAwODQ1Nzc4IF0sIFsgMTM3LjQxMjQ5MjUyOCwgMzQuNzAwNzc0NSBdLCBbIDEzNy40MTI1MDk4NjEsIDM0LjcwMDc3MDA1NiBdLCBbIDEzNy40MTI1MzEyNSwgMzQuNzAwNzY4MjIyIF0sIFsgMTM3LjQxMjU1MTU1NjAwMDAxMSwgMzQuNzAwNzY4ODg5IF0sIFsgMTM3LjQxMjU2ODkxNjk5OTk4NywgMzQuNzAwNzcyOTE3IF0sIFsgMTM3LjQxMjU4NDY2NywgMzQuNzAwNzc4NDcyIF0sIFsgMTM3LjQxMjU5OTk3MjAwMDAxLCAzNC43MDA3ODY5MTcgXSwgWyAxMzcuNDEyNjEwODA2LCAzNC43MDA3OTgyNSBdLCBbIDEzNy40MTI2NDkwMjgsIDM0LjcwMDgzOTE5NCBdLCBbIDEzNy40MTI2NTk4NjEsIDM0LjcwMDg0ODExMSBdIF0sIFsgWyAxMzcuNDEzMDI1MTY3LCAzNC43MDA2NTQxNjcgXSwgWyAxMzcuNDEzMDI1ODA2LCAzNC43MDA2NDkzODkgXSwgWyAxMzcuNDEzMDI3MjIyMDAwMDExLCAzNC43MDA2NDU4NjEgXSwgWyAxMzcuNDEzMDMxNTgzLCAzNC43MDA2NDM0MTcgXSwgWyAxMzcuNDEzMjcwMjc4LCAzNC43MDA2NjQ5NDQgXSwgWyAxMzcuNDEzMjY4NDcyLCAzNC43MDA2ODM4NjEgXSwgWyAxMzcuNDEzMDMxOTcyLCAzNC43MDA2NjIxNjcgXSwgWyAxMzcuNDEzMDI4Njk0LCAzNC43MDA2NjExOTQgXSwgWyAxMzcuNDEzMDI2NSwgMzQuNzAwNjU4ODYxIF0sIFsgMTM3LjQxMzAyNTE2NywgMzQuNzAwNjU0MTY3IF0gXSwgWyBbIDEzNy40MDM5MzA5NDQsIDM0LjcwMjM5MDc3OCBdLCBbIDEzNy40MDQwMjQzMzMsIDM0LjcwMjM2MzI3OCBdLCBbIDEzNy40MDQxMjM1NTYsIDM0LjcwMjMzMjY5NCBdLCBbIDEzNy40MDQxNjIxNjcwMDAwMSwgMzQuNzAyMzIxNDQ0IF0sIFsgMTM3LjQwNDE3OTUyNzk5OTk4NiwgMzQuNzAyMzE2MDgzIF0sIFsgMTM3LjQwNDE5MzY5NDAwMDAxNCwgMzQuNzAyMzEyNTU2IF0sIFsgMTM3LjQwNDIwMTc3Nzk5OTk4NywgMzQuNzAyMzExODA2IF0sIFsgMTM3LjQwNDIxMDk0NCwgMzQuNzAyMzExODA2IF0sIFsgMTM3LjQwNDIyMjMwNiwgMzQuNzAyMzEyNSBdLCBbIDEzNy40MDQyMzgxMzksIDM0LjcwMjMxNDQ0NCBdLCBbIDEzNy40MDQyNzE3NzgsIDM0LjcwMjMxNzg4OSBdLCBbIDEzNy40MDQ0MjI3NzgsIDM0LjcwMjMzMzc1IF0sIFsgMTM3LjQwNDU5NDc1LCAzNC43MDIzNTE4ODkgXSwgWyAxMzcuNDA0NjMyNTY4MzU5MDA2LCAzNC43MDIzNTU3MzE4NTI5OTcgXSwgWyAxMzcuNDA1MDkxOTE3LCAzNC43MDI0MDIzMDYgXSwgWyAxMzcuNDA1MjAxNjM5MDAwMDEyLCAzNC43MDI0MTM5NzIgXSwgWyAxMzcuNDA1MjE0Nzc3OTk5OTg3LCAzNC43MDI0Mjc5MTcgXSwgWyAxMzcuNDA1MTc1ODMyOTk5OTg3LCAzNC43MDI2OTY3NSBdLCBbIDEzNy40MDUwOTMyNzgwMDAwMSwgMzQuNzAyNjg4Njk0IF0sIFsgMTM3LjQwNTAwODU1NjAwMDAxMywgMzQuNzAyNjgwODYxIF0sIFsgMTM3LjQwNDk3MjQxNzAwMDAxLCAzNC43MDI2Nzk0NzIgXSwgWyAxMzcuNDA0OTA4Mzg5MDAwMDEzLCAzNC43MDI2MjA0NzIgXSwgWyAxMzcuNDA0Njc0Mjc3OTk5OTg3LCAzNC43MDI1OTY5NDQgXSwgWyAxMzcuNDA0NjMyNTY4MzU5MDA2LCAzNC43MDI2MDk5NTk2NjY3MDIgXSwgWyAxMzcuNDA0NTQ3MjIyLCAzNC43MDI2MzY2NjcgXSwgWyAxMzcuNDA0NDUxNjY2OTk5OTg5LCAzNC43MDI2NjQ0NDQgXSwgWyAxMzcuNDA0MjY0MTY3LCAzNC43MDI2NDE4MzMgXSwgWyAxMzcuNDA0MTAwOTE3LCAzNC43MDI2MTk4NjEgXSwgWyAxMzcuNDAzOTQ3MTY3MDAwMDEzLCAzNC43MDI1OTk4ODkgXSwgWyAxMzcuNDAzODkzOTcyLCAzNC43MDI1OTI4NjEgXSwgWyAxMzcuNDAzOTA1MTY3LCAzNC43MDI0OTc5MTcgXSwgWyAxMzcuNDAzOTE4LCAzNC43MDI0MDIwNTYgXSwgWyAxMzcuNDAzOTE4ODYxLCAzNC43MDIzOTcxMTEgXSwgWyAxMzcuNDAzOTIwOTE3LCAzNC43MDIzOTQ1ODMgXSwgWyAxMzcuNDAzOTI1ODMyOTk5OTg4LCAzNC43MDIzOTI1IF0sIFsgMTM3LjQwMzkzMDk0NCwgMzQuNzAyMzkwNzc4IF0gXSwgWyBbIDEzNy40MDQ2MzI1NjgzNTkwMDYsIDM0LjcwMjY0NzU2NDA3MTY5NyBdLCBbIDEzNy40MDQ2NjI1LCAzNC43MDI2Mzg2MTEgXSwgWyAxMzcuNDA0ODkwOTE2OTk5OTg5LCAzNC43MDI2NjMxMzkgXSwgWyAxMzcuNDA0OTI2Mjc4LCAzNC43MDI2OTkxMzkgXSwgWyAxMzcuNDA0OTI0NSwgMzQuNzAyNzIwMzA2IF0sIFsgMTM3LjQwNDkxNDAyOCwgMzQuNzAyNzI2MTExIF0sIFsgMTM3LjQwNDYzMjU2ODM1OTAwNiwgMzQuNzAyNjk2MjA0MDU0MDk5IF0sIFsgMTM3LjQwNDUyNTc1LCAzNC43MDI2ODQ4NjEgXSwgWyAxMzcuNDA0NTI1ODMzLCAzNC43MDI2Nzk2MzkgXSwgWyAxMzcuNDA0NjMyNTY4MzU5MDA2LCAzNC43MDI2NDc1NjQwNzE2OTcgXSBdLCBbIFsgMTM3LjQwNjc4MjM2MTAwMDAxMiwgMzQuNzAyMDI2MDI4IF0sIFsgMTM3LjQwNjgwMjMwNiwgMzQuNzAxODk2NTI4IF0sIFsgMTM3LjQwNjgxNzYxMSwgMzQuNzAxNzkzODA2IF0sIFsgMTM3LjQwNjgyNjkxNjk5OTk4OSwgMzQuNzAxNzMxNjY3IF0sIFsgMTM3LjQwNzI5NTY2NywgMzQuNzAxNzc3OTE3IF0sIFsgMTM3LjQwNzMyODE5NCwgMzQuNzAxODEyMzYxIF0sIFsgMTM3LjQwNzI4OTM4NTY2OTk5OCwgMzQuNzAyMTA2NDM2NzA1NTk4IF0sIFsgMTM3LjQwNzI4MTYzOSwgMzQuNzAyMTY1MTM5IF0sIFsgMTM3LjQwNzI2MTc3OCwgMzQuNzAyMTY5ODYxIF0sIFsgMTM3LjQwNzIzNzMzMzAwMDAxMiwgMzQuNzAyMTcxNzIyIF0sIFsgMTM3LjQwNzE5MDgwNTk5OTk4OCwgMzQuNzAyMTY3MDI4IF0sIFsgMTM3LjQwNjk2NjMzMzAwMDAxNCwgMzQuNzAyMTQ5ODg5IF0sIFsgMTM3LjQwNjg1NTE5NCwgMzQuNzAyMTQxMjc4IF0sIFsgMTM3LjQwNjgyNTI3ODAwMDAxNCwgMzQuNzAyMTM4ODg5IF0sIFsgMTM3LjQwNjgxODYxMSwgMzQuNzAyMTM4MTk0IF0sIFsgMTM3LjQwNjc5Njc3OCwgMzQuNzAyMTM1OTcyIF0sIFsgMTM3LjQwNjc2NjQxNywgMzQuNzAyMTMyMjUgXSwgWyAxMzcuNDA2NzcwMzExNzA3OTg3LCAzNC43MDIxMDY0MzY3MDU1OTggXSwgWyAxMzcuNDA2NzgyMzYxMDAwMDEyLCAzNC43MDIwMjYwMjggXSBdLCBbIFsgMTM3LjQwNjMzMTY2Njk5OTk4OSwgMzQuNzAwOTM1MjUgXSwgWyAxMzcuNDA2NTQ5NjExLCAzNC43MDA5NTU1NTYgXSwgWyAxMzcuNDA2NTQ1NTMwOTAxMDEzLCAzNC43MDA5Nzc0MTQ3MjAxIF0sIFsgMTM3LjQwNjUzMzA1NiwgMzQuNzAxMDQ0NSBdLCBbIDEzNy40MDYzMTYzMDYsIDM0LjcwMTAyMTc1IF0sIFsgMTM3LjQwNjMyNDE5MDI5NjAwNCwgMzQuNzAwOTc3NDE0NzIwMSBdLCBbIDEzNy40MDYzMzE2NjY5OTk5ODksIDM0LjcwMDkzNTI1IF0gXSwgWyBbIDEzNy40MDczNDg4NjEsIDM0LjcwMjIzODE5NCBdLCBbIDEzNy40MDczNTc1ODMsIDM0LjcwMjIzNzI3OCBdLCBbIDEzNy40MDczNjg5NDQwMDAwMTIsIDM0LjcwMjIzNzk3MiBdLCBbIDEzNy40MDczNzkxNTAzOTA5OTQsIDM0LjcwMjIzODk1NzUyMzU5OCBdLCBbIDEzNy40MDc0NjAxMTEsIDM0LjcwMjI0NyBdLCBbIDEzNy40MDc1ODcyMjE5OTk5ODksIDM0LjcwMjI1ODYzOSBdLCBbIDEzNy40MDc3NzUyNDk5OTk5ODYsIDM0LjcwMjI3NzkxNyBdLCBbIDEzNy40MDc5Mjk1MjgwMDAwMTEsIDM0LjcwMjI5NDIyMiBdLCBbIDEzNy40MDgwMDUxOTQsIDM0LjcwMjMwMTA4MyBdLCBbIDEzNy40MDgwMTcsIDM0LjcwMjMwMzEzOSBdLCBbIDEzNy40MDgwMjEyNzgsIDM0LjcwMjMwNjM4OSBdLCBbIDEzNy40MDgwMjQ2NjcsIDM0LjcwMjMxMDYxMSBdLCBbIDEzNy40MDgwMjcxOTQsIDM0LjcwMjMxNjU1NiBdLCBbIDEzNy40MDgwMjc1MjgsIDM0LjcwMjMyMjMzMyBdLCBbIDEzNy40MDgwMjU3MjIsIDM0LjcwMjMzODkxNyBdLCBbIDEzNy40MDgwMDg1LCAzNC43MDI0NTgzODkgXSwgWyAxMzcuNDA3OTg5LCAzNC43MDI1ODU4MzMgXSwgWyAxMzcuNDA3OTcxMjUsIDM0LjcwMjcxMDgwNiBdLCBbIDEzNy40MDc5NTU5MTcwMDAwMSwgMzQuNzAyODA1MzA2IF0sIFsgMTM3LjQwNzk1MzIyMiwgMzQuNzAyODE2ODYxIF0sIFsgMTM3LjQwNzk0OTA4MywgMzQuNzAyODIyOTE3IF0sIFsgMTM3LjQwNzc1OTc1LCAzNC43MDI4MDQgXSwgWyAxMzcuNDA3NTk0NzQ5OTk5OTg3LCAzNC43MDI3ODc0NzIgXSwgWyAxMzcuNDA3NDMwMzA2LCAzNC43MDI3NzE3NSBdLCBbIDEzNy40MDczNzkxNTAzOTA5OTQsIDM0LjcwMjc2NjY5NTQ1MjkwMSBdLCBbIDEzNy40MDcyNjQ0NDQsIDM0LjcwMjc1NTMwNiBdLCBbIDEzNy40MDcyNjQ2NjcsIDM0LjcwMjc1MjMzMyBdLCBbIDEzNy40MDcyNjUxOTQsIDM0LjcwMjc0NzI3OCBdLCBbIDEzNy40MDcyNzU0NzIsIDM0LjcwMjY3NjQ3MiBdLCBbIDEzNy40MDcyODg3NSwgMzQuNzAyNTg2NDcyIF0sIFsgMTM3LjQwNzMwNzcyMjAwMDAxMywgMzQuNzAyNDY0MDI4IF0sIFsgMTM3LjQwNzMyMTE5NCwgMzQuNzAyMzY2MzYxIF0sIFsgMTM3LjQwNzMzNTc0OTk5OTk4NywgMzQuNzAyMjY2MzYxIF0sIFsgMTM3LjQwNzMzNzc3OCwgMzQuNzAyMjUzNTU2IF0sIFsgMTM3LjQwNzMzOTcyMTk5OTk4OSwgMzQuNzAyMjQ1ODg5IF0sIFsgMTM3LjQwNzM0MzYzOSwgMzQuNzAyMjQwNzIyIF0sIFsgMTM3LjQwNzM0ODg2MSwgMzQuNzAyMjM4MTk0IF0gXSwgWyBbIDEzNy40MDgwOTk3NzgsIDM0LjcwMjMxNTI1IF0sIFsgMTM3LjQwODEwNDI1LCAzNC43MDIzMTM0MTcgXSwgWyAxMzcuNDA4MTEwOTE2OTk5OTg4LCAzNC43MDIzMTI5NzIgXSwgWyAxMzcuNDA4MTIyMjUsIDM0LjcwMjMxMzU4MyBdLCBbIDEzNy40MDgxNDQxMTEwMDAwMTMsIDM0LjcwMjMxNTc3OCBdLCBbIDEzNy40MDgxNjAzNjEsIDM0LjcwMjMxOCBdLCBbIDEzNy40MDgxNzcwODMsIDM0LjcwMjMxODk3MiBdLCBbIDEzNy40MDgyMDMzODksIDM0LjcwMjMyIF0sIFsgMTM3LjQwODIxNTYxMSwgMzQuNzAyMzIwMjUgXSwgWyAxMzcuNDA4MzMzMzMzLCAzNC43MDIzMzEzNjEgXSwgWyAxMzcuNDA4NDQzNjExLCAzNC43MDIzNDE3NzggXSwgWyAxMzcuNDA4NDY5NDcyLCAzNC43MDIzNDU0MTcgXSwgWyAxMzcuNDA4NDgyMjUsIDM0LjcwMjM0NzMwNiBdLCBbIDEzNy40MDg0ODgzODkwMDAwMTMsIDM0LjcwMjM0OTE2NyBdLCBbIDEzNy40MDg0OTQ5NDQwMDAwMTIsIDM0LjcwMjM1MzIyMiBdLCBbIDEzNy40MDg1MDE3MjIwMDAwMTEsIDM0LjcwMjM2MTc3OCBdLCBbIDEzNy40MDg1MDM1LCAzNC43MDIzNzIwNTYgXSwgWyAxMzcuNDA4NTAyNDcyLCAzNC43MDIzODgyNzggXSwgWyAxMzcuNDA4NDk0NDQ0MDAwMDEzLCAzNC43MDI0NDI1NTYgXSwgWyAxMzcuNDA4NDgzNzQ5OTk5OTg4LCAzNC43MDI1MTc1IF0sIFsgMTM3LjQwODQ1NDA4MywgMzQuNzAyNzE5NDE3IF0sIFsgMTM3LjQwODQzNzA4MywgMzQuNzAyODQxODYxIF0sIFsgMTM3LjQwODQzMjU4MywgMzQuNzAyODY5OTE3IF0sIFsgMTM3LjQwODMzMzMzMywgMzQuNzAyODU5NzIyIF0sIFsgMTM3LjQwODIxNzAyOCwgMzQuNzAyODQ3ODA2IF0sIFsgMTM3LjQwODAxNjY2NywgMzQuNzAyODMgXSwgWyAxMzcuNDA4MDE2LCAzNC43MDI4MjI1IF0sIFsgMTM3LjQwODAxODM2MDk5OTk4OSwgMzQuNzAyODA2IF0sIFsgMTM3LjQwODAzMTgzMywgMzQuNzAyNzE0MTk0IF0sIFsgMTM3LjQwODA1MDQ3MjAwMDAxNCwgMzQuNzAyNTg1MDU2IF0sIFsgMTM3LjQwODA2OTQxNywgMzQuNzAyNDU2NjY3IF0sIFsgMTM3LjQwODA4NTI1LCAzNC43MDIzNDQ1NTYgXSwgWyAxMzcuNDA4MDg4MzYxMDAwMDExLCAzNC43MDIzMzAyMjIgXSwgWyAxMzcuNDA4MDkxNzIyLCAzNC43MDIzMjMxOTQgXSwgWyAxMzcuNDA4MDk1LCAzNC43MDIzMTkxMTEgXSwgWyAxMzcuNDA4MDk5Nzc4LCAzNC43MDIzMTUyNSBdIF0sIFsgWyAxMzcuNDA3NDE5NDE3LCAzNC43MDIwNjUxMzkgXSwgWyAxMzcuNDA3Mzk0NTI4LCAzNC43MDIwNjI4NjEgXSwgWyAxMzcuNDA3Mzg1MzYxLCAzNC43MDIwNTkyNzggXSwgWyAxMzcuNDA3Mzc5MTUwMzkwOTk0LCAzNC43MDIwNTM5MDg3NjAzOTggXSwgWyAxMzcuNDA3Mzc4MjUsIDM0LjcwMjA1MzQxNyBdLCBbIDEzNy40MDczNzI2Mzg5OTk5ODgsIDM0LjcwMjA0NTUgXSwgWyAxMzcuNDA3Mzc5MTUwMzkwOTk0LCAzNC43MDIwMTAyNzE3MjkzIF0sIFsgMTM3LjQwNzM4MDM4OSwgMzQuNzAyMDAzNDcyIF0sIFsgMTM3LjQwNzM4ODU1NiwgMzQuNzAxOTk3MDU2IF0sIFsgMTM3LjQwNzM5NjgzMywgMzQuNzAxOTkxODA2IF0sIFsgMTM3LjQwNzQwODk0NCwgMzQuNzAxOTg3NjM5IF0sIFsgMTM3LjQwNzQzMTQ0NCwgMzQuNzAxOTkwMTExIF0sIFsgMTM3LjQwNzQxOTQxNywgMzQuNzAyMDY1MTM5IF0gXSwgWyBbIDEzNy40MDc0MDMsIDM0LjcwMDk1NDc3OCBdLCBbIDEzNy40MDczNzkxNTAzOTA5OTQsIDM0LjcwMDk1MjQ3NDE4NDkwMiBdLCBbIDEzNy40MDcxODU1LCAzNC43MDA5MzM3NSBdLCBbIDEzNy40MDcyMzMxMTEwMDAwMTEsIDM0LjcwMDkwNTA4MyBdLCBbIDEzNy40MDcyNTY2NjcwMDAwMTMsIDM0LjcwMDg5NjgzMyBdLCBbIDEzNy40MDcyOTEyNDk5OTk5ODYsIDM0LjcwMDg4ODMwNiBdLCBbIDEzNy40MDczMjA3MjIsIDM0LjcwMDg4NDE5NCBdLCBbIDEzNy40MDczNjM2MTEsIDM0LjcwMDg4NDcyMiBdLCBbIDEzNy40MDczNzkxNTAzOTA5OTQsIDM0LjcwMDg4NjExNDc3OTc5OSBdLCBbIDEzNy40MDc0NDQ5NDQsIDM0LjcwMDg5MjA1NiBdLCBbIDEzNy40MDc0MjQ2MTEwMDAwMSwgMzQuNzAwOTEyNDcyIF0sIFsgMTM3LjQwNzQyMDQ0NCwgMzQuNzAwOTQzMzA2IF0sIFsgMTM3LjQwNzQwMywgMzQuNzAwOTU0Nzc4IF0gXSwgWyBbIDEzNy40MDg4ODUyNzgwMDAwMTQsIDM0LjcwMjM4NTI1IF0sIFsgMTM3LjQwODg5NzE5NCwgMzQuNzAyMzg3NjY3IF0sIFsgMTM3LjQwODkwNjU4MywgMzQuNzAyMzkyMTY3IF0sIFsgMTM3LjQwODkxNTI1LCAzNC43MDI0MDI1IF0sIFsgMTM3LjQwODkxOTMwNiwgMzQuNzAyNDExOTcyIF0sIFsgMTM3LjQwODkyMSwgMzQuNzAyNDI3MDI4IF0sIFsgMTM3LjQwODkxODg2MDk5OTk4OSwgMzQuNzAyNDQ2NTgzIF0sIFsgMTM3LjQwODg1NjY5NCwgMzQuNzAyOTExODg5IF0sIFsgMTM3LjQwODc1MjQ0MTQwNTk5NCwgMzQuNzAyOTAxODM3MjE2OTk5IF0sIFsgMTM3LjQwODQ5MzE5Mzk5OTk4OCwgMzQuNzAyODc2ODMzIF0sIFsgMTM3LjQwODQ5ODgzMzAwMDAxLCAzNC43MDI4MzE1NTYgXSwgWyAxMzcuNDA4NTE4MDgzLCAzNC43MDI2ODk5NzIgXSwgWyAxMzcuNDA4NTUzNjM5LCAzNC43MDI0MjE5NzIgXSwgWyAxMzcuNDA4NTYxMzYxMDAwMDExLCAzNC43MDIzNjk4NjEgXSwgWyAxMzcuNDA4NTYzOTcyLCAzNC43MDIzNjY1MjggXSwgWyAxMzcuNDA4NTY4LCAzNC43MDIzNjI4ODkgXSwgWyAxMzcuNDA4NTc2MTY3LCAzNC43MDIzNTkyNzggXSwgWyAxMzcuNDA4NTkxODg5LCAzNC43MDIzNTcgXSwgWyAxMzcuNDA4NzUyNDQxNDA1OTk0LCAzNC43MDIzNzI0NDU5NzIzMDEgXSwgWyAxMzcuNDA4ODg1Mjc4MDAwMDE0LCAzNC43MDIzODUyNSBdIF0sIFsgWyAxMzcuNDA5MzA0NzIyLCAzNC43MDA0OTQ1ODMgXSwgWyAxMzcuNDA5MjI3NjExLCAzNC43MDA1OTE4MzMgXSwgWyAxMzcuNDA5MjE0MDgzLCAzNC43MDA1OTgzMzMgXSwgWyAxMzcuNDA5MTk1MDI4LCAzNC43MDA2MDUxMzkgXSwgWyAxMzcuNDA5MTczNTI4LCAzNC43MDA2MDY4ODkgXSwgWyAxMzcuNDA5MTQxODYxLCAzNC43MDA2MDQ4MDYgXSwgWyAxMzcuNDA4ODEyOTcyLCAzNC43MDA1NzM2MzkgXSwgWyAxMzcuNDA4NzkwNSwgMzQuNzAwNTcxODYxIF0sIFsgMTM3LjQwODc2NywgMzQuNzAwNTY2MjUgXSwgWyAxMzcuNDA4NzU2Mjc4LCAzNC43MDA1NTU5NzIgXSwgWyAxMzcuNDA4NzUyNDQxNDA1OTk0LCAzNC43MDA1NTA2ODk1MzczMDIgXSwgWyAxMzcuNDA4NzQ0NTU1OTk5OTg4LCAzNC43MDA1NDAzMDYgXSwgWyAxMzcuNDA4NzM3NzIyMDAwMDEyLCAzNC43MDA1MjQwMjggXSwgWyAxMzcuNDA4NzM5MjIyLCAzNC43MDA1MDgxMzkgXSwgWyAxMzcuNDA4NzQ2NzIxOTk5OTg5LCAzNC43MDA0OTU2OTQgXSwgWyAxMzcuNDA4NzUyNDQxNDA1OTk0LCAzNC43MDA0ODg3ODM3MDIzOTcgXSwgWyAxMzcuNDA4NzU1ODYxLCAzNC43MDA0ODQ5NDQgXSwgWyAxMzcuNDA4NzY1MzMzLCAzNC43MDA0NzcwODMgXSwgWyAxMzcuNDA5MDAzNDcyLCAzNC43MDAzOTQzMDYgXSwgWyAxMzcuNDA5MDI5ODg5MDAwMDEsIDM0LjcwMDM4OTYzOSBdLCBbIDEzNy40MDkwNTY1LCAzNC43MDAzODY4ODkgXSwgWyAxMzcuNDA5MDk0NzIyLCAzNC43MDAzODQ5MTcgXSwgWyAxMzcuNDA5MTM0ODg5LCAzNC43MDAzODc4MDYgXSwgWyAxMzcuNDA5MjcyODg5LCAzNC43MDA0MDA4ODkgXSwgWyAxMzcuNDA5MjkxNDcyLCAzNC43MDA0MDc3NzggXSwgWyAxMzcuNDA5MzEwOTQ0LCAzNC43MDA0MjAyNzggXSwgWyAxMzcuNDA5MzIyMzYxLCAzNC43MDA0NDI4MDYgXSwgWyAxMzcuNDA5MzI0Mjc4MDAwMDE0LCAzNC43MDA0NjA2MzkgXSwgWyAxMzcuNDA5MzE2MzYxLCAzNC43MDA0Nzg0MTcgXSwgWyAxMzcuNDA5MzA0NzIyLCAzNC43MDA0OTQ1ODMgXSBdLCBbIFsgMTM3LjQxMDQzODk3MiwgMzQuNzAwNjgxNzIyIF0sIFsgMTM3LjQxMDQzMDI1LCAzNC43MDA2NzkxMzkgXSwgWyAxMzcuNDEwNDIwMTY3MDAwMDEyLCAzNC43MDA2NzI5MTcgXSwgWyAxMzcuNDEwNDA5NjY3MDAwMDEsIDM0LjcwMDY2MzM4OSBdLCBbIDEzNy40MTA0MDY1ODMsIDM0LjcwMDY1MTQxNyBdLCBbIDEzNy40MTA0NDY5NDQsIDM0LjcwMDM4MTMzMyBdLCBbIDEzNy40MTA3MDcyNSwgMzQuNzAwNDA2OTQ0IF0sIFsgMTM3LjQxMDc0MTQxNywgMzQuNzAwNDA5NzUgXSwgWyAxMzcuNDEwNzYxOTQ0LCAzNC43MDA0MDkyNzggXSwgWyAxMzcuNDEwNzg1NDE3LCAzNC43MDA0MDgzMzMgXSwgWyAxMzcuNDEwODA1ODA2MDAwMDEzLCAzNC43MDA0MDYxMTEgXSwgWyAxMzcuNDEwODI5NjExLCAzNC43MDA0MDE1NTYgXSwgWyAxMzcuNDEwODUyOTQ0LCAzNC43MDAzOTYxOTQgXSwgWyAxMzcuNDEwODgzMDU1OTk5OTg5LCAzNC43MDAzODk2MzkgXSwgWyAxMzcuNDEwODU1ODYwOTk5OTg3LCAzNC43MDA2ODA0NDQgXSwgWyAxMzcuNDEwODE2MjIyLCAzNC43MDA3MTQ5NDQgXSwgWyAxMzcuNDEwNDQ0NjY3LCAzNC43MDA2ODI0NDQgXSwgWyAxMzcuNDEwNDM4OTcyLCAzNC43MDA2ODE3MjIgXSBdLCBbIFsgMTM3LjQxMTQ3MTI3OCwgMzQuNzAxMjAyIF0sIFsgMTM3LjQxMTQ5NzkxNywgMzQuNzAxMTk4NSBdLCBbIDEzNy40MTE0OTkwMjM0MzY5ODgsIDM0LjcwMTE5ODkyNDQxOTEwMyBdLCBbIDEzNy40MTE1MTgxMTEsIDM0LjcwMTIwMjYxMSBdLCBbIDEzNy40MTE1NDA4NjEsIDM0LjcwMTIwOTk3MiBdLCBbIDEzNy40MTE1NTk2NjcsIDM0LjcwMTIxOTk0NCBdLCBbIDEzNy40MTE1NzIwMjgsIDM0LjcwMTIzMjM2MSBdLCBbIDEzNy40MTE1Nzg3MjIsIDM0LjcwMTI0OTI3OCBdLCBbIDEzNy40MTE1ODEzODksIDM0LjcwMTI2NTA1NiBdLCBbIDEzNy40MTE1ODEyMjIsIDM0LjcwMTI4MTYzOSBdLCBbIDEzNy40MTE1NzUyNSwgMzQuNzAxMjkzNjM5IF0sIFsgMTM3LjQxMTU2Mjk3MjAwMDAxMywgMzQuNzAxMzA5MTY3IF0sIFsgMTM3LjQxMTU0NTQxNzAwMDAxMywgMzQuNzAxMzE2Njk0IF0sIFsgMTM3LjQxMTUwMTAyOCwgMzQuNzAxMzI1NjExIF0sIFsgMTM3LjQxMTQ5OTAyMzQzNjk4OCwgMzQuNzAxMzI1Njg3MzA4MTk5IF0sIFsgMTM3LjQxMTQ3MTExMSwgMzQuNzAxMzI3Mzg5IF0sIFsgMTM3LjQxMTQ0MTc1LCAzNC43MDEzMjUyNzggXSwgWyAxMzcuNDExNDIxOTcyLCAzNC43MDEzMTg3NSBdLCBbIDEzNy40MTE0MDUxMTEsIDM0LjcwMTMwNDgwNiBdLCBbIDEzNy40MTE0MDA0MTcwMDAwMSwgMzQuNzAxMjk5NSBdLCBbIDEzNy40MTEzODk5NzIsIDM0LjcwMTI4MjM4OSBdLCBbIDEzNy40MTEzODgwODMsIDM0LjcwMTI2ODMzMyBdLCBbIDEzNy40MTEzOTIwODMwMDAwMSwgMzQuNzAxMjU1NDQ0IF0sIFsgMTM3LjQxMTQwNDY5NCwgMzQuNzAxMjM1NjY3IF0sIFsgMTM3LjQxMTQyMTQ3MiwgMzQuNzAxMjIwODMzIF0sIFsgMTM3LjQxMTQ0NDY2NzAwMDAxMiwgMzQuNzAxMjA5NDQ0IF0sIFsgMTM3LjQxMTQ3MTI3OCwgMzQuNzAxMjAyIF0gXSwgWyBbIDEzNy40MTEzNDYwMjgsIDM0LjcwMTI4ODc3OCBdLCBbIDEzNy40MTEzNTY0NDQsIDM0LjcwMTMwNjYxMSBdLCBbIDEzNy40MTEzNjg1LCAzNC43MDEzMjQ1MjggXSwgWyAxMzcuNDExMzg5MTk0LCAzNC43MDEzNDI2MTEgXSwgWyAxMzcuNDExNDExNzIyLCAzNC43MDEzNTg2OTQgXSwgWyAxMzcuNDExNDQxMzMzLCAzNC43MDEzNzIzNjEgXSwgWyAxMzcuNDExNDc5NDcyLCAzNC43MDEzODIyNzggXSwgWyAxMzcuNDExNDk3Mjc4MDAwMDEzLCAzNC43MDEzODc0NzIgXSwgWyAxMzcuNDExNDk5MDIzNDM2OTg4LCAzNC43MDEzODg0NDc4MjM5MDIgXSwgWyAxMzcuNDExNTE0NzUsIDM0LjcwMTM5NjQ0NCBdLCBbIDEzNy40MTE1MjQ1MjgsIDM0LjcwMTQwOTk0NCBdLCBbIDEzNy40MTE1MzM0MTY5OTk5ODcsIDM0LjcwMTQyODQxNyBdLCBbIDEzNy40MTE1MjQ1MjgsIDM0LjcwMTQ0NzI3OCBdLCBbIDEzNy40MTE1MDk2MTEwMDAwMTQsIDM0LjcwMTQ2MDM4OSBdLCBbIDEzNy40MTE0OTkwMjM0MzY5ODgsIDM0LjcwMTQ1OTIyMjI4ODY5OCBdLCBbIDEzNy40MTExNTczMzMsIDM0LjcwMTQyMTYxMSBdLCBbIDEzNy40MTExNDk4ODksIDM0LjcwMTQwODI3OCBdLCBbIDEzNy40MTExODUwODMsIDM0LjcwMTIwNzE2NyBdLCBbIDEzNy40MTEyMzE1MjgsIDM0LjcwMTE4MjU1NiBdLCBbIDEzNy40MTEyNDM0NDQsIDM0LjcwMTE5NDc3OCBdLCBbIDEzNy40MTEyOTUsIDM0LjcwMTIwNTUgXSwgWyAxMzcuNDExMzE0ODg5MDAwMDEsIDM0LjcwMTIwNjA4MyBdLCBbIDEzNy40MTEzNDcyNzgsIDM0LjcwMTIwMzIyMiBdLCBbIDEzNy40MTEzNTQ3NDk5OTk5ODcsIDM0LjcwMTI0ODc1IF0sIFsgMTM3LjQxMTM0NDk0NCwgMzQuNzAxMjU4NSBdLCBbIDEzNy40MTEzNDE5MTY5OTk5ODcsIDM0LjcwMTI3MjY2NyBdLCBbIDEzNy40MTEzNDYwMjgsIDM0LjcwMTI4ODc3OCBdIF0sIFsgWyAxMzcuNDEyNjgyMTM5LCAzNC43MDA3NDc4MDYgXSwgWyAxMzcuNDEyNjY1NTI4LCAzNC43MDA3Mzk5MTcgXSwgWyAxMzcuNDEyNjUsIDM0LjcwMDczMDgzMyBdLCBbIDEzNy40MTI2MzYsIDM0LjcwMDcyMDEzOSBdLCBbIDEzNy40MTI2MjM1MjgwMDAwMTIsIDM0LjcwMDcwODE2NyBdLCBbIDEzNy40MTI2MTI3NzgwMDAwMSwgMzQuNzAwNjk1MTk0IF0sIFsgMTM3LjQxMjYwMzgwNiwgMzQuNzAwNjgxNDQ0IF0sIFsgMTM3LjQxMjU5NywgMzQuNzAwNjY2NjY3IF0sIFsgMTM3LjQxMjU5MjEzOSwgMzQuNzAwNjUxNDQ0IF0sIFsgMTM3LjQxMjU4OTM2MDk5OTk4OCwgMzQuNzAwNjM1ODMzIF0sIFsgMTM3LjQxMjU4ODg4OSwgMzQuNzAwNjIwMDU2IF0sIFsgMTM3LjQxMjU5MDQ3MiwgMzQuNzAwNjA0Mzg5IF0sIFsgMTM3LjQxMjU5NDM2MSwgMzQuNzAwNTg5MDU2IF0sIFsgMTM3LjQxMjYwMDE5NCwgMzQuNzAwNTc0MTY3IF0sIFsgMTM3LjQxMjYwODEzOTAwMDAxNCwgMzQuNzAwNTU5NzIyIF0sIFsgMTM3LjQxMjYxODAyOCwgMzQuNzAwNTQ2MzYxIF0sIFsgMTM3LjQxMjYyOTY2NywgMzQuNzAwNTMzODg5IF0sIFsgMTM3LjQxMjY0MzA1NiwgMzQuNzAwNTIyNTgzIF0sIFsgMTM3LjQxMjY1Nzg4OSwgMzQuNzAwNTEyNzUgXSwgWyAxMzcuNDEyNjczODg5LCAzNC43MDA1MDQyMjIgXSwgWyAxMzcuNDEyNjkxMDI4MDAwMDEyLCAzNC43MDA0OTczMzMgXSwgWyAxMzcuNDEyNzA5LCAzNC43MDA0OTIwODMgXSwgWyAxMzcuNDEyNzI3NTU2LCAzNC43MDA0ODg2MTEgXSwgWyAxMzcuNDEyNzQ2NTU2LCAzNC43MDA0ODY3NzggXSwgWyAxMzcuNDEyNzUyOTcyLCAzNC43MDA0ODY1ODMgXSwgWyAxMzcuNDEyNzcyMDgzLCAzNC43MDA0ODc0NDQgXSwgWyAxMzcuNDEyNzkwODYxLCAzNC43MDA0OTAxMTEgXSwgWyAxMzcuNDEyODA5MjIyLCAzNC43MDA0OTQ0MTcgXSwgWyAxMzcuNDEyODI2ODA2LCAzNC43MDA1MDA0MTcgXSwgWyAxMzcuNDEyODQzNDQ0LCAzNC43MDA1MDgwMjggXSwgWyAxMzcuNDEyODU4OTcyLCAzNC43MDA1MTcxMTEgXSwgWyAxMzcuNDEyODcyMzE0NDUzMDExLCAzNC43MDA1MjcyNDIzNjExOTcgXSwgWyAxMzcuNDEyODczMDgzLCAzNC43MDA1Mjc2MzkgXSwgWyAxMzcuNDEyODg1NjY3MDAwMDEyLCAzNC43MDA1Mzk1IF0sIFsgMTM3LjQxMjg5NjQ5OTk5OTk4OCwgMzQuNzAwNTUyMzYxIF0sIFsgMTM3LjQxMjkwNTUsIDM0LjcwMDU2NjMzMyBdLCBbIDEzNy40MTI5MTI1MjgsIDM0LjcwMDU4MDkxNyBdLCBbIDEzNy40MTI5MTc0NzIsIDM0LjcwMDU5NjA1NiBdLCBbIDEzNy40MTI5MjAyNTAwMDAwMTMsIDM0LjcwMDYxMTYzOSBdLCBbIDEzNy40MTI5MjA5NzIsIDM0LjcwMDYyNzQxNyBdLCBbIDEzNy40MTI5MTkzNjEsIDM0LjcwMDY0MzAyOCBdLCBbIDEzNy40MTI5MTU2OTQsIDM0LjcwMDY1ODUyOCBdLCBbIDEzNy40MTI5MDk4NjEsIDM0LjcwMDY3MzUgXSwgWyAxMzcuNDEyOTAyMDI4LCAzNC43MDA2ODc4NjEgXSwgWyAxMzcuNDEyODkyMjUsIDM0LjcwMDcwMTQxNyBdLCBbIDEzNy40MTI4ODA2MTEsIDM0LjcwMDcxMzg2MSBdLCBbIDEzNy40MTI4NzIzMTQ0NTMwMTEsIDM0LjcwMDcyMTA0NzEwMjM5OCBdLCBbIDEzNy40MTI4Njc0NDQsIDM0LjcwMDcyNTI1IF0sIFsgMTM3LjQxMjg1MjcyMiwgMzQuNzAwNzM1Mjc4IF0sIFsgMTM3LjQxMjgzNjY5NCwgMzQuNzAwNzQzODA2IF0sIFsgMTM3LjQxMjgxOTU4Mjk5OTk4NywgMzQuNzAwNzUwNzc4IF0sIFsgMTM3LjQxMjgwMTY5NCwgMzQuNzAwNzU1OTQ0IF0sIFsgMTM3LjQxMjc4MzE2Njk5OTk4NiwgMzQuNzAwNzU5Njk0IF0sIFsgMTM3LjQxMjc2NDE2NywgMzQuNzAwNzYxNDQ0IF0sIFsgMTM3LjQxMjc1NTc3OCwgMzQuNzAwNzYxNzIyIF0sIFsgMTM3LjQxMjczNjc3ODAwMDAxLCAzNC43MDA3NjA5NDQgXSwgWyAxMzcuNDEyNzE3OTcyLCAzNC43MDA3NTgxMTEgXSwgWyAxMzcuNDEyNjk5NjM5MDAwMDEsIDM0LjcwMDc1MzgwNiBdLCBbIDEzNy40MTI2ODIxMzksIDM0LjcwMDc0NzgwNiBdIF0sIFsgWyAxMzcuNDEyOTcwNSwgMzQuNzAwODA2MzYxIF0sIFsgMTM3LjQxMjk0NTExMSwgMzQuNzAwODI0NzIyIF0sIFsgMTM3LjQxMjkxNDcyMjAwMDAxMSwgMzQuNzAwODQ1MDU2IF0sIFsgMTM3LjQxMjg3MjMxNDQ1MzAxMSwgMzQuNzAwODcyMjQ2NjA4IF0sIFsgMTM3LjQxMjg3MTQ3MiwgMzQuNzAwODcyODMzIF0sIFsgMTM3LjQxMjg0MDcyMiwgMzQuNzAwODg0Nzc4IF0sIFsgMTM3LjQxMjgyMjUsIDM0LjcwMDg5MDA1NiBdLCBbIDEzNy40MTI4MjE4MDYwMDAwMTEsIDM0LjcwMDg3MzcyMiBdLCBbIDEzNy40MTI4NDM2Mzg5OTk5ODgsIDM0LjcwMDg3MDgwNiBdLCBbIDEzNy40MTI4NjQ3NzgsIDM0LjcwMDg2MzExMSBdLCBbIDEzNy40MTI4NzIzMTQ0NTMwMTEsIDM0LjcwMDg1ODE0ODQ3NjAwMSBdLCBbIDEzNy40MTI5Mjk5NDQwMDAwMTIsIDM0LjcwMDgxOTg4OSBdLCBbIDEzNy40MTI5NTQzMzI5OTk5ODgsIDM0LjcwMDc5NzE5NCBdLCBbIDEzNy40MTI5NTg1NTYsIDM0LjcwMDc4NTYzOSBdLCBbIDEzNy40MTI5NjA0NzIsIDM0LjcwMDc3MDg2MSBdLCBbIDEzNy40MTI5NTg4ODksIDM0LjcwMDc1Nzk3MiBdLCBbIDEzNy40MTI5NjQ4NjEsIDM0LjcwMDc0NTY5NCBdLCBbIDEzNy40MTI5NzY5NDQsIDM0LjcwMDczNTM4OSBdLCBbIDEzNy40MTI5OTQyNzgwMDAwMTQsIDM0LjcwMDcyNDI3OCBdLCBbIDEzNy40MTMwMTE5NDQsIDM0LjcwMDcxNzExMSBdLCBbIDEzNy40MTMwMzQxOTQsIDM0LjcwMDcxMzgzMyBdLCBbIDEzNy40MTMwNTMzMDYsIDM0LjcwMDcxMjY5NCBdLCBbIDEzNy40MTMyNTgsIDM0LjcwMDcyODA1NiBdLCBbIDEzNy40MTMyNTU0NDM5OTk5ODYsIDM0LjcwMDc0OTcyMiBdLCBbIDEzNy40MTMxNzc3MjIsIDM0LjcwMDc0MjkxNyBdLCBbIDEzNy40MTMxNTI2MTA5OTk5ODcsIDM0LjcwMDc0MTk3MiBdLCBbIDEzNy40MTMxMjU1MjgsIDM0LjcwMDc0MzY2NyBdLCBbIDEzNy40MTMxMDA3NzgsIDM0LjcwMDc0NzA1NiBdLCBbIDEzNy40MTMwNzk1LCAzNC43MDA3NTI1IF0sIFsgMTM3LjQxMzA1ODU1NjAwMDAxLCAzNC43MDA3NTU4ODkgXSwgWyAxMzcuNDEzMDM3MTk0LCAzNC43MDA3NjQ4MzMgXSwgWyAxMzcuNDEzMDE3MjUsIDM0LjcwMDc3Njg4OSBdLCBbIDEzNy40MTMwMDAxMzksIDM0LjcwMDc4NzcyMiBdLCBbIDEzNy40MTI5ODUzMzMsIDM0LjcwMDc5Nzg2MSBdLCBbIDEzNy40MTI5NzA1LCAzNC43MDA4MDYzNjEgXSBdLCBbIFsgMTM3LjQxNTEyNTE2NzAwMDAxNCwgMzQuNzAxOTM1NTU2IF0sIFsgMTM3LjQxNTA5NjYxMSwgMzQuNzAxOTQ4Njk0IF0sIFsgMTM3LjQxNDg1NjI1MDAwMDAxNCwgMzQuNzAxODQyMTY3IF0sIFsgMTM3LjQxNDgzNjg2MSwgMzQuNzAxODIxMTk0IF0sIFsgMTM3LjQxNDgyMjk0NCwgMzQuNzAxNzk5OTQ0IF0sIFsgMTM3LjQxNDgzNDMwNTk5OTk4OSwgMzQuNzAxNzY4NDcyIF0sIFsgMTM3LjQxNDk3NzYzOSwgMzQuNzAxNzAwNTU2IF0sIFsgMTM3LjQxNTA4OTU4MywgMzQuNzAxNjQ3NSBdLCBbIDEzNy40MTUxMjM2OTM5OTk5ODgsIDM0LjcwMTY2MTEzOSBdLCBbIDEzNy40MTUxMjQ0NzIsIDM0LjcwMTcwMDI1IF0sIFsgMTM3LjQxNTEyODA4MzAwMDAxMywgMzQuNzAxODg3NSBdLCBbIDEzNy40MTUxMjY0MTcwMDAwMSwgMzQuNzAxOTE2NjExIF0sIFsgMTM3LjQxNTEyNTE2NzAwMDAxNCwgMzQuNzAxOTM1NTU2IF0gXSwgWyBbIDEzNy40MDY1NTk3MjIsIDM0LjcwMjcyMzYxMSBdLCBbIDEzNy40MDY1ODQ1MjgsIDM0LjcwMjczMDg2MSBdLCBbIDEzNy40MDY1OTk4MDYsIDM0LjcwMjc2MjI3OCBdLCBbIDEzNy40MDY1ODc2MTEsIDM0LjcwMjc4MTA1NiBdLCBbIDEzNy40MDY1NzEzODksIDM0LjcwMjc5MTM2MSBdLCBbIDEzNy40MDY1NTE2NjcsIDM0LjcwMjgwMjMwNiBdLCBbIDEzNy40MDY1MzgxNjcsIDM0LjcwMjgxNjMwNiBdLCBbIDEzNy40MDY1Mjk4MzMsIDM0LjcwMjgzODEzOSBdLCBbIDEzNy40MDY1NDc2MzksIDM0LjcwMjg1MDU1NiBdLCBbIDEzNy40MDY0NzAzMDU5OTk5ODksIDM0LjcwMjkwNDk3MiBdLCBbIDEzNy40MDY0MDE4MzMsIDM0LjcwMjg5NzcyMiBdLCBbIDEzNy40MDYyOTM1MjgsIDM0LjcwMjg4NjAyOCBdLCBbIDEzNy40MDYxODM1NTYsIDM0LjcwMjg3MzcyMiBdLCBbIDEzNy40MDYxMDgyMjIsIDM0LjcwMjg2NDg2MSBdLCBbIDEzNy40MDYxMDkwMjgsIDM0LjcwMjg0OTMzMyBdLCBbIDEzNy40MDYxMDg1NTYsIDM0LjcwMjgzNTcyMiBdLCBbIDEzNy40MDYxMDYxMzksIDM0LjcwMjgzMDY5NCBdLCBbIDEzNy40MDYwOTk0NzIsIDM0LjcwMjgyNjQ3MiBdLCBbIDEzNy40MDYwMDU4NTkzNzUsIDM0LjcwMjc4MDU1NjIxMzA5OSBdLCBbIDEzNy40MDU5ODU2NjcwMDAwMSwgMzQuNzAyNzcwNjExIF0sIFsgMTM3LjQwNTc5OTM4OSwgMzQuNzAyNzUwMTY3IF0sIFsgMTM3LjQwNTY0MDUyOCwgMzQuNzAyNzMzNTI4IF0sIFsgMTM3LjQwNTU0MDk0NCwgMzQuNzAyNzIzNzIyIF0sIFsgMTM3LjQwNTUzODEzODk5OTk4NywgMzQuNzAyNzM0IF0sIFsgMTM3LjQwNTM2OCwgMzQuNzAyNzE1NzUgXSwgWyAxMzcuNDA1MjE5MTY3MDAwMDEzLCAzNC43MDI3MDEgXSwgWyAxMzcuNDA1MjU4MDI4LCAzNC43MDI0MzI3MjIgXSwgWyAxMzcuNDA1Mjc1MDI4LCAzNC43MDI0MjE3NzggXSwgWyAxMzcuNDA1NDE5ODA2LCAzNC43MDI0MzY2MzkgXSwgWyAxMzcuNDA1NjM3NjY3LCAzNC43MDI0NTk1NTYgXSwgWyAxMzcuNDA1ODA0MTY3MDAwMDE0LCAzNC43MDI0NzU0NDQgXSwgWyAxMzcuNDA1OTY1NDQ0LCAzNC43MDI0OTEzNjEgXSwgWyAxMzcuNDA2MDA1ODU5Mzc1LCAzNC43MDI0OTU1NTg2MDIzMDEgXSwgWyAxMzcuNDA2MTgzNzIyLCAzNC43MDI1MTQxMTEgXSwgWyAxMzcuNDA2MzQ3MTk0LCAzNC43MDI1MzI0NDQgXSwgWyAxMzcuNDA2NTEwNDQ0LCAzNC43MDI1NDk4MDYgXSwgWyAxMzcuNDA2NjE5MDgzMDAwMDEsIDM0LjcwMjU2MDMwNiBdLCBbIDEzNy40MDY2NzU3NSwgMzQuNzAyNTY3MjIyIF0sIFsgMTM3LjQwNjY4MjQ0NDAwMDAxMiwgMzQuNzAyNTc4Mzg5IF0sIFsgMTM3LjQwNjY5MTMzMywgMzQuNzAyNTkxIF0sIFsgMTM3LjQwNjcwNTMzMywgMzQuNzAyNjA4MzYxIF0sIFsgMTM3LjQwNjcwNjU1NTk5OTk4OSwgMzQuNzAyNjA5ODA2IF0sIFsgMTM3LjQwNjU5Mjg4OSwgMzQuNzAyNjc5Mjc4IF0sIFsgMTM3LjQwNjU4MjgzMjk5OTk4NywgMzQuNzAyNjc2MjIyIF0sIFsgMTM3LjQwNjU1OTcyMiwgMzQuNzAyNzIzNjExIF0gXSwgWyBbIDEzNy40MDY0NTU5MTY5OTk5ODgsIDM0LjcwMTI0NjU4MyBdLCBbIDEzNy40MDYzODU5MTcsIDM0LjcwMTI0MDY2NyBdLCBbIDEzNy40MDYzMTksIDM0LjcwMTIzNDU4MyBdLCBbIDEzNy40MDYyOTUxOTQsIDM0LjcwMTIzMDY2NyBdLCBbIDEzNy40MDYyODQyNSwgMzQuNzAxMjI3NjM5IF0sIFsgMTM3LjQwNjMwOTYzOSwgMzQuNzAxMDU0MzA2IF0sIFsgMTM3LjQwNjU2MzYxMSwgMzQuNzAxMDgwMDI4IF0sIFsgMTM3LjQwNjU4Mzg4Njc1Mjk5OCwgMzQuNzAwOTc3NDE0NzIwMSBdLCBbIDEzNy40MDY1ODUwMjgsIDM0LjcwMDk3MTU1NiBdLCBbIDEzNy40MDY1ODYzMDYsIDM0LjcwMDk2NjUgXSwgWyAxMzcuNDA2NTg4Njk0LCAzNC43MDA5NjM3NzggXSwgWyAxMzcuNDA2NTkxNTU2LCAzNC43MDA5NjI2MTEgXSwgWyAxMzcuNDA2NTk3MzMzLCAzNC43MDA5NjI1ODMgXSwgWyAxMzcuNDA2NzYwOTA2NTMyMDE0LCAzNC43MDA5Nzc0MTQ3MjAxIF0sIFsgMTM3LjQwNjc4MDU1NiwgMzQuNzAwOTc5MTk0IF0sIFsgMTM3LjQwNjgxNTI3ODAwMDAxLCAzNC43MDA5ODM0NDQgXSwgWyAxMzcuNDA2ODM1MjUsIDM0LjcwMDk4NTkxNyBdLCBbIDEzNy40MDY4Mzg1MjgsIDM0LjcwMDk4NjQ3MiBdLCBbIDEzNy40MDY4MTU1MjgwMDAwMSwgMzQuNzAxMDc0NDE3IF0sIFsgMTM3LjQwNjgwMjM2MSwgMzQuNzAxMTI0OTE3IF0sIFsgMTM3LjQwNjc2NzExMSwgMzQuNzAxMjgzMTk0IF0sIFsgMTM3LjQwNjcwMzc3OCwgMzQuNzAxMzEzMjUgXSwgWyAxMzcuNDA2Njg5MjUsIDM0LjcwMTMwODQxNyBdLCBbIDEzNy40MDY2MzU1LCAzNC43MDEyODk3NzggXSwgWyAxMzcuNDA2NTkyLCAzNC43MDEyNzU2MTEgXSwgWyAxMzcuNDA2NTU1NTI4MDAwMDEzLCAzNC43MDEyNjU2NjcgXSwgWyAxMzcuNDA2NTIzNjExMDAwMDExLCAzNC43MDEyNTcyNzggXSwgWyAxMzcuNDA2NDk3MTk0LCAzNC43MDEyNTExOTQgXSwgWyAxMzcuNDA2NDU1OTE2OTk5OTg4LCAzNC43MDEyNDY1ODMgXSBdLCBbIFsgMTM3LjQxMDAzNjc3OCwgMzQuNzAyNDQ2ODA2IF0sIFsgMTM3LjQwOTUyMTkxNywgMzQuNzAyMzk0MTY3IF0sIFsgMTM3LjQwOTUwNTMzMywgMzQuNzAyMzkxNzc4IF0sIFsgMTM3LjQwOTQ5ODQ0NCwgMzQuNzAyMzkwMDgzIF0sIFsgMTM3LjQwOTQ5MjExMSwgMzQuNzAyMzg2MzA2IF0sIFsgMTM3LjQwOTQ4NTMzMywgMzQuNzAyMzgxIF0sIFsgMTM3LjQwOTQ4MDUsIDM0LjcwMjM3MjI3OCBdLCBbIDEzNy40MDk0NzY5NzIsIDM0LjcwMjM2MTA4MyBdLCBbIDEzNy40MDk0NzcyNSwgMzQuNzAyMzQ4OTE3IF0sIFsgMTM3LjQwOTQ3OTM4OTAwMDAxMiwgMzQuNzAyMzI2NjM5IF0sIFsgMTM3LjQwOTUwMjI1LCAzNC43MDIxNjI0NDQgXSwgWyAxMzcuNDA5NTEwNDM2NzMzMDAxLCAzNC43MDIxMDY0MzY3MDU1OTggXSwgWyAxMzcuNDA5NTE2MTY3LCAzNC43MDIwNjczODkgXSwgWyAxMzcuNDA5NTM5OTE2OTk5OTg5LCAzNC43MDIwNTIxMTEgXSwgWyAxMzcuNDA5NzE4MjUsIDM0LjcwMjA3MTU4MyBdLCBbIDEzNy40MDk5MDQwODI5OTk5ODYsIDM0LjcwMjA5MTY2NyBdLCBbIDEzNy40MTAwNDk2OTMzMzQ5OTcsIDM0LjcwMjEwNjQzNjcwNTU5OCBdLCBbIDEzNy40MTAwNzU4MzMsIDM0LjcwMjEwOTA4MyBdLCBbIDEzNy40MTAxMjU3MzI0MjE5ODksIDM0LjcwMjExNDIwNTU0MzkgXSwgWyAxMzcuNDEwMjU2LCAzNC43MDIxMjc1ODMgXSwgWyAxMzcuNDEwNjAzMjUsIDM0LjcwMjE2MDMzMyBdLCBbIDEzNy40MTA2MzY0NDQsIDM0LjcwMjE2MzYxMSBdLCBbIDEzNy40MTA2NTM2OTQsIDM0LjcwMjE2NTU1NiBdLCBbIDEzNy40MTA2NjM0MTcsIDM0LjcwMjE2NzMzMyBdLCBbIDEzNy40MTA2NzUzMDYsIDM0LjcwMjE3MjcyMiBdLCBbIDEzNy40MTA2OTAwODMsIDM0LjcwMjE4Mjk3MiBdLCBbIDEzNy40MTA1NTA3NSwgMzQuNzAyNDk5MTM5IF0sIFsgMTM3LjQxMDQxNzA4MywgMzQuNzAyNDg0NTI4IF0sIFsgMTM3LjQxMDMxMTcyMTk5OTk4OSwgMzQuNzAyNDczODMzIF0sIFsgMTM3LjQxMDEyNTczMjQyMTk4OSwgMzQuNzAyNDU1NTQ3MTE0Mjk3IF0sIFsgMTM3LjQxMDAzNjc3OCwgMzQuNzAyNDQ2ODA2IF0gXSwgWyBbIDEzNy40MDgxNTUzNjEwMDAwMTMsIDM0LjcwMTk0Mjk3MiBdLCBbIDEzNy40MDgxNjMzMDYsIDM0LjcwMTg5ODA4MyBdLCBbIDEzNy40MDgxNjY1NTYsIDM0LjcwMTg4ODYxMSBdLCBbIDEzNy40MDgxNzI2Mzg5OTk5ODYsIDM0LjcwMTg4MDc1IF0sIFsgMTM3LjQwODE4MTAyOCwgMzQuNzAxODczMDU2IF0sIFsgMTM3LjQwODE5MjI1MDAwMDAxMywgMzQuNzAxODY3IF0sIFsgMTM3LjQwODIwNDgwNTk5OTk4NiwgMzQuNzAxODY1IF0sIFsgMTM3LjQwODIxNDMwNiwgMzQuNzAxODY2ODYxIF0sIFsgMTM3LjQwODMzMzMzMywgMzQuNzAxODc5NDcyIF0sIFsgMTM3LjQwODM2NzM4OSwgMzQuNzAxODgzMDU2IF0sIFsgMTM3LjQwODUzMzkxNywgMzQuNzAxOTAwMzA2IF0sIFsgMTM3LjQwODczMDQ0NDAwMDAxNCwgMzQuNzAxOTIwMDI4IF0sIFsgMTM3LjQwODc1MjQ0MTQwNTk5NCwgMzQuNzAxOTIyMzE0OTk0Njk3IF0sIFsgMTM3LjQwODkyOTk0NCwgMzQuNzAxOTQwODA2IF0sIFsgMTM3LjQwODk2NzE2Njk5OTk4NiwgMzQuNzAxOTQ0MDgzIF0sIFsgMTM3LjQwOTA2MTk0NCwgMzQuNzAxOTUzNDQ0IF0sIFsgMTM3LjQwOTE1NTMwNiwgMzQuNzAxOTYyNzIyIF0sIFsgMTM3LjQwOTI0MDY5NCwgMzQuNzAxOTcwNzUgXSwgWyAxMzcuNDA5Mjg3NjY3LCAzNC43MDE5NzY2OTQgXSwgWyAxMzcuNDA5MzA1NDQ0MDAwMDEyLCAzNC43MDE5ODA3MjIgXSwgWyAxMzcuNDA5MzIyMDU2LCAzNC43MDE5ODU3NSBdLCBbIDEzNy40MDkzNTMyMjIsIDM0LjcwMTk5OTU1NiBdLCBbIDEzNy40MDkzODMyNzgsIDM0LjcwMjAxNjM2MSBdLCBbIDEzNy40MDk0MzY2MzksIDM0LjcwMjA0ODM2MSBdLCBbIDEzNy40MDk0NSwgMzQuNzAyMDYwNzUgXSwgWyAxMzcuNDA5NDU1MzYxLCAzNC43MDIwNjg3NzggXSwgWyAxMzcuNDA5NDU3OTE3LCAzNC43MDIwNzk3NzggXSwgWyAxMzcuNDA5NDU1NTU2MDAwMDEyLCAzNC43MDIwOTY2MzkgXSwgWyAxMzcuNDA5NDUzOTczODIwMDA3LCAzNC43MDIxMDY0MzY3MDU1OTggXSwgWyAxMzcuNDA5NDQ1Mjc4LCAzNC43MDIxNjI1NTYgXSwgWyAxMzcuNDA5NDI2ODYwOTk5OTg2LCAzNC43MDIyODU0NzIgXSwgWyAxMzcuNDA5NDIwMTk0LCAzNC43MDIzMjQ1MjggXSwgWyAxMzcuNDA5NDE1Nzc4MDAwMDEsIDM0LjcwMjM0MTY2NyBdLCBbIDEzNy40MDk0MDkyNzgsIDM0LjcwMjM1NDM4OSBdLCBbIDEzNy40MDkzOTkwNTYwMDAwMTIsIDM0LjcwMjM2NzE5NCBdLCBbIDEzNy40MDkzODgzNjEsIDM0LjcwMjM3NDgwNiBdLCBbIDEzNy40MDkzNzY5MTcsIDM0LjcwMjM3OTY5NCBdLCBbIDEzNy40MDkzNjE3NDk5OTk5ODgsIDM0LjcwMjM4MDUyOCBdLCBbIDEzNy40MDkyOTUxMzksIDM0LjcwMjM3NDg4OSBdLCBbIDEzNy40MDkxODU1MjgsIDM0LjcwMjM2MzExMSBdLCBbIDEzNy40MDg4NTEzODksIDM0LjcwMjMzMTY5NCBdLCBbIDEzNy40MDg3NTI0NDE0MDU5OTQsIDM0LjcwMjMyMTQ5OTc1MzE5NyBdLCBbIDEzNy40MDg0ODQxNjcwMDAwMTIsIDM0LjcwMjI5MzgzMyBdLCBbIDEzNy40MDgzMzMzMzMsIDM0LjcwMjI3ODY5NCBdLCBbIDEzNy40MDgyMTU0NDQsIDM0LjcwMjI2Njg2MSBdLCBbIDEzNy40MDgxMzA2MzksIDM0LjcwMjI2MTgwNiBdLCBbIDEzNy40MDgxMjI2MzksIDM0LjcwMjI1OTMwNiBdLCBbIDEzNy40MDgxMTU1MjgsIDM0LjcwMjI1MzcyMiBdLCBbIDEzNy40MDgxMTAyNzgsIDM0LjcwMjI0NzA1NiBdLCBbIDEzNy40MDgxMDU3NzgsIDM0LjcwMjIzODk0NCBdLCBbIDEzNy40MDgxMDM5MTcsIDM0LjcwMjIzMTc1IF0sIFsgMTM3LjQwODEwMzk3MiwgMzQuNzAyMjIxMDI4IF0sIFsgMTM3LjQwODExMDY5Mzk5OTk4NywgMzQuNzAyMTY1MTk0IF0sIFsgMTM3LjQwODEyMzAzMjgwMjk5LCAzNC43MDIxMDY0MzY3MDU1OTggXSwgWyAxMzcuNDA4MTM4NTgzMDAwMDEsIDM0LjcwMjAzMjM2MSBdLCBbIDEzNy40MDgxNTUzNjEwMDAwMTMsIDM0LjcwMTk0Mjk3MiBdIF0sIFsgWyAxMzcuNDExNTEzNzIyLCAzNC43MDAyMjUxMTEgXSwgWyAxMzcuNDExNTMyMDU2LCAzNC43MDAyMjUxNjcgXSwgWyAxMzcuNDExNTQ5MTY3LCAzNC43MDAyNTg4NjEgXSwgWyAxMzcuNDExNDk5MDIzNDM2OTg4LCAzNC43MDA2MTY4ODkwNjE4OTggXSwgWyAxMzcuNDExNDk3NTU2LCAzNC43MDA2MjczMDYgXSwgWyAxMzcuNDExNDY0ODMzLCAzNC43MDA2NDQ2MTEgXSwgWyAxMzcuNDEwOTUxMzMzMDAwMDE0LCAzNC43MDA1OTYwNTYgXSwgWyAxMzcuNDEwOTMzNzc3OTk5OTg2LCAzNC43MDA1NjgyMjIgXSwgWyAxMzcuNDEwOTU4NzUsIDM0LjcwMDM3MzA4MyBdLCBbIDEzNy40MTEzODc0NzIsIDM0LjcwMDI0NjE5NCBdLCBbIDEzNy40MTE0MjY5NzE5OTk5ODcsIDM0LjcwMDIzNjExMSBdLCBbIDEzNy40MTE0NjA2NjcsIDM0LjcwMDIyOTQ3MiBdLCBbIDEzNy40MTE0OTIsIDM0LjcwMDIyNjg2MSBdLCBbIDEzNy40MTE0OTkwMjM0MzY5ODgsIDM0LjcwMDIyNjQ5ODM0NzU5NyBdLCBbIDEzNy40MTE1MTM3MjIsIDM0LjcwMDIyNTExMSBdIF0sIFsgWyAxMzcuNDEyNDM1MzA2LCAzNC43MDIxMzI1IF0sIFsgMTM3LjQxMjQ0NDA4MywgMzQuNzAyMTQ4OTcyIF0sIFsgMTM3LjQxMjM2MzcyMiwgMzQuNzAyMjg5NDE3IF0sIFsgMTM3LjQxMjM1NjY2NzAwMDAxMiwgMzQuNzAyMzAxODMzIF0sIFsgMTM3LjQxMjMwOTQ0Mzk5OTk4NywgMzQuNzAyMzg1IF0sIFsgMTM3LjQxMjMwMjY2NywgMzQuNzAyMzk2ODg5IF0sIFsgMTM3LjQxMjI2NDMzMywgMzQuNzAyNDY0MTM5IF0sIFsgMTM3LjQxMjIzNDI1MDAwMDAxMiwgMzQuNzAyNDc0NzUgXSwgWyAxMzcuNDExODQ5OTE3MDAwMDEyLCAzNC43MDIzNjc4ODkgXSwgWyAxMzcuNDExODM0NDQ0LCAzNC43MDIzNDQxMTEgXSwgWyAxMzcuNDExOTExMzM5NTQ0OTg2LCAzNC43MDIxMDY0MzY3MDU1OTggXSwgWyAxMzcuNDExOTM5MTY3MDAwMDE0LCAzNC43MDIwMjA0NDQgXSwgWyAxMzcuNDExOTU4MjIyMDAwMDEsIDM0LjcwMjAxMTU1NiBdLCBbIDEzNy40MTIwNDMyMjIsIDM0LjcwMjAzMjEzOSBdLCBbIDEzNy40MTIzMzM0NjMwMDk5ODYsIDM0LjcwMjEwNjQzNjcwNTU5OCBdLCBbIDEzNy40MTI0MzUzMDYsIDM0LjcwMjEzMjUgXSBdLCBbIFsgMTM3LjQxMTYyNywgMzQuNzAxMTQ3ODYxIF0sIFsgMTM3LjQxMTYxMzA1NiwgMzQuNzAxMTU4MzMzIF0sIFsgMTM3LjQxMTU5NzA1NiwgMzQuNzAxMTY4MDI4IF0sIFsgMTM3LjQxMTU4MjIyMiwgMzQuNzAxMTczNzIyIF0sIFsgMTM3LjQxMTU1ODk3MiwgMzQuNzAxMTc3Mzg5IF0sIFsgMTM3LjQxMTU0MDQxNywgMzQuNzAxMTc1MDgzIF0sIFsgMTM3LjQxMTUyODk0NCwgMzQuNzAxMTY4NDE3IF0sIFsgMTM3LjQxMTUxODIyMjAwMDAxMiwgMzQuNzAxMTY0NDcyIF0sIFsgMTM3LjQxMTUwMDc0OTk5OTk4OCwgMzQuNzAxMTYzMzYxIF0sIFsgMTM3LjQxMTQ5OTAyMzQzNjk4OCwgMzQuNzAxMTYzNjY1Mzc1MTk4IF0sIFsgMTM3LjQxMTQ0MjE2NywgMzQuNzAxMTcyOTQ0IF0sIFsgMTM3LjQxMTQwNzQ3MiwgMzQuNzAxMTc2NTI4IF0sIFsgMTM3LjQxMTM3MDAyOCwgMzQuNzAxMTgxNzIyIF0sIFsgMTM3LjQxMTMzMDE5Mzk5OTk4NywgMzQuNzAxMTgxNTI4IF0sIFsgMTM3LjQxMTMwODY5NDAwMDAxMywgMzQuNzAxMTgwOTQ0IF0sIFsgMTM3LjQxMTI4ODI3OCwgMzQuNzAxMTc3NzUgXSwgWyAxMzcuNDExMjc1NDk5OTk5OTg4LCAzNC43MDExNzU0MTcgXSwgWyAxMzcuNDExMjYzNDcyLCAzNC43MDExNjc3NzggXSwgWyAxMzcuNDExMzQ2MzA2MDAwMDEzLCAzNC43MDExMjg1ODMgXSwgWyAxMzcuNDExMzU5NDQ0LCAzNC43MDEwNjU2MzkgXSwgWyAxMzcuNDExNDk5MDIzNDM2OTg4LCAzNC43MDEwMDIxOTc3MjkxMDMgXSwgWyAxMzcuNDExNTUzNTUyMzE1MDEzLCAzNC43MDA5Nzc0MTQ3MjAxIF0sIFsgMTM3LjQxMTcxMTY2NywgMzQuNzAwOTA1NTU2IF0sIFsgMTM3LjQxMTcxMDI3Nzk5OTk4NywgMzQuNzAwOTE5MTY3IF0sIFsgMTM3LjQxMTcwOTQ0NCwgMzQuNzAwOTMyOTQ0IF0sIFsgMTM3LjQxMTcxMTU1NiwgMzQuNzAwOTQ3MzYxIF0sIFsgMTM3LjQxMTcxNTUyOCwgMzQuNzAwOTU5NDQ0IF0sIFsgMTM3LjQxMTcxNzc1LCAzNC43MDA5NzI5NzIgXSwgWyAxMzcuNDExNzE3MTk0MDEzOTg4LCAzNC43MDA5Nzc0MTQ3MjAxIF0sIFsgMTM3LjQxMTcxNTA1NiwgMzQuNzAwOTg2NSBdLCBbIDEzNy40MTE3MDc1NTYwMDAwMSwgMzQuNzAwOTk4NSBdLCBbIDEzNy40MTE3MDIzNjEwMDAwMSwgMzQuNzAxMDA4NSBdLCBbIDEzNy40MTE2OTM1MjgsIDM0LjcwMTAxNDY2NyBdLCBbIDEzNy40MTE2ODM4MzMwMDAwMTIsIDM0LjcwMTAyNDg2MSBdLCBbIDEzNy40MTE2NzMwODMwMDAwMTEsIDM0LjcwMTAzNTE2NyBdLCBbIDEzNy40MTE2NTc4NjEsIDM0LjcwMTA1NzAyOCBdLCBbIDEzNy40MTE2NDM2MzksIDM0LjcwMTA4MjcyMiBdLCBbIDEzNy40MTE2Mzg4NjEsIDM0LjcwMTA5OTMzMyBdLCBbIDEzNy40MTE2Mzc2MTEsIDM0LjcwMTExODQ0NCBdLCBbIDEzNy40MTE2MzQ4MzMsIDM0LjcwMTEzNjM4OSBdLCBbIDEzNy40MTE2MjcsIDM0LjcwMTE0Nzg2MSBdIF0sIFsgWyAxMzcuNDExOTc2NTU2MDAwMDEzLCAzNC43MDA4NjAwMjggXSwgWyAxMzcuNDEyMDExMjc4LCAzNC43MDA4NjU0NDQgXSwgWyAxMzcuNDEyMDMzMjUsIDM0LjcwMDg3MSBdLCBbIDEzNy40MTE5NTM1MjgsIDM0LjcwMDkzNTA4MyBdLCBbIDEzNy40MTE5MDc0NDYxNzQwMTMsIDM0LjcwMDk3NzQxNDcyMDEgXSwgWyAxMzcuNDExOTAyOTE3LCAzNC43MDA5ODE1MjggXSwgWyAxMzcuNDExODkxMzg5LCAzNC43MDEwMDI0NDQgXSwgWyAxMzcuNDExODA3NjY3LCAzNC43MDExNDYyMjIgXSwgWyAxMzcuNDExNzYzNjY3LCAzNC43MDEyMjI0MTcgXSwgWyAxMzcuNDExNzE4Njk0LCAzNC43MDEyOTAzODkgXSwgWyAxMzcuNDExNjY2MjIyLCAzNC43MDEzNzg4MzMgXSwgWyAxMzcuNDExNjUwMjIyLCAzNC43MDEzOTU3MjIgXSwgWyAxMzcuNDExNjI5MjIxOTk5OTg4LCAzNC43MDE0MTQ5NzIgXSwgWyAxMzcuNDExNTk1NjM5MDAwMDEyLCAzNC43MDE0MjY5NDQgXSwgWyAxMzcuNDExNTY3Nzc4LCAzNC43MDE0MjE0MTcgXSwgWyAxMzcuNDExNTUzNDQ0LCAzNC43MDE0MDY0NzIgXSwgWyAxMzcuNDExNTQwOTQ0LCAzNC43MDEzOTI0NDQgXSwgWyAxMzcuNDExNTM3MzA2MDAwMDE0LCAzNC43MDEzNzk3MjIgXSwgWyAxMzcuNDExNTM2ODMzMDAwMDE0LCAzNC43MDEzNjE3NzggXSwgWyAxMzcuNDExNTM5NTI4LCAzNC43MDEzNTA3NzggXSwgWyAxMzcuNDExNTQ3NDcyLCAzNC43MDEzNDM2MzkgXSwgWyAxMzcuNDExNTYyNDE3LCAzNC43MDEzMzkwMjggXSwgWyAxMzcuNDExNTgyMjUsIDM0LjcwMTMzNDQ3MiBdLCBbIDEzNy40MTE1OTI5NDQsIDM0LjcwMTMyODMzMyBdLCBbIDEzNy40MTE2MTcwODMwMDAwMSwgMzQuNzAxMjk5MzMzIF0sIFsgMTM3LjQxMTYyMDY2NywgMzQuNzAxMjg4MjUgXSwgWyAxMzcuNDExNjE5ODYxLCAzNC43MDEyNzU4MDYgXSwgWyAxMzcuNDExNjE2NzUsIDM0LjcwMTI2MTE5NCBdLCBbIDEzNy40MTE2MDEyNSwgMzQuNzAxMjIxNjY3IF0sIFsgMTM3LjQxMTYwMDU1NiwgMzQuNzAxMjEzMDgzIF0sIFsgMTM3LjQxMTYwODMwNiwgMzQuNzAxMjA1Nzc4IF0sIFsgMTM3LjQxMTYyNDA4MywgMzQuNzAxMTk0NjY3IF0sIFsgMTM3LjQxMTY1MDExMSwgMzQuNzAxMTczMjIyIF0sIFsgMTM3LjQxMTY2ODE2Njk5OTk4OCwgMzQuNzAxMTQ5NSBdLCBbIDEzNy40MTE2NzUsIDM0LjcwMTEzMzE2NyBdLCBbIDEzNy40MTE2NzQzODkwMDAwMTIsIDM0LjcwMTExMjE2NyBdLCBbIDEzNy40MTE2NzY5NDQsIDM0LjcwMTA5MDYxMSBdLCBbIDEzNy40MTE2ODY5MTcsIDM0LjcwMTA2NDQ0NCBdLCBbIDEzNy40MTE3MDMyMjIsIDM0LjcwMTA0NjgzMyBdLCBbIDEzNy40MTE3MjMyNzgwMDAwMTEsIDM0LjcwMTAzMzM2MSBdLCBbIDEzNy40MTE3MzI4NjEsIDM0LjcwMTAyNDg2MSBdLCBbIDEzNy40MTE3NDQ3MjIsIDM0LjcwMTAxMjExMSBdLCBbIDEzNy40MTE3NTIzMDYwMDAwMTEsIDM0LjcwMDk5NTYxMSBdLCBbIDEzNy40MTE3NTE5NDQsIDM0LjcwMDk3OTQ3MiBdLCBbIDEzNy40MTE3NTE3MzY1MjIwMDcsIDM0LjcwMDk3NzQxNDcyMDEgXSwgWyAxMzcuNDExNzQ4MDI4LCAzNC43MDA5NTE4ODkgXSwgWyAxMzcuNDExNzQ1ODA2LCAzNC43MDA5MzU3NzggXSwgWyAxMzcuNDExNzQ2ODMzLCAzNC43MDA5MTgyNzggXSwgWyAxMzcuNDExNzUwMDU1OTk5OTg4LCAzNC43MDA5MDAxMzkgXSwgWyAxMzcuNDExNzU1MTY3LCAzNC43MDA4OTI4MzMgXSwgWyAxMzcuNDExNzcxNDE3MDAwMDExLCAzNC43MDA4ODQyMjIgXSwgWyAxMzcuNDExNzk2NTgzMDAwMDEyLCAzNC43MDA4NzMgXSwgWyAxMzcuNDExODI5LCAzNC43MDA4NjM5MTcgXSwgWyAxMzcuNDExODY1MTExLCAzNC43MDA4NTg5NzIgXSwgWyAxMzcuNDExOTAzMTk0LCAzNC43MDA4NTgxOTQgXSwgWyAxMzcuNDExOTQ3MTk0LCAzNC43MDA4NTg3MjIgXSwgWyAxMzcuNDExOTc2NTU2MDAwMDEzLCAzNC43MDA4NjAwMjggXSBdLCBbIFsgMTM3LjQxMjg4NzAyOCwgMzQuNzAwMzM0NTgzIF0sIFsgMTM3LjQxMjg3MjMxNDQ1MzAxMSwgMzQuNzAwMzQ2OTgwNTY2MzAyIF0sIFsgMTM3LjQxMjgyMTM2MSwgMzQuNzAwMzg5ODA2IF0sIFsgMTM3LjQxMjgyMTA4MzAwMDAxMSwgMzQuNzAwMzkwMDI4IF0sIFsgMTM3LjQxMjgxOSwgMzQuNzAwMzY2MDgzIF0sIFsgMTM3LjQxMjgzNTA4MywgMzQuNzAwMTU0Mzg5IF0sIFsgMTM3LjQxMjg3MjMxNDQ1MzAxMSwgMzQuNzAwMTc2MzgwNzE3OTk4IF0sIFsgMTM3LjQxMjkzNTAyOCwgMzQuNzAwMjEzMzMzIF0sIFsgMTM3LjQxMjg4NDk3MiwgMzQuNzAwMjc1MDgzIF0sIFsgMTM3LjQxMjg3OTg4OTAwMDAxLCAzNC43MDAyOTA3NzggXSwgWyAxMzcuNDEyODgwOTE3LCAzNC43MDAzMDE2OTQgXSwgWyAxMzcuNDEyODg1MTExLCAzNC43MDAzMTg3MjIgXSwgWyAxMzcuNDEyODg3MDI4LCAzNC43MDAzMzQ1ODMgXSBdLCBbIFsgMTM3LjQxNDEwNDMwNjAwMDAxMywgMzQuNzAwOTExODA2IF0sIFsgMTM3LjQxNDI0NTYwNTQ2OTAwNiwgMzQuNzAwNjkxNzMyNjQzMyBdLCBbIDEzNy40MTQzNzg0NDQsIDM0LjcwMDQ4NDgzMyBdLCBbIDEzNy40MTQzODM2NjcwMDAwMSwgMzQuNzAwNDc1ODg5IF0sIFsgMTM3LjQxNDM2NjYxMSwgMzQuNzAwNTgyODMzIF0sIFsgMTM3LjQxNDMzOTI3OCwgMzQuNzAwNzEzODg5IF0sIFsgMTM3LjQxNDMxNTA1NiwgMzQuNzAwODIwOTQ0IF0sIFsgMTM3LjQxNDI3ODUyODAwMDAxMSwgMzQuNzAwOTQ0ODg5IF0sIFsgMTM3LjQxNDI0NTYwNTQ2OTAwNiwgMzQuNzAwOTU2MTU2MDU3MDAzIF0sIFsgMTM3LjQxNDIyNDExMTAwMDAxLCAzNC43MDA5NjMzODkgXSwgWyAxMzcuNDE0MTA0MzA2MDAwMDEzLCAzNC43MDA5MTE4MDYgXSBdLCBbIFsgMTM3LjQwNTY3NzU1NiwgMzQuNzAzMTI3NDE3IF0sIFsgMTM3LjQwNTY2NCwgMzQuNzAzMjMzNjM5IF0sIFsgMTM3LjQwNTI4MzgwNiwgMzQuNzAzMTk4OTQ0IF0sIFsgMTM3LjQwNDg3OTI1LCAzNC43MDMxNjA5NzIgXSwgWyAxMzcuNDA0NjMyNTY4MzU5MDA2LCAzNC43MDMxMzcyMzkzNzI1MDIgXSwgWyAxMzcuNDA0NDg3MjQ5OTk5OTg4LCAzNC43MDMxMjMyNSBdLCBbIDEzNy40MDQ0MjE3NTAwMDAwMTIsIDM0LjcwMzExNjMzMyBdLCBbIDEzNy40MDQ0MzEwMjgsIDM0LjcwMzAzODE2NyBdLCBbIDEzNy40MDQ0NDE2NjY5OTk5ODYsIDM0LjcwMjk0NDAyOCBdLCBbIDEzNy40MDQzOTE5NzIwMDAwMTMsIDM0LjcwMjk0MDI1IF0sIFsgMTM3LjQwNDM3ODgzMzAwMDAxLCAzNC43MDMwMzggXSwgWyAxMzcuNDA0MzY4ODg5MDAwMDExLCAzNC43MDMxMTA3NzggXSwgWyAxMzcuNDA0MTAxNjk0LCAzNC43MDMwODIzNjEgXSwgWyAxMzcuNDAzODc2NDQ0LCAzNC43MDMwNjI3NzggXSwgWyAxMzcuNDAzODUxMjc4LCAzNC43MDMwMzg4MzMgXSwgWyAxMzcuNDAzODQ4OTcyLCAzNC43MDMwMzUyNSBdLCBbIDEzNy40MDM4MzQzNjEsIDM0LjcwMzAwNDM2MSBdLCBbIDEzNy40MDM4NTkzMzMwMDAwMTQsIDM0LjcwMjg0MDk0NCBdLCBbIDEzNy40MDM4NjA0NDQsIDM0LjcwMjgxNzMzMyBdLCBbIDEzNy40MDM4NjIxMzkwMDAwMTIsIDM0LjcwMjc5OTM4OSBdLCBbIDEzNy40MDM4Njc5MTcwMDAwMTQsIDM0LjcwMjc1NzgwNiBdLCBbIDEzNy40MDM4NzkxNjcwMDAwMTQsIDM0LjcwMjY3NjM4OSBdLCBbIDEzNy40MDM4ODA5NzIsIDM0LjcwMjY2NTM4OSBdLCBbIDEzNy40MDM4ODMzNjEsIDM0LjcwMjY1ODgwNiBdLCBbIDEzNy40MDM4ODcxNjcsIDM0LjcwMjY1MjgzMyBdLCBbIDEzNy40MDM4OTM5MTcsIDM0LjcwMjY0Nzc3OCBdLCBbIDEzNy40MDM5MDIzMDYsIDM0LjcwMjY0Mzk3MiBdLCBbIDEzNy40MDM5MTI3NzgsIDM0LjcwMjY0MTY5NCBdLCBbIDEzNy40MDM5Mjg5NDQsIDM0LjcwMjY0MjkxNyBdLCBbIDEzNy40MDQwOTkxNjcsIDM0LjcwMjY2MDE2NyBdLCBbIDEzNy40MDQyNjAyNSwgMzQuNzAyNjc4ODg5IF0sIFsgMTM3LjQwNDM5NDMzMywgMzQuNzAyNjk2MTk0IF0sIFsgMTM3LjQwNDQwMzE5NCwgMzQuNzAyNjk4NjExIF0sIFsgMTM3LjQwNDQxMTk0NCwgMzQuNzAyNzAwODYxIF0sIFsgMTM3LjQwNDQxNjg2MDk5OTk4NywgMzQuNzAyNzA0MDgzIF0sIFsgMTM3LjQwNDQxOTE2Njk5OTk4NiwgMzQuNzAyNzA4MTM5IF0sIFsgMTM3LjQwNDQyMDgwNiwgMzQuNzAyNzE0ODg5IF0sIFsgMTM3LjQwNDQyMDk0NCwgMzQuNzAyNzIyMTExIF0sIFsgMTM3LjQwNDQxODkxNjk5OTk4NywgMzQuNzAyNzM4MTY3IF0sIFsgMTM3LjQwNDQxNDg2MSwgMzQuNzAyNzY4NDcyIF0sIFsgMTM3LjQwNDQwNjUsIDM0LjcwMjgyNjM2MSBdLCBbIDEzNy40MDQ0NjI0MTcsIDM0LjcwMjgyOTM4OSBdLCBbIDEzNy40MDQ0NzU3NzgsIDM0LjcwMjczNDg4OSBdLCBbIDEzNy40MDQ2MzI1NjgzNTkwMDYsIDM0LjcwMjc1Mjk2NjY5OTg5NyBdLCBbIDEzNy40MDQ4OTc5NDQsIDM0LjcwMjc4MzU1NiBdLCBbIDEzNy40MDQ4ODk2OTQsIDM0LjcwMjg0MTU1NiBdLCBbIDEzNy40MDQ5MjQ1MjgsIDM0LjcwMjg0NTA4MyBdLCBbIDEzNy40MDQ5MDE4MzMsIDM0LjcwMjk5ODQ3MiBdLCBbIDEzNy40MDQ5NTc2MzksIDM0LjcwMzAwNjM4OSBdLCBbIDEzNy40MDQ5NjgxOTQsIDM0LjcwMjkyNzIyMiBdLCBbIDEzNy40MDUwOTI3NSwgMzQuNzAyODQzNzc4IF0sIFsgMTM3LjQwNTE5MjE5NCwgMzQuNzAyNzc1NSBdLCBbIDEzNy40MDUyMjA0MTcwMDAwMSwgMzQuNzAyNzU3MzMzIF0sIFsgMTM3LjQwNTIyNjQxNywgMzQuNzAyNzUzODg5IF0sIFsgMTM3LjQwNTIzMzQxNywgMzQuNzAyNzUyODA2IF0sIFsgMTM3LjQwNTI0MDE2Njk5OTk4OCwgMzQuNzAyNzUzMzMzIF0sIFsgMTM3LjQwNTI1MzI3OCwgMzQuNzAyNzU0NDcyIF0sIFsgMTM3LjQwNTM2NDYzOSwgMzQuNzAyNzY0ODg5IF0sIFsgMTM3LjQwNTQ1NTYxMSwgMzQuNzAyNzc2MTY3IF0sIFsgMTM3LjQwNTQ1NzM2MSwgMzQuNzAyNzc3MTM5IF0sIFsgMTM3LjQwNTQ1ODEzOSwgMzQuNzAyNzc4MTM5IF0sIFsgMTM3LjQwNTQ1ODc3OCwgMzQuNzAyNzc5ODYxIF0sIFsgMTM3LjQwNTQ0NzM4ODk5OTk4OCwgMzQuNzAyODc4Nzc4IF0sIFsgMTM3LjQwNTQ4OTIyMiwgMzQuNzAyODgxOTQ0IF0sIFsgMTM3LjQwNTUwMTUwMDAwMDAxNCwgMzQuNzAyNzkyMTExIF0sIFsgMTM3LjQwNTUwMzY2NywgMzQuNzAyNzg1MzYxIF0sIFsgMTM3LjQwNTUwNzY5NCwgMzQuNzAyNzgzMjc4IF0sIFsgMTM3LjQwNTUxMzA1NiwgMzQuNzAyNzgyNjM5IF0sIFsgMTM3LjQwNTU2NTM2MDk5OTk4NywgMzQuNzAyNzg4MjIyIF0sIFsgMTM3LjQwNTYzOTE2NywgMzQuNzAyNzk1OTE3IF0sIFsgMTM3LjQwNTY1MjkxNywgMzQuNzAyNzk4MzA2IF0sIFsgMTM3LjQwNTcxMjE5Mzk5OTk4OSwgMzQuNzAyODY4NjExIF0sIFsgMTM3LjQwNTcxMDE2NywgMzQuNzAyODg0NTU2IF0sIFsgMTM3LjQwNTY5MjgzMjk5OTk4OSwgMzQuNzAzMDExMzYxIF0sIFsgMTM3LjQwNTY3NzU1NiwgMzQuNzAzMTI3NDE3IF0gXSwgWyBbIDEzNy40MDYyNjI0MTcsIDM0LjcwMjkyNDQxNyBdLCBbIDEzNy40MDY0MDI1MDAwMDAwMTMsIDM0LjcwMjkzODgzMyBdLCBbIDEzNy40MDY1MTEwNTYsIDM0LjcwMjk1MDYxMSBdLCBbIDEzNy40MDY2MjA3NzgsIDM0LjcwMjk2MjAyOCBdLCBbIDEzNy40MDY3MDk3NzgsIDM0LjcwMjk3MTM4OSBdLCBbIDEzNy40MDY2Nzg3MzYyNTMxMjcsIDM0LjcwMzA2Mjg3ODM2NDYyNiBdLCBbIDEzNy40MDY0ODM4NTYzNDI3NiwgMzQuNzAzMTczMjQ3NTU0NTgxIF0sIFsgMTM3LjQwNjEzMTcyNjA1MDk3MiwgMzQuNzAzMTQzNDQ3MDM0MDk0IF0sIFsgMTM3LjQwNjEwOTUwMDQ3NDMxNSwgMzQuNzAzMjgwNDg2Mzg1OTUgXSwgWyAxMzcuNDA2MDE5MjIyLCAzNC43MDMyNzE2MTEgXSwgWyAxMzcuNDA2MDA1ODU5Mzc1LCAzNC43MDMyNzAxNTc2Nzg4MDEgXSwgWyAxMzcuNDA1NzEzOTE3MDAwMDE0LCAzNC43MDMyMzg0MTcgXSwgWyAxMzcuNDA1NzE0NDI5MzI5MDA5LCAzNC43MDMyMzU0NDMyODUxMDIgXSwgWyAxMzcuNDA1NzIwMzMzLCAzNC43MDMxOTgzNjEgXSwgWyAxMzcuNDA1NzMzMTY3LCAzNC43MDMxMDE0MTcgXSwgWyAxMzcuNDA1NzQ1NDcyLCAzNC43MDMwMTUzMDYgXSwgWyAxMzcuNDA1NzUyMjIyLCAzNC43MDI5Njk3NzggXSwgWyAxMzcuNDA1NzU0NTgzLCAzNC43MDI5NTQ0NDQgXSwgWyAxMzcuNDA1NzU3NjkzOTk5OTg4LCAzNC43MDI5NDMxNjcgXSwgWyAxMzcuNDA1NzYwODYxLCAzNC43MDI5MzY2NjcgXSwgWyAxMzcuNDA1NzY0Nzc4LCAzNC43MDI5MzExNjcgXSwgWyAxMzcuNDA1NzcwMjIyLCAzNC43MDI5MjYzNjEgXSwgWyAxMzcuNDA1Nzc3ODMzLCAzNC43MDI5MjE3NSBdLCBbIDEzNy40MDU3ODQ4MDYwMDAwMTQsIDM0LjcwMjkxOTUgXSwgWyAxMzcuNDA1NzkyNDQ0MDAwMDE0LCAzNC43MDI5MTg0NzIgXSwgWyAxMzcuNDA1ODAwOTcyLCAzNC43MDI5MTc4MzMgXSwgWyAxMzcuNDA1ODY0NDE3LCAzNC43MDI5MjI2NjcgXSwgWyAxMzcuNDA1ODc1NDQ0LCAzNC43MDI5MjQxOTQgXSwgWyAxMzcuNDA1ODgxNDQzOTk5OTg4LCAzNC43MDI5MjczMzMgXSwgWyAxMzcuNDA1ODg2Njk0LCAzNC43MDI5MzE4MzMgXSwgWyAxMzcuNDA1ODksIDM0LjcwMjkzODU4MyBdLCBbIDEzNy40MDU4OTIzMzMsIDM0LjcwMjk1ODQxNyBdLCBbIDEzNy40MDU5NDczNjA5OTk5ODgsIDM0LjcwMjk2MzI1IF0sIFsgMTM3LjQwNTk1NTg2MSwgMzQuNzAyODc3MTM5IF0sIFsgMTM3LjQwNTkxNjIyMiwgMzQuNzAyODczMjUgXSwgWyAxMzcuNDA1ODA0NDE3MDAwMDEzLCAzNC43MDI4NjE5NDQgXSwgWyAxMzcuNDA1NzczMjc4LCAzNC43MDI4NTg5NDQgXSwgWyAxMzcuNDA1NzY3MTY3LCAzNC43MDI4NTg1IF0sIFsgMTM3LjQwNTc2Mzg4OTAwMDAxMywgMzQuNzAyODU1MjUgXSwgWyAxMzcuNDA1NzYzMjIyLCAzNC43MDI4NTExOTQgXSwgWyAxMzcuNDA1NzYzNDE3LCAzNC43MDI4NDU0MTcgXSwgWyAxMzcuNDA1NzY0Mjc4LCAzNC43MDI4MzcyMjIgXSwgWyAxMzcuNDA1NzY2LCAzNC43MDI4MjU1IF0sIFsgMTM3LjQwNTc2OTM2MTAwMDAxMSwgMzQuNzAyODE5MzYxIF0sIFsgMTM3LjQwNTc3NDM2MSwgMzQuNzAyODE2ODMzIF0sIFsgMTM3LjQwNTc4MjY2NzAwMDAxMSwgMzQuNzAyODE1MzYxIF0sIFsgMTM3LjQwNTc5MDUyODAwMDAxMSwgMzQuNzAyODE1MDgzIF0sIFsgMTM3LjQwNTgwOTgzMywgMzQuNzAyODE2MzA2IF0sIFsgMTM3LjQwNTg5MzkxNjk5OTk4NiwgMzQuNzAyODIzMTY3IF0sIFsgMTM3LjQwNTk2ODcyMjAwMDAxMSwgMzQuNzAyODMwMDU2IF0sIFsgMTM3LjQwNTk3ODExMSwgMzQuNzAyODMxNDcyIF0sIFsgMTM3LjQwNTk4MzU4MywgMzQuNzAyODMzNzIyIF0sIFsgMTM3LjQwNTk4ODY5NCwgMzQuNzAyODM2NSBdLCBbIDEzNy40MDU5OTUxNjY5OTk5ODYsIDM0LjcwMjg0MTU1NiBdLCBbIDEzNy40MDU5OTk0NDQsIDM0LjcwMjg0NTY5NCBdLCBbIDEzNy40MDYwMDU4NTkzNzUsIDM0LjcwMjg1MjUxODc2MDQwMiBdLCBbIDEzNy40MDYwMjEyMjIsIDM0LjcwMjg2ODcyMiBdLCBbIDEzNy40MDYwMDkyNzgsIDM0LjcwMjk2NzcyMiBdLCBbIDEzNy40MDYwNTk4MDYsIDM0LjcwMzAwMTQ0NCBdLCBbIDEzNy40MDYwNzAzMDYsIDM0LjcwMjkzNDA4MyBdLCBbIDEzNy40MDYwNzIzMzMsIDM0LjcwMjkxOTQ3MiBdLCBbIDEzNy40MDYwNzM2MzksIDM0LjcwMjkxNTQxNyBdLCBbIDEzNy40MDYwNzU1ODI5OTk5ODksIDM0LjcwMjkxMDI3OCBdLCBbIDEzNy40MDYwNzkwODMsIDM0LjcwMjkwODI3OCBdLCBbIDEzNy40MDYwODM1NTYsIDM0LjcwMjkwNzE5NCBdLCBbIDEzNy40MDYwODk0NDQsIDM0LjcwMjkwNjM2MSBdLCBbIDEzNy40MDYxNjc5NDQsIDM0LjcwMjkxNDA1NiBdLCBbIDEzNy40MDYyNjI0MTcsIDM0LjcwMjkyNDQxNyBdIF0sIFsgWyAxMzcuNDA2NDI4MDgzLCAzNC42OTg0MDY1IF0sIFsgMTM3LjQwNjQ0Mzk0Mzk5OTk4OSwgMzQuNjk4NTM1Mzg5IF0sIFsgMTM3LjQwNjQ2MDgzMzAwMDAxMSwgMzQuNjk4NjcxODMzIF0sIFsgMTM3LjQwNjQ2NjY3OTkzMzAwNCwgMzQuNjk4NzE5MzI0NTMyMjk4IF0sIFsgMTM3LjQwNjQ5MzExMSwgMzQuNjk4OTMzNTgzIF0sIFsgMTM3LjQwNjUwNjgwNjAwMDAxLCAzNC42OTkwNjAwMjggXSwgWyAxMzcuNDA2NTI5MjIxOTk5OTg5LCAzNC42OTkyNjczMzMgXSwgWyAxMzcuNDA2NTQyMjUsIDM0LjY5OTM4NzMwNiBdLCBbIDEzNy40MDYyNjg4NjEsIDM0LjY5OTQwNzY2NyBdLCBbIDEzNy40MDYyNDY1NTYwMDAwMTMsIDM0LjY5OTM4OTY5NCBdLCBbIDEzNy40MDYyMzYxMTEsIDM0LjY5OTI5NjA1NiBdLCBbIDEzNy40MDYyMzA5NzIsIDM0LjY5OTI0OTg4OSBdLCBbIDEzNy40MDYyMjA3NDk5OTk5ODksIDM0LjY5OTE0Njc3OCBdLCBbIDEzNy40MDYyMTMxMzg5OTk5ODgsIDM0LjY5OTA4MjUyOCBdLCBbIDEzNy40MDYxNjk2MzQ5ODU5ODYsIDM0LjY5ODcxOTMyNDUzMjI5OCBdLCBbIDEzNy40MDYxNjY5NDQsIDM0LjY5ODY5Njg2MSBdLCBbIDEzNy40MDYxNTMxNjcwMDAwMTQsIDM0LjY5ODU4MTU4MyBdLCBbIDEzNy40MDYxNTc2NjcsIDM0LjY5ODU4MTE5NCBdLCBbIDEzNy40MDYxNDE3NDk5OTk5ODksIDM0LjY5ODQ0NDgzMyBdLCBbIDEzNy40MDYxNjY2OTQsIDM0LjY5ODQyNzY2NyBdLCBbIDEzNy40MDY0MjgwODMsIDM0LjY5ODQwNjUgXSBdLCBbIFsgMTM3LjQwNzg1ODUsIDM0LjcwNDEwMzYxMSBdLCBbIDEzNy40MDc3NTc0NDQsIDM0LjcwNDExNDcyMiBdLCBbIDEzNy40MDc3MDE3NSwgMzQuNzA0MTE0ODA2IF0sIFsgMTM3LjQwNzY3MDk3MiwgMzQuNzA0MTEzNDQ0IF0sIFsgMTM3LjQwNzYzNDk0NCwgMzQuNzA0MTExMDgzIF0sIFsgMTM3LjQwNzU5NzkxNywgMzQuNzA0MTA2OTE3IF0sIFsgMTM3LjQwNzU2NDgzMywgMzQuNzA0MTAwMDI4IF0sIFsgMTM3LjQwNzU0MTg4ODk5OTk4NywgMzQuNzA0MDkzMTM5IF0sIFsgMTM3LjQwNzUxMTQxNywgMzQuNzA0MDgzOTE3IF0sIFsgMTM3LjQwNzQ4NTE2NywgMzQuNzA0MDczNSBdLCBbIDEzNy40MDc0NTUsIDM0LjcwNDA2MTgzMyBdLCBbIDEzNy40MDczOTIxMzksIDM0LjcwNDAyNTQ3MiBdLCBbIDEzNy40MDczNzkxNTAzOTA5OTQsIDM0LjcwNDAxNzc2MDEyNzAwMiBdLCBbIDEzNy40MDczMzk5NzE5OTk5ODgsIDM0LjcwMzk5NDM2MSBdLCBbIDEzNy40MDczMjAwODMsIDM0LjcwMzk4MTg4OSBdLCBbIDEzNy40MDcyODc2MzksIDM0LjcwMzk2MTUyOCBdLCBbIDEzNy40MDcxMTA0MTcwMDAwMTMsIDM0LjcwMzg1MDIyMiBdLCBbIDEzNy40MDcwNTUzMDYsIDM0LjcwMzgxNDgwNiBdLCBbIDEzNy40MDY5MTY0MTcsIDM0LjcwMzcyNTY2NyBdLCBbIDEzNy40MDY4MjMwMjgsIDM0LjcwMzY2NjA1NiBdLCBbIDEzNy40MDY4MDQ2MzksIDM0LjcwMzY1Mjk0NCBdLCBbIDEzNy40MDY3OTk4ODkwMDAwMTMsIDM0LjcwMzYzMjMwNiBdLCBbIDEzNy40MDY4MjI5MTcsIDM0LjcwMzYyNzk0NCBdLCBbIDEzNy40MDcyNDQ4ODksIDM0LjcwMzUzODM4OSBdLCBbIDEzNy40MDcyNjM0NDQsIDM0LjcwMzUzNDY2NyBdLCBbIDEzNy40MDcyNzkyNDk5OTk5ODgsIDM0LjcwMzUzMzE5NCBdLCBbIDEzNy40MDcyOTI0NzIsIDM0LjcwMzUzNDY5NCBdLCBbIDEzNy40MDczNDI4MDYsIDM0LjcwMzU0MTE2NyBdLCBbIDEzNy40MDczNzkxNTAzOTA5OTQsIDM0LjcwMzU0NDk4MTQ0Nzg5OCBdLCBbIDEzNy40MDc2MjI4ODkwMDAwMSwgMzQuNzAzNTcwNTU2IF0sIFsgMTM3LjQwNzgwMjQxNywgMzQuNzAzNTg5MzA2IF0sIFsgMTM3LjQwNzkyOCwgMzQuNzAzNjAzODMzIF0sIFsgMTM3LjQwODMzMzMzMywgMzQuNzAzNjUwNjExIF0sIFsgMTM3LjQwODc1MjQ0MTQwNTk5NCwgMzQuNzAzNjk4OTU3OTI5ODAyIF0sIFsgMTM3LjQwOTA0NDg2MTAwMDAxMiwgMzQuNzAzNzMyNjk0IF0sIFsgMTM3LjQwOTQzMDM2MSwgMzQuNzAzNzQ0ODMzIF0sIFsgMTM3LjQwOTIyNzUyOCwgMzQuNzAzODk0ODA2IF0sIFsgMTM3LjQwODk5ODE5NCwgMzQuNzA0MDQ2Njk0IF0sIFsgMTM3LjQwODk2MTEzOTAwMDAxMywgMzQuNzA0MDY5MjIyIF0sIFsgMTM3LjQwODk0NTEzOSwgMzQuNzA0MDgwODg5IF0sIFsgMTM3LjQwODkyNDExMSwgMzQuNzA0MDk5NSBdLCBbIDEzNy40MDg4Nzc4NjEsIDM0LjcwNDE1MDE2NyBdLCBbIDEzNy40MDg4NTcxMzksIDM0LjcwNDE1NTg4OSBdLCBbIDEzNy40MDg3NTI0NDE0MDU5OTQsIDM0LjcwNDEzMTUzMjg2ODQwMiBdLCBbIDEzNy40MDg2NjQ3NzgsIDM0LjcwNDExMTExMSBdLCBbIDEzNy40MDg1NzgzODkwMDAwMTMsIDM0LjcwNDA5MSBdLCBbIDEzNy40MDg0NjY0MTcsIDM0LjcwNDA3MDU4MyBdLCBbIDEzNy40MDg0NTcxMzksIDM0LjcwNDA2OTY5NCBdLCBbIDEzNy40MDg0NTAyNDk5OTk5ODcsIDM0LjcwNDA2Mjc1IF0sIFsgMTM3LjQwODQ2MzQ0NCwgMzQuNzAzOTEzODg5IF0sIFsgMTM3LjQwODQyLCAzNC43MDM5MTEyNzggXSwgWyAxMzcuNDA4NDA2Njk0LCAzNC43MDQwNTk3NzggXSwgWyAxMzcuNDA4Mzk4NSwgMzQuNzA0MDY1NzUgXSwgWyAxMzcuNDA4Mzk1NjY3LCAzNC43MDQwNjU1ODMgXSwgWyAxMzcuNDA4MzMzMzMzLCAzNC43MDQwNjcwNTYgXSwgWyAxMzcuNDA4MzIxNDQ0LCAzNC43MDQwNjczMzMgXSwgWyAxMzcuNDA4MTk2MTM5MDAwMDEyLCAzNC43MDQwNzQ3MjIgXSwgWyAxMzcuNDA4MDAzMTY3LCAzNC43MDQwODQwMjggXSwgWyAxMzcuNDA3OTAzNjY3LCAzNC43MDQwOTg2MzkgXSwgWyAxMzcuNDA3ODU4NSwgMzQuNzA0MTAzNjExIF0gXSwgWyBbIDEzNy40MDc5Mjk2MTA5OTk5ODYsIDM0LjcwMjI0MTgzMyBdLCBbIDEzNy40MDc3ODQ1LCAzNC43MDIyMjc4ODkgXSwgWyAxMzcuNDA3NjAxMjc3OTk5OTg3LCAzNC43MDIyMDk2NjcgXSwgWyAxMzcuNDA3NDYzMjUsIDM0LjcwMjE5NjQxNyBdLCBbIDEzNy40MDczOTUyMjIsIDM0LjcwMjE4OTQxNyBdLCBbIDEzNy40MDczODEzNjEsIDM0LjcwMjE4NjU4MyBdLCBbIDEzNy40MDczNzkxNTAzOTA5OTQsIDM0LjcwMjE4NTcyNTYzMjgwMiBdLCBbIDEzNy40MDczNzM0NzE5OTk5ODksIDM0LjcwMjE4Mjg4OSBdLCBbIDEzNy40MDczNjc5MTY5OTk5ODgsIDM0LjcwMjE3OTU1NiBdLCBbIDEzNy40MDczNjMxOTQsIDM0LjcwMjE3NTYxMSBdLCBbIDEzNy40MDczNjA2OTQsIDM0LjcwMjE3MjgwNiBdLCBbIDEzNy40MDczNTgxNjcwMDAwMTIsIDM0LjcwMjE3MDExMSBdLCBbIDEzNy40MDczNTY5NDQwMDAwMTQsIDM0LjcwMjE2NjY5NCBdLCBbIDEzNy40MDczNjYyMjIsIDM0LjcwMjEyOSBdLCBbIDEzNy40MDczNjc1MjgsIDM0LjcwMjEyMTYxMSBdLCBbIDEzNy40MDczNzcyMjIsIDM0LjcwMjExNTE2NyBdLCBbIDEzNy40MDczNzkxNTAzOTA5OTQsIDM0LjcwMjExNTA3MDI5MDM5NyBdLCBbIDEzNy40MDczODkzMzMsIDM0LjcwMjExMyBdLCBbIDEzNy40MDc0NjMyNSwgMzQuNzAyMTIwODYxIF0sIFsgMTM3LjQwNzQ2NTAzMTIzNjAwMSwgMzQuNzAyMTA2NDM2NzA1NTk4IF0sIFsgMTM3LjQwNzQ4NTc1LCAzNC43MDE5MzU1NTYgXSwgWyAxMzcuNDA3NDEzODg5LCAzNC43MDE5Mjk0NzIgXSwgWyAxMzcuNDA3NDA3NTU2MDAwMDEsIDM0LjcwMTkyNjI1IF0sIFsgMTM3LjQwNzQwMzQ5OTk5OTk4NywgMzQuNzAxOTIxMjIyIF0sIFsgMTM3LjQwNzQwMTUyOCwgMzQuNzAxOTEzMTExIF0sIFsgMTM3LjQwNzQwOTU1NiwgMzQuNzAxODYwOTcyIF0sIFsgMTM3LjQwNzQxOTU1NiwgMzQuNzAxODA1ODg5IF0sIFsgMTM3LjQwNzQzMTA4MywgMzQuNzAxNzk2MTExIF0sIFsgMTM3LjQwNzYxNzgwNiwgMzQuNzAxODE1MDI4IF0sIFsgMTM3LjQwNzc3OTc1LCAzNC43MDE4MzA5NDQgXSwgWyAxMzcuNDA4MDA4MTY3LCAzNC43MDE4NTQxMTEgXSwgWyAxMzcuNDA4MDM3MzMzMDAwMDEsIDM0LjcwMTg1Njk0NCBdLCBbIDEzNy40MDgwNTU3NzgsIDM0LjcwMTg1OTY5NCBdLCBbIDEzNy40MDgwNzA1MjgsIDM0LjcwMTg2NDI3OCBdLCBbIDEzNy40MDgwODExMzg5OTk5ODksIDM0LjcwMTg3MDE5NCBdLCBbIDEzNy40MDgwOTAyMjIsIDM0LjcwMTg3ODQ3MiBdLCBbIDEzNy40MDgwOTUxNjcsIDM0LjcwMTg4ODkxNyBdLCBbIDEzNy40MDgwOTcwNTYsIDM0LjcwMTkwMzE2NyBdLCBbIDEzNy40MDgwOTUxMzkwMDAwMTEsIDM0LjcwMTkyMDQ3MiBdLCBbIDEzNy40MDgwOTA0NDQwMDAwMSwgMzQuNzAxOTU0ODMzIF0sIFsgMTM3LjQwODA4OTAyOCwgMzQuNzAxOTYyMTM5IF0sIFsgMTM3LjQwODA4MjE5NCwgMzQuNzAxOTc1MDI4IF0sIFsgMTM3LjQwODA3MzI3Nzk5OTk4OSwgMzQuNzAxOTgwNjM5IF0sIFsgMTM3LjQwNzk5NTk3MiwgMzQuNzAxOTczNjY3IF0sIFsgMTM3LjQwNzk3OTExMSwgMzQuNzAyMDc2MzA2IF0sIFsgMTM3LjQwODAzNDkxNywgMzQuNzAyMDgxMzMzIF0sIFsgMTM3LjQwODA0NzgwNjAwMDAxMywgMzQuNzAyMDg2MzYxIF0sIFsgMTM3LjQwODA1NTQ3MiwgMzQuNzAyMDk0NDQ0IF0sIFsgMTM3LjQwODA1ODIyMiwgMzQuNzAyMTA0IF0sIFsgMTM3LjQwODA1Nzc1NDk0Mzk5NywgMzQuNzAyMTA2NDM2NzA1NTk4IF0sIFsgMTM3LjQwODA1NTUyOCwgMzQuNzAyMTEzOTE3IF0sIFsgMTM3LjQwODA0OTc3OCwgMzQuNzAyMTIwMjUgXSwgWyAxMzcuNDA4MDQyMDI4MDAwMDExLCAzNC43MDIxMjUwNTYgXSwgWyAxMzcuNDA3OTcxNzIyMDAwMDEzLCAzNC43MDIxMTgyNSBdLCBbIDEzNy40MDc5NjIyNSwgMzQuNzAyMTY5NzIyIF0sIFsgMTM3LjQwODAzMjI1LCAzNC43MDIxNzc2MTEgXSwgWyAxMzcuNDA4MDQwNTU2LCAzNC43MDIxODQwODMgXSwgWyAxMzcuNDA4MDQ0MDgzLCAzNC43MDIxODkzMDYgXSwgWyAxMzcuNDA4MDQ2MDU1OTk5OTg5LCAzNC43MDIxOTY4ODkgXSwgWyAxMzcuNDA4MDQ0ODg5LCAzNC43MDIyMDYwODMgXSwgWyAxMzcuNDA4MDQyMjIyLCAzNC43MDIyMjYxMTEgXSwgWyAxMzcuNDA4MDM5Mjc4LCAzNC43MDIyMzM4NjEgXSwgWyAxMzcuNDA4MDMxNDQzOTk5OTg4LCAzNC43MDIyNDExNjcgXSwgWyAxMzcuNDA4MDIzMDU2LCAzNC43MDIyNDU1MjggXSwgWyAxMzcuNDA4MDEyOTE3LCAzNC43MDIyNDg3NzggXSwgWyAxMzcuNDA4MDAzNTI4LCAzNC43MDIyNDkgXSwgWyAxMzcuNDA3OTI5NjEwOTk5OTg2LCAzNC43MDIyNDE4MzMgXSBdLCBbIFsgMTM3LjQwNjY2MzQ3MiwgMzQuNjk4Mzg3NDcyIF0sIFsgMTM3LjQwNjcyOTgwNTk5OTk4NywgMzQuNjk4MzgwNTgzIF0sIFsgMTM3LjQwNjc0MzExMSwgMzQuNjk4Mzc5MTk0IF0sIFsgMTM3LjQwNjgwNzcyMiwgMzQuNjk4Mzc0MTk0IF0sIFsgMTM3LjQwNzI0NjQ0NCwgMzQuNjk4MzM5ODA2IF0sIFsgMTM3LjQwNzI3NiwgMzQuNjk4MzM3NSBdLCBbIDEzNy40MDczMDQ1NTYwMDAwMTQsIDM0LjY5ODM1NjgwNiBdLCBbIDEzNy40MDczMTM2OTQwMDAwMSwgMzQuNjk4NDU4Mzg5IF0sIFsgMTM3LjQwNzMyOTAyOCwgMzQuNjk4NjI3NTgzIF0sIFsgMTM3LjQwNzMxOTkxNywgMzQuNjk4NjQ3OTcyIF0sIFsgMTM3LjQwNjgxOTY2NywgMzQuNjk4Njg1ODMzIF0sIFsgMTM3LjQwNjgyNDc0NTE4MzAwMiwgMzQuNjk4NzE5MzI0NTMyMjk4IF0sIFsgMTM3LjQwNjgyOCwgMzQuNjk4NzQwMzYxIF0sIFsgMTM3LjQwNzEwNTkwNzY4NDAxMywgMzQuNjk4NzE5MzI0NTMyMjk4IF0sIFsgMTM3LjQwNzMyODAyOCwgMzQuNjk4NzAyNSBdLCBbIDEzNy40MDczNDE2MTEsIDM0LjY5ODcxMTAyOCBdLCBbIDEzNy40MDczNDMwMTcyNDc5OTYsIDM0LjY5ODcxOTMyNDUzMjI5OCBdLCBbIDEzNy40MDczNTQ1ODMsIDM0LjY5ODc4NjYzOSBdLCBbIDEzNy40MDczNjMwODMsIDM0LjY5ODg1ODc1IF0sIFsgMTM3LjQwNzM3MzA1NjAwMDAxMiwgMzQuNjk4OTQyNTgzIF0sIFsgMTM3LjQwNzM3OTE1MDM5MDk5NCwgMzQuNjk4OTk0NTYwODc1Mzk4IF0sIFsgMTM3LjQwNzM4MjY2NywgMzQuNjk5MDI0NDE3IF0sIFsgMTM3LjQwNzM4NDAyOCwgMzQuNjk5MDM1NTgzIF0sIFsgMTM3LjQwNzQxMzY5NDAwMDAxMywgMzQuNjk5MjE3NTU2IF0sIFsgMTM3LjQwNzQyMzU4MywgMzQuNjk5MzE1NjExIF0sIFsgMTM3LjQwNzM3OTE1MDM5MDk5NCwgMzQuNjk5MzE5MTQ2MjkwMTAxIF0sIFsgMTM3LjQwNjgxMDU4MywgMzQuNjk5MzY0NDE3IF0sIFsgMTM3LjQwNjc3MzQ3MiwgMzQuNjk5MzY3Mzg5IF0sIFsgMTM3LjQwNjcxNzI3OCwgMzQuNjk5Mzc0MjUgXSwgWyAxMzcuNDA2NjA3NSwgMzQuNjk5MzgyNSBdLCBbIDEzNy40MDY1NzE5NDQsIDM0LjY5OTA1NDk0NCBdLCBbIDEzNy40MDY1Njc4MDYsIDM0LjY5OTAxNjExMSBdLCBbIDEzNy40MDY1NTgyNzgsIDM0LjY5ODkyODU4MyBdLCBbIDEzNy40MDY1MzUyNSwgMzQuNjk4NzQxNTU2IF0sIFsgMTM3LjQwNjUzMjU2NDQ4NjAxNCwgMzQuNjk4NzE5MzI0NTMyMjk4IF0sIFsgMTM3LjQwNjUyNTg2MSwgMzQuNjk4NjY1NTgzIF0sIFsgMTM3LjQwNjQ5MzIyMiwgMzQuNjk4NDAxMjIyIF0sIFsgMTM3LjQwNjY2MzQ3MiwgMzQuNjk4Mzg3NDcyIF0gXSwgWyBbIDEzNy40MDg0MjQxMzksIDM0LjY5OTMyNDg4OSBdLCBbIDEzNy40MDg2ODM0NDQsIDM0LjY5OTE5NDkxNyBdLCBbIDEzNy40MDg3MzU5NzE5OTk5ODgsIDM0LjY5OTIwNDYzOSBdLCBbIDEzNy40MDg3NTI0NDE0MDU5OTQsIDM0LjY5OTE5NjI5MjYxMDkgXSwgWyAxMzcuNDA4ODQyMTM5LCAzNC42OTkxNTA3MjIgXSwgWyAxMzcuNDA4ODY3NzIyLCAzNC42OTkwOTggXSwgWyAxMzcuNDA4OTkxNjExLCAzNC42OTg5MDM2NjcgXSwgWyAxMzcuNDA5MTc3NDcyMDAwMDEsIDM0LjY5OTE2MTY2NyBdLCBbIDEzNy40MDkzOTUzODksIDM0LjY5OTQ3NDMzMyBdLCBbIDEzNy40MDkxNTEzNjEsIDM0LjY5OTc4ODU1NiBdLCBbIDEzNy40MDkxMzgyMjIsIDM0LjY5OTgwNTY5NCBdLCBbIDEzNy40MDkxMDUxMTczODIwMTIsIDM0LjY5OTg0ODM3NzMyODg5OCBdLCBbIDEzNy40MDg5ODk2NjY5OTk5ODYsIDM0LjY5OTk5NzMwNiBdLCBbIDEzNy40MDg3NTI0NDE0MDU5OTQsIDM0LjY5OTg2NDg0NTA2NTIgXSwgWyAxMzcuNDA4NzIyOTQ4NTM1OTk2LCAzNC42OTk4NDgzNzczMjg4OTggXSwgWyAxMzcuNDA4MzMzMzMzLCAzNC42OTk2MzA4MzMgXSwgWyAxMzcuNDA4MjE3NTU2MDAwMDExLCAzNC42OTk1NjYxOTQgXSwgWyAxMzcuNDA4MTMyMDU2LCAzNC42OTk1MTg0MTcgXSwgWyAxMzcuNDA4MTEzODMyOTk5OTg3LCAzNC42OTk0ODc2OTQgXSwgWyAxMzcuNDA4MzMzMzMzLCAzNC42OTkzNzI1MjggXSwgWyAxMzcuNDA4NDI0MTM5LCAzNC42OTkzMjQ4ODkgXSBdLCBbIFsgMTM3LjQxMDQ0MzUwMDAwMDAxNCwgMzQuNzAyNzQwNjk0IF0sIFsgMTM3LjQxMDQyNDQxNywgMzQuNzAyNzg0MzYxIF0sIFsgMTM3LjQxMDQwODg4OSwgMzQuNzAyODE2OTQ0IF0sIFsgMTM3LjQxMDM5NjcyMiwgMzQuNzAyODM3NDE3IF0sIFsgMTM3LjQxMDM3ODEzODk5OTk4OCwgMzQuNzAyODYzMDU2IF0sIFsgMTM3LjQxMDM2MDMwNiwgMzQuNzAyODg2NjM5IF0sIFsgMTM3LjQxMDMzODMwNiwgMzQuNzAyOTA4NzUgXSwgWyAxMzcuNDEwMzE2NjY2OTk5OTg5LCAzNC43MDI5MjkwODMgXSwgWyAxMzcuNDEwMjk0NjY2OTk5OTg4LCAzNC43MDI5NDg0MTcgXSwgWyAxMzcuNDEwMjcwNTgzLCAzNC43MDI5NjUxMzkgXSwgWyAxMzcuNDEwMjQ3MTY3LCAzNC43MDI5ODA1MjggXSwgWyAxMzcuNDEwMjE0MDI4MDAwMDEzLCAzNC43MDI5OTY4MDYgXSwgWyAxMzcuNDEwMTc3Mzg5MDAwMDEyLCAzNC43MDMwMDkyNSBdLCBbIDEzNy40MTAxNDA5NDQsIDM0LjcwMzAxODg2MSBdLCBbIDEzNy40MTAxMjU3MzI0MjE5ODksIDM0LjcwMzAyMTU1Njk5MzQ5OCBdLCBbIDEzNy40MTAxMTAzODkwMDAwMSwgMzQuNzAzMDI0MzMzIF0sIFsgMTM3LjQxMDA3NDk0NCwgMzQuNzAzMDI3NDcyIF0sIFsgMTM3LjQxMDAzNTc1LCAzNC43MDMwMjgyNzggXSwgWyAxMzcuNDA5OTkzNTAwMDAwMDEzLCAzNC43MDMwMjQ2NjcgXSwgWyAxMzcuNDA5OTEzMjIyLCAzNC43MDMwMTY1MjggXSwgWyAxMzcuNDA5NzY5MjIyLCAzNC43MDMwMDI3NSBdLCBbIDEzNy40MDkzODgyMjIsIDM0LjcwMjk2NDU1NiBdLCBbIDEzNy40MDkzODgxOTQsIDM0LjcwMjk1MzkxNyBdLCBbIDEzNy40MDk0MTMyNzc5OTk5ODgsIDM0LjcwMjc1OTg2MSBdLCBbIDEzNy40MDk0MTQ1ODMsIDM0LjcwMjc1NDkxNyBdLCBbIDEzNy40MDk0MTk1ODI5OTk5ODgsIDM0LjcwMjc1MDc1IF0sIFsgMTM3LjQwOTQyNzc3OCwgMzQuNzAyNzQ3MDI4IF0sIFsgMTM3LjQwOTQzODAyODAwMDAxMSwgMzQuNzAyNzQ2MzA2IF0sIFsgMTM3LjQwOTQ4Nzk0NCwgMzQuNzAyNzUwOTcyIF0sIFsgMTM3LjQwOTcwOTEzOSwgMzQuNzAyNzcxMjc4IF0sIFsgMTM3LjQwOTcxODMzMywgMzQuNzAyNzM5MTY3IF0sIFsgMTM3LjQwOTQzNzM4OSwgMzQuNzAyNzA4ODg5IF0sIFsgMTM3LjQwOTQzMTU4MzAwMDAxNCwgMzQuNzAyNzA3NDQ0IF0sIFsgMTM3LjQwOTQyNzYzOSwgMzQuNzAyNzAyMjIyIF0sIFsgMTM3LjQwOTQyNTExMSwgMzQuNzAyNjk2NDcyIF0sIFsgMTM3LjQwOTQyNTE5NCwgMzQuNzAyNjkwNTI4IF0sIFsgMTM3LjQwOTQyODk0NDAwMDAxMywgMzQuNzAyNjYwMTM5IF0sIFsgMTM3LjQwOTQ2MDExMDk5OTk4NywgMzQuNzAyNDU1OTcyIF0sIFsgMTM3LjQwOTQ2ODcyMjAwMDAxNCwgMzQuNzAyNDQ5MTk0IF0sIFsgMTM3LjQwOTQ4MzExMDk5OTk4NiwgMzQuNzAyNDQ2MTk0IF0sIFsgMTM3LjQwOTQ5NzA4MywgMzQuNzAyNDQ0ODg5IF0sIFsgMTM3LjQwOTUyMDQ0NCwgMzQuNzAyNDQ3IF0sIFsgMTM3LjQwOTY1ODY5NCwgMzQuNzAyNDYwMjUgXSwgWyAxMzcuNDA5ODQxNTgzLCAzNC43MDI0NzgyNzggXSwgWyAxMzcuNDA5ODk0MTk0LCAzNC43MDI0ODIxMzkgXSwgWyAxMzcuNDA5OTA0NDcyLCAzNC43MDI0ODU2MzkgXSwgWyAxMzcuNDA5OTA4OTcyMDAwMDExLCAzNC43MDI0OTA2OTQgXSwgWyAxMzcuNDA5OTEyNDcyLCAzNC43MDI0OTc0NDQgXSwgWyAxMzcuNDA5OTEyMDU2LCAzNC43MDI1MDU4MzMgXSwgWyAxMzcuNDA5OTAyMTM5LCAzNC43MDI1ODYyNSBdLCBbIDEzNy40MDk5NDUxNjY5OTk5ODksIDM0LjcwMjU4OTY5NCBdLCBbIDEzNy40MDk5NTUsIDM0LjcwMjUxNTgzMyBdLCBbIDEzNy40MDk5NTg1ODMsIDM0LjcwMjUwNjI3OCBdLCBbIDEzNy40MDk5NjQ1NTYsIDM0LjcwMjQ5OTk0NCBdLCBbIDEzNy40MDk5NzYzMzMsIDM0LjcwMjQ5NDUgXSwgWyAxMzcuNDA5OTkwMTkzOTk5OTg4LCAzNC43MDI0OTM1IF0sIFsgMTM3LjQxMDAyNzE5NCwgMzQuNzAyNDk3OTE3IF0sIFsgMTM3LjQxMDAzNTMwNiwgMzQuNzAyNTAwNDQ0IF0sIFsgMTM3LjQxMDA0MTE5NCwgMzQuNzAyNTA2MTk0IF0sIFsgMTM3LjQxMDA0NzAyOCwgMzQuNzAyNTE2NTU2IF0sIFsgMTM3LjQxMDA1LCAzNC43MDI1Mjg3MjIgXSwgWyAxMzcuNDEwMDUwODg5LCAzNC43MDI1MzY5MTcgXSwgWyAxMzcuNDEwMDUwODA1OTk5OTg3LCAzNC43MDI1NDMxMzkgXSwgWyAxMzcuNDEwMDQzMDI4LCAzNC43MDI2MDcyNSBdLCBbIDEzNy40MTAwODAwMjgwMDAwMSwgMzQuNzAyNjQ0MzA2IF0sIFsgMTM3LjQxMDA5ODA1NjAwMDAxLCAzNC43MDI1MzI1ODMgXSwgWyAxMzcuNDEwMDk5MzMzLCAzNC43MDI1MjIzMDYgXSwgWyAxMzcuNDEwMTAzNDcyLCAzNC43MDI1MTgwNTYgXSwgWyAxMzcuNDEwMTA5NjY3LCAzNC43MDI1MTMxNjcgXSwgWyAxMzcuNDEwMTIwNDcxOTk5OTg4LCAzNC43MDI1MDkgXSwgWyAxMzcuNDEwMTI1NzMyNDIxOTg5LCAzNC43MDI1MDg3ODg0MjUyOTggXSwgWyAxMzcuNDEwMTMxMjc4LCAzNC43MDI1MDggXSwgWyAxMzcuNDEwMjkzNjM5LCAzNC43MDI1MjMwODMgXSwgWyAxMzcuNDEwNTE3MzYwOTk5OTg5LCAzNC43MDI1NDU1MjggXSwgWyAxMzcuNDEwNTI4MDgzLCAzNC43MDI1NDgyMjIgXSwgWyAxMzcuNDEwNTAwODYxLCAzNC43MDI2MTA2NjcgXSwgWyAxMzcuNDEwNDQzNTAwMDAwMDE0LCAzNC43MDI3NDA2OTQgXSBdLCBbIFsgMTM3LjQxMDY5MTEzOSwgMzQuNjk5NDUyNzIyIF0sIFsgMTM3LjQxMDQ4MjA4MywgMzQuNjk5NTU2IF0sIFsgMTM3LjQxMDI4OTgwNiwgMzQuNjk5NjU1ODMzIF0sIFsgMTM3LjQxMDEyNTczMjQyMTk4OSwgMzQuNjk5NzQxMTIzODEwNDk3IF0sIFsgMTM3LjQxMDA3NDY2NywgMzQuNjk5NzY3Njk0IF0sIFsgMTM3LjQxMDA3OTkxNywgMzQuNjk5NzcxMzYxIF0sIFsgMTM3LjQwOTkyMzY3Mjk5Njk5NiwgMzQuNjk5ODQ4Mzc3MzI4ODk4IF0sIFsgMTM3LjQwOTg4ODk0Mzk5OTk4OCwgMzQuNjk5ODY1NSBdLCBbIDEzNy40MDk3OTI4MDYwMDAwMTMsIDM0LjY5OTkxMzExMSBdLCBbIDEzNy40MDk3NzA1MjgsIDM0LjY5OTkwODE5NCBdLCBbIDEzNy40MDk3MjgzMTQ3Mjk5ODksIDM0LjY5OTg0ODM3NzMyODg5OCBdLCBbIDEzNy40MDk1MzEwODMsIDM0LjY5OTU2ODg4OSBdLCBbIDEzNy40MDk0ODQyMjIsIDM0LjY5OTUwMjQ3MiBdLCBbIDEzNy40MDk0NDY1NTYsIDM0LjY5OTQ0ODExMSBdLCBbIDEzNy40MDk0MDYyNzgsIDM0LjY5OTM5MDAyOCBdLCBbIDEzNy40MDkyNjM0NDQsIDM0LjY5OTE4NDEzOSBdLCBbIDEzNy40MDkyNjg5NDQsIDM0LjY5OTE2MTk0NCBdLCBbIDEzNy40MDkzMTUzODksIDM0LjY5OTEzNjk3MiBdLCBbIDEzNy40MDkzMzg4MzMsIDM0LjY5OTE3MDYzOSBdLCBbIDEzNy40MDk4MDI4MDU5OTk5ODgsIDM0LjY5ODkyMzMzMyBdLCBbIDEzNy40MDk4MzkzMjAwODEwMDUsIDM0LjY5ODcxOTMyNDUzMjI5OCBdLCBbIDEzNy40MDk4NjQzMzMsIDM0LjY5ODU3OTU1NiBdLCBbIDEzNy40MDk5NDU5NzIsIDM0LjY5ODUzNTgzMyBdLCBbIDEzNy40MDk5MzgxNjcsIDM0LjY5ODUyMTA4MyBdLCBbIDEzNy40MTAxMjU3MzI0MjE5ODksIDM0LjY5ODQyNDM4NTEwMDUwMiBdLCBbIDEzNy40MTAxMjY5NDQwMDAwMTIsIDM0LjY5ODQyMzc3OCBdLCBbIDEzNy40MTAxODU2MTEsIDM0LjY5ODQzNzI3OCBdLCBbIDEzNy40MTAxOTc5MTcsIDM0LjY5ODQ2ODgwNiBdLCBbIDEzNy40MTAyNDIyNzgsIDM0LjY5ODU5MDY5NCBdLCBbIDEzNy40MTAyODUzMDYsIDM0LjY5ODY3NjYxMSBdLCBbIDEzNy40MTAzMTE3OTE5MTYwMDEsIDM0LjY5ODcxOTMyNDUzMjI5OCBdLCBbIDEzNy40MTAzMTgsIDM0LjY5ODcyOTM2MSBdLCBbIDEzNy40MTAzMzkxNjY5OTk5ODksIDM0LjY5ODc2Mzc3OCBdLCBbIDEzNy40MTAzOTI2MzksIDM0LjY5ODgzNzY2NyBdLCBbIDEzNy40MTA0MzczNjEsIDM0LjY5ODg5OTgwNiBdLCBbIDEzNy40MTA1MDAzODksIDM0LjY5ODk4NzM4OSBdLCBbIDEzNy40MTA1NTgxMzg5OTk5ODgsIDM0LjY5OTA2ODQxNyBdLCBbIDEzNy40MTA2MTA3NDk5OTk5ODksIDM0LjY5OTE0MjMwNiBdLCBbIDEzNy40MTA2MjAxNjcsIDM0LjY5OTE1NTU1NiBdLCBbIDEzNy40MTA3ODExOTQsIDM0LjY5OTM4MDc3OCBdLCBbIDEzNy40MTA3NzQ0MTcsIDM0LjY5OTQxMjA4MyBdLCBbIDEzNy40MTA3MDI1ODI5OTk5ODgsIDM0LjY5OTQ0NzExMSBdLCBbIDEzNy40MTA2OTExMzksIDM0LjY5OTQ1MjcyMiBdIF0sIFsgWyAxMzcuNDA5NDI3MTY3LCAzNC42OTgxNjkxMzkgXSwgWyAxMzcuNDA5NDYxNDE2OTk5OTg5LCAzNC42OTgxOTQ5NDQgXSwgWyAxMzcuNDA5Mjk5NDcxOTk5OTg3LCAzNC42OTgzMjY1MjggXSwgWyAxMzcuNDA5MjQwMDU1OTk5OTg3LCAzNC42OTg0MTkwNTYgXSwgWyAxMzcuNDA5MjIzMDgzLCAzNC42OTg0NDUyNSBdLCBbIDEzNy40MDkwNDY3NjQxMzg5OTIsIDM0LjY5ODcxOTMyNDUzMjI5OCBdLCBbIDEzNy40MDkwMjYzMDU5OTk5ODcsIDM0LjY5ODc1MTEzOSBdLCBbIDEzNy40MDkwMDkzNjA5OTk5ODgsIDM0LjY5ODc3NzQxNyBdLCBbIDEzNy40MDg5ODQ4MDYsIDM0LjY5ODgxNTYxMSBdLCBbIDEzNy40MDg5NzY3NSwgMzQuNjk4ODI4MjUgXSwgWyAxMzcuNDA4OTQ2MTExLCAzNC42OTg4NzYzMzMgXSwgWyAxMzcuNDA4ODI4ODYwOTk5OTg5LCAzNC42OTkwNjA0MTcgXSwgWyAxMzcuNDA4NzUyNDQxNDA1OTk0LCAzNC42OTkwOTc4MTk1OTg5OTcgXSwgWyAxMzcuNDA4NzUxODA2LCAzNC42OTkwOTgxMzkgXSwgWyAxMzcuNDA4NzI3NDQ0LCAzNC42OTg5MDU4MDYgXSwgWyAxMzcuNDA4Njk3MjgxMTU1MDE0LCAzNC42OTg3MTkzMjQ1MzIyOTggXSwgWyAxMzcuNDA4NjkwNzc4LCAzNC42OTg2NzkxNjcgXSwgWyAxMzcuNDA4Njg0MzMzLCAzNC42OTg2NDA3NzggXSwgWyAxMzcuNDA4NjU2NTU2MDAwMDExLCAzNC42OTg0NzYwMjggXSwgWyAxMzcuNDA4NjI1OTcyMDAwMDEsIDM0LjY5ODIzODgwNiBdLCBbIDEzNy40MDg2MzE4MzI5OTk5ODcsIDM0LjY5ODIyOTUgXSwgWyAxMzcuNDA4NzUyNDQxNDA1OTk0LCAzNC42OTgyMjAzNDU5MDkzOTggXSwgWyAxMzcuNDA5NDI3MTY3LCAzNC42OTgxNjkxMzkgXSBdLCBbIFsgMTM3LjQwOTAzMzA1NiwgMzQuNjk4ODUyMTExIF0sIFsgMTM3LjQwOTExODQ1ODEyMzAwNCwgMzQuNjk4NzE5MzI0NTMyMjk4IF0sIFsgMTM3LjQwOTM0MzkxNywgMzQuNjk4MzY4NzIyIF0sIFsgMTM3LjQwOTM1NDgwNjAwMDAxLCAzNC42OTgzNTk4NjEgXSwgWyAxMzcuNDA5NTQ3MDI4LCAzNC42OTgyMDM5NzIgXSwgWyAxMzcuNDA5NTgxODYxLCAzNC42OTgxNzU2OTQgXSwgWyAxMzcuNDA5NjA2MzYwOTk5OTg3LCAzNC42OTgxNTU3MjIgXSwgWyAxMzcuNDA5Nzc2NzIyLCAzNC42OTgxNDM1NTYgXSwgWyAxMzcuNDA5ODE2MzMzLCAzNC42OTgxNDA2OTQgXSwgWyAxMzcuNDEwMDM5Mzg5LCAzNC42OTgxMjQ3NSBdLCBbIDEzNy40MTAwNjk1NTYsIDM0LjY5ODEzNzU4MyBdLCBbIDEzNy40MTAxMjU3MzI0MjE5ODksIDM0LjY5ODI4Mzg2NjA3MTMgXSwgWyAxMzcuNDEwMTMyOTE3LCAzNC42OTgzMDI2MTEgXSwgWyAxMzcuNDEwMTI1NzMyNDIxOTg5LCAzNC42OTgzMTI2NjQ4MzQyOTcgXSwgWyAxMzcuNDEwMTA4NjY3LCAzNC42OTgzMzYzNjEgXSwgWyAxMzcuNDA5NzUyOTQ0LCAzNC42OTg1MjMzMzMgXSwgWyAxMzcuNDA5NzE3OTYwNjY5MDEzLCAzNC42OTg3MTkzMjQ1MzIyOTggXSwgWyAxMzcuNDA5NjkyMDU2MDAwMDExLCAzNC42OTg4NjQ0MTcgXSwgWyAxMzcuNDA5MjczNzUwMDAwMDExLCAzNC42OTkwODcyNzggXSwgWyAxMzcuNDA5MjY4NSwgMzQuNjk5MDgwNTI4IF0sIFsgMTM3LjQwOTIyODgzMjk5OTk4NiwgMzQuNjk5MDk5OTE3IF0sIFsgMTM3LjQwOTIwMjgzMywgMzQuNjk5MDk4MjUgXSwgWyAxMzcuNDA5MDI5NDQ0LCAzNC42OTg4NTc1MjggXSwgWyAxMzcuNDA5MDMzMDU2LCAzNC42OTg4NTIxMTEgXSBdLCBbIFsgMTM3LjQxMDg3NTQ3MTk5OTk4NywgMzQuNjk5MzY5NTgzIF0sIFsgMTM3LjQxMDg0MTcyMTk5OTk4NiwgMzQuNjk5MzY0MjUgXSwgWyAxMzcuNDEwNjczODA2LCAzNC42OTkxMjkzODkgXSwgWyAxMzcuNDEwNjM4MTk0LCAzNC42OTkwODAwNTYgXSwgWyAxMzcuNDEwNTg4NzQ5OTk5OTg4LCAzNC42OTkwMTEzNjEgXSwgWyAxMzcuNDEwNTU3NjM5LCAzNC42OTg5NjgxNjcgXSwgWyAxMzcuNDEwNDQzOTcyLCAzNC42OTg4MTAyNSBdLCBbIDEzNy40MTAzOTI2NjcsIDM0LjY5ODczOTIyMiBdLCBbIDEzNy40MTAzODAzOTgwNjkwMDksIDM0LjY5ODcxOTMyNDUzMjI5OCBdLCBbIDEzNy40MTAzNDA5MTcwMDAwMTMsIDM0LjY5ODY1NTUgXSwgWyAxMzcuNDEwMjk5OTQ0LCAzNC42OTg1NzM2MzkgXSwgWyAxMzcuNDEwMjU2Mzg5MDAwMDExLCAzNC42OTg0NTM5MTcgXSwgWyAxMzcuNDEwMjA0NDcyLCAzNC42OTgzMjUgXSwgWyAxMzcuNDEwMTI4MzYxLCAzNC42OTgxMjY4MDYgXSwgWyAxMzcuNDEwMTM4NTgzLCAzNC42OTgxMTE1NTYgXSwgWyAxMzcuNDEwNDIzNzc4LCAzNC42OTgxMDQwNTYgXSwgWyAxMzcuNDEwNDQwMTY3LCAzNC42OTgxMDQ3NSBdLCBbIDEzNy40MTA1MDkxMzksIDM0LjY5ODEwMzA1NiBdLCBbIDEzNy40MTA2ODU4MzMsIDM0LjY5ODEwMzg4OSBdLCBbIDEzNy40MTA3Mjg1MjgsIDM0LjY5ODEwNDA4MyBdLCBbIDEzNy40MTA4MzEwNTYsIDM0LjY5ODEwNjM4OSBdLCBbIDEzNy40MTEwMTQzMzMsIDM0LjY5ODExMDcyMiBdLCBbIDEzNy40MTExNjIyNSwgMzQuNjk4MTE4OTcyIF0sIFsgMTM3LjQxMTQ5OTAyMzQzNjk4OCwgMzQuNjk4MTQ1NzI2MjIwMTk3IF0sIFsgMTM3LjQxMTUwODY5NCwgMzQuNjk4MTQ2NSBdLCBbIDEzNy40MTE3MDAxOTQsIDM0LjY5ODE2NDUgXSwgWyAxMzcuNDExNzc3MTY3LCAzNC42OTgxNjk3NSBdLCBbIDEzNy40MTE4NzQ2MzksIDM0LjY5ODE3MSBdLCBbIDEzNy40MTE5NjMzODksIDM0LjY5ODE3MTM2MSBdLCBbIDEzNy40MTE5NjA4MDYsIDM0LjY5ODIyNDkxNyBdLCBbIDEzNy40MTE5NDc4ODksIDM0LjY5ODI0NTA1NiBdLCBbIDEzNy40MTE5MzgyNzgsIDM0LjY5ODMxNjgzMyBdLCBbIDEzNy40MTE5ODY0MTcsIDM0LjY5ODMxOTUyOCBdLCBbIDEzNy40MTIwMTA2Mzg5OTk5ODgsIDM0LjY5ODE3MTU1NiBdLCBbIDEzNy40MTIwODU3NDk5OTk5ODksIDM0LjY5ODE3MTgzMyBdLCBbIDEzNy40MTI0MDcxOTQsIDM0LjY5ODE2NzUgXSwgWyAxMzcuNDEyNDIxMTEwOTk5OTg2LCAzNC42OTgxODU1ODMgXSwgWyAxMzcuNDEyMjU3ODI5MjE4OTg3LCAzNC42OTg3MTkzMjQ1MzIyOTggXSwgWyAxMzcuNDEyMjAxMzMzMDAwMDEzLCAzNC42OTg5MDQgXSwgWyAxMzcuNDEyMTY1NjY3MDAwMDExLCAzNC42OTg5MjE0NzIgXSwgWyAxMzcuNDEyMDgyMTY3LCAzNC42OTg5NTA1IF0sIFsgMTM3LjQxMjAyMjcyMTk5OTk4OSwgMzQuNjk4OTcyMDU2IF0sIFsgMTM3LjQxMTc2Mjg4ODk5OTk4OCwgMzQuNjk5MDYzMTExIF0sIFsgMTM3LjQxMTY5MDU4MywgMzQuNjk5MDg4MjIyIF0sIFsgMTM3LjQxMTQ5OTAyMzQzNjk4OCwgMzQuNjk5MTU0ODQ1ODY0MDAxIF0sIFsgMTM3LjQxMTM3MTE5NCwgMzQuNjk5MTk5MzA2IF0sIFsgMTM3LjQxMTI5MzExMSwgMzQuNjk5MjI2NDE3IF0sIFsgMTM3LjQxMTE1MTAyOCwgMzQuNjk5Mjc0MTExIF0sIFsgMTM3LjQxMDk3NTc3OCwgMzQuNjk5MzMwMTY3IF0sIFsgMTM3LjQxMDg3NTQ3MTk5OTk4NywgMzQuNjk5MzY5NTgzIF0gXSwgWyBbIDEzNy40MTM0OTc5MTcsIDM0LjcwMTcxMzM4OSBdLCBbIDEzNy40MTM0NzUzMDYsIDM0LjcwMTcxMTQ0NCBdLCBbIDEzNy40MTM0NTk1ODMsIDM0LjcwMTcwMzYzOSBdLCBbIDEzNy40MTI5NzUzMzMsIDM0LjcwMTM3Mjg2MSBdLCBbIDEzNy40MTMwMDU3NSwgMzQuNzAxMzIyMDU2IF0sIFsgMTM3LjQxMzA4ODE2NzAwMDAxMiwgMzQuNzAxMzU4MzA2IF0sIFsgMTM3LjQxMzEwOTUsIDM0LjcwMTMzODMzMyBdLCBbIDEzNy40MTMwMTk3NzgsIDM0LjcwMTI5OTIyMiBdLCBbIDEzNy40MTMxMzA3NSwgMzQuNzAxMTM4MTY3IF0sIFsgMTM3LjQxMzIxNTY5NCwgMzQuNzAxMDMyNjk0IF0sIFsgMTM3LjQxMzI1NzExMSwgMzQuNzAwOTgxMzA2IF0sIFsgMTM3LjQxMzI4MDQzNjM2OTAwNywgMzQuNzAwOTc3NDE0NzIwMSBdLCBbIDEzNy40MTMyOTI5MTcsIDM0LjcwMDk3NTQ3MiBdLCBbIDEzNy40MTMyOTY5NzIzOTI5OTksIDM0LjcwMDk3NzQxNDcyMDEgXSwgWyAxMzcuNDE0MTE1OTQ0LCAzNC43MDEzNjk0NzIgXSwgWyAxMzcuNDE0MDQwNSwgMzQuNzAxNTQ4OTQ0IF0sIFsgMTM3LjQxMzk3NzgwNiwgMzQuNzAxNTM4MzMzIF0sIFsgMTM3LjQxMzk2MTE5NCwgMzQuNzAxNTM1NTgzIF0sIFsgMTM3LjQxMzkyNDUyOCwgMzQuNzAxNTMyNSBdLCBbIDEzNy40MTM4ODcxOTQwMDAwMTIsIDM0LjcwMTUzMjQ3MiBdLCBbIDEzNy40MTM4NTU5NzIsIDM0LjcwMTUzNzIyMiBdLCBbIDEzNy40MTM3OTk1ODMwMDAwMTQsIDM0LjcwMTU1MTEzOSBdLCBbIDEzNy40MTM3NTk0NDQsIDM0LjcwMTU2NDQ3MiBdLCBbIDEzNy40MTM3MTk0NDQsIDM0LjcwMTU4MTc3OCBdLCBbIDEzNy40MTM2NjE4MDYsIDM0LjcwMTYxNzIyMiBdLCBbIDEzNy40MTM1MzE5NDQsIDM0LjcwMTcwMzUgXSwgWyAxMzcuNDEzNTE1NDk5OTk5OTg4LCAzNC43MDE3MTQ0NDQgXSwgWyAxMzcuNDEzNDk3OTE3LCAzNC43MDE3MTMzODkgXSBdLCBbIFsgMTM3LjQxNDE5MTU1NiwgMzQuNzAxMTAxODMzIF0sIFsgMTM3LjQxNDIwMTU4MywgMzQuNzAxMTMyMjc4IF0sIFsgMTM3LjQxNDEzNjYxMSwgMzQuNzAxMzEwODMzIF0sIFsgMTM3LjQxNDEwNTI3OCwgMzQuNzAxMzA3Mjc4IF0sIFsgMTM3LjQxNDA4NjAyODAwMDAxNCwgMzQuNzAxMjk4MTM5IF0sIFsgMTM3LjQxMzQxMjU2NzE3OTk4OSwgMzQuNzAwOTc3NDE0NzIwMSBdLCBbIDEzNy40MTMzMzA2NjcsIDM0LjcwMDkzODQxNyBdLCBbIDEzNy40MTMzMjY3NTAwMDAwMSwgMzQuNzAwOTA1MzYxIF0sIFsgMTM3LjQxMzQyOTI1LCAzNC43MDA3OTMzNjEgXSwgWyAxMzcuNDEzNDM0ODA2LCAzNC43MDA3OTE0NDQgXSwgWyAxMzcuNDEzNDQwMzg4OTk5OTg3LCAzNC43MDA3OTAwODMgXSwgWyAxMzcuNDEzNDQ2MDU2LCAzNC43MDA3ODkwODMgXSwgWyAxMzcuNDEzNDUyOTE3LCAzNC43MDA3ODg2MTEgXSwgWyAxMzcuNDEzNDU5OTE3MDAwMDEyLCAzNC43MDA3ODg3NzggXSwgWyAxMzcuNDEzNDY3MTEwOTk5OTg5LCAzNC43MDA3ODk2NjcgXSwgWyAxMzcuNDEzNjQ2MjUsIDM0LjcwMDg2NjgzMyBdLCBbIDEzNy40MTM5MDI4NTEzNzI5OTUsIDM0LjcwMDk3NzQxNDcyMDEgXSwgWyAxMzcuNDE0MTkxNTU2LCAzNC43MDExMDE4MzMgXSBdLCBbIFsgMTM3LjQxNDA2NDAyODAwMDAxMywgMzQuNjk4NzQ4MjUgXSwgWyAxMzcuNDE0MDAzNzc4LCAzNC42OTg3NDkyNzggXSwgWyAxMzcuNDEzOTUxNDE3LCAzNC42OTg3NTY2NjcgXSwgWyAxMzcuNDEzODg4MTM5LCAzNC42OTg3NzA5NDQgXSwgWyAxMzcuNDEzODI2MTk0LCAzNC42OTg3ODc2NjcgXSwgWyAxMzcuNDEzODA2NDQzOTk5OTg4LCAzNC42OTg3OTE3NzggXSwgWyAxMzcuNDEzNzcxMzA2LCAzNC42OTg3OTI3NSBdLCBbIDEzNy40MTM1MDcwMjgsIDM0LjY5ODc4OTIyMiBdLCBbIDEzNy40MTMzNzQ5NDQsIDM0LjY5ODc4NzUgXSwgWyAxMzcuNDEzMjg0MzMzLCAzNC42OTg3ODU5NzIgXSwgWyAxMzcuNDEzMjU5MTExLCAzNC42OTg3ODU0NzIgXSwgWyAxMzcuNDEzMTY5MTk0LCAzNC42OTg3OTA4MDYgXSwgWyAxMzcuNDEyOTM1MzYxLCAzNC42OTg4MjI0NzIgXSwgWyAxMzcuNDEyODcyMzE0NDUzMDExLCAzNC42OTg4MzMyNDIzODA3MDEgXSwgWyAxMzcuNDEyNzUwNDQ0MDAwMDExLCAzNC42OTg4NTQxMTEgXSwgWyAxMzcuNDEyMjc3ODA2LCAzNC42OTg5MjQ1IF0sIFsgMTM3LjQxMjI1NTk3MiwgMzQuNjk4ODkwOTE3IF0sIFsgMTM3LjQxMjI3NDY2NywgMzQuNjk4ODI5NzUgXSwgWyAxMzcuNDEyMzA4NDU5MjQ0MDAyLCAzNC42OTg3MTkzMjQ1MzIyOTggXSwgWyAxMzcuNDEyMzIzNzUwMDAwMDEzLCAzNC42OTg2NjkyNzggXSwgWyAxMzcuNDEyMzcwMDI4LCAzNC42OTg1MTgyNzggXSwgWyAxMzcuNDEyNDA4NTI3OTk5OTg2LCAzNC42OTgzOTIzMzMgXSwgWyAxMzcuNDEyNDgwMDgzLCAzNC42OTgxNTgyNSBdLCBbIDEzNy40MTI1MjAxMzksIDM0LjY5ODE1MjMwNiBdLCBbIDEzNy40MTI1Njg0NzIsIDM0LjY5ODE0NTE2NyBdLCBbIDEzNy40MTI2MzY4NjEwMDAwMSwgMzQuNjk4MTM1MDI4IF0sIFsgMTM3LjQxMjg3MjMxNDQ1MzAxMSwgMzQuNjk4MDk4NTM3NjA1Mjk3IF0sIFsgMTM3LjQxMzEwMDc1MDAwMDAxMiwgMzQuNjk4MDYzMTM5IF0sIFsgMTM3LjQxMzEyOTAyNzk5OTk4NiwgMzQuNjk4MDU4NzUgXSwgWyAxMzcuNDEzMTU1MTk0MDAwMDEyLCAzNC42OTgwNTUyNzggXSwgWyAxMzcuNDEzMjYwMTk0LCAzNC42OTgwNDEyNzggXSwgWyAxMzcuNDEzMzY2NDcyLCAzNC42OTgwMjgxNjcgXSwgWyAxMzcuNDEzNTI3MTExLCAzNC42OTgwMTcwMjggXSwgWyAxMzcuNDEzNTg4NTU2LCAzNC42OTgwMTU4MzMgXSwgWyAxMzcuNDEzNjYzNTU1OTk5OTg5LCAzNC42OTgwMTQzMDYgXSwgWyAxMzcuNDEzOTU2MTExLCAzNC42OTgwMjM0NzIgXSwgWyAxMzcuNDE0MTg3Nzc4MDAwMDEzLCAzNC42OTgwMzU2OTQgXSwgWyAxMzcuNDE0MjQ1NjA1NDY5MDA2LCAzNC42OTgwMzg1MzgzNDM5MDEgXSwgWyAxMzcuNDE0NTI3NSwgMzQuNjk4MDUyMzMzIF0sIFsgMTM3LjQxNDYxMTEzODk5OTk4NywgMzQuNjk4MDU2NjY3IF0sIFsgMTM3LjQxNDcwNDEzOSwgMzQuNjk4MDYxNTI4IF0sIFsgMTM3LjQxNDcyNDY5NCwgMzQuNjk4MDc1Mjc4IF0sIFsgMTM3LjQxNDU5NjAzNjE4Nzk4NywgMzQuNjk4NzE5MzI0NTMyMjk4IF0sIFsgMTM3LjQxNDU4NTk3MiwgMzQuNjk4NzY5NzIyIF0sIFsgMTM3LjQxNDU2NDgwNTk5OTk4NywgMzQuNjk4ODQ2NjY3IF0sIFsgMTM3LjQxNDU2NDM2MSwgMzQuNjk4ODQ4MTk0IF0sIFsgMTM3LjQxNDU0Nzk3MiwgMzQuNjk4ODgwMDU2IF0sIFsgMTM3LjQxNDUzMDUwMDAwMDAxMiwgMzQuNjk4ODc0OTQ0IF0sIFsgMTM3LjQxNDM0MzI1LCAzNC42OTg4MTk2OTQgXSwgWyAxMzcuNDE0MjQ1NjA1NDY5MDA2LCAzNC42OTg3ODg2NzUyODI5OTggXSwgWyAxMzcuNDE0MjQzNjEwOTk5OTg5LCAzNC42OTg3ODggXSwgWyAxMzcuNDE0MTgwMzYxLCAzNC42OTg3Njk1NTYgXSwgWyAxMzcuNDE0MTE3NjM5MDAwMDExLCAzNC42OTg3NTQ3MjIgXSwgWyAxMzcuNDE0MDY0MDI4MDAwMDEzLCAzNC42OTg3NDgyNSBdIF0sIFsgWyAxMzcuNDE0MDQ1MTM5LCAzNC43MDE5NzMxNjcgXSwgWyAxMzcuNDE0MDMzNTU2LCAzNC43MDE5NzEzODkgXSwgWyAxMzcuNDE0MDIzMDU2LCAzNC43MDE5NjI3NzggXSwgWyAxMzcuNDE0MDE2ODA2LCAzNC43MDE5NDg4ODkgXSwgWyAxMzcuNDE0MDE5NDcyLCAzNC43MDE5MzM5MTcgXSwgWyAxMzcuNDE0MTM4NjM4OTk5OTg3LCAzNC43MDE3MDIyNzggXSwgWyAxMzcuNDE0MTcwNDQ0LCAzNC43MDE2NDA0NDQgXSwgWyAxMzcuNDE0MTgzNTI4LCAzNC43MDE2MTE0NDQgXSwgWyAxMzcuNDE0MTkyOTcyLCAzNC43MDE1OTA0NDQgXSwgWyAxMzcuNDE0MjQ1NjA1NDY5MDA2LCAzNC43MDE0NzM2MTk1OTE3MDIgXSwgWyAxMzcuNDE0MjcsIDM0LjcwMTQxOTUyOCBdLCBbIDEzNy40MTQyOTY1NTYwMDAwMTEsIDM0LjcwMTM2MDU1NiBdLCBbIDEzNy40MTQzMTk2NjcsIDM0LjcwMTMwOTI3OCBdLCBbIDEzNy40MTQzNjEzMzI5OTk5ODgsIDM0LjcwMTE4Nzk0NCBdLCBbIDEzNy40MTQzNzc0MTcsIDM0LjcwMTE2NDExMSBdLCBbIDEzNy40MTQ0MTUzMzMsIDM0LjcwMTE0MzQ3MiBdLCBbIDEzNy40MTQ2ODI4MDYsIDM0LjcwMTI2MDY2NyBdLCBbIDEzNy40MTQ3OTI4ODkwMDAwMTIsIDM0LjcwMTI4MDE5NCBdLCBbIDEzNy40MTUwMjgsIDM0LjcwMTM4MDYxMSBdLCBbIDEzNy40MTUwMzA4NjEsIDM0LjcwMTM4NzgwNiBdLCBbIDEzNy40MTUwMjMxMzksIDM0LjcwMTQwMjYxMSBdLCBbIDEzNy40MTQ5Mjk4ODksIDM0LjcwMTQ2MjU1NiBdLCBbIDEzNy40MTQ4OSwgMzQuNzAxNDg0MTExIF0sIFsgMTM3LjQxNDQ5OTUsIDM0LjcwMTY5NDQxNyBdLCBbIDEzNy40MTQ0ODYzMDU5OTk5ODYsIDM0LjcwMTcwMTU1NiBdLCBbIDEzNy40MTQzNjIxOTQsIDM0LjcwMTc2ODQ0NCBdLCBbIDEzNy40MTQzNTg1ODMsIDM0LjcwMTc3MDYxMSBdLCBbIDEzNy40MTQyNDU2MDU0NjkwMDYsIDM0LjcwMTg0NTA3NTIyIF0sIFsgMTM3LjQxNDExODkxNywgMzQuNzAxOTI4NTgzIF0sIFsgMTM3LjQxNDA1MzA4MywgMzQuNzAxOTY4NTU2IF0sIFsgMTM3LjQxNDA0NTEzOSwgMzQuNzAxOTczMTY3IF0gXSwgWyBbIDEzNy40MTQzODE1MjgsIDM0LjcwMDQyMzg2MSBdLCBbIDEzNy40MTQzNzEyNzgsIDM0LjcwMDQyNzMzMyBdLCBbIDEzNy40MTQzNTU3MjIwMDAwMSwgMzQuNzAwNDM5MzMzIF0sIFsgMTM3LjQxNDMzMTc3OCwgMzQuNzAwNDY1Mjc4IF0sIFsgMTM3LjQxNDI0NTYwNTQ2OTAwNiwgMzQuNzAwNTk5NDM3MzcxNjAxIF0sIFsgMTM3LjQxNDA1Nzg2MSwgMzQuNzAwODkxNzc4IF0sIFsgMTM3LjQxMzU2Mjg2MSwgMzQuNzAwNjc4NSBdLCBbIDEzNy40MTM1NjAxMTEwMDAwMSwgMzQuNzAwNjcwNTgzIF0sIFsgMTM3LjQxMzU1ODU1NiwgMzQuNzAwNjYyNjM5IF0sIFsgMTM3LjQxMzU1ODA4MywgMzQuNzAwNjU0ODg5IF0sIFsgMTM3LjQxMzU1OTU4MywgMzQuNzAwNjQ0NjExIF0sIFsgMTM3LjQxMzU2MzA1NTk5OTk4NywgMzQuNzAwNjM0NSBdLCBbIDEzNy40MTM1Njg4MDYsIDM0LjcwMDYyNDUgXSwgWyAxMzcuNDEzNzUsIDM0LjcwMDQzOTAyOCBdLCBbIDEzNy40MTM5MDA2MTEsIDM0LjcwMDI4ODA4MyBdLCBbIDEzNy40MTQwMTU5NzE5OTk5ODcsIDM0LjcwMDE2MzE2NyBdLCBbIDEzNy40MTQxNjg5NzIsIDM0LjcgXSwgWyAxMzcuNDE0MjA4MjIyMDAwMDEzLCAzNC42OTk5NTgxMzkgXSwgWyAxMzcuNDE0MjQ1NjA1NDY5MDA2LCAzNC42OTk5MTA1MjgwNzEzOTkgXSwgWyAxMzcuNDE0MjYzMjUsIDM0LjY5OTg4ODA4MyBdLCBbIDEzNy40MTQyOTI1MDY0MDQ5OSwgMzQuNjk5ODQ4Mzc3MzI4ODk4IF0sIFsgMTM3LjQxNDMwNTk3MiwgMzQuNjk5ODMwMTExIF0sIFsgMTM3LjQxNDM2MjE2NywgMzQuNjk5NzQyODA2IF0sIFsgMTM3LjQxNDM2NDIyMTk5OTk4OSwgMzQuNjk5NzM4NTgzIF0sIFsgMTM3LjQxNDM5MDY5NCwgMzQuNjk5NjgzIF0sIFsgMTM3LjQxNDQxMzQxNywgMzQuNjk5NjE1OTcyIF0sIFsgMTM3LjQxNDQ0OTg2MSwgMzQuNjk5NTAxODMzIF0sIFsgMTM3LjQxNDQ5NjY5NCwgMzQuNjk5NTA2NDQ0IF0sIFsgMTM3LjQxNDQ4NjM4OSwgMzQuNjk5NTk2OTcyIF0sIFsgMTM3LjQxNDQ3MjM2MSwgMzQuNjk5NzYyNDE3IF0sIFsgMTM3LjQxNDQ2NTEwNDkyMTk4NywgMzQuNjk5ODQ4Mzc3MzI4ODk4IF0sIFsgMTM3LjQxNDQ2MTE2NzAwMDAxMywgMzQuNjk5ODk0ODA2IF0sIFsgMTM3LjQxNDQ1MTI3OCwgMzQuNyBdLCBbIDEzNy40MTQ0NDU4MzMsIDM0LjcwMDA1ODAyOCBdLCBbIDEzNy40MTQ0NDAzODksIDM0LjcwMDExNjA4MyBdLCBbIDEzNy40MTQ0MjgwNTYsIDM0LjcwMDI0NzI1IF0sIFsgMTM3LjQxNDQxOTIyMiwgMzQuNzAwMjgyNDQ0IF0sIFsgMTM3LjQxNDM5NDUyOCwgMzQuNzAwNDIwMDU2IF0sIFsgMTM3LjQxNDM4MTUyOCwgMzQuNzAwNDIzODYxIF0gXSwgWyBbIDEzNy40MDM0OTg0NzIsIDM0LjcwMTcwODM2MSBdLCBbIDEzNy40MDM0ODE5NDQsIDM0LjcwMTcyMzQ0NCBdLCBbIDEzNy40MDM0Nzc5MTcsIDM0LjcwMTcyNzA1NiBdLCBbIDEzNy40MDM0NjYxNjcsIDM0LjcwMTc0MDc3OCBdLCBbIDEzNy40MDM0NTc0NzIwMDAwMTQsIDM0LjcwMTc1MzYxMSBdLCBbIDEzNy40MDM0MDYzNjEsIDM0LjcwMTgyODQ0NCBdLCBbIDEzNy40MDMyODc0NDQsIDM0LjcwMjAwMzAyOCBdLCBbIDEzNy40MDMzMDkzMDYwMDAwMTEsIDM0LjcwMjAxMzI1IF0sIFsgMTM3LjQwMzQ3OTMzMywgMzQuNzAxNzYzODMzIF0sIFsgMTM3LjQwMzQ4NzQ3MiwgMzQuNzAxNzUxOTE3IF0sIFsgMTM3LjQwMzUwMTk0NCwgMzQuNzAxNzM1MDI4IF0sIFsgMTM3LjQwMzUyNDUsIDM0LjcwMTkwODg4OSBdLCBbIDEzNy40MDM1NDc2ODczNzE5OTcsIDM0LjcwMjEwNjQzNjcwNTU5OCBdLCBbIDEzNy40MDM1NDg1NTYsIDM0LjcwMjExMzgzMyBdLCBbIDEzNy40MDM1OTc4MDYsIDM0LjcwMjUxMTU4MyBdLCBbIDEzNy40MDM2MzM0NzIsIDM0LjcwMjc5OSBdLCBbIDEzNy40MDM2Nzc4MzI5OTk5ODksIDM0LjcwMzE1OTUyOCBdLCBbIDEzNy40MDM2NzM0NzIsIDM0LjcwMzE1OTcyMiBdLCBbIDEzNy40MDM2NzQ5MTY5OTk5ODksIDM0LjcwMzE3NzkxNyBdLCBbIDEzNy40MDM2MDUzNDg3NjE5OTksIDM0LjcwMzIzNTQ0MzI4NTEwMiBdLCBbIDEzNy40MDM1MDI0MTcsIDM0LjcwMzMyMDYxMSBdLCBbIDEzNy40MDMyNTkyNzczNDQwMDYsIDM0LjcwMzMzNjAwMzE3MjA5NyBdLCBbIDEzNy40MDIyMDY1ODMsIDM0LjcwMzQwMjYzOSBdLCBbIDEzNy40MDIxOTEwNTYsIDM0LjcwMzM5MzkxNyBdLCBbIDEzNy40MDIxODE2MzksIDM0LjcwMzM4NDAyOCBdLCBbIDEzNy40MDIxNzUyNzc5OTk5ODcsIDM0LjcwMzM3NDQ3MiBdLCBbIDEzNy40MDIxNDksIDM0LjcwMzMwMzEzOSBdLCBbIDEzNy40MDIxMjQwMDU2NjU5OTYsIDM0LjcwMzIzNTQ0MzI4NTEwMiBdLCBbIDEzNy40MDIwNzk4MDU5OTk5ODksIDM0LjcwMzExNTU4MyBdLCBbIDEzNy40MDE5NTA4NjA5OTk5ODksIDM0LjcwMjc2NTUgXSwgWyAxMzcuNDAxOTQ5NzUsIDM0LjcwMjc1ODgzMyBdLCBbIDEzNy40MDE5NTA3MjIsIDM0LjcwMjc1MjA1NiBdLCBbIDEzNy40MDE5NTMyMjIsIDM0LjcwMjc0NjgzMyBdLCBbIDEzNy40MDIxNTI4MzMsIDM0LjcwMjQ5NjE2NyBdLCBbIDEzNy40MDI2NDEyNzgsIDM0LjcwMjc1MzYxMSBdLCBbIDEzNy40MDI2NTU5NzIsIDM0LjcwMjczNDU1NiBdLCBbIDEzNy40MDIxNjc3MjIsIDM0LjcwMjQ3NzMwNiBdLCBbIDEzNy40MDIzNzkwNTYsIDM0LjcwMjIxMTg2MSBdLCBbIDEzNy40MDIzNzQ0NzIsIDM0LjcwMjIwOTMzMyBdLCBbIDEzNy40MDIzOTM0OTk5OTk5ODgsIDM0LjcwMjE4NTU4MyBdLCBbIDEzNy40MDI0NTY2MDY0NTQ5OSwgMzQuNzAyMTA2NDM2NzA1NTk4IF0sIFsgMTM3LjQwMjY3NzA4Mjk5OTk4NiwgMzQuNzAxODI5OTQ0IF0sIFsgMTM3LjQwMjc1NzExMSwgMzQuNzAxNzI0ODMzIF0sIFsgMTM3LjQwMjgzOTAyNzk5OTk4OCwgMzQuNzAxNjE3MzA2IF0sIFsgMTM3LjQwMzA5ODk3MiwgMzQuNzAxMjkwMjc4IF0sIFsgMTM3LjQwMzEwMjMzMywgMzQuNzAxMjg2MDI4IF0sIFsgMTM3LjQwMzE1Njk0Mzk5OTk4OCwgMzQuNzAxMjE3MjUgXSwgWyAxMzcuNDAzMjE3MTk0LCAzNC43MDExNDEyMjIgXSwgWyAxMzcuNDAzMjIzNTI4MDAwMDEyLCAzNC43MDExMzc2OTQgXSwgWyAxMzcuNDAzMjI5OTcyLCAzNC43MDExMzUzMzMgXSwgWyAxMzcuNDAzMjM2NSwgMzQuNzAxMTM0MjIyIF0sIFsgMTM3LjQwMzI0MzI3OCwgMzQuNzAxMTM0MjIyIF0sIFsgMTM3LjQwMzI1MDE2NzAwMDAxLCAzNC43MDExMzU0NzIgXSwgWyAxMzcuNDAzMjU3MjUsIDM0LjcwMTEzNzg4OSBdLCBbIDEzNy40MDMyNTkyNzczNDQwMDYsIDM0LjcwMTEzOTI1NTI2MzIgXSwgWyAxMzcuNDAzNDE3MTM5LCAzNC43MDEyNDQyMjIgXSwgWyAxMzcuNDAzNDIzODMzLCAzNC43MDEyNTA4ODkgXSwgWyAxMzcuNDAzNDI5NzQ5OTk5OTg3LCAzNC43MDEyNTggXSwgWyAxMzcuNDAzNDM0NjY3LCAzNC43MDEyNjUzODkgXSwgWyAxMzcuNDAzNDM5NjExMDAwMDEsIDM0LjcwMTI3NTE5NCBdLCBbIDEzNy40MDM0NDMwMjgsIDM0LjcwMTI4NTYzOSBdLCBbIDEzNy40MDM0NDUxMzkwMDAwMTMsIDM0LjcwMTI5NjYzOSBdLCBbIDEzNy40MDM0NDgxMzksIDM0LjcwMTMxOTg4OSBdLCBbIDEzNy40MDM0NzQ3MjIsIDM0LjcwMTUyNTAyOCBdLCBbIDEzNy40MDM0OTM4MDYsIDM0LjcwMTY3MTc1IF0sIFsgMTM3LjQwMzQ5ODQ3MiwgMzQuNzAxNzA4MzYxIF0gXSwgWyBbIDEzNy40MDM1MTAzNjEsIDM0LjcwMzYxMzQxNyBdLCBbIDEzNy40MDM0OTk4MzMwMDAwMTIsIDM0LjcwMzYzMjM2MSBdLCBbIDEzNy40MDM0ODM1LCAzNC43MDM2NTEzMzMgXSwgWyAxMzcuNDAzNDU4ODg5LCAzNC43MDM2NzY1MjggXSwgWyAxMzcuNDAzNDQ0NTI4LCAzNC43MDM2OTAwODMgXSwgWyAxMzcuNDAzNDM0NzIxOTk5OTg2LCAzNC43MDM2OTU5NDQgXSwgWyAxMzcuNDAzNDIwODg4OTk5OTg5LCAzNC43MDM3MDU1MjggXSwgWyAxMzcuNDAzNDExNDE3LCAzNC43MDM3MTY1NTYgXSwgWyAxMzcuNDAzNDA0NDcyLCAzNC43MDM3Mjc1NTYgXSwgWyAxMzcuNDAzMzk5ODA2MDAwMDEsIDM0LjcwMzczOTc1IF0sIFsgMTM3LjQwMzQyMTg2MSwgMzQuNzAzNzQ1Mzg5IF0sIFsgMTM3LjQwMzQyNTg4OSwgMzQuNzAzNzM0ODMzIF0sIFsgMTM3LjQwMzQzMTExMSwgMzQuNzAzNzI2NTI4IF0sIFsgMTM3LjQwMzQzNzk0NCwgMzQuNzAzNzE4NTgzIF0sIFsgMTM3LjQwMzQ0ODk0NCwgMzQuNzAzNzEwOTcyIF0sIFsgMTM3LjQwMzQ2MDE5NCwgMzQuNzAzNzA0MTk0IF0sIFsgMTM3LjQwMzQ3NjUwMDAwMDAxMSwgMzQuNzAzNjg4ODMzIF0sIFsgMTM3LjQwMzUwMTg2MSwgMzQuNzAzNjYyODMzIF0sIFsgMTM3LjQwMzUxOTk0NDAwMDAxLCAzNC43MDM2NDE4ODkgXSwgWyAxMzcuNDAzNTMyMDgyOTk5OTg4LCAzNC43MDM2MTk5NDQgXSwgWyAxMzcuNDAzNTQyNTgyOTk5OTg5LCAzNC43MDM1ODc1NTYgXSwgWyAxMzcuNDAzNTc3MzYxLCAzNC43MDMzNzc0NDQgXSwgWyAxMzcuNDAzNjk3NjkzOTk5OTg3LCAzNC43MDMzOTExOTQgXSwgWyAxMzcuNDAzNjUxOTcyLCAzNC43MDM2NTk2NjcgXSwgWyAxMzcuNDAzNjg0Mzg5LCAzNC43MDM2NjMzODkgXSwgWyAxMzcuNDAzNzMwMTM5LCAzNC43MDMzOTQ4MDYgXSwgWyAxMzcuNDA0MTQwMDU1OTk5OTg5LCAzNC43MDM0NDE1MjggXSwgWyAxMzcuNDA0MjAyMDgzLCAzNC43MDM0NDk4MDYgXSwgWyAxMzcuNDA0MjQzMzYxLCAzNC43MDM0NTc0NzIgXSwgWyAxMzcuNDA0NDkyMzA2LCAzNC43MDM1MTY3NSBdLCBbIDEzNy40MDQ1NTAzMzMsIDM0LjcwMzUzMTUgXSwgWyAxMzcuNDA0NjMyNTY4MzU5MDA2LCAzNC43MDM1NTI0Mjk4MzIwMDEgXSwgWyAxMzcuNDA0NzU1MjUsIDM0LjcwMzU4MzY2NyBdLCBbIDEzNy40MDQ3OTQ1ODMwMDAwMTIsIDM0LjcwMzU5MzY5NCBdLCBbIDEzNy40MDQ4ODgwODMsIDM0LjcwMzYwODkxNyBdLCBbIDEzNy40MDQ5NjQ3MjE5OTk5ODgsIDM0LjcwMzYxNzc3OCBdLCBbIDEzNy40MDUwMjYxOTM5OTk5ODcsIDM0LjcwMzYxOTM4OSBdLCBbIDEzNy40MDUxMDExNjcsIDM0LjcwMzYxNjE2NyBdLCBbIDEzNy40MDUyODExMTEsIDM0LjcwMzU5NTI1IF0sIFsgMTM3LjQwNTMyNzcyMjAwMDAxLCAzNC43MDM1ODkxMzkgXSwgWyAxMzcuNDA1MzQyNDcyLCAzNC43MDM1OTk2MzkgXSwgWyAxMzcuNDA1MzM4NjM5LCAzNC43MDM3ODM3NSBdLCBbIDEzNy40MDUwMDIzMDYsIDM0LjcwMzc0MDEzOSBdLCBbIDEzNy40MDQ5OTQ2NjcwMDAwMTEsIDM0LjcwMzc4MDE5NCBdLCBbIDEzNy40MDUzMzc3Nzc5OTk5ODksIDM0LjcwMzgyNDc3OCBdLCBbIDEzNy40MDUzMzE1MjgsIDM0LjcwNDExOTc1IF0sIFsgMTM3LjQwNTMwNTA1NiwgMzQuNzA0MTM3NjY3IF0sIFsgMTM3LjQwNDk1OTExMTAwMDAxMSwgMzQuNzA0MDk3MTM5IF0sIFsgMTM3LjQwNDg2MjI1LCAzNC43MDQwODU3NzggXSwgWyAxMzcuNDA0NjQ5OTcxOTk5OTg3LCAzNC43MDQwNjA4NjEgXSwgWyAxMzcuNDA0NjMyNTY4MzU5MDA2LCAzNC43MDQwNTg4Mzc2MDk5OTkgXSwgWyAxMzcuNDA0NDY0NTU2LCAzNC43MDQwMzkwNTYgXSwgWyAxMzcuNDA0MTY3MDU2LCAzNC43MDQwMDQxMzkgXSwgWyAxMzcuNDA0MDk2MTM4OTk5OTg5LCAzNC43MDM5OTU4MzMgXSwgWyAxMzcuNDA0MDc2ODg5LCAzNC43MDM5OTM1NTYgXSwgWyAxMzcuNDA0MDI5Mzg4OTk5OTg3LCAzNC43MDM5ODc5NzIgXSwgWyAxMzcuNDAzODgzOTQ0LCAzNC43MDM5NzEwMjggXSwgWyAxMzcuNDAzNTkzNDE3LCAzNC43MDM5MzcxNjcgXSwgWyAxMzcuNDAzNDg1ODYxLCAzNC43MDM5MjQ2MzkgXSwgWyAxMzcuNDAzMjU5Mjc3MzQ0MDA2LCAzNC43MDM4OTgyMzYyNDAxIF0sIFsgMTM3LjQwMjk4MDExMSwgMzQuNzAzODY1Njk0IF0sIFsgMTM3LjQwMjk2NTMzMywgMzQuNzAzODUwNzUgXSwgWyAxMzcuNDAyOTgxMDI4LCAzNC43MDM4Mzk3MjIgXSwgWyAxMzcuNDAyOTk3NTgzLCAzNC43MDM4MjYxNjcgXSwgWyAxMzcuNDAzMTkzNjY3MDAwMDExLCAzNC43MDM2NTIyNSBdLCBbIDEzNy40MDMyNTkyNzczNDQwMDYsIDM0LjcwMzU5NDA0MzI5NjgwMyBdLCBbIDEzNy40MDMyNTk4ODksIDM0LjcwMzU5MzUyOCBdLCBbIDEzNy40MDMzNTkwODMsIDM0LjcwMzUxMDExMSBdLCBbIDEzNy40MDM1MTc4NjEwMDAwMTIsIDM0LjcwMzM3MDYxMSBdLCBbIDEzNy40MDM1NTQ0NDQsIDM0LjcwMzM3NDc3OCBdLCBbIDEzNy40MDM1MTk4ODksIDM0LjcwMzU4MzgzMyBdLCBbIDEzNy40MDM1MTAzNjEsIDM0LjcwMzYxMzQxNyBdIF0sIFsgWyAxMzcuNDA4ODcwMTM4OTk5OTg3LCAzNC43MDE4NzU4MzMgXSwgWyAxMzcuNDA4ODYxNjExLCAzNC43MDE4NzAxOTQgXSwgWyAxMzcuNDA4ODUxNzUsIDM0LjcwMTg1Nzc1IF0sIFsgMTM3LjQwODg0NDUyOCwgMzQuNzAxODQ2ODYxIF0sIFsgMTM3LjQwODg0NjA1NTk5OTk4NywgMzQuNzAxODE0Nzc4IF0sIFsgMTM3LjQwODg0MzE0NDIwNTM3NywgMzQuNzAxODE0NjcxMzgwMzE5IF0sIFsgMTM3LjQwODk0NTM3MDA2ODQ5NCwgMzQuNzAxMTk5MjA1OTU0MzAzIF0sIFsgMTM3LjQwODk5NjUwNjYzNjYxMiwgMzQuNzAxMjA1MDU5NzY2MzczIF0sIFsgMTM3LjQwOTAwMTgwNiwgMzQuNzAxMTYzODMzIF0sIFsgMTM3LjQwOTExOTE2NywgMzQuNzAxMTczMzMzIF0sIFsgMTM3LjQwOTE0NTY2NywgMzQuNzAxMjAyNSBdLCBbIDEzNy40MDk0NjM0OTk5OTk5ODcsIDM0LjcwMTIyNjAyOCBdLCBbIDEzNy40MDk1NzE2MzEyMDMyNDksIDM0LjcwMTM0MTI5MzgyMTIwMSBdLCBbIDEzNy40MDk1MTIyMjE5OTk5ODksIDM0LjcwMTY4Nzg2MSBdLCBbIDEzNy40MDkyMDY3MjIsIDM0LjcwMTY2MTUyOCBdLCBbIDEzNy40MDkyMzQ2MzksIDM0LjcwMTQ2OTA4MyBdLCBbIDEzNy40MDkxNjk2NjY5OTk5ODYsIDM0LjcwMTQ2MjUyOCBdLCBbIDEzNy40MDkxMzM3MjIsIDM0LjcwMTcwOTYxMSBdLCBbIDEzNy40MDkxNjQ2MTEsIDM0LjcwMTcxMjI3OCBdLCBbIDEzNy40MDk1MDMsIDM0LjcwMTc0MTQxNyBdLCBbIDEzNy40MDk0NzE1NTYsIDM0LjcwMTkyNDc3OCBdLCBbIDEzNy40MDk0MTkwNTYsIDM0LjcwMTkzMjcyMiBdLCBbIDEzNy40MDkyNDkzODksIDM0LjcwMTkxNzExMSBdLCBbIDEzNy40MDkxNjI5MTcsIDM0LjcwMTkwODk3MiBdLCBbIDEzNy40MDkwNjk3NzgsIDM0LjcwMTg5OTc3OCBdLCBbIDEzNy40MDg5NzQ2NjcsIDM0LjcwMTg5MDMzMyBdLCBbIDEzNy40MDg5Mzc1MjgsIDM0LjcwMTg4NzA1NiBdLCBbIDEzNy40MDg4Nzg0NzIsIDM0LjcwMTg4MDg4OSBdLCBbIDEzNy40MDg4NzAxMzg5OTk5ODcsIDM0LjcwMTg3NTgzMyBdIF0sIFsgWyAxMzcuNDA4NTYyODMzLCAzNC43MDA4NDcxOTQgXSwgWyAxMzcuNDA4NTUwMDgzLCAzNC43MDA5MzM0MTcgXSwgWyAxMzcuNDA4MzMzMzMzLCAzNC43MDA5MTM0NDQgXSwgWyAxMzcuNDA3ODU2MDgzMDAwMDEzLCAzNC43MDA4Njk1IF0sIFsgMTM3LjQwNzc1MTI1LCAzNC43MDA4NTgxNjcgXSwgWyAxMzcuNDA3NzQ3NjExLCAzNC43MDA4Nzk2MzkgXSwgWyAxMzcuNDA3ODQ4NzIyMDAwMDExLCAzNC43MDA4OTA1MjggXSwgWyAxMzcuNDA3ODUzODYxLCAzNC43MDA4OTEwNTYgXSwgWyAxMzcuNDA3ODUyMjc4LCAzNC43MDA5MDcxOTQgXSwgWyAxMzcuNDA3NDU2MjIyLCAzNC43MDA4NjU4ODkgXSwgWyAxMzcuNDA3Mzc5MTUwMzkwOTk0LCAzNC43MDA4NTYyNTkyMDcyIF0sIFsgMTM3LjQwNzM3ODkxNjk5OTk4OCwgMzQuNzAwODU2MjIyIF0sIFsgMTM3LjQwNzMzODk0NCwgMzQuNzAwODUyMDU2IF0sIFsgMTM3LjQwNzMwNzMwNiwgMzQuNzAwODUyNzUgXSwgWyAxMzcuNDA3MjYxNjk0LCAzNC43MDA4NjA2NjcgXSwgWyAxMzcuNDA3MjI0MDgyOTk5OTg4LCAzNC43MDA4NzI4MzMgXSwgWyAxMzcuNDA3MTkzNjY3LCAzNC43MDA4ODg1ODMgXSwgWyAxMzcuNDA3MTU5NTU2MDAwMDExLCAzNC43MDA5MDgyMjIgXSwgWyAxMzcuNDA3MDg3MTk0MDAwMDEzLCAzNC43MDA5NTI2OTQgXSwgWyAxMzcuNDA3MDcwODYxLCAzNC43MDA5NTk4NjEgXSwgWyAxMzcuNDA3MDUzNzIyLCAzNC43MDA5NjUzMDYgXSwgWyAxMzcuNDA3MDMxMzYxLCAzNC43MDA5NjgyMjIgXSwgWyAxMzcuNDA3MDA2Nzc4MDAwMDEsIDM0LjcwMDk2NjM4OSBdLCBbIDEzNy40MDY5OTE2MTEsIDM0LjcwMDk2Mzk3MiBdLCBbIDEzNy40MDY5OTY2OTM5OTk5ODYsIDM0LjcwMDk0NDUgXSwgWyAxMzcuNDA3MDA0NTgzLCAzNC43MDA5MTc2MTEgXSwgWyAxMzcuNDA3MDE0MTExLCAzNC43MDA4ODkxMTEgXSwgWyAxMzcuNDA3MDIxODg5LCAzNC43MDA4NjY3NSBdLCBbIDEzNy40MDcwMzMxNjcsIDM0LjcwMDgzNjQxNyBdLCBbIDEzNy40MDcwNDMyMjIsIDM0LjcwMDgxMDA4MyBdLCBbIDEzNy40MDcwNTUwNTYsIDM0LjcwMDc4MTQ3MiBdLCBbIDEzNy40MDcwNjYzMzI5OTk5ODksIDM0LjcwMDc1NTUgXSwgWyAxMzcuNDA3MDc4Njk0LCAzNC43MDA3MjU2MzkgXSwgWyAxMzcuNDA3MDkxNTgzMDAwMDEsIDM0LjcwMDY5NjU4MyBdLCBbIDEzNy40MDcxMDU2OTQsIDM0LjcwMDY2NTI3OCBdLCBbIDEzNy40MDcxMjEwODMsIDM0LjcwMDYzMjY5NCBdLCBbIDEzNy40MDcxMzQsIDM0LjcwMDYwNDYzOSBdLCBbIDEzNy40MDcxNTAyNzc5OTk5ODksIDM0LjcwMDU2OTcyMiBdLCBbIDEzNy40MDcxNzI5NzIwMDAwMTIsIDM0LjcwMDUyNjMwNiBdLCBbIDEzNy40MDcxOTgxMzksIDM0LjcwMDQ3NTc3OCBdLCBbIDEzNy40MDcyMjE2OTM5OTk5ODYsIDM0LjcwMDQyODgzMyBdLCBbIDEzNy40MDcyNDM1MjgsIDM0LjcwMDM4ODMzMyBdLCBbIDEzNy40MDcyNjAwMjgsIDM0LjcwMDM1ODQ0NCBdLCBbIDEzNy40MDcyNzIwODMsIDM0LjcwMDMzNTA4MyBdLCBbIDEzNy40MDcyNzQ0NzIwMDAwMTIsIDM0LjcwMDMzMDM4OSBdLCBbIDEzNy40MDczMDAwODMsIDM0LjcwMDI4MzE5NCBdLCBbIDEzNy40MDczMTg3NSwgMzQuNzAwMjQ4MTY3IF0sIFsgMTM3LjQwNzM3OTE1MDM5MDk5NCwgMzQuNzAwMjUzNjMwOTEwMjk2IF0sIFsgMTM3LjQwNzczNTQxNywgMzQuNzAwMjg1OTE3IF0sIFsgMTM3LjQwODE1MDI1LCAzNC43MDA1MjgyNSBdLCBbIDEzNy40MDgxODgzMDYsIDM0LjcwMDU0OTgwNiBdLCBbIDEzNy40MDgyMjE0NDQsIDM0LjcwMDU2NzMzMyBdLCBbIDEzNy40MDgyODQ1ODMwMDAwMTEsIDM0LjcwMDU5MSBdLCBbIDEzNy40MDgzMzMzMzMsIDM0LjcwMDYwMDM4OSBdLCBbIDEzNy40MDgzNDEwNTYwMDAwMTIsIDM0LjcwMDYwMTg4OSBdLCBbIDEzNy40MDgzOTA3NSwgMzQuNzAwNjA4NTU2IF0sIFsgMTM3LjQwODQ0MjUsIDM0LjcwMDYxMDYxMSBdLCBbIDEzNy40MDg1OTM5NDM5OTk5ODksIDM0LjcwMDYyNDkxNyBdLCBbIDEzNy40MDg1OTc3NzgsIDM0LjcwMDU5MzUyOCBdLCBbIDEzNy40MDg3NTI0NDE0MDU5OTQsIDM0LjcwMDYwODExNjE1NzM5NyBdLCBbIDEzNy40MDkyOTY5MTcsIDM0LjcwMDY1OTQ3MiBdLCBbIDEzNy40MDkzMDg0MTcsIDM0LjcwMDU2NjEzOSBdLCBbIDEzNy40MDk0MTY2NjY5OTk5ODgsIDM0LjcwMDQ0MjI1IF0sIFsgMTM3LjQwOTQ2NjE5NCwgMzQuNzAwNDI5ODg5IF0sIFsgMTM3LjQwOTU4Mzc3ODAwMDAxMiwgMzQuNzAwNDM4MjIyIF0sIFsgMTM3LjQwOTYxMTI3OCwgMzQuNzAwNDMzNzUgXSwgWyAxMzcuNDA5NjI0NzUsIDM0LjcwMDQ1MjgzMyBdLCBbIDEzNy40MDk1OTUyMjIsIDM0LjcwMDY1NiBdLCBbIDEzNy40MDk1NjU5NDQsIDM0LjcwMDY4MjY2NyBdLCBbIDEzNy40MDk0MDMxMzksIDM0LjcwMDY2ODI3OCBdLCBbIDEzNy40MDkzNTgyMjIsIDM0LjcwMDkxMzQxNyBdLCBbIDEzNy40MDkzMDc2NjcsIDM0LjcwMDkzODgzMyBdLCBbIDEzNy40MDkxODA4ODksIDM0LjcwMDkyNTExMSBdLCBbIDEzNy40MDkxODIxNjcwMDAwMTIsIDM0LjcwMDkxNTAyOCBdLCBbIDEzNy40MDkxMjYzNjEsIDM0LjcwMDkxMTI1IF0sIFsgMTM3LjQwOTExMzAwMzY1Mzk5OSwgMzQuNzAwOTc3NDE0NzIwMSBdLCBbIDEzNy40MDkxMTA1NTYsIDM0LjcwMDk4OTYzOSBdLCBbIDEzNy40MDkwOTQxOTQsIDM0LjcwMDk4ODE2NyBdLCBbIDEzNy40MDg5NzQxNjQ3ODYwMDIsIDM0LjcwMDk3NzQxNDcyMDEgXSwgWyAxMzcuNDA4ODYyMTY3LCAzNC43MDA5Njc0MTcgXSwgWyAxMzcuNDA4ODY0NzIyLCAzNC43MDA5NDUwMjggXSwgWyAxMzcuNDA4Nzg3NjExLCAzNC43MDA5MjkxMzkgXSwgWyAxMzcuNDA4Nzg1MzMzLCAzNC43MDA5NDMzMDYgXSwgWyAxMzcuNDA4NzUyNDQxNDA1OTk0LCAzNC43MDA5Mzk0MDAyNzkwOTcgXSwgWyAxMzcuNDA4NjA5NzUwMDAwMDExLCAzNC43MDA5MjI0NzIgXSwgWyAxMzcuNDA4NjIxMzYxLCAzNC43MDA4NTQ5MTcgXSwgWyAxMzcuNDA4NTYyODMzLCAzNC43MDA4NDcxOTQgXSBdLCBbIFsgMTM3LjQwNzQ3NjUsIDM0LjY5OTMxMzYxMSBdLCBbIDEzNy40MDc0NjczNjA5OTk5ODgsIDM0LjY5OTMxNTY5NCBdLCBbIDEzNy40MDc0NjUyMjIwMDAwMTMsIDM0LjY5OTI5NDYxMSBdLCBbIDEzNy40MDc0NTM4NjEsIDM0LjY5OTE4MTY2NyBdLCBbIDEzNy40MDc0NTM4NjEsIDM0LjY5OTE4MTQxNyBdLCBbIDEzNy40MDc0NDc5NDQwMDAwMTIsIDM0LjY5OTEzODk0NCBdLCBbIDEzNy40MDc0MzI5MTcsIDM0LjY5OTAzMTY5NCBdLCBbIDEzNy40MDc0MzI5MTcsIDM0LjY5OTAzMTQ0NCBdLCBbIDEzNy40MDc0MjEyNzc5OTk5ODcsIDM0LjY5ODkzMzExMSBdLCBbIDEzNy40MDc0MDM0NzIsIDM0LjY5ODc4MjY2NyBdLCBbIDEzNy40MDczOTY2MTk4MDM5OSwgMzQuNjk4NzE5MzI0NTMyMjk4IF0sIFsgMTM3LjQwNzM5NTUsIDM0LjY5ODcwOTEzOSBdLCBbIDEzNy40MDczOTIzODksIDM0LjY5ODY4MDM4OSBdLCBbIDEzNy40MDczODkxMzksIDM0LjY5ODY1MDgwNiBdLCBbIDEzNy40MDczODY1ODMsIDM0LjY5ODYyMjYxMSBdLCBbIDEzNy40MDczNzkxNTAzOTA5OTQsIDM0LjY5ODU0MDM5NDgyODQ5OCBdLCBbIDEzNy40MDczNjIwNTYwMDAwMTEsIDM0LjY5ODM1MTM4OSBdLCBbIDEzNy40MDczNzkxNTAzOTA5OTQsIDM0LjY5ODMzNjkyMDE4OTM5OCBdLCBbIDEzNy40MDczODg0MTcsIDM0LjY5ODMyOTI1IF0sIFsgMTM3LjQwNzQ1MjM2MSwgMzQuNjk4MzI2MjIyIF0sIFsgMTM3LjQwNzYyMzE2NywgMzQuNjk4MzExNzIyIF0sIFsgMTM3LjQwNzY2MDA4MywgMzQuNjk4MzA4NTgzIF0sIFsgMTM3LjQwODA0OTc3OCwgMzQuNjk4Mjc1NDcyIF0sIFsgMTM3LjQwODEzNDQxNzAwMDAxNCwgMzQuNjk4MjY4Mjc4IF0sIFsgMTM3LjQwODE3NTg4OSwgMzQuNjk4MjY0NzUgXSwgWyAxMzcuNDA4MTkxODA2LCAzNC42OTgyNjM0NzIgXSwgWyAxMzcuNDA4MjUyNSwgMzQuNjk4MjU4MzA2IF0sIFsgMTM3LjQwODMzMzMzMywgMzQuNjk4MjU0IF0sIFsgMTM3LjQwODM4Nzk0NCwgMzQuNjk4MjUxMDgzIF0sIFsgMTM3LjQwODU1MDUyOCwgMzQuNjk4MjM3MTM5IF0sIFsgMTM3LjQwODU2NjYxMSwgMzQuNjk4MjQ2NDE3IF0sIFsgMTM3LjQwODU5Njg2MSwgMzQuNjk4NDgxNjM5IF0sIFsgMTM3LjQwODYwNzkxNzAwMDAxMiwgMzQuNjk4NTU5Njk0IF0sIFsgMTM3LjQwODYxNjI1LCAzNC42OTg2MTg1NTYgXSwgWyAxMzcuNDA4NjI1Mjc3OTk5OTg4LCAzNC42OTg2ODIzNjEgXSwgWyAxMzcuNDA4NjMxMjY1NzEzMDEyLCAzNC42OTg3MTkzMjQ1MzIyOTggXSwgWyAxMzcuNDA4NjYyNTI4LCAzNC42OTg5MTI1MjggXSwgWyAxMzcuNDA4NjY4NDQ0LCAzNC42OTg5NTk0NzIgXSwgWyAxMzcuNDA4NjksIDM0LjY5OTEyOTU1NiBdLCBbIDEzNy40MDg2NjQ4MzI5OTk5ODksIDM0LjY5OTE0MzIyMiBdLCBbIDEzNy40MDg1OTcwMjgsIDM0LjY5OTE3NzQxNyBdLCBbIDEzNy40MDg0OTY0NDQsIDM0LjY5OTIyODExMSBdLCBbIDEzNy40MDgzOTM1NTYsIDM0LjY5OTI4MDA1NiBdLCBbIDEzNy40MDgzMzMzMzMsIDM0LjY5OTMxMTY2NyBdLCBbIDEzNy40MDgxNzA3NzgsIDM0LjY5OTM5Njk3MiBdLCBbIDEzNy40MDgwOTk2MTEwMDAwMTEsIDM0LjY5OTQzNDM2MSBdLCBbIDEzNy40MDgwODI4MzMsIDM0LjY5OTQ0MzE2NyBdLCBbIDEzNy40MDgwMzksIDM0LjY5OTQ2NjIyMiBdLCBbIDEzNy40MDgwMDU4MzMsIDM0LjY5OTQ4MjcyMiBdLCBbIDEzNy40MDc5MzcxOTQsIDM0LjY5OTUxNjg4OSBdLCBbIDEzNy40MDc1MjMyMjIsIDM0LjY5OTcyMjg4OSBdLCBbIDEzNy40MDc1MDMwNTYsIDM0LjY5OTU0NTY5NCBdLCBbIDEzNy40MDc0ODM5MTcsIDM0LjY5OTM3ODE5NCBdLCBbIDEzNy40MDc0NzY1LCAzNC42OTkzMTM2MTEgXSBdLCBbIFsgMTM3LjQxMjUwNzkxNywgMzQuNzAyMTc2Njk0IF0sIFsgMTM3LjQxMjU1MjI4NTI5ODAwNSwgMzQuNzAyMTA2NDM2NzA1NTk4IF0sIFsgMTM3LjQxMjU1NDcyMjAwMDAxLCAzNC43MDIxMDI1IF0sIFsgMTM3LjQxMjU2MjExMSwgMzQuNzAyMDkwMDU2IF0sIFsgMTM3LjQxMjU3MzY5NCwgMzQuNzAyMDcwNSBdLCBbIDEzNy40MTI3MTYzNjEsIDM0LjcwMTgyOTYzOSBdLCBbIDEzNy40MTI3Mjg4MzI5OTk5ODksIDM0LjcwMTgwNzQ0NCBdLCBbIDEzNy40MTI4NzIzMTQ0NTMwMTEsIDM0LjcwMTg2NzU5NjE4MTMwMiBdLCBbIDEzNy40MTI5MjE3NTAwMDAwMSwgMzQuNzAxODg4MzYxIF0sIFsgMTM3LjQxMzA4NDgzMywgMzQuNzAxOTU5IF0sIFsgMTM3LjQxMzA5MzE5NCwgMzQuNzAxOTQ0OTE3IF0sIFsgMTM3LjQxMjg5MzA1NiwgMzQuNzAxODU3NTgzIF0sIFsgMTM3LjQxMjg3MjMxNDQ1MzAxMSwgMzQuNzAxODQ4ODI1NjY4NTk4IF0sIFsgMTM3LjQxMjczNzYzOSwgMzQuNzAxNzkxOTE3IF0sIFsgMTM3LjQxMjc4NjYxMSwgMzQuNzAxNzA1IF0sIFsgMTM3LjQxMjgwNDQxNywgMzQuNzAxNjczNSBdLCBbIDEzNy40MTI4NzIzMTQ0NTMwMTEsIDM0LjcwMTU1MzE3MDgyNzQwMyBdLCBbIDEzNy40MTI5NTE2NjY5OTk5ODcsIDM0LjcwMTQxMjU4MyBdLCBbIDEzNy40MTI5NjI5NzIsIDM0LjcwMTM5MzYxMSBdLCBbIDEzNy40MTM0MTY4ODksIDM0LjcwMTcwMzcyMiBdLCBbIDEzNy40MTM0NTY2OTQsIDM0LjcwMTcyOTYxMSBdLCBbIDEzNy40MTM0NTg1ODMsIDM0LjcwMTczMzY2NyBdLCBbIDEzNy40MTM0NjcwMjgwMDAwMTQsIDM0LjcwMTc0NjYzOSBdLCBbIDEzNy40MTM0MTYzNjEsIDM0LjcwMTc4MDI3OCBdLCBbIDEzNy40MTM0MTI2MzksIDM0LjcwMTc4MjUyOCBdLCBbIDEzNy40MTMzMjY2NjcsIDM0LjcwMTgyOTU4MyBdLCBbIDEzNy40MTMzMTU1NTU5OTk5ODYsIDM0LjcwMTgzNDE5NCBdLCBbIDEzNy40MTMzMDMsIDM0LjcwMTgzNjIyMiBdLCBbIDEzNy40MTMyODk4ODksIDM0LjcwMTgzNjI1IF0sIFsgMTM3LjQxMzI3NzU1NiwgMzQuNzAxODM2MjUgXSwgWyAxMzcuNDEzMjY1NjY3LCAzNC43MDE4MzUxMTEgXSwgWyAxMzcuNDEzMjI5NjExLCAzNC43MDE4Mjg3NzggXSwgWyAxMzcuNDEyOTI2MjIyMDAwMDEsIDM0LjcwMTcwNDcyMiBdLCBbIDEzNy40MTI4NzQwODMsIDM0LjcwMTY4MzM2MSBdLCBbIDEzNy40MTI4NzIzMTQ0NTMwMTEsIDM0LjcwMTY4NDcxNTY4NTkgXSwgWyAxMzcuNDEyODU2MjIxOTk5OTg4LCAzNC43MDE2OTcxMTEgXSwgWyAxMzcuNDEyODcyMzE0NDUzMDExLCAzNC43MDE3MDM5MTMwNDEzOTkgXSwgWyAxMzcuNDEyODc0NDcyLCAzNC43MDE3MDQ4MzMgXSwgWyAxMzcuNDEzMjIyMDI4LCAzNC43MDE4NDY4MzMgXSwgWyAxMzcuNDEzMjYxODg5MDAwMDEyLCAzNC43MDE4NTM3NzggXSwgWyAxMzcuNDEzMjc2MzA2LCAzNC43MDE4NTUxOTQgXSwgWyAxMzcuNDEzMjg5OTQ0MDAwMDEzLCAzNC43MDE4NTUxNjcgXSwgWyAxMzcuNDEzMzA1MTM4OTk5OTg4LCAzNC43MDE4NTUxMzkgXSwgWyAxMzcuNDEzMzIzMDI4LCAzNC43MDE4NTIzMDYgXSwgWyAxMzcuNDEzMzM4MTY3LCAzNC43MDE4NDU5NzIgXSwgWyAxMzcuNDEzNDI3OTcyLCAzNC43MDE3OTY4MzMgXSwgWyAxMzcuNDEzNDgxMTk0MDAwMDEzLCAzNC43MDE3NjE1IF0sIFsgMTM3LjQxMzUyOTQ3MiwgMzQuNzAxNzI5NDE3IF0sIFsgMTM3LjQxMzU2ODYxMDk5OTk4OCwgMzQuNzAxNzAzNDE3IF0sIFsgMTM3LjQxMzY3NTgzMzAwMDAxMywgMzQuNzAxNjMyMjUgXSwgWyAxMzcuNDEzNzA5NzIyLCAzNC43MDE2MTE0NDQgXSwgWyAxMzcuNDEzNzMxNzIyLCAzNC43MDE1OTc4ODkgXSwgWyAxMzcuNDEzNzY5LCAzNC43MDE1ODE2NjcgXSwgWyAxMzcuNDEzODA3MTY2OTk5OTg3LCAzNC43MDE1NjkwNTYgXSwgWyAxMzcuNDEzODYxMzg5LCAzNC43MDE1NTU2OTQgXSwgWyAxMzcuNDEzODg5MzA1OTk5OTg3LCAzNC43MDE1NTE0MTcgXSwgWyAxMzcuNDEzOTIzMjc4LCAzNC43MDE1NTEzMzMgXSwgWyAxMzcuNDEzOTU3Nzc4LCAzNC43MDE1NTQzMzMgXSwgWyAxMzcuNDEzOTcyNjExLCAzNC43MDE1NTY3MjIgXSwgWyAxMzcuNDE0MDI5ODYwOTk5OTg5LCAzNC43MDE1Njg4ODkgXSwgWyAxMzcuNDEzOTU4NTI4LCAzNC43MDE3MDI0NDQgXSwgWyAxMzcuNDEzOTU4NDE3LCAzNC43MDE3MDI2MzkgXSwgWyAxMzcuNDEzODYzMjc4LCAzNC43MDE4ODI0NzIgXSwgWyAxMzcuNDEzODQ0ODg4OTk5OTg5LCAzNC43MDE5MTcyNSBdLCBbIDEzNy40MTM4MjA3NTAwMDAwMTQsIDM0LjcwMTk1MzM2MSBdLCBbIDEzNy40MTM3Njk0MTcsIDM0LjcwMjA0NjEzOSBdLCBbIDEzNy40MTM3MzYwNDg4MjE5ODgsIDM0LjcwMjEwNjQzNjcwNTU5OCBdLCBbIDEzNy40MTM2MjAxOTQsIDM0LjcwMjMxNTcyMiBdLCBbIDEzNy40MTM2MDI1LCAzNC43MDIzNDc2OTQgXSwgWyAxMzcuNDEzNDU2NTgzLCAzNC43MDI2MTEzMDYgXSwgWyAxMzcuNDEzMzM0NDE2OTk5OTg3LCAzNC43MDI4MjUyNzggXSwgWyAxMzcuNDEzMzE3OTQ0LCAzNC43MDI4MjkxOTQgXSwgWyAxMzcuNDEzMjg5MDgzLCAzNC43MDI4MTYgXSwgWyAxMzcuNDEzMjkzNTI4LCAzNC43MDI4MDAwMjggXSwgWyAxMzcuNDEzMjc2NDcyLCAzNC43MDI3OTQ3NSBdLCBbIDEzNy40MTMyNjM0NzIwMDAwMTEsIDM0LjcwMjc5MDcyMiBdLCBbIDEzNy40MTMxODIzODkwMDAwMTMsIDM0LjcwMjc2MjEzOSBdLCBbIDEzNy40MTI4NzIzMTQ0NTMwMTEsIDM0LjcwMjY3Njc3MDg4NjI5OSBdLCBbIDEzNy40MTI1ODk3MjIsIDM0LjcwMjU5ODk3MiBdLCBbIDEzNy40MTI1ODI5MTcsIDM0LjcwMjU5MTg2MSBdLCBbIDEzNy40MTI1Nzk3NzgsIDM0LjcwMjU1OTY5NCBdLCBbIDEzNy40MTI1NzY2NjcsIDM0LjcwMjU0MzAyOCBdLCBbIDEzNy40MTI1NzI1ODMwMDAwMTQsIDM0LjcwMjUyNSBdLCBbIDEzNy40MTI1NjcxNjcsIDM0LjcwMjUwODUyOCBdLCBbIDEzNy40MTI1NjE0NzIsIDM0LjcwMjQ5NDQ3MiBdLCBbIDEzNy40MTI1NTc3MjIsIDM0LjcwMjQ4NzI1IF0sIFsgMTM3LjQxMjU1NDIyMjAwMDAxMSwgMzQuNzAyNDgwNDE3IF0sIFsgMTM3LjQxMjU0MTYxMSwgMzQuNzAyNDU5Njk0IF0sIFsgMTM3LjQxMjUwOTA4MywgMzQuNzAyNDI4Mzg5IF0sIFsgMTM3LjQxMjQyNTEzOSwgMzQuNzAyMzU3NDQ0IF0sIFsgMTM3LjQxMjQxOTcyMjAwMDAxLCAzNC43MDIzMzA3NSBdLCBbIDEzNy40MTI1MDc5MTcsIDM0LjcwMjE3NjY5NCBdIF0sIFsgWyAxMzcuNDA1Njc0NDE3LCAzNC42OTg3MzAwODMgXSwgWyAxMzcuNDA1Njg0ODA2MDAwMDExLCAzNC42OTg3MzQzMDYgXSwgWyAxMzcuNDA1NjkzODYxLCAzNC42OTg3Mzk5NzIgXSwgWyAxMzcuNDA1Njk3OTE3LCAzNC42OTg3NDMzMDYgXSwgWyAxMzcuNDA1NzAxNTI4LCAzNC42OTg3NDY4ODkgXSwgWyAxMzcuNDA1NzA0NjExLCAzNC42OTg3NTA3NzggXSwgWyAxMzcuNDA1NzA3ODg5MDAwMDEzLCAzNC42OTg3NTY4ODkgXSwgWyAxMzcuNDA1NzA5NjY3LCAzNC42OTg3NjM0NzIgXSwgWyAxMzcuNDA1NzA5ODg5LCAzNC42OTg3NzA1ODMgXSwgWyAxMzcuNDA1Njk4Njk0LCAzNC42OTg4MjUzMzMgXSwgWyAxMzcuNDA1NzQyODA2LCAzNC42OTg4MzExOTQgXSwgWyAxMzcuNDA1NzUwOTQ0LCAzNC42OTg3NzMyMjIgXSwgWyAxMzcuNDA1NzU3NjY2OTk5OTg5LCAzNC42OTg3NTkwNTYgXSwgWyAxMzcuNDA1NzY0NTI4LCAzNC42OTg3NTE5MTcgXSwgWyAxMzcuNDA1ODEzNTU2LCAzNC42OTg3MjEgXSwgWyAxMzcuNDA1ODEzMzY3MzY2OTg5LCAzNC42OTg3MTkzMjQ1MzIyOTggXSwgWyAxMzcuNDA1NzgzNDQ0LCAzNC42OTg0NTQ0NzIgXSwgWyAxMzcuNDA1OTAzODA2LCAzNC42OTg0NDQ3NzggXSwgWyAxMzcuNDA2MDA1ODU5Mzc1LCAzNC42OTg0MzY1NDQ5MTQzMDEgXSwgWyAxMzcuNDA2MDYyMTM5LCAzNC42OTg0MzIwMjggXSwgWyAxMzcuNDA2MDgxNSwgMzQuNjk4NDQ1NTgzIF0sIFsgMTM3LjQwNjA5Nzk3MiwgMzQuNjk4NTg1OTE3IF0sIFsgMTM3LjQwNjEwNDI3Nzk5OTk4NywgMzQuNjk4NTg1NDcyIF0sIFsgMTM3LjQwNjEyMDMzMjY4NTk4NywgMzQuNjk4NzE5MzI0NTMyMjk4IF0sIFsgMTM3LjQwNjEyMzQxNywgMzQuNjk4NzQ1MjUgXSwgWyAxMzcuNDA2MTU0MTY3MDAwMDExLCAzNC42OTkwMDI0MTcgXSwgWyAxMzcuNDA2MTcyMTk0LCAzNC42OTkxNTMgXSwgWyAxMzcuNDA2MTg3NTI4LCAzNC42OTkyNTMwNTYgXSwgWyAxMzcuNDA2MjAzLCAzNC42OTkzOTIzMDYgXSwgWyAxMzcuNDA2MTc4NTI4LCAzNC42OTk0MjIxOTQgXSwgWyAxMzcuNDA2MDA1ODU5Mzc1LCAzNC42OTk0ODI5NDk1NjQ0OTggXSwgWyAxMzcuNDA1ODkzMjUsIDM0LjY5OTUyMjU1NiBdLCBbIDEzNy40MDU3Njg5NDM5OTk5ODgsIDM0LjY5OTU2ODIyMiBdLCBbIDEzNy40MDU3MDEzMzMsIDM0LjY5OTU4OTA4MyBdLCBbIDEzNy40MDU2NzkxOTM5OTk5ODcsIDM0LjY5OTU5NDgwNiBdLCBbIDEzNy40MDU2NDUwNTYsIDM0LjY5OTYwMDY2NyBdLCBbIDEzNy40MDU0NzY3NzgsIDM0LjY5OTYyMzQ0NCBdLCBbIDEzNy40MDUzNjgxMTEsIDM0LjY5OTYzNjA4MyBdLCBbIDEzNy40MDUzMzIzMDYsIDM0LjY5OTYzOTA1NiBdLCBbIDEzNy40MDUzMjM4MDYwMDAwMTMsIDM0LjY5OTYzOTMzMyBdLCBbIDEzNy40MDUyNzI3MjIsIDM0LjY5OTY0MDY5NCBdLCBbIDEzNy40MDUwODc4MzMwMDAwMSwgMzQuNjk5NjUwMzMzIF0sIFsgMTM3LjQwNDYzMjU2ODM1OTAwNiwgMzQuNjk5Njg2MjgyMzgxMyBdLCBbIDEzNy40MDQ1OTE1LCAzNC42OTk2ODk1MjggXSwgWyAxMzcuNDA0MjQ5NTgzLCAzNC42OTk3MTI2MzkgXSwgWyAxMzcuNDA0MjMxOTcyLCAzNC42OTk1ODE2OTQgXSwgWyAxMzcuNDA0MjIwMTM4OTk5OTg5LCAzNC42OTk0NTY1ODMgXSwgWyAxMzcuNDA0MjEzMzA2LCAzNC42OTkzOTYxOTQgXSwgWyAxMzcuNDA0MjAzNjkzOTk5OTg5LCAzNC42OTkzMTE3NSBdLCBbIDEzNy40MDQyMjY5NzIsIDM0LjY5OTI5MDUgXSwgWyAxMzcuNDA0NjEyOTQ0LCAzNC42OTkyNDYyMjIgXSwgWyAxMzcuNDA0NjAzOTQ0LCAzNC42OTkxOTI2OTQgXSwgWyAxMzcuNDA0MjE4MDgyOTk5OTg5LCAzNC42OTkyMzY5NzIgXSwgWyAxMzcuNDA0MTkzMTY2OTk5OTg4LCAzNC42OTkyMTg1NTYgXSwgWyAxMzcuNDA0MTc4Mjc3OTk5OTg5LCAzNC42OTkwODc3NzggXSwgWyAxMzcuNDA0MTc0NDcyLCAzNC42OTkwNTQ4NjEgXSwgWyAxMzcuNDA0MTY1NzIxOTk5OTg4LCAzNC42OTg5Nzc3MjIgXSwgWyAxMzcuNDA0MTU2NTI3OTk5OTg3LCAzNC42OTg4OTQxNjcgXSwgWyAxMzcuNDA0MTM3Mzg3MzA2MDA4LCAzNC42OTg3MTkzMjQ1MzIyOTggXSwgWyAxMzcuNDA0MTMzNDQ0LCAzNC42OTg2ODMwODMgXSwgWyAxMzcuNDA0MTEyMDU2LCAzNC42OTg0OTUyNSBdLCBbIDEzNy40MDQxMjQ3NzgwMDAwMTEsIDM0LjY5ODQ4MDY5NCBdLCBbIDEzNy40MDQyMzMxOTQsIDM0LjY5ODQ1MTQ3MiBdLCBbIDEzNy40MDQyNzIxMzksIDM0LjY5ODQ0MDkxNyBdLCBbIDEzNy40MDQzMDUzMDYsIDM0LjY5ODQzNDgzMyBdLCBbIDEzNy40MDQzMzY4NjEsIDM0LjY5ODQzNDU4MyBdLCBbIDEzNy40MDQ2MTg1LCAzNC42OTg0NDY3NSBdLCBbIDEzNy40MDQ2MzI1NjgzNTkwMDYsIDM0LjY5ODQ0NzM4MzI1MzA5NyBdLCBbIDEzNy40MDQ4MTM3NzgsIDM0LjY5ODQ1NTYxMSBdLCBbIDEzNy40MDQ4OTI2MzksIDM0LjY5ODQ1OTE5NCBdLCBbIDEzNy40MDUwMjU3MjIsIDM0LjY5ODQ2NzAyOCBdLCBbIDEzNy40MDUxMTkxNjcsIDM0LjY5ODQ3MzM2MSBdLCBbIDEzNy40MDUyNDIzMDYsIDM0LjY5ODQ3ODYxMSBdLCBbIDEzNy40MDUyMzAzMDYsIDM0LjY5ODU1NCBdLCBbIDEzNy40MDUyMjQ2MTEsIDM0LjY5ODU4MzM4OSBdLCBbIDEzNy40MDUxOTczNzc0NDc5OSwgMzQuNjk4NzE5MzI0NTMyMjk4IF0sIFsgMTM3LjQwNTE2NDExMSwgMzQuNjk4ODg1NDQ0IF0sIFsgMTM3LjQwNTE1NTMzMzAwMDAxLCAzNC42OTkwMTU1MjggXSwgWyAxMzcuNDA1MTYyNzQ5OTk5OTg4LCAzNC42OTkyNDUxMzkgXSwgWyAxMzcuNDA1MjA2NDE2OTk5OTg4LCAzNC42OTkyNDQ4ODkgXSwgWyAxMzcuNDA1MjAzMzMzLCAzNC42OTg4OTAyMjIgXSwgWyAxMzcuNDA1MjE4MDU2LCAzNC42OTg4OTIwODMgXSwgWyAxMzcuNDA1MjUyNzI0NjkwOTk2LCAzNC42OTg3MTkzMjQ1MzIyOTggXSwgWyAxMzcuNDA1MjY4MzMzLCAzNC42OTg2NDE0NzIgXSwgWyAxMzcuNDA1Mjc4NDQ0LCAzNC42OTg1OTA3NzggXSwgWyAxMzcuNDA1MjgxMTk0LCAzNC42OTg1NTkzMDYgXSwgWyAxMzcuNDA1MjkzMzA2LCAzNC42OTg0ODI5MTcgXSwgWyAxMzcuNDA1MzQ3Nzc4LCAzNC42OTg0ODQzNjEgXSwgWyAxMzcuNDA1NDAwOTE3LCAzNC42OTg0ODI3MjIgXSwgWyAxMzcuNDA1NDQwMzMzLCAzNC42OTg0ODExMTEgXSwgWyAxMzcuNDA1NDkwOTcyLCAzNC42OTg0NzcgXSwgWyAxMzcuNDA1NzM5ODg4OTk5OTg5LCAzNC42OTg0NTY4ODkgXSwgWyAxMzcuNDA1NzUyODg5MDAwMDEzLCAzNC42OTg1NzIwODMgXSwgWyAxMzcuNDA1NzY0NTI4LCAzNC42OTg2NzUzODkgXSwgWyAxMzcuNDA1NzY0NDQ0LCAzNC42OTg2ODI1IF0sIFsgMTM3LjQwNTc2MjgzMzAwMDAxMSwgMzQuNjk4Njg4NjM5IF0sIFsgMTM3LjQwNTc1OTU1NiwgMzQuNjk4NjkzNzc4IF0sIFsgMTM3LjQwNTc1NDExMSwgMzQuNjk4Njk4MTk0IF0sIFsgMTM3LjQwNTc0NjkxNjk5OTk4OCwgMzQuNjk4NzAxMzg5IF0sIFsgMTM3LjQwNTczNzc0OTk5OTk4NiwgMzQuNjk4NzAzMzg5IF0sIFsgMTM3LjQwNTY2OTYxMSwgMzQuNjk4Njg5MTY3IF0sIFsgMTM3LjQwNTY2NDQ0NDExMjAwNiwgMzQuNjk4NzE5MzI0NTMyMjk4IF0sIFsgMTM3LjQwNTY2Mjk0NCwgMzQuNjk4NzI3NDE3IF0sIFsgMTM3LjQwNTY3NDQxNywgMzQuNjk4NzMwMDgzIF0gXSwgWyBbIDEzNy40MDYwMDU4NTkzNzUsIDM0LjcwMTI1Mjc5NjY2ODU5OCBdLCBbIDEzNy40MDYwODYyNDk5OTk5ODcsIDM0LjcwMTI2MjA4MyBdLCBbIDEzNy40MDYxOTgyNzgsIDM0LjcwMTI3NDQxNyBdLCBbIDEzNy40MDYzMDE0NDQsIDM0LjcwMTI4NTYzOSBdLCBbIDEzNy40MDYzOTY3Nzc5OTk5ODcsIDM0LjcwMTI5NTc1IF0sIFsgMTM3LjQwNjQ2OTQ5OTk5OTk4NiwgMzQuNzAxMzAzMzYxIF0sIFsgMTM3LjQwNjUwOTgwNiwgMzQuNzAxMzA4NSBdLCBbIDEzNy40MDY1Mjc4MzMwMDAwMTMsIDM0LjcwMTMxMjUyOCBdLCBbIDEzNy40MDY1NTM3MjIwMDAwMTIsIDM0LjcwMTMxOTQxNyBdLCBbIDEzNy40MDY1NzIyNzgsIDM0LjcwMTMyNTQxNyBdLCBbIDEzNy40MDY2MzE5NDQsIDM0LjcwMTM0NzExMSBdLCBbIDEzNy40MDY2OTk5MTcsIDM0LjcwMTM3NDAyOCBdLCBbIDEzNy40MDY3MDgyMjIsIDM0LjcwMTM3NjcyMiBdLCBbIDEzNy40MDY3MTE0MTcsIDM0LjcwMTM4MTc1IF0sIFsgMTM3LjQwNjcxNzg4OSwgMzQuNzAxMzkxNDcyIF0sIFsgMTM3LjQwNjczNzE2Njk5OTk4OSwgMzQuNzAxNDE5ODMzIF0sIFsgMTM3LjQwNjcyMDc3OCwgMzQuNzAxNTI2ODg5IF0sIFsgMTM3LjQwNjY5MDU1NiwgMzQuNzAxNzE3MTY3IF0sIFsgMTM3LjQwNjY1NjQ3MiwgMzQuNzAxOTM2NTU2IF0sIFsgMTM3LjQwNjYyOTc2NDM1OTk5MSwgMzQuNzAyMTA2NDM2NzA1NTk4IF0sIFsgMTM3LjQwNjYyODA1NTk5OTk4OCwgMzQuNzAyMTE3Mjc4IF0sIFsgMTM3LjQwNjYyMSwgMzQuNzAyMTY4MTM5IF0sIFsgMTM3LjQwNjYxMzM2MTAwMDAxMiwgMzQuNzAyMjEwNzIyIF0sIFsgMTM3LjQwNjYwOTQxNywgMzQuNzAyMjM5NjY3IF0sIFsgMTM3LjQwNjYwNjk3MiwgMzQuNzAyMjYxMDI4IF0sIFsgMTM3LjQwNjYwNDQxNzAwMDAxMSwgMzQuNzAyMjgxNzc4IF0sIFsgMTM3LjQwNjYwMTg2MTAwMDAxMywgMzQuNzAyMzA0OTQ0IF0sIFsgMTM3LjQwNjU5OTA4MywgMzQuNzAyMzMwMTExIF0sIFsgMTM3LjQwNjU5Njc1LCAzNC43MDIzNTI5MTcgXSwgWyAxMzcuNDA2NTk1Mjc4LCAzNC43MDIzNzE3NSBdLCBbIDEzNy40MDY1OTM2OTQsIDM0LjcwMjM4ODgwNiBdLCBbIDEzNy40MDY1OTIxMzksIDM0LjcwMjQxMzMzMyBdLCBbIDEzNy40MDY1OTExMTEwMDAwMTIsIDM0LjcwMjQzNjEzOSBdLCBbIDEzNy40MDY1OTAzODksIDM0LjcwMjQ1MTE5NCBdLCBbIDEzNy40MDY1MzQyNzgsIDM0LjcwMjQ5MjU4MyBdLCBbIDEzNy40MDY1MjE1NTYsIDM0LjcwMjUwMzgwNiBdLCBbIDEzNy40MDY0Mzk1MjgsIDM0LjcwMjQ5NTc1IF0sIFsgMTM3LjQwNjI5MTY5NCwgMzQuNzAyNDgxMzYxIF0sIFsgMTM3LjQwNjEzMDc0OTk5OTk4OCwgMzQuNzAyNDY0ODA2IF0sIFsgMTM3LjQwNjAwNTg1OTM3NSwgMzQuNzAyNDUxODI5MjM2OCBdLCBbIDEzNy40MDU5NjUxMTEsIDM0LjcwMjQ0NzU1NiBdLCBbIDEzNy40MDU3OTk0NDQsIDM0LjcwMjQzMDY2NyBdLCBbIDEzNy40MDU2Mzc2MzksIDM0LjcwMjQxNTQ3MiBdLCBbIDEzNy40MDU0MTk0NzIsIDM0LjcwMjM5MzM2MSBdLCBbIDEzNy40MDUyNjIyMjIsIDM0LjcwMjM3NzQ0NCBdLCBbIDEzNy40MDUwOTIyMjIsIDM0LjcwMjM1OTY2NyBdLCBbIDEzNy40MDQ5MjY2OTQwMDAwMTEsIDM0LjcwMjM0Mjk0NCBdLCBbIDEzNy40MDQ5MjEyMjIwMDAwMTMsIDM0LjcwMjM0MjQxNyBdLCBbIDEzNy40MDQ5MTA3NSwgMzQuNzAyMzM5MzYxIF0sIFsgMTM3LjQwNDkwMDY2NywgMzQuNzAyMzMzMjUgXSwgWyAxMzcuNDA0ODkxNDcyLCAzNC43MDIzMjQ2MTEgXSwgWyAxMzcuNDA0ODg2ODYxLCAzNC43MDIzMTQwODMgXSwgWyAxMzcuNDA0ODg1ODYxLCAzNC43MDIzMDQ0NDQgXSwgWyAxMzcuNDA0ODk1MTM5LCAzNC43MDIyMzA2NjcgXSwgWyAxMzcuNDA0ODQyODMzLCAzNC43MDIyMjYwODMgXSwgWyAxMzcuNDA0ODM0NTI4LCAzNC43MDIyOTE2MzkgXSwgWyAxMzcuNDA0ODI4MjIyLCAzNC43MDIzMDgyNSBdLCBbIDEzNy40MDQ4MjA1LCAzNC43MDIzMTcgXSwgWyAxMzcuNDA0ODA5NSwgMzQuNzAyMzIyOTcyIF0sIFsgMTM3LjQwNDc5NTU1NjAwMDAxLCAzNC43MDIzMjczMzMgXSwgWyAxMzcuNDA0Nzc2NjY3LCAzNC43MDIzMjgwODMgXSwgWyAxMzcuNDA0NzY0NDQ0LCAzNC43MDIzMjY5NDQgXSwgWyAxMzcuNDA0NjMyNTY4MzU5MDA2LCAzNC43MDIzMTM0MjU3OTcyIF0sIFsgMTM3LjQwNDU5NTUsIDM0LjcwMjMwOTYxMSBdLCBbIDEzNy40MDQ0MzgwNTYsIDM0LjcwMjI5Mzc3OCBdLCBbIDEzNy40MDQyODc1ODMwMDAwMTMsIDM0LjcwMjI3ODExMSBdLCBbIDEzNy40MDQyMzgyMjIsIDM0LjcwMjI3MzI1IF0sIFsgMTM3LjQwNDIwNzg4OSwgMzQuNzAyMjcwNzc4IF0sIFsgMTM3LjQwNDE5ODA1NjAwMDAxMywgMzQuNzAyMjcxNjk0IF0sIFsgMTM3LjQwNDE5MDk3MiwgMzQuNzAyMjczMjUgXSwgWyAxMzcuNDA0MTc4NzUsIDM0LjcwMjI3NjI1IF0sIFsgMTM3LjQwNDEwNzYzODk5OTk4OSwgMzQuNzAyMjk3NzUgXSwgWyAxMzcuNDA0MDA2NjM4OTk5OTg4LCAzNC43MDIzMjg2OTQgXSwgWyAxMzcuNDAzOTA2MDgzMDAwMDEsIDM0LjcwMjM1OSBdLCBbIDEzNy40MDM4ODc3NzgwMDAwMTIsIDM0LjcwMjM2NzIyMiBdLCBbIDEzNy40MDM4Nzc4NjEwMDAwMTIsIDM0LjcwMjM3NTA4MyBdLCBbIDEzNy40MDM4NzI4NjEsIDM0LjcwMjM4MTg2MSBdLCBbIDEzNy40MDM4NzAyNTAwMDAwMTEsIDM0LjcwMjM4ODgwNiBdLCBbIDEzNy40MDM4NjcyNSwgMzQuNzAyNDA5NDcyIF0sIFsgMTM3LjQwMzg1NywgMzQuNzAyNDgzNzc4IF0sIFsgMTM3LjQwMzg0OTg2MSwgMzQuNzAyNTQ0NzIyIF0sIFsgMTM3LjQwMzgzNzU1NjAwMDAxMywgMzQuNzAyNjMzODA2IF0sIFsgMTM3LjQwMzc5OTU4MywgMzQuNzAyOTAyMzYxIF0sIFsgMTM3LjQwMzc3NjExMTAwMDAxMywgMzQuNzAzMDYzNDE3IF0sIFsgMTM3LjQwMzcyMDMzMywgMzQuNzAzMDU4OTQ0IF0sIFsgMTM3LjQwMzY4NzI1LCAzNC43MDI3ODk2MTEgXSwgWyAxMzcuNDAzNjAyODg5MDAwMDEzLCAzNC43MDIxMDkyMjIgXSwgWyAxMzcuNDAzNjAyNTgxNjQ0MDA5LCAzNC43MDIxMDY0MzY3MDU1OTggXSwgWyAxMzcuNDAzNTc4NzIyLCAzNC43MDE5MDQwODMgXSwgWyAxMzcuNDAzNTU1Mjc4LCAzNC43MDE3MjMzMDYgXSwgWyAxMzcuNDAzNTAzOTQ0LCAzNC43MDEzMjcxOTQgXSwgWyAxMzcuNDAzNTEyMTk0LCAzNC43MDEyMzI0MTcgXSwgWyAxMzcuNDAzNjY4MDU1OTk5OTg3LCAzNC43MDEwNzAyNzggXSwgWyAxMzcuNDAzNzM0Njg1OTM5MDE0LCAzNC43MDA5Nzc0MTQ3MjAxIF0sIFsgMTM3LjQwMzc2NTEzOSwgMzQuNzAwOTM0OTcyIF0sIFsgMTM3LjQwMzg2Mjc3OCwgMzQuNzAwNzYyMTM5IF0sIFsgMTM3LjQwMzg3MjA4MzAwMDAxLCAzNC43MDA3MzYyNSBdLCBbIDEzNy40MDM4NzM1NTYsIDM0LjcwMDcxODExMSBdLCBbIDEzNy40MDM4NzQzODksIDM0LjcwMDY5NjMwNiBdLCBbIDEzNy40MDM4NzA3NzgsIDM0LjcwMDY1NiBdLCBbIDEzNy40MDM5MTkwNTYsIDM0LjcwMDU1NzM4OSBdLCBbIDEzNy40MDM5OTYzMDYwMDAwMSwgMzQuNzAwNTAzNTgzIF0sIFsgMTM3LjQwNDI4NDE2Njk5OTk4NiwgMzQuNzAwMzk1MzA2IF0sIFsgMTM3LjQwNDMyMTg2MSwgMzQuNzAwMzMyNTgzIF0sIFsgMTM3LjQwNDI4NTgwNiwgMzQuNyBdLCBbIDEzNy40MDQyNjkzMjg1NjU5ODgsIDM0LjY5OTg0ODM3NzMyODg5OCBdLCBbIDEzNy40MDQyNjMsIDM0LjY5OTc4OTk3MiBdLCBbIDEzNy40MDQyOTk2OTQsIDM0LjY5OTc1NDQ3MiBdLCBbIDEzNy40MDQ1OTY1NTYsIDM0LjY5OTczNDQxNyBdLCBbIDEzNy40MDQ2MzI1NjgzNTkwMDYsIDM0LjY5OTczMTc1MjE3NjkwMiBdLCBbIDEzNy40MDQ4ODA5NDQwMDAwMTMsIDM0LjY5OTcxMzM4OSBdLCBbIDEzNy40MDUwOTI1NTYsIDM0LjY5OTY5NTIyMiBdLCBbIDEzNy40MDUyNzUxMzksIDM0LjY5OTY4NTc1IF0sIFsgMTM3LjQwNTMzNTk0NCwgMzQuNjk5Njg0MDI4IF0sIFsgMTM3LjQwNTM3NDY2NywgMzQuNjk5NjgwNzc4IF0sIFsgMTM3LjQwNTQ4NTMzMywgMzQuNjk5NjY3OTQ0IF0sIFsgMTM3LjQwNTY1NDg4OSwgMzQuNjk5NjQ1IF0sIFsgMTM3LjQwNTY5Mjg2MSwgMzQuNjk5NjM4NTI4IF0sIFsgMTM3LjQwNTcxOTAyOCwgMzQuNjk5NjMxNjk0IF0sIFsgMTM3LjQwNTc4OTU4MywgMzQuNjk5NjA5OTE3IF0sIFsgMTM3LjQwNTkxNSwgMzQuNjk5NTYzODg5IF0sIFsgMTM3LjQwNjAwNTg1OTM3NSwgMzQuNjk5NTMxOTMyNDM5NTk4IF0sIFsgMTM3LjQwNjE5NjMzMywgMzQuNjk5NDY0ODg5IF0sIFsgMTM3LjQwNjIyODYxMDk5OTk4OSwgMzQuNjk5NDU3ODA2IF0sIFsgMTM3LjQwNjI3NTExMTAwMDAxNCwgMzQuNjk5NDUyNDcyIF0sIFsgMTM3LjQwNjU0Njg4OSwgMzQuNjk5NDMyMjIyIF0sIFsgMTM3LjQwNjYxMzI1LCAzNC42OTk0MjcyNSBdLCBbIDEzNy40MDY3MjIyMjIwMDAwMTMsIDM0LjY5OTQxOTEzOSBdLCBbIDEzNy40MDY3Nzk5NDQsIDM0LjY5OTQxNTc3OCBdLCBbIDEzNy40MDY4MTA3MjE5OTk5ODksIDM0LjY5OTQxMzI3OCBdLCBbIDEzNy40MDczNzkxNTAzOTA5OTQsIDM0LjY5OTM2ODA4MDQzMjk5NyBdLCBbIDEzNy40MDczOTQxMzksIDM0LjY5OTM2Njg4OSBdLCBbIDEzNy40MDc0MjA4MzMsIDM0LjY5OTM4Mjc3OCBdLCBbIDEzNy40MDc0NjQ5NDQsIDM0LjY5OTc2ODgwNiBdLCBbIDEzNy40MDc0NTg2NjY5OTk5ODYsIDM0LjY5OTgyNjYxMSBdLCBbIDEzNy40MDc0NDE1ODc5NTgwMDQsIDM0LjY5OTg0ODM3NzMyODg5OCBdLCBbIDEzNy40MDc0MDQwODI5OTk5ODksIDM0LjY5OTg5NTg2MSBdLCBbIDEzNy40MDczODg2NjcsIDM0LjY5OTkyMTEzOSBdLCBbIDEzNy40MDczNzkxNTAzOTA5OTQsIDM0LjY5OTkzNTk3NjA4ODA5OSBdLCBbIDEzNy40MDczMzc4NjEsIDM0LjcgXSwgWyAxMzcuNDA3MzExMjc4LCAzNC43MDAwNDEyNzggXSwgWyAxMzcuNDA3MjM1LCAzNC43MDAxNjExNjcgXSwgWyAxMzcuNDA3MTQ0ODA2LCAzNC43MDAxNTMyMjIgXSwgWyAxMzcuNDA3MTUwMjc3OTk5OTg5LCAzNC43MDAxMTQ3MjIgXSwgWyAxMzcuNDA3MTQzNjExLCAzNC43MDAxMTQgXSwgWyAxMzcuNDA3MTU4NSwgMzQuNyBdLCBbIDEzNy40MDcxNzE5MTcsIDM0LjY5OTg5NzMwNiBdLCBbIDEzNy40MDcxMjc1ODMsIDM0LjY5OTg5MjYzOSBdLCBbIDEzNy40MDcxMTEwMjgsIDM0LjcgXSwgWyAxMzcuNDA3MTA5NTgzLCAzNC43MDAwMDk0MTcgXSwgWyAxMzcuNDA3MDg3ODA2LCAzNC43MDAxNDUzODkgXSwgWyAxMzcuNDA3MDA2ODA2LCAzNC43MDAxMzc1MjggXSwgWyAxMzcuNDA2ODg2MDI4LCAzNC43MDAxMjU1IF0sIFsgMTM3LjQwNjgxMjc3Nzk5OTk4OCwgMzQuNzAwMTE4NTI4IF0sIFsgMTM3LjQwNjczNDkxNywgMzQuNzAwMTExMDI4IF0sIFsgMTM3LjQwNjU5NjkxNywgMzQuNzAwMDk4MjIyIF0sIFsgMTM3LjQwNjU5NDQ3MiwgMzQuNzAwMTI5NjExIF0sIFsgMTM3LjQwNjU4MDIyMiwgMzQuNzAwMTc1MDU2IF0sIFsgMTM3LjQwNjY0NDA4MywgMzQuNzAwMTgwNDQ0IF0sIFsgMTM3LjQwNjY0ODU1NiwgMzQuNzAwMTQzMTExIF0sIFsgMTM3LjQwNjcyMDA4MzAwMDAxLCAzNC43MDAxNTE4ODkgXSwgWyAxMzcuNDA2NjgwMjIyLCAzNC43MDA0MDk4ODkgXSwgWyAxMzcuNDA2NzIzNTU2LCAzNC43MDA0MTQ0MTcgXSwgWyAxMzcuNDA2NzYzMzMyOTk5OTg2LCAzNC43MDAxNTY2NjcgXSwgWyAxMzcuNDA2ODEyODg5LCAzNC43MDAxNjIxNjcgXSwgWyAxMzcuNDA2OTUzMzA2LCAzNC43MDAxNzc3NSBdLCBbIDEzNy40MDcxNDEwMjgwMDAwMTIsIDM0LjcwMDIwMDkxNyBdLCBbIDEzNy40MDcxNjc1NTYsIDM0LjcwMDIzODA4MyBdLCBbIDEzNy40MDcxMjg4MDYsIDM0LjcwMDMxMjI3OCBdLCBbIDEzNy40MDcwOTUxMzksIDM0LjcwMDM3OTYxMSBdLCBbIDEzNy40MDcwNjQxMTEwMDAwMTEsIDM0LjcwMDQ0MDEzOSBdLCBbIDEzNy40MDcwNDcxNjcsIDM0LjcwMDQ3MzcyMiBdLCBbIDEzNy40MDcwMzQ1LCAzNC43MDA0NzI0NzIgXSwgWyAxMzcuNDA2OTk4MjQ5OTk5OTg3LCAzNC43MDA0NjkwMjggXSwgWyAxMzcuNDA2ODEzNzIyMDAwMDEsIDM0LjcwMDQ1MTU1NiBdLCBbIDEzNy40MDY3NzE1ODMsIDM0LjcwMDQ0NzU4MyBdLCBbIDEzNy40MDY3Njc0MTcsIDM0LjcwMDQ4MjM4OSBdLCBbIDEzNy40MDY4MTM4MzMsIDM0LjcwMDQ4NzA4MyBdLCBbIDEzNy40MDY5OTI5MTcsIDM0LjcwMDUwNTExMSBdLCBbIDEzNy40MDcwMjk0NzIsIDM0LjcwMDUwODgzMyBdLCBbIDEzNy40MDY5OTMwMjc5OTk5ODgsIDM0LjcwMDU4MzM2MSBdLCBbIDEzNy40MDY5NzMzODksIDM0LjcwMDYyNTY5NCBdLCBbIDEzNy40MDY5NTEzNjEwMDAwMTIsIDM0LjcwMDY3NDEzOSBdLCBbIDEzNy40MDY5MzI2MTEsIDM0LjcwMDcxNTcyMiBdLCBbIDEzNy40MDY5MTI2NjcsIDM0LjcwMDc2MzcyMiBdLCBbIDEzNy40MDY4OTksIDM0LjcwMDc5NzM4OSBdLCBbIDEzNy40MDY4ODgyNzgsIDM0LjcwMDgyNjY5NCBdLCBbIDEzNy40MDY4ODI2MzksIDM0LjcwMDg0MjA1NiBdLCBbIDEzNy40MDY4Nzc3NzgsIDM0LjcwMDg1NTQ3MiBdLCBbIDEzNy40MDY4NDkyMjIsIDM0LjcwMDk1MSBdLCBbIDEzNy40MDY4NDg0NzIsIDM0LjcwMDk1MzYzOSBdLCBbIDEzNy40MDY4NDExNjcwMDAwMSwgMzQuNzAwOTUzMTExIF0sIFsgMTM3LjQwNjgxNTE2NywgMzQuNzAwOTUxMDgzIF0sIFsgMTM3LjQwNjc4MzE5NDAwMDAxMywgMzQuNzAwOTQ4NjExIF0sIFsgMTM3LjQwNjU2MDExMSwgMzQuNzAwOTI1IF0sIFsgMTM3LjQwNjM4MzMzMywgMzQuNzAwOTA1Nzc4IF0sIFsgMTM3LjQwNjM3MDc3OCwgMzQuNzAwOTA0ODA2IF0sIFsgMTM3LjQwNjM2NTYxMTAwMDAxMiwgMzQuNzAwODk5NDE3IF0sIFsgMTM3LjQwNjM2MTY2NywgMzQuNzAwODkxMzA2IF0sIFsgMTM3LjQwNjM2MDMzMywgMzQuNzAwODgzNjM5IF0sIFsgMTM3LjQwNjM2MTI3OCwgMzQuNzAwODY2MTM5IF0sIFsgMTM3LjQwNjM2MTQ3MTk5OTk4NiwgMzQuNzAwODYwMzg5IF0sIFsgMTM3LjQwNjMwODQxNywgMzQuNzAwODU3ODYxIF0sIFsgMTM3LjQwNjE1ODk0NCwgMzQuNzAwODQ1NjM5IF0sIFsgMTM3LjQwNjAwNTg1OTM3NSwgMzQuNzAwODMwMzQ5MzMzNiBdLCBbIDEzNy40MDU4OTY3NzgsIDM0LjcwMDgxOTQ3MiBdLCBbIDEzNy40MDU2NzA4NjEsIDM0LjcwMDc5NjExMSBdLCBbIDEzNy40MDU1MTk3NSwgMzQuNzAwNzgwODA2IF0sIFsgMTM3LjQwNTUwNTMzMywgMzQuNzAwODE4MjUgXSwgWyAxMzcuNDA1NTgzMzA2MDAwMDExLCAzNC43MDA4MjY1NTYgXSwgWyAxMzcuNDA1ODY2MzA2LCAzNC43MDA4NTUyMjIgXSwgWyAxMzcuNDA2MDA1ODU5Mzc1LCAzNC43MDA4NjkyNDQyMDQzOTggXSwgWyAxMzcuNDA2MDkxNzc4LCAzNC43MDA4Nzc4NjEgXSwgWyAxMzcuNDA2MTAxOTQ0LCAzNC43MDA5MTU2OTQgXSwgWyAxMzcuNDA2MTUyODMzLCAzNC43MDA5MTk1NTYgXSwgWyAxMzcuNDA2MTY0ODMzLCAzNC43MDA4ODMwMjggXSwgWyAxMzcuNDA2Mjc0MDI4MDAwMDEzLCAzNC43MDA4OTQwODMgXSwgWyAxMzcuNDA2MjYxNjY4MjksIDM0LjcwMDk3NzQxNDcyMDEgXSwgWyAxMzcuNDA2MjQ2NSwgMzQuNzAxMDc5NjY3IF0sIFsgMTM3LjQwNjIyNDk3MiwgMzQuNzAxMjE3Mjc4IF0sIFsgMTM3LjQwNjIyMzI1MDAwMDAxMSwgMzQuNzAxMjI2MjIyIF0sIFsgMTM3LjQwNjIxOTMzMywgMzQuNzAxMjMxIF0sIFsgMTM3LjQwNjIxMzExMSwgMzQuNzAxMjMzNDQ0IF0sIFsgMTM3LjQwNjIwNjExMDk5OTk4OSwgMzQuNzAxMjMzMTExIF0sIFsgMTM3LjQwNjE5NjM4OSwgMzQuNzAxMjMyMzA2IF0sIFsgMTM3LjQwNjA4Njc3OCwgMzQuNzAxMjIxMTY3IF0sIFsgMTM3LjQwNjAwNTg1OTM3NSwgMzQuNzAxMjEyODQ1MTI3NiBdLCBbIDEzNy40MDU4MDc4MDYwMDAwMTMsIDM0LjcwMTE5MjUgXSwgWyAxMzcuNDA1Nzk4NSwgMzQuNzAxMjI4ODYxIF0sIFsgMTM3LjQwNjAwNTg1OTM3NSwgMzQuNzAxMjUyNzk2NjY4NTk4IF0gXSwgWyBbIDEzNy40MTAxMDk0NzE5OTk5ODgsIDM0LjcwMzExNzAyOCBdLCBbIDEzNy40MTAxMjU3MzI0MjE5ODksIDM0LjcwMzExNTEzMTY4MDQ5OCBdLCBbIDEzNy40MTAxNDA2NjcsIDM0LjcwMzExMzI1IF0sIFsgMTM3LjQxMDE3MSwgMzQuNzAzMTA4MTM5IF0sIFsgMTM3LjQxMDIwMTg4OSwgMzQuNzAzMTAxMzMzIF0sIFsgMTM3LjQxMDIzMTc3OCwgMzQuNzAzMDkyMzMzIF0sIFsgMTM3LjQxMDI1ODM4OSwgMzQuNzAzMDgyNjM5IF0sIFsgMTM3LjQxMDI4ODI1LCAzNC43MDMwNjk2OTQgXSwgWyAxMzcuNDEwMzIxMDU1OTk5OTg3LCAzNC43MDMwNTQ3NSBdLCBbIDEzNy40MTAzNTc3NzgsIDM0LjcwMzAzMTY5NCBdLCBbIDEzNy40MTAzODcxOTQsIDM0LjcwMzAxMDM2MSBdLCBbIDEzNy40MTA0MTM0NDQsIDM0LjcwMjk4ODM4OSBdLCBbIDEzNy40MTA0MzY1LCAzNC43MDI5NjYxNjcgXSwgWyAxMzcuNDEwNDU0Nzc4LCAzNC43MDI5NDU0NzIgXSwgWyAxMzcuNDEwNDY1Nzc4LCAzNC43MDI5MzEyMjIgXSwgWyAxMzcuNDEwNDc3NTAwMDAwMDEzLCAzNC43MDI5MTMxNjcgXSwgWyAxMzcuNDEwNDg4Njk0LCAzNC43MDI4OTAxNjcgXSwgWyAxMzcuNDEwNTE1MjUsIDM0LjcwMjgzMTc3OCBdLCBbIDEzNy40MTA1NjgwODI5OTk5ODcsIDM0LjcwMjcxNjQ0NCBdLCBbIDEzNy40MTA2Mjk2OTQsIDM0LjcwMjU3OTQ3MiBdLCBbIDEzNy40MTA3MzUsIDM0LjcwMjM0NzY2NyBdLCBbIDEzNy40MTA3ODI2MTEsIDM0LjcwMjI0NDcyMiBdLCBbIDEzNy40MTA4MDA3NzgsIDM0LjcwMjIxODI1IF0sIFsgMTM3LjQxMDgxMTg2MTAwMDAxMywgMzQuNzAyMjAwMDI4IF0sIFsgMTM3LjQxMDgyODgwNjAwMDAxMiwgMzQuNzAyMTc2OTE3IF0sIFsgMTM3LjQxMDg0MzM4OSwgMzQuNzAyMTU5ODYxIF0sIFsgMTM3LjQxMDg5ODA1NiwgMzQuNzAyMTExOTcyIF0sIFsgMTM3LjQxMDkwMzg0NDQwMTk4NiwgMzQuNzAyMTA2NDM2NzA1NTk4IF0sIFsgMTM3LjQxMDkyNDUsIDM0LjcwMjA4NzExMSBdLCBbIDEzNy40MTA5NDMxMTEsIDM0LjcwMjA3MDc1IF0sIFsgMTM3LjQxMDk1ODY5Mzk5OTk4NywgMzQuNzAyMDU3NzUgXSwgWyAxMzcuNDEwOTgxNzc4LCAzNC43MDIwMzg2NjcgXSwgWyAxMzcuNDExMDIxOTcxOTk5OTg2LCAzNC43MDIwMDc3NzggXSwgWyAxMzcuNDExMDU2Mjc4LCAzNC43MDE5ODM4MDYgXSwgWyAxMzcuNDExMTIzOTE3LCAzNC43MDE5MzQxNjcgXSwgWyAxMzcuNDExMjYxMTY3LCAzNC43MDE4MzMxOTQgXSwgWyAxMzcuNDExNDI5NTU2LCAzNC43MDE3MDc3MjIgXSwgWyAxMzcuNDExNDk5MDIzNDM2OTg4LCAzNC43MDE2NTU5NDI5NjU1MDIgXSwgWyAxMzcuNDExNjEyNTI4LCAzNC43MDE1NzEzMzMgXSwgWyAxMzcuNDExNjE0Mjc4LCAzNC43MDE1Njk5NzIgXSwgWyAxMzcuNDExNjM5NjM4OTk5OTg2LCAzNC43MDE1ODAyNzggXSwgWyAxMzcuNDExNTc0NjY3LCAzNC43MDE2ODE1ODMgXSwgWyAxMzcuNDExNjUxOTE3LCAzNC43MDE3MDcyNzggXSwgWyAxMzcuNDExNzQ2LCAzNC43MDE3Mzg1NTYgXSwgWyAxMzcuNDExNzY2NzUsIDM0LjcwMTcwNzA1NiBdLCBbIDEzNy40MTE3ODA5NzIsIDM0LjcwMTY4NTQ3MiBdLCBbIDEzNy40MTE3ODE4NjIyODkyNzQsIDM0LjcwMTY4Mzg4ODIxOTEwMSBdLCBbIDEzNy40MTIzNTc0NDEzOTMyMjYsIDM0LjcwMTkxMjAzNzU2OTY0OSBdLCBbIDEzNy40MTI4NDQyMDk3Mzc3NTYsIDM0LjcwMTA3MTIyMDIzMjQyMSBdLCBbIDEzNy40MTI3MDQzOTMyOTgzODQsIDM0LjcwMTAxNTg3NDk5NDA0OSBdLCBbIDEzNy40MTI2Nzg1MDEzNjUxMjIsIDM0LjcwMTA1MjA2MjI2OTQ5IF0sIFsgMTM3LjQxMjUyMDU2MDU3MjUxNywgMzQuNzAwOTg2MDczNjk2NTEyIF0sIFsgMTM3LjQxMjQ2ODc3NjcwNjEwNiwgMzQuNzAxMDY5MDkxNTcwMDkxIF0sIFsgMTM3LjQxMjE2MDY2MjcwMDc4NSwgMzQuNzAwOTQ3NzU3NzI2NzggXSwgWyAxMzcuNDEyMTI5NTkyMzgwOTIxLCAzNC43MDA5OTI0NTk2ODk3NDMgXSwgWyAxMzcuNDEyMTE2MTM1OTYwNDc0LCAzNC43MDA5ODYxMzc5ODQ3MzUgXSwgWyAxMzcuNDEyMTE3ODYxMDAwMDEzLCAzNC43MDA5ODM0NzIgXSwgWyAxMzcuNDEyMTExMTY3LCAzNC43MDA5ODA1NTYgXSwgWyAxMzcuNDEyMTEwODIxNDk4OTk5LCAzNC43MDA5Nzc0MTQ3MjAxIF0sIFsgMTM3LjQxMjEwODM4OSwgMzQuNzAwOTU2MDI4IF0sIFsgMTM3LjQxMjIyOTU4MywgMzQuNzAwODkzNjk0IF0sIFsgMTM3LjQxMjc2NDU4MzAwMDAxMiwgMzQuNzAwOTM0NTI4IF0sIFsgMTM3LjQxMjc5MTExMSwgMzQuNzAwOTM1MTk0IF0sIFsgMTM3LjQxMjgxMzEzOSwgMzQuNzAwOTM0NDE3IF0sIFsgMTM3LjQxMjgzMTA1NTk5OTk4NywgMzQuNzAwOTMxNjk0IF0sIFsgMTM3LjQxMjg0NjUyNzk5OTk4OSwgMzQuNzAwOTI3MDU2IF0sIFsgMTM3LjQxMjg2MjExMTAwMDAxLCAzNC43MDA5MjEyNSBdLCBbIDEzNy40MTI4NzIzMTQ0NTMwMTEsIDM0LjcwMDkxNjUwODYyMDg5OSBdLCBbIDEzNy40MTI4ODEwODMsIDM0LjcwMDkxMjI3OCBdLCBbIDEzNy40MTI5NzE5NzIsIDM0LjcwMDg2MDcyMiBdLCBbIDEzNy40MTMwNjg2NjcsIDM0LjcwMDgxMzE5NCBdLCBbIDEzNy40MTMwOTczMzMsIDM0LjcwMDgwMjA1NiBdLCBbIDEzNy40MTMxMjM4MzI5OTk5ODYsIDM0LjcwMDc5NTIyMiBdLCBbIDEzNy40MTMxMzc1ODMsIDM0LjcwMDc5MTY5NCBdLCBbIDEzNy40MTMxNTkxOTQsIDM0LjcwMDc4OTAyOCBdLCBbIDEzNy40MTMxOTIxMzg5OTk5ODksIDM0LjcwMDc4ODY5NCBdLCBbIDEzNy40MTMxOTEwODI5OTk5ODcsIDM0LjcwMDc5OTE2NyBdLCBbIDEzNy40MTMyMjY0NDQsIDM0LjcwMDc5OTE2NyBdLCBbIDEzNy40MTMyNDc2MzksIDM0LjcwMDgwNDcyMiBdLCBbIDEzNy40MTMyNzg1ODMsIDM0LjcwMDgxNTkxNyBdLCBbIDEzNy40MTMyNDU0NzIsIDM0LjcwMDg1MjA1NiBdLCBbIDEzNy40MTMxOTMwNTYwMDAwMTEsIDM0LjcwMDkwOTMwNiBdLCBbIDEzNy40MTMxNzY5NDQwMDAwMTQsIDM0LjcwMDkyNzAyOCBdLCBbIDEzNy40MTMxNzIwNTYsIDM0LjcwMDkzMjMzMyBdLCBbIDEzNy40MTMxMzU2OTE5NzYwMDksIDM0LjcwMDk3NzQxNDcyMDEgXSwgWyAxMzcuNDEzMDQyMzA2LCAzNC43MDEwOTMyNSBdLCBbIDEzNy40MTI5MzMyNzgsIDM0LjcwMTI1MTUyOCBdLCBbIDEzNy40MTI5MTc1LCAzNC43MDEyNzgwMjggXSwgWyAxMzcuNDEyODg2MzMyOTk5OTg5LCAzNC43MDEzMzAzNjEgXSwgWyAxMzcuNDEyODcyOTE2OTk5OTg3LCAzNC43MDEzNTI4ODkgXSwgWyAxMzcuNDEyODcyMzE0NDUzMDExLCAzNC43MDEzNTM2ODAyOTI4OTcgXSwgWyAxMzcuNDEyODU5MjIyLCAzNC43MDEzNzU4ODkgXSwgWyAxMzcuNDEyNjczMzA1OTk5OTg4LCAzNC43MDE3MDUyMjIgXSwgWyAxMzcuNDEyNjQzNzUsIDM0LjcwMTc1NzYxMSBdLCBbIDEzNy40MTI2MzUzNjEwMDAwMTQsIDM0LjcwMTc3MjUgXSwgWyAxMzcuNDEyNjI0MTExMDAwMDE0LCAzNC43MDE3OTI0MTcgXSwgWyAxMzcuNDEyNDc4Nzc4LCAzNC43MDIwMzggXSwgWyAxMzcuNDEyNDM1OTE3MDAwMDEsIDM0LjcwMjA0Njc1IF0sIFsgMTM3LjQxMjM0Njc3OCwgMzQuNzAyMDIzOTQ0IF0sIFsgMTM3LjQxMjA4OTgzMzAwMDAxLCAzNC43MDE5NTgxMTEgXSwgWyAxMzcuNDEyMDY1NTgyOTk5OTg2LCAzNC43MDE5NTExMzkgXSwgWyAxMzcuNDEyMDEwNDE3LCAzNC43MDE5Mzc4MDYgXSwgWyAxMzcuNDExOTgyMzMzLCAzNC43MDE5MzEwNTYgXSwgWyAxMzcuNDExODg5ODA2LCAzNC43MDE5MDg3NSBdLCBbIDEzNy40MTE1NzI4MDYsIDM0LjcwMTgzMjM4OSBdLCBbIDEzNy40MTE1MzM5NDQwMDAwMTMsIDM0LjcwMTgyODk3MiBdLCBbIDEzNy40MTE1MTk1MjgwMDAwMTQsIDM0LjcwMTgyOSBdLCBbIDEzNy40MTE0OTkwMjM0MzY5ODgsIDM0LjcwMTgzMTA5MTI2NTI5OCBdLCBbIDEzNy40MTE0OTE2OTQsIDM0LjcwMTgzMTgzMyBdLCBbIDEzNy40MTE0NjcxMzksIDM0LjcwMTgzNTMwNiBdLCBbIDEzNy40MTE0NDE4MzMsIDM0LjcwMTg0MDk0NCBdLCBbIDEzNy40MTE0MTY0MTcsIDM0LjcwMTg0NzIyMiBdLCBbIDEzNy40MTEzOTIsIDM0LjcwMTg1OTE2NyBdLCBbIDEzNy40MTEwNDkzNTIzNjg5OTEsIDM0LjcwMjEwNjQzNjcwNTU5OCBdLCBbIDEzNy40MTA5MzgsIDM0LjcwMjE4NjgwNiBdLCBbIDEzNy40MTA5MTE3NSwgMzQuNzAyMjA1MjUgXSwgWyAxMzcuNDEwODk0MTM5LCAzNC43MDIyMjgzNjEgXSwgWyAxMzcuNDEwODgzNzIyLCAzNC43MDIyNDg3NSBdLCBbIDEzNy40MTA4NTAyMjIsIDM0LjcwMjMyODY5NCBdLCBbIDEzNy40MTA3OTY5NzIwMDAwMTQsIDM0LjcwMjQ0NjUyOCBdLCBbIDEzNy40MTA3NzgyMjIsIDM0LjcwMjQ5MzgwNiBdLCBbIDEzNy40MTA3MjM2MzksIDM0LjcwMjYyMjcyMiBdLCBbIDEzNy40MTA3MDgzNjEsIDM0LjcwMjY1ODc3OCBdLCBbIDEzNy40MTA0NjQxNjA4ODQ5OTksIDM0LjcwMzIzNTQ0MzI4NTEwMiBdLCBbIDEzNy40MTAyNzYzODg5OTk5ODksIDM0LjcwMzY3ODg2MSBdLCBbIDEzNy40MTAyNTg0MTcsIDM0LjcwMzY4OSBdLCBbIDEzNy40MTAxMjU3MzI0MjE5ODksIDM0LjcwMzY4NDk1ODczODY5OCBdLCBbIDEzNy40MDk3ODMxOTQsIDM0LjcwMzY3NDUyOCBdLCBbIDEzNy40MDk1MzQzODg5OTk5ODcsIDM0LjcwMzY2NjkxNyBdLCBbIDEzNy40MDk1MTA4MzMwMDAwMTMsIDM0LjcwMzY2NjE2NyBdLCBbIDEzNy40MDk0MzU0NzIwMDAwMTMsIDM0LjcwMzY2MzgwNiBdLCBbIDEzNy40MDkwNzMzNjEsIDM0LjcwMzY1MjQxNyBdLCBbIDEzNy40MDkwMzI2MTA5OTk5ODYsIDM0LjcwMzY0ODQ0NCBdLCBbIDEzNy40MDg3NTI0NDE0MDU5OTQsIDM0LjcwMzYxNjExMDU1MzM5OCBdLCBbIDEzNy40MDgzMzMzMzMsIDM0LjcwMzU2Nzc1IF0sIFsgMTM3LjQwNzgxNTgzMywgMzQuNzAzNTA4MDU2IF0sIFsgMTM3LjQwNzM3OTE1MDM5MDk5NCwgMzQuNzAzNDYyMjYxOTkzOTk4IF0sIFsgMTM3LjQwNzM1Njc3OCwgMzQuNzAzNDU5OTE3IF0sIFsgMTM3LjQwNzMwNjc1LCAzNC43MDM0NTM0NDQgXSwgWyAxMzcuNDA3MjgwMjIyLCAzNC43MDM0NTA2MTEgXSwgWyAxMzcuNDA3MjQ2Mjc4LCAzNC43MDM0NTM3MjIgXSwgWyAxMzcuNDA3MjIxMTkzOTk5OTg3LCAzNC43MDM0NTg3NSBdLCBbIDEzNy40MDY4NDU2OTQsIDM0LjcwMzUzODM2MSBdLCBbIDEzNy40MDY4MjI2NjcsIDM0LjcwMzU0MzI3OCBdLCBbIDEzNy40MDY4MTg3MTA5MTUxNjEsIDM0LjcwMzU0NDI2OTQwNDM4OSBdLCBbIDEzNy40MDY4MjEwMjgsIDM0LjcwMzUwNjU4MyBdLCBbIDEzNy40MDY4MjI1MjgsIDM0LjcwMzQ5NTY5NCBdLCBbIDEzNy40MDY4MjkyNzgsIDM0LjcwMzQ0Nzg4OSBdLCBbIDEzNy40MDY4NDAwODMsIDM0LjcwMzM3NjU1NiBdLCBbIDEzNy40MDY4NDA3MjIsIDM0LjcwMzM3MzAyOCBdLCBbIDEzNy40MDY4NDI2NjcsIDM0LjcwMzM2MDUgXSwgWyAxMzcuNDA2ODQ1MzYxLCAzNC43MDMzNDk2OTQgXSwgWyAxMzcuNDA2ODQ3OTQ0LCAzNC43MDMzMzc4NjEgXSwgWyAxMzcuNDA2ODUyNjk0LCAzNC43MDMzMTk2MzkgXSwgWyAxMzcuNDA2ODYxMTM5LCAzNC43MDMyOTI1ODMgXSwgWyAxMzcuNDA2ODY5NTgzLCAzNC43MDMyNjc5NDQgXSwgWyAxMzcuNDA2ODc5NzUsIDM0LjcwMzI0Mjc3OCBdLCBbIDEzNy40MDY4ODI4NDMwMzcwMSwgMzQuNzAzMjM1NDQzMjg1MTAyIF0sIFsgMTM3LjQwNjg5MDkxNywgMzQuNzAzMjE2MTY3IF0sIFsgMTM3LjQwNjkwMzMwNiwgMzQuNzAzMTkxMjUgXSwgWyAxMzcuNDA2OTE2NjY3LCAzNC43MDMxNjYwODMgXSwgWyAxMzcuNDA2OTM3NjEwOTk5OTg5LCAzNC43MDMxMjk0NDQgXSwgWyAxMzcuNDA2OTQzNDcyLCAzNC43MDMxMTg0MTcgXSwgWyAxMzcuNDA2OTQ3Mzg5MDAwMDEsIDM0LjcwMzEwNzE2NyBdLCBbIDEzNy40MDY5NTEzNjEwMDAwMTIsIDM0LjcwMzA4ODMwNiBdLCBbIDEzNy40MDY5NjEwODMsIDM0LjcwMzAyMDIyMiBdLCBbIDEzNy40MDY5NzQ0NDQwMDAwMTQsIDM0LjcwMjkyMDAyOCBdLCBbIDEzNy40MDY5ODY4ODksIDM0LjcwMjg0NjYzOSBdLCBbIDEzNy40MDcwMzg4MDYsIDM0LjcwMjgyMyBdLCBbIDEzNy40MDcxNzU1LCAzNC43MDI4MzY4ODkgXSwgWyAxMzcuNDA3MTk1MzMzLCAzNC43MDI4NTc4MzMgXSwgWyAxMzcuNDA3MTkzNjExLCAzNC43MDI4Njk1NTYgXSwgWyAxMzcuNDA3MDUxNzc4MDAwMDEsIDM0LjcwMjg1NTQxNyBdLCBbIDEzNy40MDcwNTE0NDQsIDM0LjcwMjg2MDMwNiBdLCBbIDEzNy40MDcwMDIwNTYwMDAwMSwgMzQuNzAzMjE1NjY3IF0sIFsgMTM3LjQwNzAwNTY2NywgMzQuNzAzMjIwNjM5IF0sIFsgMTM3LjQwNzAxMzExMSwgMzQuNzAzMjI1NzUgXSwgWyAxMzcuNDA3MDI4NDE3LCAzNC43MDMyMzE2NjcgXSwgWyAxMzcuNDA3MDcwODU4Mjc5MDEzLCAzNC43MDMyMzU0NDMyODUxMDIgXSwgWyAxMzcuNDA3Mzc5MTUwMzkwOTk0LCAzNC43MDMyNjI5MTQyMDkzOTcgXSwgWyAxMzcuNDA3OTM4MDU2LCAzNC43MDMzMTI3MjIgXSwgWyAxMzcuNDA3OTUxMDAwMjM4LCAzNC43MDMyMzU0NDMyODUxMDIgXSwgWyAxMzcuNDA4MDAwMDgzLCAzNC43MDI5NDIyNSBdLCBbIDEzNy40MDczNzkxNTAzOTA5OTQsIDM0LjcwMjg4NjE3MjIzNTYwMSBdLCBbIDEzNy40MDcyNTU3NSwgMzQuNzAyODc1MDI4IF0sIFsgMTM3LjQwNzI1NzMzMywgMzQuNzAyODY0MTExIF0sIFsgMTM3LjQwNzI4MjcyMiwgMzQuNzAyODQ3ODMzIF0sIFsgMTM3LjQwNzM3OTE1MDM5MDk5NCwgMzQuNzAyODU3NjA1NDU4ODAzIF0sIFsgMTM3LjQwNzU5NTc3OCwgMzQuNzAyODc5NTgzIF0sIFsgMTM3LjQwODE5NDU4MzAwMDAxMSwgMzQuNzAyOTM2OTE3IF0sIFsgMTM3LjQwODMzMzMzMywgMzQuNzAyOTUwMTY3IF0sIFsgMTM3LjQwODM5NzkxNywgMzQuNzAyOTU2MzMzIF0sIFsgMTM3LjQwODQxODU4MzAwMDAxNCwgMzQuNzAyOTc2Nzc4IF0sIFsgMTM3LjQwODQxNTc0OTk5OTk4OSwgMzQuNzAzMDE2MjUgXSwgWyAxMzcuNDA4MzkwODA2LCAzNC43MDMwMzMxNjcgXSwgWyAxMzcuNDA4NDkwNSwgMzQuNzAzMDQ0MzMzIF0sIFsgMTM3LjQwODQ2OTkxNywgMzQuNzAzMDIzNjM5IF0sIFsgMTM3LjQwODQ3Mjg2MSwgMzQuNzAyOTgzMzMzIF0sIFsgMTM3LjQwODQ5ODAyOCwgMzQuNzAyOTY1ODg5IF0sIFsgMTM3LjQwODYxMTA1NjAwMDAxMiwgMzQuNzAyOTc2NjY3IF0sIFsgMTM3LjQwODc1MjQ0MTQwNTk5NCwgMzQuNzAyOTkwMDQzODY2NTk5IF0sIFsgMTM3LjQwOTA0MDUsIDM0LjcwMzAxNzI3OCBdLCBbIDEzNy40MDkwNTIxNjcsIDM0LjcwMzAxODQxNyBdLCBbIDEzNy40MDkwMzcyNzgsIDM0LjcwMzExMjU4MyBdLCBbIDEzNy40MDkwNTI4NjEsIDM0LjcwMzE0NDU1NiBdLCBbIDEzNy40MDkwODI2MzksIDM0LjcwMzE2OSBdLCBbIDEzNy40MDkxMjI4MzMsIDM0LjcwMzE3NTU4MyBdLCBbIDEzNy40MDkxMzU1NTYsIDM0LjcwMzEyMjQ3MiBdLCBbIDEzNy40MDkxMTQ4MDYsIDM0LjcwMzExOTE2NyBdLCBbIDEzNy40MDkxMDg1NTYsIDM0LjcwMzExNDA1NiBdLCBbIDEzNy40MDkxMDQzODksIDM0LjcwMzEwNTUgXSwgWyAxMzcuNDA5MTE3MTM4OTk5OTg5LCAzNC43MDMwMjUwNTYgXSwgWyAxMzcuNDA5Mzg2NzUwMDAwMDEsIDM0LjcwMzA1MjQ3MiBdLCBbIDEzNy40MDk3MjQ4MDYwMDAwMTQsIDM0LjcwMzA4ODAyOCBdLCBbIDEzNy40MDk4NzQ4MzMsIDM0LjcwMzEwMjc3OCBdLCBbIDEzNy40MDk5NjMyNzgsIDM0LjcwMzExMTg4OSBdLCBbIDEzNy40MTAwMDc2MTEsIDM0LjcwMzExNjk0NCBdLCBbIDEzNy40MTAwNDEwMjgsIDM0LjcwMzExOTEzOSBdLCBbIDEzNy40MTAwNzMxMzksIDM0LjcwMzExODcyMiBdLCBbIDEzNy40MTAxMDk0NzE5OTk5ODgsIDM0LjcwMzExNzAyOCBdIF0sIFsgWyAxMzcuNDExODMzMzg5LCAzNC43MDE1ODIzMzMgXSwgWyAxMzcuNDExODIzMjUsIDM0LjcwMTU4MTYzOSBdLCBbIDEzNy40MTE3MTU4MzI5OTk5ODgsIDM0LjcwMTU0Njg2MSBdLCBbIDEzNy40MTE3MDQsIDM0LjcwMTUzMDg2MSBdLCBbIDEzNy40MTE2OTg5NDQsIDM0LjcwMTUyMDM4OSBdLCBbIDEzNy40MTE2OTcxNjcsIDM0LjcwMTUwOTIyMiBdLCBbIDEzNy40MTE3MDIyNzgsIDM0LjcwMTQ5ODc1IF0sIFsgMTM3LjQxMTcyNTg4OSwgMzQuNzAxNTA3NzIyIF0sIFsgMTM3LjQxMTcxNjY2NywgMzQuNzAxNTI2NTgzIF0sIFsgMTM3LjQxMTgzMDg2MSwgMzQuNzAxNTY5NzIyIF0sIFsgMTM3LjQxMTgzOTIyMiwgMzQuNzAxNTUzNjY3IF0sIFsgMTM3LjQxMTg1NTI3OCwgMzQuNzAxNTU4NTgzIF0sIFsgMTM3LjQxMTg3NjMzMywgMzQuNzAxNTE3Njk0IF0sIFsgMTM3LjQxMTgxNTQ0NDAwMDAxMywgMzQuNzAxNDkzMzA2IF0sIFsgMTM3LjQxMTgwMjg2MTAwMDAxMiwgMzQuNzAxNTE0OTcyIF0sIFsgMTM3LjQxMTc2Mzk0NCwgMzQuNzAxNDk4Mjc4IF0sIFsgMTM3LjQxMTczMzgzMywgMzQuNzAxNDcwNzUgXSwgWyAxMzcuNDExNzQwOTE3LCAzNC43MDE0NjE3MjIgXSwgWyAxMzcuNDExNzg0OTQ0LCAzNC43MDE0MDQ3NSBdLCBbIDEzNy40MTE4MjYxMTEwMDAwMTEsIDM0LjcwMTMzMzk3MiBdLCBbIDEzNy40MTE5MDIwMjc5OTk5ODYsIDM0LjcwMTE5NzE2NyBdLCBbIDEzNy40MTE5ODgzMzMwMDAwMTEsIDM0LjcwMTA0MzYzOSBdLCBbIDEzNy40MTIwMDE3MjIwMDAwMTQsIDM0LjcwMTAyNzQ3MiBdLCBbIDEzNy40MTIwNTQxOTQsIDM0LjcwMTAyMDY5NCBdLCBbIDEzNy40MTIwODU0NzIsIDM0LjcwMTAzMzUyOCBdLCBbIDEzNy40MTIwOTAzMjMyMTM3ODksIDM0LjcwMTAyNjAzMDYyODc3NSBdLCBbIDEzNy40MTIxNDUxMjc1NDA4NjcsIDM0LjcwMTA1NDE5MDkzMjI0NyBdLCBbIDEzNy40MTIxNDc3MTY3MzQxODIsIDM0LjcwMTA3MzM0ODg5NDcwMyBdLCBbIDEzNy40MTE4NjU0OTQ2NjIwOTUsIDM0LjcwMTU3NTcxMTY2MDA5MSBdLCBbIDEzNy40MTE4Mzg4ODgwODQyNzYsIDM0LjcwMTU4MjQ0MjEyODMxMyBdLCBbIDEzNy40MTE4NDAxNjcsIDM0LjcwMTU4MDE2NyBdLCBbIDEzNy40MTE4MzMzODksIDM0LjcwMTU4MjMzMyBdIF0sIFsgWyAxMzcuNDA1ODAzODMzLCAzNC43MDM0MTkwODMgXSwgWyAxMzcuNDA1NDAyODMzMDAwMDExLCAzNC43MDM0OTQwMjggXSwgWyAxMzcuNDA1Mzc4ODYxLCAzNC43MDM0OTg1MjggXSwgWyAxMzcuNDA1MzIxMTk0MDAwMDEsIDM0LjcwMzUwNjAyOCBdLCBbIDEzNy40MDUyNjcxMzg5OTk5ODksIDM0LjcwMzUxMzA4MyBdLCBbIDEzNy40MDUwOTE1NTYsIDM0LjcwMzUzMzUyOCBdLCBbIDEzNy40MDUwMjUwODMsIDM0LjcwMzUzNjQ0NCBdLCBbIDEzNy40MDQ5NzMyMjIsIDM0LjcwMzUzNTExMSBdLCBbIDEzNy40MDQ5MDQ4NjEsIDM0LjcwMzUyNzExMSBdLCBbIDEzNy40MDQ4MTkyNSwgMzQuNzAzNTEzMjIyIF0sIFsgMTM3LjQwNDYzMjU2ODM1OTAwNiwgMzQuNzAzNDY1NjYyNTYyNzk5IF0sIFsgMTM3LjQwNDUyMTIyMiwgMzQuNzAzNDM3Mjc4IF0sIFsgMTM3LjQwNDI2ODI1LCAzNC43MDMzNzcwODMgXSwgWyAxMzcuNDA0MjIwOTQ0LCAzNC43MDMzNjgzNjEgXSwgWyAxMzcuNDA0MTU1MTExLCAzNC43MDMzNTk1NTYgXSwgWyAxMzcuNDA0MDIyNDE3LCAzNC43MDMzNDQ0NzIgXSwgWyAxMzcuNDAzODQ2Mzg5LCAzNC43MDMzMjM0NzIgXSwgWyAxMzcuNDAzNzQ0MzA2LCAzNC43MDMzMTE4NjEgXSwgWyAxMzcuNDAzNzEyMTY3LCAzNC43MDMzMDgxOTQgXSwgWyAxMzcuNDAzNjY1NjY3MDAwMDEzLCAzNC43MDMzMDI4ODkgXSwgWyAxMzcuNDAzNjQ5NjM5LCAzNC43MDMyNjc3NzggXSwgWyAxMzcuNDAzNjg4NzMxNzg3MDE0LCAzNC43MDMyMzU0NDMyODUxMDIgXSwgWyAxMzcuNDAzNzM1NTU1OTk5OTg3LCAzNC43MDMxOTY2NjcgXSwgWyAxMzcuNDAzNzMyMTY2OTk5OTg3LCAzNC43MDMxNTUgXSwgWyAxMzcuNDAzNzI0MjUwMDAwMDEsIDM0LjcwMzA5MDkxNyBdLCBbIDEzNy40MDM4MDYyNSwgMzQuNzAzMDk3NTI4IF0sIFsgMTM3LjQwNDA5NjM2MSwgMzQuNzAzMTIyNjY3IF0sIFsgMTM3LjQwNDQ4MTU4MywgMzQuNzAzMTYzNTU2IF0sIFsgMTM3LjQwNDYzMjU2ODM1OTAwNiwgMzQuNzAzMTc4MDgyODk1NTk3IF0sIFsgMTM3LjQwNDg3MTk0NCwgMzQuNzAzMjAxMTExIF0sIFsgMTM3LjQwNTIzNzYzODU3ODAwMSwgMzQuNzAzMjM1NDQzMjg1MTAyIF0sIFsgMTM3LjQwNTI4MTk0NCwgMzQuNzAzMjM5NjExIF0sIFsgMTM3LjQwNTY5NjY2NywgMzQuNzAzMjc3NDcyIF0sIFsgMTM3LjQwNjAwNTg1OTM3NSwgMzQuNzAzMzExMDQ1NzYzMjAxIF0sIFsgMTM3LjQwNjAxMzIyMjAwMDAxMywgMzQuNzAzMzExODMzIF0sIFsgMTM3LjQwNjI2OTYxMSwgMzQuNzAzMzM3MTExIF0sIFsgMTM3LjQwNjUzMDgwNiwgMzQuNzAzMzY1MDgzIF0sIFsgMTM3LjQwNjU2ODIyMiwgMzQuNzAzMzU4Nzc4IF0sIFsgMTM3LjQwNjYwNDQxNzAwMDAxMSwgMzQuNzAzMzQzMzA2IF0sIFsgMTM3LjQwNjYzMzA1NiwgMzQuNzAzMzIgXSwgWyAxMzcuNDA2NjUyNDE3LCAzNC43MDMyOTEgXSwgWyAxMzcuNDA2NjcxMjQyNDM1MDEsIDM0LjcwMzIzNTQ0MzI4NTEwMiBdLCBbIDEzNy40MDY3NjM2NjcsIDM0LjcwMjk2MjcyMiBdLCBbIDEzNy40MDY4MjEsIDM0LjcwMjk2NzEzOSBdLCBbIDEzNy40MDY4NDMyNzgsIDM0LjcwMjk3MDQxNyBdLCBbIDEzNy40MDY4NjM2MTEsIDM0LjcwMjk3ODU4MyBdLCBbIDEzNy40MDY4Nzg0NzE5OTk5ODgsIDM0LjcwMjk4NDA1NiBdLCBbIDEzNy40MDY4ODcsIDM0LjcwMjk4OTk3MiBdLCBbIDEzNy40MDY4OTExNjcsIDM0LjcwMjk5NjE5NCBdLCBbIDEzNy40MDY4OTMwNTYsIDM0LjcwMzAwOCBdLCBbIDEzNy40MDY4ODgzMzMwMDAwMTIsIDM0LjcwMzA0MTM2MSBdLCBbIDEzNy40MDY4Nzk1MjgsIDM0LjcwMzA4ODQ0NCBdLCBbIDEzNy40MDY4NzM2OTQwMDAwMTIsIDM0LjcwMzExMDgwNiBdLCBbIDEzNy40MDY4Njc2MzkwMDAwMTIsIDM0LjcwMzEyOTIyMiBdLCBbIDEzNy40MDY4NjAyNzgwMDAwMTEsIDM0LjcwMzE0NzA4MyBdLCBbIDEzNy40MDY4Mzk2NjcwMDAwMTQsIDM0LjcwMzE5NTE2NyBdLCBbIDEzNy40MDY4MjMzMTYyNDM5ODcsIDM0LjcwMzIzNTQ0MzI4NTEwMiBdLCBbIDEzNy40MDY4MjE3NzgsIDM0LjcwMzIzOTE5NCBdLCBbIDEzNy40MDY4MTk5NDQsIDM0LjcwMzI0MzYxMSBdLCBbIDEzNy40MDY4MTEzODkwMDAwMTIsIDM0LjcwMzI2NzcyMiBdLCBbIDEzNy40MDY4MDEyMjIwMDAwMTMsIDM0LjcwMzI5ODYzOSBdLCBbIDEzNy40MDY3OTI0NDQsIDM0LjcwMzMyNzA1NiBdLCBbIDEzNy40MDY3ODU0NDQsIDM0LjcwMzM1NTY2NyBdLCBbIDEzNy40MDY3ODAwODMsIDM0LjcwMzM4NTMzMyBdLCBbIDEzNy40MDY3NzMyMjIsIDM0LjcwMzQzMDA1NiBdLCBbIDEzNy40MDY3NjExMTEsIDM0LjcwMzUwNjE2NyBdLCBbIDEzNy40MDY3NTkyNzgwMDAwMSwgMzQuNzAzNTE1NzIyIF0sIFsgMTM3LjQwNjc1NjUzMDc2NDA1NiwgMzQuNzAzNTYwMTIxMTk0NTYzIF0sIFsgMTM3LjQwNjcxODkxNywgMzQuNzAzNTY5Mjc4IF0sIFsgMTM3LjQwNjYwOTE5NCwgMzQuNzAzNTI2MTExIF0sIFsgMTM3LjQwNjQzNjg4OSwgMzQuNzAzNDY5MTM5IF0sIFsgMTM3LjQwNjM3NDMwNiwgMzQuNzAzNDUxOTQ0IF0sIFsgMTM3LjQwNjMwMDg4OSwgMzQuNzAzNDM4ODMzIF0sIFsgMTM3LjQwNjAwNTg1OTM3NSwgMzQuNzAzNDE2OTQxMDEyNDk5IF0sIFsgMTM3LjQwNTkyMTkxNywgMzQuNzAzNDEwNzIyIF0sIFsgMTM3LjQwNTg2MTExMSwgMzQuNzAzNDEyMjc4IF0sIFsgMTM3LjQwNTgwMzgzMywgMzQuNzAzNDE5MDgzIF0gXSBdLCBbIFsgWyAxMzcuNDA0NjMxMDI4MDAwMDExLCAzNC43MDE1MTkxNjcgXSwgWyAxMzcuNDA0NTk2Njk0LCAzNC43MDE2MTI4MDYgXSwgWyAxMzcuNDA0NTkxMDU1OTk5OTg3LCAzNC43MDE3MDkyNzggXSwgWyAxMzcuNDA0NTkxODYxLCAzNC43MDE3MjEyNzggXSwgWyAxMzcuNDA0NTk2OTE3LCAzNC43MDE3NzMxOTQgXSwgWyAxMzcuNDA0NjIzMjIyLCAzNC43MDE4NDg5NzIgXSwgWyAxMzcuNDA0NjMyNTY4MzU5MDA2LCAzNC43MDE4NjQ0MDE1NjgwMDIgXSwgWyAxMzcuNDA0NjY2LCAzNC43MDE5MTk2MzkgXSwgWyAxMzcuNDA0NzIzMDU2LCAzNC43MDE5ODM3MjIgXSwgWyAxMzcuNDA0NzQxMzMzLCAzNC43MDE5OTg5MTcgXSwgWyAxMzcuNDA0NjM4NTgzLCAzNC43MDE5ODk2NjcgXSwgWyAxMzcuNDA0NjMyNTY4MzU5MDA2LCAzNC43MDIwMzUwMDg3MzEwMDIgXSwgWyAxMzcuNDA0NjI2NjExLCAzNC43MDIwODAxOTQgXSwgWyAxMzcuNDA0NjMyNTY4MzU5MDA2LCAzNC43MDIwODA3NDAyOTkwMDMgXSwgWyAxMzcuNDA0OTE5MzcxMzc1OTk2LCAzNC43MDIxMDY0MzY3MDU1OTggXSwgWyAxMzcuNDA0OTY4Mjc4MDAwMDEzLCAzNC43MDIxMTA4MDYgXSwgWyAxMzcuNDA0OTk4MTk0LCAzNC43MDIxMTUwODMgXSwgWyAxMzcuNDA1OTUzMTY3LCAzNC43MDIyMDg1ODMgXSwgWyAxMzcuNDA1OTk5MTM4OTk5OTg4LCAzNC43MDIyMDk1IF0sIFsgMTM3LjQwNjAwNTg1OTM3NSwgMzQuNzAyMjEwMjA5MzcxODk4IF0sIFsgMTM3LjQwNjM1OTgwNjAwMDAxMiwgMzQuNzAyMjQ3NjM5IF0sIFsgMTM3LjQwNjM3MzgzMywgMzQuNzAyMTU3Mjc4IF0sIFsgMTM3LjQwNjI2NTE5NDAwMDAxNCwgMzQuNzAyMTQ1Nzc4IF0sIFsgMTM3LjQwNjMxMTgzMywgMzQuNzAyMTIwMDgzIF0sIFsgMTM3LjQwNjMyOTA4MDQxODk5OSwgMzQuNzAyMTA2NDM2NzA1NTk4IF0sIFsgMTM3LjQwNjM3NDY2NywgMzQuNzAyMDcwNDQ0IF0sIFsgMTM3LjQwNjQyNjgwNjAwMDAxMywgMzQuNzAyMDEyODMzIF0sIFsgMTM3LjQwNjQ2NDA1NiwgMzQuNzAxOTU0MzMzIF0sIFsgMTM3LjQwNjQ5MDQxNjk5OTk4NiwgMzQuNzAxODkxOTE3IF0sIFsgMTM3LjQwNjUwNTE5NCwgMzQuNzAxODI2OTcyIF0sIFsgMTM3LjQwNjUwODM4OTAwMDAxLCAzNC43MDE3Njg3MjIgXSwgWyAxMzcuNDA2NTAwODMzLCAzNC43MDE3MTc1MjggXSwgWyAxMzcuNDA2NDgyNTI4LCAzNC43MDE2NTA5NDQgXSwgWyAxMzcuNDA2NDQ1MDgzLCAzNC43MDE1NzQ0NzIgXSwgWyAxMzcuNDA2MzkxMDU2LCAzNC43MDE1MDUxNjcgXSwgWyAxMzcuNDA2MzIyODg5LCAzNC43MDE0NDYwODMgXSwgWyAxMzcuNDA2MjcxMDU2LCAzNC43MDE0MTM5MTcgXSwgWyAxMzcuNDA2MjE0MDgzLCAzNC43MDEzODc2OTQgXSwgWyAxMzcuNDA2MTUyMDI4LCAzNC43MDEzNjcyNSBdLCBbIDEzNy40MDYwMDU4NTkzNzUsIDM0LjcwMTM0NTEwNTE4NDEwMyBdLCBbIDEzNy40MDU5OTkyNSwgMzQuNzAxMzQ0MTExIF0sIFsgMTM3LjQwNTE4NTEzOSwgMzQuNzAxMjYyNSBdLCBbIDEzNy40MDUxMTIxOTQsIDM0LjcwMTI1ODA1NiBdLCBbIDEzNy40MDUwNDExNjcsIDM0LjcwMTI2MTgwNiBdLCBbIDEzNy40MDQ5NzE5NzIsIDM0LjcwMTI3MzY2NyBdLCBbIDEzNy40MDQ4NjYwODMsIDM0LjcwMTMwOTI3OCBdLCBbIDEzNy40MDQ3NzA1MDAwMDAwMTIsIDM0LjcwMTM2MzU1NiBdLCBbIDEzNy40MDQ2OTA2OTQwMDAwMSwgMzQuNzAxNDMzOTQ0IF0sIFsgMTM3LjQwNDYzMjU2ODM1OTAwNiwgMzQuNzAxNTE2OTc0OTMzODAzIF0sIFsgMTM3LjQwNDYzMTAyODAwMDAxMSwgMzQuNzAxNTE5MTY3IF0gXSwgWyBbIDEzNy40MDQ3MDg0MTcsIDM0LjcwMTc1NDA1NiBdLCBbIDEzNy40MDQ3MDQxOTQsIDM0LjcwMTcyMTA1NiBdLCBbIDEzNy40MDQ3MDA2MzksIDM0LjcwMTcwNDE5NCBdLCBbIDEzNy40MDQ3MDUxMTEsIDM0LjcwMTYyODI3OCBdLCBbIDEzNy40MDQ3MzE3NzgwMDAwMTMsIDM0LjcwMTU1NTIyMiBdLCBbIDEzNy40MDQ3Nzg5NDM5OTk5ODYsIDM0LjcwMTQ4ODA1NiBdLCBbIDEzNy40MDQ4NDIxMTEsIDM0LjcwMTQzMjMwNiBdLCBbIDEzNy40MDQ5MTgxNjcsIDM0LjcwMTM4OTE2NyBdLCBbIDEzNy40MDUwMDQsIDM0LjcwMTM2MDIyMiBdLCBbIDEzNy40MDUwNTU4MDYsIDM0LjcwMTM1MTI3OCBdLCBbIDEzNy40MDUxMTE1ODMsIDM0LjcwMTM0ODM4OSBdLCBbIDEzNy40MDUxNzQ1ODMsIDM0LjcwMTM1MjIyMiBdLCBbIDEzNy40MDU5ODI4MDYsIDM0LjcwMTQzMzIyMiBdLCBbIDEzNy40MDYwMDU4NTkzNzUsIDM0LjcwMTQzNjcyNDg3NzcwMiBdLCBbIDEzNy40MDYxMjE3MjIsIDM0LjcwMTQ1NDMwNiBdLCBbIDEzNy40MDYxNjcwNTU5OTk5ODcsIDM0LjcwMTQ2OTE5NCBdLCBbIDEzNy40MDYyMTEzMzI5OTk5ODcsIDM0LjcwMTQ4OTY2NyBdLCBbIDEzNy40MDYyNTAwNTYsIDM0LjcwMTUxMzc1IF0sIFsgMTM3LjQwNjMwNDg2MSwgMzQuNzAxNTYxMTM5IF0sIFsgMTM3LjQwNjM0NzgzMzAwMDAxMiwgMzQuNzAxNjE2MjIyIF0sIFsgMTM3LjQwNjM3NzU4MywgMzQuNzAxNjc2OTQ0IF0sIFsgMTM3LjQwNjM4ODM4OSwgMzQuNzAxNzE3NzUgXSwgWyAxMzcuNDA2MzkwNjk0LCAzNC43MDE3MjI2MTEgXSwgWyAxMzcuNDA2Mzk1NzUsIDM0LjcwMTc2OTAyOCBdLCBbIDEzNy40MDYzOTMyNSwgMzQuNzAxODE1NjM5IF0sIFsgMTM3LjQwNjM4MTUsIDM0LjcwMTg2Njc3OCBdLCBbIDEzNy40MDYzNjA4MDYsIDM0LjcwMTkxNTk3MiBdLCBbIDEzNy40MDYzMzE0NzIsIDM0LjcwMTk2MjA4MyBdLCBbIDEzNy40MDYyOSwgMzQuNzAyMDA4MTM5IF0sIFsgMTM3LjQwNjIzOTgwNiwgMzQuNzAyMDQ3NzIyIF0sIFsgMTM3LjQwNjE4MjI1LCAzNC43MDIwNzkzODkgXSwgWyAxMzcuNDA2MTM4MDgzLCAzNC43MDIwOTU5NzIgXSwgWyAxMzcuNDA2MDk3NTk4MTAzOTk3LCAzNC43MDIxMDY0MzY3MDU1OTggXSwgWyAxMzcuNDA2MDkxNzIyMDAwMDE0LCAzNC43MDIxMDc5NzIgXSwgWyAxMzcuNDA2MDQ0MTY3LCAzNC43MDIxMTU0NzIgXSwgWyAxMzcuNDA2MDA1ODU5Mzc1LCAzNC43MDIxMTY1Njc2MyBdLCBbIDEzNy40MDU5NjI5NDQsIDM0LjcwMjExNzg2MSBdLCBbIDEzNy40MDU4NDYyNDgxMTEwMDQsIDM0LjcwMjEwNjQzNjcwNTU5OCBdLCBbIDEzNy40MDUwMTgzMzI5OTk5ODcsIDM0LjcwMjAyNTQxNyBdLCBbIDEzNy40MDQ5NTg4MDYsIDM0LjcwMjAxMjkxNyBdLCBbIDEzNy40MDQ5MDM4MzMsIDM0LjcwMTk5MDU4MyBdLCBbIDEzNy40MDQ4NTQwODMsIDM0LjcwMTk2MDAyOCBdLCBbIDEzNy40MDQ4MDk4ODksIDM0LjcwMTkyMzMzMyBdLCBbIDEzNy40MDQ3NjM3Nzc5OTk5ODksIDM0LjcwMTg3MTY2NyBdLCBbIDEzNy40MDQ3MjkzMzMsIDM0LjcwMTgxNDg2MSBdLCBbIDEzNy40MDQ3MDg0MTcsIDM0LjcwMTc1NDA1NiBdIF0gXSwgWyBbIFsgMTM3LjQwNjI0MDQxNywgMzQuNzA0Mjc0MDI4IF0sIFsgMTM3LjQwNjQ4NjUsIDM0LjcwNDEyOTgzMyBdLCBbIDEzNy40MDY0NjYwNTYsIDM0LjcwNDExNDE5NCBdLCBbIDEzNy40MDYyMjQ5NzIsIDM0LjcwNDI1NTQ3MiBdLCBbIDEzNy40MDYwNTI5MTcwMDAwMTEsIDM0LjcwNDM1ODk0NCBdLCBbIDEzNy40MDYwNDM4Nzg4NDMwMDgsIDM0LjcwNDM2NDQzNDQ1ODQ5OCBdLCBbIDEzNy40MDYwOTAwNjY1MDAwMTMsIDM0LjcwNDM2NDQzNDQ1ODQ5OCBdLCBbIDEzNy40MDYyMTA2NjcwMDAwMTEsIDM0LjcwNDI5MTk0NCBdLCBbIDEzNy40MDYyNDA0MTcsIDM0LjcwNDI3NDAyOCBdIF0gXSwgWyBbIFsgMTM3LjQxNTUwMTc1LCAzNC43MDIzMzIxNjcgXSwgWyAxMzcuNDE1NTEzODMzLCAzNC43MDIzNTM0MTcgXSwgWyAxMzcuNDE1NTk4ODYxLCAzNC43MDIzMjA1MjggXSwgWyAxMzcuNDE1NjEwMzMyOTk5OTg5LCAzNC43MDIzMTc2OTQgXSwgWyAxMzcuNDE1NjE4ODk2NDg0MDA2LCAzNC43MDIzMTczMjM2MDk2OTggXSwgWyAxMzcuNDE1NjE4ODk2NDg0MDA2LCAzNC43MDIyOTM5OTA2NzU0IF0sIFsgMTM3LjQxNTYwNTU1NiwgMzQuNzAyMjk0NDQ0IF0sIFsgMTM3LjQxNTU4ODYzOSwgMzQuNzAyMjk4NjM5IF0sIFsgMTM3LjQxNTUwMTc1LCAzNC43MDIzMzIxNjcgXSBdIF0sIFsgWyBbIDEzNy40MTUyOTc2MzgyMDc5ODgsIDM0LjcwNDM2NDQzNDQ1ODQ5OCBdLCBbIDEzNy40MTUzNjU2NjY1ODEwMSwgMzQuNzA0MzY0NDM0NDU4NDk4IF0sIFsgMTM3LjQxNTQzMjA1NTk5OTk4NiwgMzQuNzA0Mjg2MzMzIF0sIFsgMTM3LjQxNTQ3NzMzMzAwMDAxMywgMzQuNzA0MjM3ODMzIF0sIFsgMTM3LjQxNTQ5MzYzOSwgMzQuNzA0MjIwMjIyIF0sIFsgMTM3LjQxNTUxOTc0OTk5OTk4NywgMzQuNzA0MTkwMDU2IF0sIFsgMTM3LjQxNTU1MTA1NiwgMzQuNzA0MTQ3ODA2IF0sIFsgMTM3LjQxNTU4ODQ3MiwgMzQuNzA0MDk0MTk0IF0sIFsgMTM3LjQxNTYxODg5NjQ4NDAwNiwgMzQuNzA0MDQxMTkxMjAwODAxIF0sIFsgMTM3LjQxNTYxODg5NjQ4NDAwNiwgMzQuNzAzOTE1MjkwNjY2NyBdLCBbIDEzNy40MTU1OTE3NzgsIDM0LjcwMzk2NjY5NCBdLCBbIDEzNy40MTU1ODE0NzIwMDAwMTQsIDM0LjcwMzk4NjI3OCBdLCBbIDEzNy40MTU1NzE1LCAzNC43MDQwMDUxMzkgXSwgWyAxMzcuNDE1NTE5OTE3MDAwMDEyLCAzNC43MDQxMDA0NDQgXSwgWyAxMzcuNDE1NTAzMzA2LCAzNC43MDQxMjQxOTQgXSwgWyAxMzcuNDE1NDczMjc4LCAzNC43MDQxNjQ3NSBdLCBbIDEzNy40MTU0NDkwMjgwMDAwMTIsIDM0LjcwNDE5MjgzMyBdLCBbIDEzNy40MTUzODcyMjIsIDM0LjcwNDI1OTAyOCBdLCBbIDEzNy40MTUyOTc2MzgyMDc5ODgsIDM0LjcwNDM2NDQzNDQ1ODQ5OCBdIF0gXSBdIH0gfQpdCn0K", zN = "data:application/geo+json;base64,ewoidHlwZSI6ICJGZWF0dXJlQ29sbGVjdGlvbiIsCiJuYW1lIjogInRlcnJhaW5zIiwKImNycyI6IHsgInR5cGUiOiAibmFtZSIsICJwcm9wZXJ0aWVzIjogeyAibmFtZSI6ICJ1cm46b2djOmRlZjpjcnM6T0dDOjEuMzpDUlM4NCIgfSB9LAoiZmVhdHVyZXMiOiBbCnsgInR5cGUiOiAiRmVhdHVyZSIsICJwcm9wZXJ0aWVzIjogeyB9LCAiZ2VvbWV0cnkiOiB7ICJ0eXBlIjogIlBvbHlnb24iLCAiY29vcmRpbmF0ZXMiOiBbIFsgWyAxMzcuNDA0Mzc5NDg5NDcwNSwgMzQuNzAyMTY5NjAyNjI2MDY0IF0sIFsgMTM3LjQwNjUxMjk4NDc2Nzc3MiwgMzQuNzAyMzY5Njk0MDkzOTMyIF0sIFsgMTM3LjQwNjY1OTc1OTY2NDUzNSwgMzQuNzAxMzk5Mjk5NjU5NDU3IF0sIFsgMTM3LjQwNjUzNTQ3ODM4NTEwOSwgMzQuNzAxMzM5Njk3MzI5ODU3IF0sIFsgMTM3LjQwNDUxMDcyOTIwNzQ1OSwgMzQuNzAxMTQ1OTg5NTI1MjMgXSwgWyAxMzcuNDA0Mzc5NDg5NDcwNSwgMzQuNzAyMTY5NjAyNjI2MDY0IF0gXSBdIH0gfSwKeyAidHlwZSI6ICJGZWF0dXJlIiwgInByb3BlcnRpZXMiOiB7IH0sICJnZW9tZXRyeSI6IHsgInR5cGUiOiAiUG9seWdvbiIsICJjb29yZGluYXRlcyI6IFsgWyBbIDEzNy40MDUxNDk2MTI2NTk1ODUsIDM0LjcwMDk5Mzc5MDEwNTA3MyBdLCBbIDEzNy40MDUyNTA1OTExOTkxMiwgMzQuNzAwOTgyNjE0NjE2Nzc3IF0sIFsgMTM3LjQwNTM1NDE1ODkzMTk5OSwgMzQuNzAwOTEyMzY4NjU1NzY0IF0sIFsgMTM3LjQwNTc3MzYwODI1MDE3MiwgMzQuNzAwMzIwNTk3MjgzNDg2IF0sIFsgMTM3LjQwNTc1ODA3MzA5MDI1NCwgMzQuNzAwMTY3MzMyMDY1NDA1IF0sIFsgMTM3LjQwNTYwMDEzMjI5NzYyMSwgMzQuNjk5OTk0OTA4MzU1NzI3IF0sIFsgMTM3LjQwNTM1OTMzNzMxODY4NiwgMzQuNjk5ODkwNjAyNDgwNDAxIF0sIFsgMTM3LjQwNTEwNTU5NjM3MzE0NywgMzQuNjk5ODUwMTU3MzA5Njk3IF0sIFsgMTM3LjQwNDgzMzczMTA3NDM0OCwgMzQuNjk5ODg2MzQ1MDk0OTM5IF0sIFsgMTM3LjQwNDU4NTE2ODUxNTQ2NywgMzQuNzAwMDI4OTY3Mzg4NTgzIF0sIFsgMTM3LjQwNDQ2MDg4NzIzNjAxMywgMzQuNzAwMTc1ODQ2ODA3MTkxIF0sIFsgMTM3LjQwNDQwNjUxNDE3NjI1OSwgMzQuNzAwMzUyNTI3NTAxNTE1IF0sIFsgMTM3LjQwNDQ3NjQyMjM5NTk1OSwgMzQuNzAwNDczODYyMjE3NjcgXSwgWyAxMzcuNDA1MDM3NjMwMDQ4NDEyLCAzNC43MDA5NTcwNzA2Mzc4NDggXSwgWyAxMzcuNDA1MTQ5NjEyNjU5NTg1LCAzNC43MDA5OTM3OTAxMDUwNzMgXSBdIF0gfSB9LAp7ICJ0eXBlIjogIkZlYXR1cmUiLCAicHJvcGVydGllcyI6IHsgfSwgImdlb21ldHJ5IjogeyAidHlwZSI6ICJQb2x5Z29uIiwgImNvb3JkaW5hdGVzIjogWyBbIFsgMTM3LjQwNzAxMDI3MTcxMDMzNCwgMzQuNzAwOTU0MTQzNzIzMDY3IF0sIFsgMTM3LjQwNzA0MzQ5Mjc3NDczMywgMzQuNzAwOTU1NDIxNDY0NDcxIF0sIFsgMTM3LjQwNzA3OTE3MjA4OTE5OCwgMzQuNzAwOTQ2NjgzOTE1OTM3IF0sIFsgMTM3LjQwNzE0ODI1MzMxNTExNCwgMzQuNzAwOTAyOTk2MTU5NDQ5IF0sIFsgMTM3LjQwNzIyNTY4NTAxODkxNSwgMzQuNzAwODYwNTU2NjAyNDg1IF0sIFsgMTM3LjQwNzI5MDk3MDU3MzA4NiwgMzQuNzAwODQ0MzI5NzA3MzAxIF0sIFsgMTM3LjQwNzM0MTA3MzQ0MDE5MywgMzQuNzAwODQxMjA5MTUwMTcgXSwgWyAxMzcuNDA3NzM3NjczMjA4OTk5LCAzNC43MDA4Nzc1MTE3MzYyMyBdLCBbIDEzNy40MDc3NDMxNzUyNDUwMzEsIDM0LjcwMDg0MDkyNTI1OTIyMiBdLCBbIDEzNy40MDc4NDk5Nzk0Njk1NDYsIDM0LjcwMDg1MDUwNDI2NTY4MSBdLCBbIDEzNy40MDc4Nzc0ODk2NDgzNDIsIDM0LjcwMDY3NzQxNjc2OTQzIF0sIFsgMTM3LjQwODUxOTYwOTU5MjE2MiwgMzQuNzAwNzMyNzYyMjM0MTg5IF0sIFsgMTM3LjQwODUzNDY1OTI3ODYxNSwgMzQuNzAwNjMwMzE5ODc4NDg1IF0sIFsgMTM3LjQwODMwMjExNzM1MzE0NSwgMzQuNzAwNjExNDI3ODk3Njc3IF0sIFsgMTM3LjQwODE4MzAxNDQ2MDMyLCAzNC43MDA1NzA5ODMwNzkzMDkgXSwgWyAxMzcuNDA3NzM0OTIyMTkxMzY2LCAzNC43MDAyOTg1MTIyMDg3ODIgXSwgWyAxMzcuNDA3MzI5ODc1MjYwNzg1LCAzNC43MDAyNTcwMDI5MTM2NzMgXSwgWyAxMzcuNDA3MTA4MzM3NDA3NDM2LCAzNC43MDA2OTU1MTA0NzI4NjIgXSwgWyAxMzcuNDA3MDMwOTg1MjU2OTEsIDM0LjcwMDg4NjAyNjQwNDk3MyBdLCBbIDEzNy40MDcwMTAyNzE3MTAzMzQsIDM0LjcwMDk1NDE0MzcyMzA2NyBdIF0gXSB9IH0sCnsgInR5cGUiOiAiRmVhdHVyZSIsICJwcm9wZXJ0aWVzIjogeyB9LCAiZ2VvbWV0cnkiOiB7ICJ0eXBlIjogIlBvbHlnb24iLCAiY29vcmRpbmF0ZXMiOiBbIFsgWyAxMzcuNDA1OTE3NDcwMzAzNzM0LCAzNC43MDA0MDkyMDM2MDgxMjUgXSwgWyAxMzcuNDA2NDk0ODYwNDE0NTQsIDM0LjcwMDQ1ODE2MzIxODMxNSBdLCBbIDEzNy40MDY1NDQwNTUwODc2NjQsIDM0LjcwMDA5ODQxNTg0MTc4NiBdLCBbIDEzNy40MDU5NTM3MTkwMTAyODQsIDM0LjcwMDA0NzMyNzMzMDExMSBdLCBbIDEzNy40MDU5MTc0NzAzMDM3MzQsIDM0LjcwMDQwOTIwMzYwODEyNSBdIF0gXSB9IH0sCnsgInR5cGUiOiAiRmVhdHVyZSIsICJwcm9wZXJ0aWVzIjogeyB9LCAiZ2VvbWV0cnkiOiB7ICJ0eXBlIjogIlBvbHlnb24iLCAiY29vcmRpbmF0ZXMiOiBbIFsgWyAxMzcuNDA2MTQ3OTA4NTA5NDExLCAzNC43MDA3ODE3MjE2NTI5MzggXSwgWyAxMzcuNDA2NzI3ODg3ODEzNTAzLCAzNC43MDA4MzI4MDk3MTExNjYgXSwgWyAxMzcuNDA2NzcxOTA0MDk5OTY5LCAzNC43MDA0OTY0Nzk0MTQ3NjcgXSwgWyAxMzcuNDA2MTg5MzM1NjAyNTkxLCAzNC43MDA0NDExMzM3OTE5NjIgXSwgWyAxMzcuNDA2MTQ3OTA4NTA5NDExLCAzNC43MDA3ODE3MjE2NTI5MzggXSBdIF0gfSB9Cl0KfQo=";
function NN(pl) {
  const Ss = new Na.LngLatBounds(
    [137.401885986328, 34.6975902563304],
    [137.415618896484, 34.7043644344585]
  ), In = new Na.LngLatBounds(
    [
      Ss.getWest() - (Ss.getEast() - Ss.getWest()) / 2,
      Ss.getSouth() - (Ss.getNorth() - Ss.getSouth()) / 2
    ],
    [
      Ss.getEast() + (Ss.getEast() - Ss.getWest()) / 2,
      Ss.getNorth() + (Ss.getNorth() - Ss.getSouth()) / 2
    ]
  ), Rs = new Na.Map({
    container: pl,
    style: {
      version: 8,
      sources: {
        terrains: {
          type: "geojson",
          data: zN
        },
        streets: {
          type: "geojson",
          data: DN
        },
        buildings: {
          type: "geojson",
          data: hN
        }
      },
      layers: [
        {
          id: "background",
          type: "background",
          paint: {
            "background-color": "#F6F8FA"
          }
        },
        {
          id: "terrains-fill",
          type: "fill",
          source: "terrains",
          paint: {
            "fill-color": "#CCF0D7"
          }
        },
        {
          id: "streets-fill",
          type: "fill",
          source: "streets",
          paint: {
            "fill-color": "#E6E6E6"
          }
        },
        {
          id: "streets-line",
          type: "line",
          source: "streets",
          paint: {
            "line-color": "#8B8B8B"
          }
        },
        {
          id: "buildings-fill",
          type: "fill",
          source: "buildings",
          paint: {
            "fill-color": "#DFD0D8"
          }
        }
      ],
      glyphs: "https://glyphs.geolonia.com/{fontstack}/{range}.pbf"
    },
    bounds: Ss,
    maxBounds: In,
    attributionControl: !1
  });
  return Rs.addControl(new Na.ScaleControl(), "bottom-left"), Rs.addControl(
    new Na.AttributionControl({
      compact: !0,
      customAttribution: ""
    }),
    "bottom-right"
  ), Rs.addControl(
    new Na.GeolocateControl({
      positionOptions: {
        enableHighAccuracy: !0
      },
      trackUserLocation: !0,
      fitBoundsOptions: {
        maxZoom: 18
      }
    }),
    "bottom-right"
  ), Rs.addControl(new Na.NavigationControl(), "bottom-right"), Rs;
}
export {
  NN as createCampusMap
};
