<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ room.title }} - Team Terrace Chat</title>
    <style>
        body { font-family: sans-serif; margin: 0; padding: 0; display: flex; flex-direction: column; height: 100vh; }
        header { background: #333; color: #fff; padding: 1rem; }
        #chat-container { flex: 1; overflow-y: auto; padding: 1rem; background: #f0f2f5; }
        .message { background: #fff; padding: 0.5rem 1rem; margin-bottom: 0.5rem; border-radius: 8px; max-width: 80%; box-shadow: 0 1px 2px rgba(0,0,0,0.1); }
        .message.question { border-left: 4px solid #ff9800; background: #fff3e0; }
        #input-area { padding: 1rem; background: #fff; border-top: 1px solid #ddd; display: flex; gap: 0.5rem; }
        #message-input { flex: 1; padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px; }
        button { padding: 0.5rem 1rem; background: #007bff; color: #fff; border: none; border-radius: 4px; cursor: pointer; }
        button:hover { background: #0056b3; }
        
        /* Modal Styles */
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); }
        .modal-content { background-color: #fefefe; margin: 15% auto; padding: 20px; border: 1px solid #888; width: 80%; max-width: 600px; border-radius: 8px; }
        .close { color: #aaa; float: right; font-size: 28px; font-weight: bold; cursor: pointer; }
        .close:hover { color: black; }
        .thread-icon { cursor: pointer; color: #007bff; font-weight: bold; margin-left: 10px; }
        .reply { background: #e9ecef; margin: 5px 0; padding: 5px 10px; border-radius: 4px; }
    </style>
</head>
<body>
    <header>
        <h1>{{ room.title }}</h1>
    </header>

    <div id="chat-container">
        <!-- Messages will be loaded here -->
    </div>

    <div id="input-area">
        {% csrf_token %}
        <label style="display: flex; align-items: center; margin-right: 5px;">
            <input type="checkbox" id="is-question"> Ë≥™Âïè
        </label>
        <input type="text" id="message-input" placeholder="„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÂÖ•Âäõ...">
        <button id="send-button">ÈÄÅ‰ø°</button>
    </div>

    <div id="thread-modal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal()">&times;</span>
            <h2>„Çπ„É¨„ÉÉ„Éâ</h2>
            <div id="thread-messages"></div>
            <div style="margin-top: 10px; display: flex; gap: 5px;">
                <input type="text" id="reply-input" style="flex: 1; padding: 5px;" placeholder="Ëøî‰ø°...">
                <button onclick="sendReply()">Ëøî‰ø°</button>
            </div>
        </div>
    </div>

    <script>
        const roomId = "{{ room.uuid }}";
        const chatContainer = document.getElementById('chat-container');
        const messageInput = document.getElementById('message-input');
        const sendButton = document.getElementById('send-button');
        const isQuestionCheckbox = document.getElementById('is-question');
        let currentThreadId = null;

        // „É°„ÉÉ„Çª„Éº„Ç∏„ÇíË°®Á§∫„Åô„ÇãÈñ¢Êï∞
        function appendMessage(msg) {
            // ÈáçË§á„ÉÅ„Çß„ÉÉ„ÇØ: Êó¢„Å´Âêå„ÅòID„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØËøΩÂä†„Åó„Å™„ÅÑ
            const existingMsg = document.getElementById(`msg-${msg.id}`);
            if (existingMsg) return;

            const div = document.createElement('div');
            div.id = `msg-${msg.id}`; // ID„Çí‰ªò‰∏é
            div.className = `message ${msg.is_question ? 'question' : ''}`;
            div.textContent = msg.content;
            
            if (msg.is_question) {
                const icon = document.createElement('span');
                icon.className = 'thread-icon';
                icon.textContent = 'üí¨ „Çπ„É¨„ÉÉ„Éâ';
                icon.onclick = () => openThread(msg.id);
                div.appendChild(icon);
            }
            
            chatContainer.appendChild(div);
            // Êñ∞„Åó„ÅÑ„É°„ÉÉ„Çª„Éº„Ç∏„ÅÆID„ÅåÁèæÂú®„ÅÆlastMessageId„Çà„ÇäÂ§ß„Åç„ÅÑÂ†¥ÂêàÊõ¥Êñ∞
            if (msg.id > lastMessageId) {
                lastMessageId = msg.id;
            }
            chatContainer.scrollTop = chatContainer.scrollHeight; // ÊúÄ‰∏ãÈÉ®„Å∏„Çπ„ÇØ„É≠„Éº„É´
        }

        // „É°„ÉÉ„Çª„Éº„Ç∏‰∏ÄË¶ß„ÇíÂèñÂæó
        let lastMessageId = 0;
        async function fetchMessages() {
            try {
                let url = `/team_terrace/api/room/${roomId}/messages/list/`;
                if (lastMessageId > 0) {
                    url += `?after_id=${lastMessageId}`;
                }

                const res = await fetch(url);
                if (res.ok) {
                    const data = await res.json();
                    if (data.messages.length > 0) {
                        data.messages.forEach(appendMessage);
                        // lastMessageId is updated in appendMessage
                    }
                }
            } catch (error) {
                console.error('Failed to fetch messages:', error);
            }
        }

        // „É°„ÉÉ„Çª„Éº„Ç∏ÈÄÅ‰ø°
        async function sendMessage() {
            const content = messageInput.value.trim();
            const isQuestion = isQuestionCheckbox.checked;
            if (!content) return;

            try {
                const res = await fetch(`/team_terrace/api/room/${roomId}/messages/`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': getCookie('csrftoken')
                    },
                    body: JSON.stringify({ content: content, is_question: isQuestion })
                });

                if (res.ok) {
                    messageInput.value = '';
                    isQuestionCheckbox.checked = false;
                    const newMsg = await res.json();
                    appendMessage(newMsg);
                }
            } catch (error) {
                console.error('Failed to send message:', error);
            }
        }

        // --- Thread Modal Logic ---
        const modal = document.getElementById('thread-modal');
        const threadMessages = document.getElementById('thread-messages');
        const replyInput = document.getElementById('reply-input');

        async function openThread(messageId) {
            currentThreadId = messageId;
            modal.style.display = "block";
            threadMessages.innerHTML = 'Loading...';
            
            try {
                const res = await fetch(`/team_terrace/api/messages/${messageId}/replies/list/`);
                if (res.ok) {
                    const data = await res.json();
                    threadMessages.innerHTML = ''; // Clear loading
                    if (data.replies.length === 0) {
                        threadMessages.innerHTML = '<p>Ëøî‰ø°„ÅØ„Åæ„Å†„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ</p>';
                    } else {
                        data.replies.forEach(r => {
                            const div = document.createElement('div');
                            div.className = 'reply';
                            div.textContent = r.content;
                            threadMessages.appendChild(div);
                        });
                    }
                }
            } catch (error) {
                threadMessages.textContent = 'Error loading replies.';
            }
        }

        function closeModal() {
            modal.style.display = "none";
            currentThreadId = null;
        }

        async function sendReply() {
            if (!currentThreadId) return;
            const content = replyInput.value.trim();
            if (!content) return;

            try {
                const res = await fetch(`/team_terrace/api/messages/${currentThreadId}/replies/`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': getCookie('csrftoken')
                    },
                    body: JSON.stringify({ content: content })
                });

                if (res.ok) {
                    replyInput.value = '';
                    openThread(currentThreadId); // Reload replies
                }
            } catch (error) {
                alert('Error sending reply');
            }
        }

        window.onclick = function(event) {
            if (event.target == modal) {
                closeModal();
            }
        }
        // --------------------------

        // CSRF„Éà„Éº„ÇØ„É≥ÂèñÂæó„ÅÆ„Åü„ÇÅ„ÅÆ„Éò„É´„Éë„ÉºÈñ¢Êï∞
        function getCookie(name) {
            let cookieValue = null;
            if (document.cookie && document.cookie !== '') {
                const cookies = document.cookie.split(';');
                for (let i = 0; i < cookies.length; i++) {
                    const cookie = cookies[i].trim();
                    if (cookie.substring(0, name.length + 1) === (name + '=')) {
                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                        break;
                    }
                }
            }
            return cookieValue;
        }

        sendButton.addEventListener('click', sendMessage);
        messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') sendMessage();
        });

        // ÂàùÂõû„É≠„Éº„Éâ
        fetchMessages();

        // „Éù„Éº„É™„É≥„Ç∞ÈñãÂßã (2ÁßíÈñìÈöî)
        setInterval(fetchMessages, 2000);
    </script>
</body>
</html>
