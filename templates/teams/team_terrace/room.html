<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ room.title }} - Team Terrace Chat</title>
    <style>
        body { font-family: sans-serif; margin: 0; padding: 0; display: flex; flex-direction: column; height: 100vh; }
        header { background: #333; color: #fff; padding: 1rem; }
        #chat-container { flex: 1; overflow-y: auto; padding: 1rem; background: #f0f2f5; }
        .message { background: #fff; padding: 0.5rem 1rem; margin-bottom: 0.5rem; border-radius: 8px; max-width: 80%; box-shadow: 0 1px 2px rgba(0,0,0,0.1); }
        .message.question { border-left: 4px solid #ff9800; background: #fff3e0; }
        #input-area { padding: 1rem; background: #fff; border-top: 1px solid #ddd; display: flex; gap: 0.5rem; }
        #message-input { flex: 1; padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px; }
        button { padding: 0.5rem 1rem; background: #007bff; color: #fff; border: none; border-radius: 4px; cursor: pointer; }
        button:hover { background: #0056b3; }
        
        /* Modal Styles */
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); }
        .modal-content { background-color: #fefefe; margin: 15% auto; padding: 20px; border: 1px solid #888; width: 80%; max-width: 600px; border-radius: 8px; }
        .close { color: #aaa; float: right; font-size: 28px; font-weight: bold; cursor: pointer; }
        .close:hover { color: black; }
        .thread-icon { cursor: pointer; color: #007bff; font-weight: bold; margin-left: 10px; }
        .reply { background: #e9ecef; margin: 5px 0; padding: 5px 10px; border-radius: 4px; }

        /* Reaction Styles */
        @keyframes floatUp {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-300px) scale(1.5); opacity: 0; }
        }
        .floating-reaction {
            position: absolute;
            bottom: 120px; /* input-area height + reaction-bar height */
            /* Random horizontal position will be set by JS */
            font-size: 2rem;
            animation: floatUp 3s ease-out forwards;
            pointer-events: none;
            z-index: 1000;
        }
        .reaction-bar {
            padding: 10px;
            background: #f9f9f9;
            border-top: 1px solid #ddd;
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        .reaction-btn {
            display: flex;
            flex-direction: row; /* Horizontal layout */
            align-items: center;
            justify-content: center;
            padding: 8px 16px; /* Adjust padding for rectangular shape */
            width: auto; /* Let width adapt to content */
            min-width: 100px; /* Minimum width for consistency */
            height: 48px; /* Standard button height */
            background: #fff;
            border: 2px solid #ccc;
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.1s, background-color 0.2s;
            margin: 0;
            gap: 8px; /* Space between icon and text */
        }
        .reaction-btn:hover {
            transform: translateY(-2px); /* Slight lift instead of scale only */
            background-color: #eef;
            border-color: #007bff;
        }
        .reaction-btn:active {
            transform: translateY(0);
        }
        .reaction-icon {
            font-size: 20px; /* Slightly smaller icon to match text */
            margin-bottom: 0; /* Remove margin */
        }
        .reaction-label {
            font-size: 14px; /* Slightly larger text for readability */
            color: #555;
            font-weight: bold;
        }

        /* App Header Styles */
        .app-header {
            padding: 10px 20px;
            background-color: #fff;
            border-bottom: 1px solid #ddd;
            display: flex;
            align-items: center;
            flex-shrink: 0; /* Prevent shrinking in flex container */
        }
        .app-logo {
            font-size: 1.2rem;
            font-weight: bold;
            color: #333;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .app-logo:hover {
            color: #007bff;
        }
    </style>
</head>
<body>
    <header class="app-header">
        <a href="{% url 'team_terrace:index' %}" class="app-logo">
            <span>üîô</span> Anony Chat
        </a>
    </header>

    <div id="chat-container">
        <!-- Messages will be loaded here -->
    </div>

    <!-- Reaction Animation Container (Canvas) -->
    <div id="reaction-canvas"></div>

    <!-- Reaction Bar (Above Input Area) -->
    <div class="reaction-bar">
        <button class="reaction-btn" onclick="sendReaction('like')">
            <span class="reaction-icon">üëç</span>
            <span class="reaction-label">„ÅÑ„ÅÑ„Å≠</span>
        </button>
        <button class="reaction-btn" onclick="sendReaction('heh')">
            <!-- Using surprised face for "Heh~"? OrüòÆ. User said "Heh~" („Å∏„Åá„Äú). üòÆ fits nicely. -->
            <span class="reaction-icon">üòÆ</span>
            <span class="reaction-label">„Å∏„Åá„Äú</span>
        </button>
        <button class="reaction-btn" onclick="sendReaction('question')">
            <span class="reaction-icon">‚ùì</span>
            <span class="reaction-label">ÔºüÔºüÔºü</span>
        </button>
        <button class="reaction-btn" onclick="sendReaction('clap')">
            <span class="reaction-icon">üëè</span>
            <span class="reaction-label">„Å±„Å°„Å±„Å°</span>
        </button>
    </div>

    <div id="input-area">
        {% csrf_token %}
        <label style="display: flex; align-items: center; margin-right: 5px;">
            <input type="checkbox" id="is-question"> Ë≥™Âïè
        </label>
        <input type="text" id="message-input" placeholder="„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÂÖ•Âäõ...">
        <button id="send-button">ÈÄÅ‰ø°</button>
    </div>

    <div id="thread-modal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal()">&times;</span>
            <h2>„Çπ„É¨„ÉÉ„Éâ</h2>
            <div id="thread-messages"></div>
            <div style="margin-top: 10px; display: flex; gap: 5px;">
                <input type="text" id="reply-input" style="flex: 1; padding: 5px;" placeholder="Ëøî‰ø°...">
                <button onclick="sendReply()">Ëøî‰ø°</button>
            </div>
        </div>
    </div>

    <script>
        const roomId = "{{ room.uuid }}";
        const chatContainer = document.getElementById('chat-container');
        const messageInput = document.getElementById('message-input');
        const sendButton = document.getElementById('send-button');
        const isQuestionCheckbox = document.getElementById('is-question');
        let currentThreadId = null;

        // „É°„ÉÉ„Çª„Éº„Ç∏„ÇíË°®Á§∫„Åô„ÇãÈñ¢Êï∞
        function appendMessage(msg) {
            // ÈáçË§á„ÉÅ„Çß„ÉÉ„ÇØ: Êó¢„Å´Âêå„ÅòID„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØËøΩÂä†„Åó„Å™„ÅÑ
            const existingMsg = document.getElementById(`msg-${msg.id}`);
            if (existingMsg) return;

            const div = document.createElement('div');
            div.id = `msg-${msg.id}`; // ID„Çí‰ªò‰∏é
            div.className = `message ${msg.is_question ? 'question' : ''}`;
            div.textContent = msg.content;
            
            if (msg.is_question) {
                const icon = document.createElement('span');
                icon.className = 'thread-icon';
                icon.textContent = 'üí¨ „Çπ„É¨„ÉÉ„Éâ';
                icon.onclick = () => openThread(msg.id);
                div.appendChild(icon);
            }
            
            chatContainer.appendChild(div);
            // Êñ∞„Åó„ÅÑ„É°„ÉÉ„Çª„Éº„Ç∏„ÅÆID„ÅåÁèæÂú®„ÅÆlastMessageId„Çà„ÇäÂ§ß„Åç„ÅÑÂ†¥ÂêàÊõ¥Êñ∞
            if (msg.id > lastMessageId) {
                lastMessageId = msg.id;
            }
            chatContainer.scrollTop = chatContainer.scrollHeight; // ÊúÄ‰∏ãÈÉ®„Å∏„Çπ„ÇØ„É≠„Éº„É´
        }

        // „É°„ÉÉ„Çª„Éº„Ç∏‰∏ÄË¶ß„ÇíÂèñÂæó
        let lastMessageId = 0;
        async function fetchMessages() {
            try {
                let url = `/team_terrace/api/room/${roomId}/messages/list/`;
                if (lastMessageId > 0) {
                    url += `?after_id=${lastMessageId}`;
                }

                const res = await fetch(url);
                if (res.ok) {
                    const data = await res.json();
                    if (data.messages.length > 0) {
                        data.messages.forEach(appendMessage);
                        // lastMessageId is updated in appendMessage
                    }
                }
            } catch (error) {
                console.error('Failed to fetch messages:', error);
            }
        }

        // „É°„ÉÉ„Çª„Éº„Ç∏ÈÄÅ‰ø°
        async function sendMessage() {
            const content = messageInput.value.trim();
            const isQuestion = isQuestionCheckbox.checked;
            if (!content) return;

            try {
                const res = await fetch(`/team_terrace/api/room/${roomId}/messages/`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': getCookie('csrftoken')
                    },
                    body: JSON.stringify({ content: content, is_question: isQuestion })
                });

                if (res.ok) {
                    messageInput.value = '';
                    isQuestionCheckbox.checked = false;
                    const newMsg = await res.json();
                    appendMessage(newMsg);
                }
            } catch (error) {
                console.error('Failed to send message:', error);
            }
        }

        // --- Thread Modal Logic ---
        const modal = document.getElementById('thread-modal');
        const threadMessages = document.getElementById('thread-messages');
        const replyInput = document.getElementById('reply-input');

        async function openThread(messageId) {
            currentThreadId = messageId;
            modal.style.display = "block";
            threadMessages.innerHTML = 'Loading...';
            
            try {
                const res = await fetch(`/team_terrace/api/messages/${messageId}/replies/list/`);
                if (res.ok) {
                    const data = await res.json();
                    threadMessages.innerHTML = ''; // Clear loading
                    if (data.replies.length === 0) {
                        threadMessages.innerHTML = '<p>Ëøî‰ø°„ÅØ„Åæ„Å†„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ</p>';
                    } else {
                        data.replies.forEach(r => {
                            const div = document.createElement('div');
                            div.className = 'reply';
                            div.textContent = r.content;
                            threadMessages.appendChild(div);
                        });
                    }
                }
            } catch (error) {
                threadMessages.textContent = 'Error loading replies.';
            }
        }

        function closeModal() {
            modal.style.display = "none";
            currentThreadId = null;
        }

        async function sendReply() {
            if (!currentThreadId) return;
            const content = replyInput.value.trim();
            if (!content) return;

            try {
                const res = await fetch(`/team_terrace/api/messages/${currentThreadId}/replies/`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': getCookie('csrftoken')
                    },
                    body: JSON.stringify({ content: content })
                });

                if (res.ok) {
                    replyInput.value = '';
                    openThread(currentThreadId); // Reload replies
                }
            } catch (error) {
                alert('Error sending reply');
            }
        }

        window.onclick = function(event) {
            if (event.target == modal) {
                closeModal();
            }
        }
        // --------------------------

        // CSRF„Éà„Éº„ÇØ„É≥ÂèñÂæó„ÅÆ„Åü„ÇÅ„ÅÆ„Éò„É´„Éë„ÉºÈñ¢Êï∞
        function getCookie(name) {
            let cookieValue = null;
            if (document.cookie && document.cookie !== '') {
                const cookies = document.cookie.split(';');
                for (let i = 0; i < cookies.length; i++) {
                    const cookie = cookies[i].trim();
                    if (cookie.substring(0, name.length + 1) === (name + '=')) {
                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                        break;
                    }
                }
            }
            return cookieValue;
        }

        sendButton.addEventListener('click', sendMessage);
        messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') sendMessage();
        });

        // ÂàùÂõû„É≠„Éº„Éâ
        fetchMessages();
        fetchReactions(); // Start fetching reactions

        // „Éù„Éº„É™„É≥„Ç∞ÈñãÂßã (2ÁßíÈñìÈöî)
        setInterval(() => {
            fetchMessages();
            fetchReactions();
        }, 2000);

        // --- Reaction Logic ---
        let lastReactionId = 0;

        async function sendReaction(type) {
            try {
                const res = await fetch(`/team_terrace/api/room/${roomId}/reactions/`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': getCookie('csrftoken')
                    },
                    body: JSON.stringify({ reaction_type: type })
                });
                if (res.ok) {
                    showReactionAnimation(type);
                }
            } catch (error) {
                console.error('Error sending reaction:', error);
            }
        }

        async function fetchReactions() {
             try {
                const res = await fetch(`/team_terrace/api/room/${roomId}/reactions/list/`);
                if (res.ok) {
                    const data = await res.json();
                    let maxId = lastReactionId;
                    data.reactions.forEach(r => {
                        if (r.id > lastReactionId) {
                            if (lastReactionId !== 0) { // Initial load suppression
                                showReactionAnimation(r.reaction_type);
                            }
                            if (r.id > maxId) maxId = r.id;
                        }
                    });
                    lastReactionId = maxId;
                }
            } catch (error) {
                console.error('Error fetching reactions:', error);
            }
        }

        function showReactionAnimation(type) {
            // Find body or chat container to append to. Body is safer for fixed position.
            const el = document.createElement('div');
            el.className = 'floating-reaction';
            
            let emoji = '';
            if (type === 'like') emoji = 'üëç';
            if (type === 'love') emoji = 'üòÆ'; // Mapped 'love' (from button ID in API) to 'Heh' (üòÆ) visually? Wait, button sends 'like', 'love', etc. 
            // Wait, I used 'love' for "Heh~" button in HTML above? No, I should fix the type mapping to be consistent.
            // HTML: sendReaction('love') -> Label: "„Å∏„Åá„Äú", Icon: üòÆ. 
            // This is confusing mapping. I should align type names with intent if possible, OR map correctly here.
            
            // Let's verify the button onclicks I wrote:
            // 1. sendReaction('like') -> üëç "„ÅÑ„ÅÑ„Å≠"
            // 2. sendReaction('love') -> üòÆ "„Å∏„Åá„Äú" (This usage of 'love' type for "Heh" is weird but I already wrote it in HTML chunk above. I will stick to it or fix HTML chunk? HTML chunk isn't executed yet. I can make them consistent.)
            
            // CORRECT MAPPING based on User Request:
            // "„ÅÑ„ÅÑ„Å≠" -> üëç
            // "„Å∏„Åá„Äú" -> üòÆ
            // "ÔºüÔºüÔºü" -> ‚ùì
            // "„Å±„Å°„Å±„Å°" -> üëè
            
            // I should use logical keys in sendReaction:
            // sendReaction('like')
            // sendReaction('heh')
            // sendReaction('question')
            // sendReaction('clap')

            // Updating HTML chunk to use 'heh' instead of 'love', and updating here too.
            
            if (type === 'like') emoji = 'üëç';
            if (type === 'heh') emoji = 'üòÆ';
            if (type === 'question') emoji = '‚ùì';
            if (type === 'clap') emoji = 'üëè';
            
            el.textContent = emoji;
            
            // Random horizontal position
            const randomLeft = Math.floor(Math.random() * 80) + 10; // 10% to 90%
            el.style.left = randomLeft + '%';
            
            document.body.appendChild(el);
            
            setTimeout(() => { el.remove(); }, 3000);
        }
    </script>
</body>
</html>
